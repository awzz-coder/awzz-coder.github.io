<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>面试题 | awzz博客</title><meta name="author" content="awzz-coder"><meta name="copyright" content="awzz-coder"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="求职：  平台：智联、51、 简历：前端开发（wondercv）  前端面试题HTML&#x2F;CSS1.什么是BFC ?如何触发?有何特点?如何解决margin”塌陷”?BFC代表”块级格式化上下文”（Block Formatting Context），它是CSS布局的一种概念。BFC是一个独立的渲染区域，其中的元素按照一定规则进行布局和渲染。它的存在可以解决一些常见的布局问题。 触发BFC的">
<meta property="og:type" content="article">
<meta property="og:title" content="面试题">
<meta property="og:url" content="https://awzz-coder.github.io/archives/5205ee75.html">
<meta property="og:site_name" content="awzz博客">
<meta property="og:description" content="求职：  平台：智联、51、 简历：前端开发（wondercv）  前端面试题HTML&#x2F;CSS1.什么是BFC ?如何触发?有何特点?如何解决margin”塌陷”?BFC代表”块级格式化上下文”（Block Formatting Context），它是CSS布局的一种概念。BFC是一个独立的渲染区域，其中的元素按照一定规则进行布局和渲染。它的存在可以解决一些常见的布局问题。 触发BFC的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://w.wallhaven.cc/full/2y/wallhaven-2yz3m9.jpg">
<meta property="article:published_time" content="2023-05-09T16:00:00.000Z">
<meta property="article:modified_time" content="2023-07-20T13:17:19.881Z">
<meta property="article:author" content="awzz-coder">
<meta property="article:tag" content="IT前端">
<meta property="article:tag" content="面试">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://w.wallhaven.cc/full/2y/wallhaven-2yz3m9.jpg"><link rel="shortcut icon" href="/img/magic.svg"><link rel="canonical" href="https://awzz-coder.github.io/archives/5205ee75.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><meta name="baidu-site-verification" content="codeva-1kLiQ63o8L"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":3000,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":100},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '面试题',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-07-20 21:17:19'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./img/avatar.jpeg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">19</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-graduation-cap"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-people-robbery"></i><span> 教程</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/teach/"><i class="fa-fw fas fa-comments-o"></i><span> 简介</span></a></li><li><a class="site-page child" href="/teach/"><i class="fa-fw fas fa-voicemail"></i><span> 基础</span></a></li><li><a class="site-page child" href="/teach/"><i class="fa-fw fas fa-scale-unbalanced"></i><span> 进阶</span></a></li><li><a class="site-page child" href="/teach/"><i class="fa-fw fas fa-stethoscope"></i><span> 总结</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-heart"></i><span> 娱乐</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/games/"><i class="fa-fw fas fa-heart"></i><span> 游戏</span></a></li><li><a class="site-page child" href="/cartoon/"><i class="fa-fw fas fa-heart"></i><span> 漫画</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa-heart"></i><span> 书籍</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/photo/"><i class="fa-fw fas fa-image"></i><span> 壁纸</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-toolbox"></i><span> 工具</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/seek/"><i class="fa-fw fas fa-circle-nodes"></i><span> 查询类</span></a></li><li><a class="site-page child" href="/online/"><i class="fa-fw fas fa-heart"></i><span> 在线版</span></a></li><li><a class="site-page child" href="/tools/"><i class="fa-fw fas fa-heart"></i><span> 工具类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-comments"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-list"></i><span> 其他</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-circle-info"></i><span> 关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://w.wallhaven.cc/full/2y/wallhaven-2yz3m9.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="awzz博客"><span class="site-name">awzz博客</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-graduation-cap"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-people-robbery"></i><span> 教程</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/teach/"><i class="fa-fw fas fa-comments-o"></i><span> 简介</span></a></li><li><a class="site-page child" href="/teach/"><i class="fa-fw fas fa-voicemail"></i><span> 基础</span></a></li><li><a class="site-page child" href="/teach/"><i class="fa-fw fas fa-scale-unbalanced"></i><span> 进阶</span></a></li><li><a class="site-page child" href="/teach/"><i class="fa-fw fas fa-stethoscope"></i><span> 总结</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-heart"></i><span> 娱乐</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/games/"><i class="fa-fw fas fa-heart"></i><span> 游戏</span></a></li><li><a class="site-page child" href="/cartoon/"><i class="fa-fw fas fa-heart"></i><span> 漫画</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa-heart"></i><span> 书籍</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/photo/"><i class="fa-fw fas fa-image"></i><span> 壁纸</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-toolbox"></i><span> 工具</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/seek/"><i class="fa-fw fas fa-circle-nodes"></i><span> 查询类</span></a></li><li><a class="site-page child" href="/online/"><i class="fa-fw fas fa-heart"></i><span> 在线版</span></a></li><li><a class="site-page child" href="/tools/"><i class="fa-fw fas fa-heart"></i><span> 工具类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-comments"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-list"></i><span> 其他</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-circle-info"></i><span> 关于</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">面试题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-05-09T16:00:00.000Z" title="发表于 2023-05-10 00:00:00">2023-05-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-07-20T13:17:19.881Z" title="更新于 2023-07-20 21:17:19">2023-07-20</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/">面试题整理</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">96.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>325分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>求职：</p>
<ul>
<li>平台：智联、51、</li>
<li>简历：前端开发（wondercv）</li>
</ul>
<h1 id="前端面试题"><a href="#前端面试题" class="headerlink" title="前端面试题"></a>前端面试题</h1><h2 id="HTML-x2F-CSS"><a href="#HTML-x2F-CSS" class="headerlink" title="HTML&#x2F;CSS"></a>HTML&#x2F;CSS</h2><h4 id="1-什么是BFC-如何触发-有何特点-如何解决margin”塌陷”"><a href="#1-什么是BFC-如何触发-有何特点-如何解决margin”塌陷”" class="headerlink" title="1.什么是BFC ?如何触发?有何特点?如何解决margin”塌陷”?"></a>1.什么是BFC ?如何触发?有何特点?如何解决margin”塌陷”?</h4><p>BFC代表”块级格式化上下文”（Block Formatting Context），它是CSS布局的一种概念。BFC是一个独立的渲染区域，其中的元素按照一定规则进行布局和渲染。它的存在可以解决一些常见的布局问题。</p>
<p>触发BFC的条件：</p>
<ol>
<li>根元素（<code>&lt;html&gt;</code>）本身就是一个BFC。</li>
<li>浮动元素（<code>float</code>属性不为<code>none</code>）。</li>
<li>绝对定位元素（<code>position</code>属性为<code>absolute</code>或<code>fixed</code>）。</li>
<li><code>display</code>属性为<code>inline-block</code>、<code>table-cell</code>、<code>table-caption</code>、<code>flex</code>、<code>inline-flex</code>的元素。</li>
<li><code>overflow</code>属性的值不为<code>visible</code>的元素。</li>
</ol>
<p>BFC的特点：</p>
<ol>
<li>BFC中的元素在垂直方向上一个接一个地排列。</li>
<li>BFC中的元素与外部元素相互隔离，内部的浮动元素不会影响到外部元素的布局。</li>
<li>BFC在计算高度时，会考虑其内部元素的浮动元素，使得容器能够正确包裹内部的浮动内容。</li>
</ol>
<p>解决margin塌陷的方法： margin塌陷是指在垂直方向上，两个相邻的块级元素的上下外边距（margin）会合并（塌陷）成一个外边距的问题。这种现象常常发生在嵌套的块级元素之间。</p>
<p>要解决margin塌陷，可以通过创建一个新的BFC来避免外边距合并的问题。可以通过以下方法来触发新的BFC：</p>
<ol>
<li>使用浮动（<code>float: left</code>或<code>float: right</code>）：浮动元素会触发BFC，从而避免与其他块级元素的外边距合并。</li>
<li>使用绝对定位（<code>position: absolute</code>或<code>position: fixed</code>）：绝对定位元素也会触发BFC。</li>
<li>设置元素的<code>display</code>属性为<code>inline-block</code>或<code>inline-table</code>：这样元素也会成为一个新的BFC。</li>
<li>使用CSS3中的弹性盒子布局（<code>display: flex</code>或<code>display: inline-flex</code>）：弹性盒子也会触发BFC，从而避免外边距合并。</li>
<li>设置元素的<code>overflow</code>属性为一个非<code>visible</code>的值（例如<code>overflow: hidden</code>）：这也会触发BFC，防止外边距合并。</li>
</ol>
<p>通过触发BFC，我们可以有效地解决margin塌陷问题，确保元素在垂直方向上的外边距得到正确的渲染。</p>
<h4 id="2-CSS如何出来溢出-说一下overflow不同值的区别"><a href="#2-CSS如何出来溢出-说一下overflow不同值的区别" class="headerlink" title="2.CSS如何出来溢出?说一下overflow不同值的区别"></a>2.CSS如何出来溢出?说一下overflow不同值的区别</h4><p>在CSS中，通过<code>overflow</code>属性可以控制元素内容的溢出处理方式。<code>overflow</code>属性有以下几个可能的值，每个值都有不同的作用：</p>
<ol>
<li><code>overflow: visible</code>（默认值）：内容会溢出元素框，显示在元素外部，不进行裁剪。这意味着元素框不会限制内容的显示。</li>
<li><code>overflow: hidden</code>：内容会溢出元素框的部分会被隐藏，不显示在元素外部。被裁剪的内容对用户不可见，不占据页面空间。</li>
<li><code>overflow: scroll</code>：如果内容溢出元素框，则会显示滚动条，用户可以通过滚动条查看被裁剪的内容。</li>
<li><code>overflow: auto</code>：如果内容溢出元素框，则会自动显示滚动条。当内容不溢出时，不显示滚动条，不占据页面空间。如果内容没有溢出，与<code>visible</code>效果相同。</li>
<li><code>overflow: clip</code>：内容会溢出元素框，但溢出的内容会被裁剪，不显示在元素外部。与<code>hidden</code>效果相同，但不会创建滚动条。</li>
</ol>
<p><code>overflow</code>属性的应用通常在父元素的内容区域限制了子元素的尺寸时非常有用。例如，当一个固定大小的容器内包含了大量内容时，可以使用<code>overflow: scroll</code>或<code>overflow: auto</code>，以便用户可以滚动查看全部内容。</p>
<p>需要注意的是，<code>overflow</code>属性只对具有指定尺寸（如设置<code>height</code>、<code>width</code>）和<code>overflow: hidden</code>之外的值的块级元素和可替换元素有效。对于<code>inline</code>元素，<code>overflow</code>属性无效。</p>
<p>另外，<code>overflow</code>属性在处理<code>position: absolute</code>元素时也需要特别注意。绝对定位的元素会相对于其最近的具有<code>position</code>属性值不为<code>static</code>的祖先元素进行定位。因此，如果<code>overflow</code>属性的值为<code>hidden</code>或<code>auto</code>，并且该元素的内容溢出，则被裁剪的内容可能会影响绝对定位元素的显示。这种情况下，可以考虑给绝对定位元素的祖先元素设置<code>overflow: hidden</code>或<code>overflow: auto</code>，以避免溢出内容的影响。</p>
<h4 id="3-三栏布局有什么实现方式？"><a href="#3-三栏布局有什么实现方式？" class="headerlink" title="3.三栏布局有什么实现方式？"></a>3.三栏布局有什么实现方式？</h4><p>三栏布局是指将页面内容划分为左侧、中间和右侧三个区域，并且这三个区域可以具有不同的宽度。实现三栏布局有多种方式，下面列举了几种常见的方法：</p>
<ol>
<li>使用浮动（Float）：<ul>
<li>将左侧和右侧栏设置为固定宽度的块级元素，并分别使用<code>float: left;</code>和<code>float: right;</code>进行浮动。</li>
<li>将中间栏设置为<code>width: auto;</code>，并确保其在左侧和右侧栏的外部显示，可以使用<code>margin</code>负值或<code>overflow</code>属性来实现。</li>
<li>这种方法需要注意清除浮动，可以在父容器上使用<code>clearfix</code>技巧或者使用<code>overflow: hidden;</code>来清除浮动。</li>
</ul>
</li>
<li>使用Flexbox布局：<ul>
<li>将三栏布局的容器设置为<code>display: flex;</code>，默认情况下，子元素会水平排列。</li>
<li>设置左侧和右侧栏的宽度，可以使用<code>flex: 0 0 &lt;width&gt;;</code>来固定宽度。</li>
<li>中间栏会自动占据剩余的可用空间，可以设置<code>flex: 1;</code>或者<code>flex-grow: 1;</code>来实现。</li>
</ul>
</li>
<li>使用Grid布局：<ul>
<li>将三栏布局的容器设置为<code>display: grid;</code>，并指定网格列的大小。</li>
<li>使用<code>grid-template-columns</code>属性来设置左侧、中间和右侧栏的宽度，例如<code>grid-template-columns: 200px 1fr 200px;</code>。</li>
</ul>
</li>
<li>使用绝对定位：<ul>
<li>将三栏布局的容器设置为<code>position: relative;</code>，用于定位绝对定位的子元素。</li>
<li>分别使用<code>position: absolute;</code>将左侧和右侧栏固定在左右位置，设置相应的宽度。</li>
<li>中间栏可以设置<code>margin-left</code>和<code>margin-right</code>来留出左右栏的空间。</li>
</ul>
</li>
</ol>
<h4 id="4-css-calc属性作用是什么-主要用于解决什么问题"><a href="#4-css-calc属性作用是什么-主要用于解决什么问题" class="headerlink" title="4.css calc属性作用是什么?主要用于解决什么问题?"></a>4.css calc属性作用是什么?主要用于解决什么问题?</h4><p>CSS的<code>calc()</code>函数用于执行简单的数学运算，它可以在CSS样式中动态计算属性的值。主要用于解决以下问题：</p>
<ol>
<li>动态计算长度值：<code>calc()</code>函数允许在CSS样式中使用数学表达式来计算长度值。例如，可以使用<code>calc(100% - 20px)</code>来动态地将一个元素的宽度设置为父元素宽度减去20像素。</li>
<li>响应式布局：通过<code>calc()</code>函数，可以根据不同的屏幕尺寸或视口大小来调整元素的大小和位置。这样可以实现更灵活的响应式布局。</li>
<li>解决复杂布局问题：在某些布局情况下，需要根据多个因素来计算元素的尺寸或位置。<code>calc()</code>函数提供了一种简便的方式来处理这些复杂的计算。</li>
<li>避免CSS预处理器的使用：在CSS预处理器（如Sass或Less）中，也可以使用类似的数学表达式。但使用<code>calc()</code>函数，我们可以在纯CSS中进行类似的计算，无需依赖额外的工具或预处理器。</li>
</ol>
<p>总结来说，<code>calc()</code>函数在CSS样式中的使用可以让我们更方便地进行动态计算，解决复杂的布局问题，并实现更灵活的响应式设计，而无需依赖其他工具或预处理器。</p>
<h4 id="5-有一个固定长宽div-怎么实现在屏幕上垂直水平居中"><a href="#5-有一个固定长宽div-怎么实现在屏幕上垂直水平居中" class="headerlink" title="5.有一个固定长宽div,怎么实现在屏幕上垂直水平居中"></a>5.有一个固定长宽div,怎么实现在屏幕上垂直水平居中</h4><p>要实现一个固定长宽的<code>div</code>在屏幕上垂直水平居中，可以使用绝对定位和<code>transform</code>属性的组合</p>
<ol>
<li>设置<code>body</code>的样式，让它占满整个视口（viewport），这样居中的效果会相对于视口来进行计算。</li>
<li>使用<code>display: flex;</code>让<code>body</code>变为一个弹性容器，<code>justify-content: center;</code>和<code>align-items: center;</code>分别在水平和垂直方向上将内容居中。</li>
<li>对于<code>.centered-div</code>，设置固定的宽度和高度，然后使用绝对定位<code>position: absolute;</code>将它从正常文档流中脱离，并使用<code>top: 50%;</code>和<code>left: 50%;</code>将其顶部和左侧位置定位到屏幕的中间。</li>
<li>最后，通过使用<code>transform: translate(-50%, -50%);</code>，将元素的中心点重新定位回屏幕的中心，实现垂直和水平居中。</li>
</ol>
<p>这样，固定长宽的<code>div</code>就能在屏幕上垂直水平居中了。记得根据实际情况调整<code>.centered-div</code>的宽高和其他样式，使其适应你的需求。</p>
<h4 id="6-描述一下渐进增强-progressive-enhancement-和优雅降级-gracefuldegradation"><a href="#6-描述一下渐进增强-progressive-enhancement-和优雅降级-gracefuldegradation" class="headerlink" title="6.描述一下渐进增强(progressive enhancement)和优雅降级(gracefuldegradation)"></a>6.描述一下渐进增强(progressive enhancement)和优雅降级(gracefuldegradation)</h4><p>渐进增强（Progressive Enhancement）和优雅降级（Graceful Degradation）是两种不同的前端开发方法，都旨在在不同浏览器和设备上提供更好的用户体验。</p>
<ol>
<li>渐进增强（Progressive Enhancement）： 渐进增强是一种从基本功能开始，逐步增强网页或应用程序的功能和外观的方法。开发者首先关注的是核心功能，确保在所有现代浏览器和设备上都能正常运行。然后，通过使用新的技术、特性或样式，对支持更高级功能的浏览器进行改进。这样，无论用户使用什么设备或浏览器，他们都能访问基本功能，并获得额外的增强功能，提供更好的用户体验。</li>
</ol>
<p>渐进增强的优势在于，确保基本功能的普遍可用性，并逐步提供更好的体验。它强调可访问性和可用性，为所有用户提供核心功能，不依赖于特定的浏览器或设备。</p>
<ol>
<li>优雅降级（Graceful Degradation）： 优雅降级是一种从复杂功能开始，逐步向下兼容到较旧或不支持现代特性的浏览器的方法。开发者首先关注的是使用最新的技术和特性来实现复杂的功能，并确保在现代浏览器上运行良好。然后，对不支持这些特性的旧浏览器进行回退处理，以确保它们仍然能够使用基本功能。</li>
</ol>
<p>优雅降级的优势在于，它允许开发人员专注于最先进的功能和用户体验，而不需要担心不支持这些功能的浏览器。然后，通过为旧浏览器提供替代的功能或回退方案，确保所有用户都能够访问基本功能。</p>
<p>综合来说，渐进增强和优雅降级是两种不同的开发方法，但目标都是提供更好的用户体验，无论用户使用的是现代浏览器还是较旧的浏览器。渐进增强着重于从简单到复杂，优雅降级着重于从复杂到简单，但它们的本质都是关注所有用户，并确保他们能够访问核心功能。选择使用哪种方法取决于具体的项目需求和用户群体。</p>
<h4 id="7-iframe-有哪些优点-哪些缺点-胞来解决过什么问题"><a href="#7-iframe-有哪些优点-哪些缺点-胞来解决过什么问题" class="headerlink" title="7.iframe 有哪些优点?哪些缺点?胞来解决过什么问题?"></a>7.iframe 有哪些优点?哪些缺点?胞来解决过什么问题?</h4><p><code>iframe</code>（内联框架）是HTML中的一个元素，用于在网页中嵌入另一个独立的HTML文档。<code>iframe</code>具有一些优点和缺点，同时也被用来解决特定的问题。</p>
<p>优点：</p>
<ol>
<li>分隔内容：<code>iframe</code>可以将不同的网页内容隔离开来，使得嵌入的网页具有独立的上下文，不会受到外部网页的影响。这有助于避免潜在的样式或脚本冲突。</li>
<li>代码重用：使用<code>iframe</code>可以在多个页面中重用相同的内容，而无需在每个页面中重复代码。这样可以减少维护成本，提高代码的可复用性。</li>
<li>嵌入外部内容：<code>iframe</code>可以嵌入其他网站或第三方内容，如地图、视频、广告等。这样可以方便地将其他服务或内容集成到自己的网页中。</li>
<li>异步加载：<code>iframe</code>可以异步加载，不影响主页面的加载和渲染，从而提高页面的加载速度和性能。</li>
</ol>
<p>缺点：</p>
<ol>
<li>安全性问题：由于<code>iframe</code>可以加载外部网页，如果不受信任的网页被嵌入到自己的网页中，可能会导致跨站脚本攻击（XSS）和点击劫持等安全问题。</li>
<li>SEO问题：搜索引擎可能会忽略<code>iframe</code>内的内容，导致搜索引擎优化（SEO）方面的问题。</li>
<li>页面结构复杂性：过度使用<code>iframe</code>可能导致页面结构复杂，增加了维护和调试的难度。</li>
<li>可访问性问题：对于一些辅助技术（如屏幕阅读器）来说，<code>iframe</code>的内容可能不可访问，影响网页的可访问性。</li>
</ol>
<p>使用<code>iframe</code>可以解决一些特定的问题，例如：</p>
<ol>
<li>嵌入地图：将第三方地图服务（如Google Maps）嵌入到网页中，以显示地图信息。</li>
<li>嵌入视频：将视频嵌入到网页中，以方便播放外部视频内容。</li>
<li>广告展示：展示来自广告服务提供商的广告内容，以获取收益。</li>
</ol>
<p>尽管<code>iframe</code>有其优点和应用场景，但在使用时需要谨慎考虑其安全性和可访问性，并确保适当使用以避免潜在的问题。</p>
<h4 id="8-Google-Chrome如何支持大小小于12px-的文字"><a href="#8-Google-Chrome如何支持大小小于12px-的文字" class="headerlink" title="8.Google Chrome如何支持大小小于12px 的文字?"></a>8.Google Chrome如何支持大小小于12px 的文字?</h4><p>在过去，Google Chrome曾经不支持以小于12px的字体大小进行渲染，这是因为浏览器默认对小于12px的字体进行了最小字体大小限制。然而，后来的Chrome版本中，为了更好地支持一些特定的设计需求，引入了CSS的属性<code>-webkit-text-size-adjust</code>，该属性可以用于控制文字的大小调整。</p>
<p>要在Google Chrome中支持小于12px的字体大小，可以使用<code>-webkit-text-size-adjust</code>属性并将其设置为<code>none</code>。这样做会禁用浏览器的默认字体大小调整，从而允许使用小于12px的字体大小。</p>
<p>需要注意的是，使用小于12px的字体大小可能会导致文字在某些设备上不易阅读，尤其是在高分辨率或小尺寸屏幕上。因此，在使用小字体时，务必要进行充分的测试，以确保文字在各种设备和浏览器中都能正常显示和阅读。</p>
<p>另外，需要注意的是，<code>-webkit-text-size-adjust</code>是一个WebKit引擎（用于Chrome、Safari等浏览器）的私有属性，其他浏览器不支持。如果需要在其他浏览器中支持小于12px的字体大小，可能需要考虑其他解决方案或使用不同的字体单位（如<code>em</code>或<code>rem</code>）来代替像素单位。</p>
<h4 id="9-描述一下css盒子模型"><a href="#9-描述一下css盒子模型" class="headerlink" title="9.描述一下css盒子模型"></a>9.描述一下css盒子模型</h4><p>CSS盒子模型是指在网页中的每个元素都被视为一个矩形的盒子，它由四个部分组成：内容（Content）、内边距（Padding）、边框（Border）和外边距（Margin）。这些部分构成了一个元素在页面上所占据的空间。</p>
<ol>
<li>内容（Content）：指元素的实际内容区域，例如文本、图片或其他嵌套的子元素。内容的尺寸由元素的<code>width</code>和<code>height</code>属性来确定。</li>
<li>内边距（Padding）：是围绕在内容周围的空间，它指定了内容与边框之间的距离。内边距的尺寸由元素的<code>padding</code>属性来设置。</li>
<li>边框（Border）：是内边距和外边距之间的一条线，它包围着元素的内容和内边距。边框的样式、宽度和颜色由元素的<code>border</code>属性来设置。</li>
<li>外边距（Margin）：是元素与相邻元素之间的空间，它指定了元素与周围元素的距离。外边距的尺寸由元素的<code>margin</code>属性来设置。</li>
</ol>
<p>CSS盒子模型遵循以下原则：</p>
<ol>
<li>盒子模型中的各个部分在计算元素的总尺寸时是相互紧密联系的。例如，元素的总宽度包括了内容宽度、左右内边距和左右边框的宽度，以及左右外边距的宽度。</li>
<li>默认情况下，CSS的盒子模型是采用标准盒子模型（Standard Box Model）。在标准盒子模型中，元素的总宽度和高度包括了内容、内边距和边框，但不包括外边距。也就是说，元素的外边距是在元素的总宽度和高度之外的。</li>
</ol>
<p>​		在CSS3中，引入了另一种盒子模型，称为”border-box”盒子模型，它可以通过设置<code>box-sizing: border-box;</code>来应用。在”border-box”盒子模型中，元素的总宽度和高度包括了内容、内边距和边框，同时也包括了外边距。这样可以更方便地控制元素的尺寸和布局，特别是在响应式设计和布局方面。</p>
<p>​		总结来说，CSS盒子模型是一种用于描述元素尺寸和布局的概念，它由内容、内边距、边框和外边距四个部分组成，这些部分共同构成了一个元素在页面中所占据的空间。</p>
<h4 id="10-HTML5的特性有哪些"><a href="#10-HTML5的特性有哪些" class="headerlink" title="10.HTML5的特性有哪些?"></a>10.HTML5的特性有哪些?</h4><p>HTML5是HTML（超文本标记语言）的第五个版本，它引入了许多新的特性和改进，旨在提供更强大、更丰富的Web开发体验。以下是HTML5的一些主要特性：</p>
<ol>
<li>语义化标签：HTML5引入了许多新的语义化标签，如<code>&lt;header&gt;</code>、<code>&lt;nav&gt;</code>、<code>&lt;main&gt;</code>、<code>&lt;section&gt;</code>、<code>&lt;article&gt;</code>、<code>&lt;footer&gt;</code>等，使得文档结构更加清晰，并为搜索引擎提供更多信息。</li>
<li>多媒体支持：HTML5提供了原生的多媒体支持，包括<code>&lt;audio&gt;</code>和<code>&lt;video&gt;</code>标签，使得在网页上播放音频和视频更加简单。</li>
<li>Canvas绘图：HTML5引入了<code>&lt;canvas&gt;</code>标签，允许通过JavaScript动态绘制图形、图像和动画，用于实现游戏、数据可视化等交互效果。</li>
<li>SVG支持：HTML5对Scalable Vector Graphics（可缩放矢量图形）提供了原生支持，可以通过<code>&lt;svg&gt;</code>标签在网页中绘制矢量图形。</li>
<li>新的表单控件：HTML5引入了新的表单控件，如日期选择器、邮箱验证、电话号码等，使得表单处理更加便捷和语义化。</li>
<li>本地存储：HTML5提供了本地存储功能，包括LocalStorage和SessionStorage，用于在客户端存储数据，实现离线应用和减少服务器请求。</li>
<li>Web Workers：HTML5引入了Web Workers，允许在后台线程中运行JavaScript代码，从而提高页面的性能和响应性。</li>
<li>Web Sockets：HTML5支持Web Sockets，允许在浏览器和服务器之间建立持久的、双向通信的连接，实现实时通信和推送。</li>
<li>地理位置定位：HTML5支持Geolocation API，允许网页获取用户的地理位置信息，用于定位服务和个性化内容。</li>
<li>拖放功能：HTML5引入了拖放API，使得网页元素可以被拖动和放置，用于实现更直观的用户交互。</li>
</ol>
<p>这些特性只是HTML5提供的一部分功能，它们使得Web开发更加便捷、功能更加强大，同时提高了网页的性能和用户体验。由于HTML5的广泛支持和优势，它已经成为现代Web开发的标准。</p>
<h4 id="11-CSS3-的特性有哪些"><a href="#11-CSS3-的特性有哪些" class="headerlink" title="11.CSS3 的特性有哪些?"></a>11.CSS3 的特性有哪些?</h4><p>CSS3是CSS（层叠样式表）的第三个版本，引入了许多新的特性和改进，为网页设计和布局提供了更多的灵活性和交互效果。以下是CSS3的一些主要特性：</p>
<ol>
<li>边框和背景：<ul>
<li>圆角边框（<code>border-radius</code>）：可以为元素的边框添加圆角效果。</li>
<li>阴影效果（<code>box-shadow</code>）：可以为元素添加阴影效果。</li>
<li>渐变背景（<code>linear-gradient</code>和<code>radial-gradient</code>）：可以为元素的背景添加渐变效果。</li>
</ul>
</li>
<li>选择器：<ul>
<li>属性选择器：可以根据元素的属性选择元素。</li>
<li>伪类选择器：可以选择元素的特定状态，如<code>hover</code>、<code>active</code>等。</li>
</ul>
</li>
<li>文本效果：<ul>
<li>文本阴影（<code>text-shadow</code>）：可以为文字添加阴影效果。</li>
<li>文本溢出（<code>text-overflow</code>）：可以控制文字在超出容器时的显示方式。</li>
<li>文本换行（<code>word-wrap</code>和<code>word-break</code>）：可以控制长单词或长链接的换行方式。</li>
</ul>
</li>
<li>盒子模型：<ul>
<li>盒子阴影（<code>box-shadow</code>）：可以为元素的盒子模型添加阴影效果。</li>
<li>盒子尺寸（<code>box-sizing</code>）：可以控制元素盒子模型的尺寸计算方式。</li>
</ul>
</li>
<li>转换和过渡：<ul>
<li>2D转换（<code>transform</code>）：可以对元素进行平移、缩放、旋转等2D变换。</li>
<li>过渡效果（<code>transition</code>）：可以为元素的属性添加平滑过渡效果。</li>
</ul>
</li>
<li>动画：<ul>
<li>动画效果（<code>@keyframes</code>和<code>animation</code>）：可以使用关键帧定义动画，控制元素的动画效果。</li>
</ul>
</li>
<li>Flexbox布局：<ul>
<li>弹性盒子布局（Flexbox）：可以使用<code>display: flex</code>实现灵活的、响应式的布局。</li>
</ul>
</li>
<li>Grid布局：<ul>
<li>网格布局（Grid）：可以使用<code>display: grid</code>实现复杂的网格布局。</li>
</ul>
</li>
<li>媒体查询：<ul>
<li>媒体查询（Media Queries）：可以根据设备的特性和视口尺寸应用不同的样式，实现响应式设计。</li>
</ul>
</li>
</ol>
<p>这些特性只是CSS3提供的一部分功能，它们使得网页设计和布局更加灵活、美观，同时增加了交互效果和用户体验。由于CSS3的广泛支持和优势，它已经成为现代Web开发中的标准。然而，为了确保在所有浏览器中获得一致的显示效果，开发者仍需考虑到兼容性问题，并在需要时提供适当的回退方案。</p>
<h4 id="12-如何实现水平居中"><a href="#12-如何实现水平居中" class="headerlink" title="12.如何实现水平居中?"></a>12.如何实现水平居中?</h4><p>行内级元素包括inline-block：在父元素中设置text-align:center</p>
<p>块级元素：margin: 0 auto</p>
<p>绝对定位：元素在有宽度的情况下：l0;r0;m0auto</p>
<p>flex：justify-content:center</p>
<h4 id="13-如何实现垂直居中"><a href="#13-如何实现垂直居中" class="headerlink" title="13.如何实现垂直居中?"></a>13.如何实现垂直居中?</h4><p>绝对定位：元素在有宽度的情况下：t0;b0;mauto0；弊端：必须使用定位（脱离标准流）； 必须给元素设置宽度</p>
<p>flex：弊端：flex局部中的所有元素都会被垂直居中；兼容性较差</p>
<p>top&#x2F;translate：让元素下移父元素的50%（使用相对定位，不能使用mt 它相对于的是父元素的宽度）；让元素上移自身的50%</p>
<h4 id="14-如何实现双圣杯布局"><a href="#14-如何实现双圣杯布局" class="headerlink" title="14.如何实现双圣杯布局?"></a>14.如何实现双圣杯布局?</h4><p>使用了Flexbox布局来实现双圣杯布局。<code>.container</code>是主容器，设置为<code>display: flex;</code>以创建Flexbox容器。<code>justify-content: space-between;</code>将左侧边栏和右侧边栏推到两侧，让中心内容区域占据剩余的空间。</p>
<p><code>.main-content</code>是中心内容区域，设置为<code>flex: 1;</code>以占据剩余空间。</p>
<p><code>.left-sidebar</code>和<code>.right-sidebar</code>是左侧和右侧的侧边栏，都设置为<code>flex: 0 0 200px;</code>以固定宽度为200像素。我们使用<code>order: -1;</code>来调整左侧边栏在DOM中的位置，但在显示上放在左侧。</p>
<p>这样，我们就成功实现了一个简单的双圣杯布局，可以根据需要自定义内容和样式。这种布局非常适合创建带有固定侧边栏的网站，特别是在响应式设计中非常实用。</p>
<h4 id="15-CSS中选择器的优先级"><a href="#15-CSS中选择器的优先级" class="headerlink" title="15.CSS中选择器的优先级?"></a>15.CSS中选择器的优先级?</h4><p>在 CSS 中，选择器的优先级用于确定应用在元素上的样式规则的优先顺序。当多个选择器都匹配同一个元素时，浏览器需要决定应该使用哪个样式规则。选择器的优先级是根据其特定的组合方式来计算的，优先级从高到低依次为：</p>
<ol>
<li><strong>!important：</strong> <code>!important</code> 是最高优先级的标志，当样式规则被标记为 <code>!important</code> 时，该样式将具有最高优先级，即使其他选择器的优先级更高也会被覆盖。但应尽量避免过度使用 <code>!important</code>，因为它可能导致样式管理困难和维护问题。</li>
<li><strong>内联样式（Inline Style）：</strong> 在元素的 <code>style</code> 属性中直接设置样式，内联样式优先级较高，可以覆盖外部样式表和页面级样式。</li>
<li><strong>ID 选择器：</strong> 使用 <code>#</code> 符号定义的 ID 选择器，每个 ID 选择器的优先级比内联样式低。</li>
<li><strong>类选择器、属性选择器和伪类选择器：</strong> 使用类选择器（如 <code>.class</code>）、属性选择器（如 <code>[attribute]</code>）、伪类选择器（如 <code>:hover</code>）的优先级较低，比 ID 选择器优先级低。</li>
<li><strong>元素选择器和伪元素选择器：</strong> 使用元素选择器（如 <code>div</code>、<code>p</code> 等）和伪元素选择器（如 <code>::before</code>、<code>::after</code>）的优先级较低，比类选择器、属性选择器和伪类选择器优先级低。</li>
<li><strong>通用选择器和关系选择器：</strong> 使用通用选择器（<code>*</code>）和关系选择器（如 <code>+</code>、<code>&gt;</code>、<code>~</code>）的优先级较低，比元素选择器和伪元素选择器优先级低。</li>
<li><strong>继承样式：</strong> 继承样式的优先级最低，如果一个元素没有显式地定义某个属性的样式，将会从其父元素继承该属性的样式。</li>
</ol>
<p>当多个选择器的优先级相同时，后面出现的样式规则将覆盖先前出现的样式规则。在实际开发中，了解选择器优先级的计算方式有助于更好地控制样式的应用和覆盖，避免样式冲突和重复定义。</p>
<h4 id="16-CSS-权重如何计算"><a href="#16-CSS-权重如何计算" class="headerlink" title="16.CSS 权重如何计算?"></a>16.CSS 权重如何计算?</h4><p>CSS 权重（Specificity）用于确定应用在元素上的样式规则的优先级。计算 CSS 权重涉及对选择器的特定组合进行分析，每个选择器都有一个权重值，权重值越高，优先级越高。CSS 权重的计算方式如下：</p>
<ol>
<li>对于内联样式（Inline Style），权重值为 1000。</li>
<li>对于 ID 选择器，权重值为 100。</li>
<li>对于类选择器、属性选择器和伪类选择器，权重值为 10。</li>
<li>对于元素选择器和伪元素选择器，权重值为 1。</li>
<li>通用选择器（<code>*</code>）和关系选择器（如 <code>+</code>、<code>&gt;</code>、<code>~</code>）没有权重值。</li>
</ol>
<p>权重计算的规则是将选择器的各个部分的权重值相加，得到最终的权重值。例如，对于选择器 <code>.container .item</code>，其中类选择器的权重为 10，权重值为 20（因为有两个类选择器），而对于选择器 <code>div.item</code>，其中元素选择器和类选择器的权重分别为 1 和 10，权重值为 11。</p>
<p>如果多个样式规则的权重相同，则后面出现的样式规则将覆盖先前出现的样式规则。如果样式规则都使用了 <code>!important</code> 标志，则该样式规则将具有最高优先级，即使其他样式规则的权重值更高也会被覆盖。</p>
<p>权重计算的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">  /* 内联样式，权重值为 1000 */</span><br><span class="line">  div &#123;</span><br><span class="line">    color: red; /* 权重值为 1 */</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /* ID 选择器，权重值为 100 */</span><br><span class="line">  #container &#123;</span><br><span class="line">    color: blue; /* 权重值为 101 */</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /* 类选择器和元素选择器，权重值为 10 + 1 = 11 */</span><br><span class="line">  .item &#123;</span><br><span class="line">    color: green; /* 权重值为 21 */</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;div id=&quot;container&quot; class=&quot;item&quot; style=&quot;color: purple;&quot;&gt;文本颜色&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，元素 <code>div</code> 的文本颜色最终为紫色，因为内联样式具有最高优先级。如果没有内联样式，文本颜色将为蓝色，因为 ID 选择器的权重值最高。如果同时存在多个具有相同权重的样式规则，则后面出现的样式规则将覆盖先前出现的样式规则。</p>
<h4 id="17-HTML5-input元素type属性有哪些"><a href="#17-HTML5-input元素type属性有哪些" class="headerlink" title="17.HTML5 input元素type属性有哪些?"></a>17.HTML5 input元素type属性有哪些?</h4><p>在 HTML5 中，<code>&lt;input&gt;</code> 元素的 <code>type</code> 属性用于定义输入字段的类型。不同的 <code>type</code> 属性会影响输入字段的外观和行为。以下是常见的 <code>&lt;input&gt;</code> 元素的 <code>type</code> 属性取值：</p>
<ol>
<li><strong>text：</strong> 默认值，创建一个单行文本输入框。</li>
<li><strong>password：</strong> 创建一个密码输入框，输入的内容会以圆点或星号隐藏。</li>
<li><strong>checkbox：</strong> 创建一个复选框，允许用户选择一个或多个选项。</li>
<li><strong>radio：</strong> 创建一个单选按钮，允许用户在一组选项中选择一个。</li>
<li><strong>submit：</strong> 创建一个提交按钮，用于提交表单数据。</li>
<li><strong>reset：</strong> 创建一个重置按钮，用于重置表单数据为初始值。</li>
<li><strong>button：</strong> 创建一个普通按钮，可通过 JavaScript 进行事件绑定。</li>
<li><strong>file：</strong> 创建一个文件上传字段，用于上传文件。</li>
<li><strong>image：</strong> 创建一个图像按钮，用于提交表单，并在按钮上显示图像。</li>
<li><strong>email：</strong> 创建一个用于输入电子邮件地址的文本输入框。</li>
<li><strong>number：</strong> 创建一个用于输入数值的文本输入框。</li>
<li><strong>date：</strong> 创建一个用于输入日期的文本输入框。</li>
<li><strong>time：</strong> 创建一个用于输入时间的文本输入框。</li>
<li><strong>url：</strong> 创建一个用于输入 URL 地址的文本输入框。</li>
<li><strong>tel：</strong> 创建一个用于输入电话号码的文本输入框。</li>
<li><strong>search：</strong> 创建一个用于搜索的文本输入框。</li>
</ol>
<p>使用不同的 <code>type</code> 属性可以定制不同类型的输入字段，使用户输入更加方便和准确。请注意，部分浏览器可能对某些 <code>type</code> 属性的支持存在差异，尤其是在旧版本的浏览器中。</p>
<h4 id="18-CSS中哪些属性可继承，哪些不可以"><a href="#18-CSS中哪些属性可继承，哪些不可以" class="headerlink" title="18.CSS中哪些属性可继承，哪些不可以"></a>18.CSS中哪些属性可继承，哪些不可以</h4><p>在CSS中，有一些属性是可继承的，这意味着它们的值会自动继承给子元素。而另一些属性是不可继承的，子元素不会继承父元素的这些属性值。下面是一些常见的可继承和不可继承的属性：</p>
<p>可继承属性（Inherited Properties）：</p>
<ol>
<li>字体相关属性：<code>font-family</code>、<code>font-size</code>、<code>font-weight</code>、<code>font-style</code>等。</li>
<li>文本相关属性：<code>color</code>、<code>text-align</code>、<code>line-height</code>、<code>text-indent</code>等。</li>
<li>元素可见性：<code>visibility</code>属性。</li>
<li>元素透明度：<code>opacity</code>属性。</li>
<li>表格布局相关属性：<code>caption-side</code>、<code>border-collapse</code>、<code>empty-cells</code>等。</li>
</ol>
<p>不可继承属性（Non-inherited Properties）：</p>
<ol>
<li>盒子模型相关属性：<code>width</code>、<code>height</code>、<code>margin</code>、<code>padding</code>、<code>border</code>等。</li>
<li>定位和浮动相关属性：<code>position</code>、<code>top</code>、<code>right</code>、<code>bottom</code>、<code>left</code>、<code>float</code>等。</li>
<li>背景相关属性：<code>background-color</code>、<code>background-image</code>、<code>background-size</code>等。</li>
<li>文本装饰相关属性：<code>text-decoration</code>、<code>text-transform</code>、<code>text-shadow</code>等。</li>
<li>元素的显示类型：<code>display</code>属性。</li>
<li>清除浮动：<code>clear</code>属性。</li>
<li>弹性盒子（Flexbox）和网格布局（Grid Layout）相关属性：<code>display: flex</code>、<code>display: grid</code>等。</li>
</ol>
<p>需要注意的是，并非所有的属性都完全符合可继承或不可继承的规则。有些属性可能部分可继承，部分不可继承。此外，有些属性可以通过特定的值或继承机制进行调整，例如<code>inherit</code>、<code>initial</code>、<code>unset</code>等值可以改变继承性。因此，在具体使用中，最好查阅相关文档或测试以确认属性的继承行为。</p>
<h4 id="19-CSS单位中px、-em和rem的区别-配合font-size如何计算-移动端适配方案"><a href="#19-CSS单位中px、-em和rem的区别-配合font-size如何计算-移动端适配方案" class="headerlink" title="19.CSS单位中px、 em和rem的区别?配合font-size如何计算? (移动端适配方案)"></a>19.CSS单位中px、 em和rem的区别?配合font-size如何计算? (移动端适配方案)</h4><p>在CSS中，<code>px</code>、<code>em</code>和<code>rem</code>是常见的单位，用于定义元素的尺寸。它们在计算和使用<code>font-size</code>时有一些区别，特别是在移动端适配方案中。</p>
<ol>
<li><code>px</code>（像素）：是一个固定单位，表示屏幕上的一个物理像素。它是最常见的单位，它的大小不会随着其他因素的改变而改变，因此在响应式设计中不推荐直接使用<code>px</code>作为尺寸单位，因为在不同设备上可能会导致布局和字体大小失真。</li>
<li><code>em</code>：相对单位，它是相对于父元素的字体大小计算的。例如，如果父元素的字体大小是16px，那么<code>1em</code>就等于<code>16px</code>，<code>2em</code>就等于<code>32px</code>，依此类推。但是，如果子元素使用了<code>em</code>作为字体大小单位，那么它的计算基准将是父元素的字体大小，这可能会导致字体大小的嵌套效应。</li>
<li><code>rem</code>（root em）：相对单位，它是相对于根元素（<code>html</code>元素）的字体大小计算的。与<code>em</code>不同，<code>rem</code>不会受到父元素字体大小的影响，它始终是相对于根元素的字体大小。这使得<code>rem</code>在响应式设计和移动端适配中非常实用。</li>
</ol>
<p>在移动端适配方案中，通常会使用<code>rem</code>作为字体大小和尺寸的单位，这样可以确保元素的尺寸在不同屏幕尺寸下保持相对一致。为了使用<code>rem</code>作为单位，需要设置根元素的字体大小，并根据设计的需求调整其他元素的尺寸。</p>
<p>例如，如果要将根元素的字体大小设置为<code>16px</code>，可以在CSS中这样做：</p>
<p>然后，可以根据设计的需求，在其他元素中使用<code>rem</code>来设置字体大小和尺寸。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">html &#123;</span><br><span class="line">  font-size: 16px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">body &#123;</span><br><span class="line">  font-size: 1rem; /* 等同于16px */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">h1 &#123;</span><br><span class="line">  font-size: 2rem; /* 等同于32px */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p &#123;</span><br><span class="line">  font-size: 1.2rem; /* 等同于19.2px */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.container &#123;</span><br><span class="line">  width: 20rem; /* 等同于320px */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过使用<code>rem</code>作为单位，可以实现移动端的适配，使得元素的大小和字体在不同设备上都能相对一致地展示。同时，使用<code>rem</code>也使得调整根元素的字体大小成为可能，从而实现整个页面的缩放效果。</p>
<h4 id="20-如何画一条0-5px的线"><a href="#20-如何画一条0-5px的线" class="headerlink" title="20.如何画一条0.5px的线"></a>20.如何画一条0.5px的线</h4><p>在HTML和CSS中，无法直接绘制0.5像素的线。这是由于绝大多数屏幕的物理像素是一个整数，无法显示出半个像素的线。</p>
<p>然而，你可以通过一些技巧来模拟绘制0.5像素宽的线。其中一个常用的方法是使用<code>transform</code>属性的<code>scale</code>来缩放元素，从而实现模拟0.5像素线的效果。</p>
<p>以下是一个示例，在这个示例中，我们将一个水平线条进行缩放，实现近似0.5像素宽的线：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.line &#123;</span><br><span class="line">  width: 100px; /* 线条的宽度 */</span><br><span class="line">  height: 1px; /* 线条的高度 */</span><br><span class="line">  background-color: black; /* 线条的颜色 */</span><br><span class="line">  transform: scaleY(0.5); /* 将线条在垂直方向上缩放为原来的0.5倍 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子中，我们创建了一个高度为1像素的水平线条，然后使用<code>transform: scaleY(0.5);</code>将其在垂直方向上缩放为原来的0.5倍，从而模拟出近似0.5像素宽的线。</p>
<p>需要注意的是，这种方法在不同屏幕上的显示效果可能会有所差异，而且在某些情况下可能会失去一些锐利度。在实际应用中，如果需要非常细小的线条，最好使用一种更合适的设计方法，或者考虑使用其他技术实现，如SVG或Canvas。</p>
<h4 id="21-隐藏一个元素有哪些方法-display-none与visibility-hidden与opacity-0之间的区别"><a href="#21-隐藏一个元素有哪些方法-display-none与visibility-hidden与opacity-0之间的区别" class="headerlink" title="21.隐藏一个元素有哪些方法? display: none与visibility: hidden与opacity: 0之间的区别?"></a>21.隐藏一个元素有哪些方法? display: none与visibility: hidden与opacity: 0之间的区别?</h4><p>隐藏一个元素有以下几种方法：</p>
<ol>
<li><strong>display: none：</strong> 使用 <code>display: none;</code> 属性可以完全从文档流中移除元素，并且不会在页面上占据空间。元素不会显示在页面上，也不会响应用户的交互事件。隐藏后，元素不会占据任何空间，其他元素会重新排列填充被隐藏元素的位置。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.hidden-element &#123;</span><br><span class="line">  display: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>visibility: hidden：</strong> 使用 <code>visibility: hidden;</code> 属性可以隐藏元素，但它仍然会在文档流中占据空间。元素在页面上不可见，但仍会保留其原有的大小和位置。隐藏后，元素仍然占据空间，其他元素不会重新排列填充其位置。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.hidden-element &#123;</span><br><span class="line">  visibility: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>opacity: 0：</strong> 使用 <code>opacity: 0;</code> 属性可以使元素完全透明，但元素仍然保留在文档流中，并占据空间。元素在页面上不可见，但仍然会占用其原有的位置和大小。透明后，元素仍然占据空间，其他元素不会重新排列填充其位置。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.hidden-element &#123;</span><br><span class="line">  opacity: 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>区别总结：</strong></p>
<ul>
<li><code>display: none;</code> 会完全从文档流中移除元素，不占据空间，其他元素会重新排列填充其位置。</li>
<li><code>visibility: hidden;</code> 会隐藏元素，但仍然保留其占用的空间，其他元素不会重新排列。</li>
<li><code>opacity: 0;</code> 会使元素完全透明，但仍然保留在文档流中，占据空间。</li>
</ul>
<p>选择使用哪种方法取决于具体需求。如果希望元素完全消失且不占据空间，使用 <code>display: none;</code> 是更合适的选择。如果希望元素不可见但仍占据空间，可以使用 <code>visibility: hidden;</code> 或 <code>opacity: 0;</code>。</p>
<h4 id="22-position-的值有哪些，分别有什么特点"><a href="#22-position-的值有哪些，分别有什么特点" class="headerlink" title="22.position 的值有哪些，分别有什么特点?"></a>22.position 的值有哪些，分别有什么特点?</h4><p>CSS 中的 <code>position</code> 属性用于控制元素的定位方式，有以下几个取值：</p>
<ol>
<li><strong>static：</strong> 默认值，元素按照正常的文档流布局。<code>top</code>、<code>right</code>、<code>bottom</code> 和 <code>left</code> 属性不起作用。</li>
<li><strong>relative：</strong> 设置元素相对于其正常位置进行定位。使用 <code>top</code>、<code>right</code>、<code>bottom</code> 和 <code>left</code> 属性可以对元素进行偏移，但元素仍占据原来的空间。相对定位会影响其他元素的布局，其他元素仍会按照相对定位元素的原始位置进行排列。</li>
<li><strong>absolute：</strong> 设置元素完全脱离文档流，相对于其最近的已定位（position 不是 <code>static</code>）的父元素进行定位。如果没有已定位的父元素，则相对于文档的初始位置进行定位。绝对定位会完全脱离文档流，不占据空间，其他元素会填充其位置。</li>
<li><strong>fixed：</strong> 设置元素相对于浏览器窗口进行定位，始终保持在固定的位置，即使页面滚动。固定定位也会脱离文档流，不占据空间。</li>
<li><strong>sticky：</strong> 元素在跨越特定阈值前表现为 <code>relative</code> 定位，之后表现为 <code>fixed</code> 定位。它在滚动时可以将元素固定在指定位置，类似于 <code>fixed</code>，但在某个阈值时又会恢复到 <code>relative</code> 定位，类似于 <code>relative</code>。这个阈值可以通过 <code>top</code>、<code>right</code>、<code>bottom</code> 或 <code>left</code> 属性来设置。</li>
</ol>
<p>需要注意的是，<code>relative</code>、<code>absolute</code>、<code>fixed</code> 和 <code>sticky</code> 属性值会创建一个新的定位上下文（positioned context），这意味着它们会影响子元素的定位。而 <code>static</code> 属性值不会创建新的定位上下文，子元素仍会按照正常的文档流布局。</p>
<h4 id="23-什么是浮动，浮动会引起什么问题，有何解决方案"><a href="#23-什么是浮动，浮动会引起什么问题，有何解决方案" class="headerlink" title="23.什么是浮动，浮动会引起什么问题，有何解决方案?"></a>23.什么是浮动，浮动会引起什么问题，有何解决方案?</h4><p>浮动（float）是 CSS 中的一种定位方式，用于使元素脱离正常的文档流，让元素在其容器中浮动，并排列在容器的左侧或右侧。浮动常用于实现图文混排、多列布局等效果。</p>
<p>浮动会引起以下问题：</p>
<ol>
<li><strong>父容器高度塌陷（容器高度坍塌）：</strong> 当一个元素浮动后，它会脱离文档流，导致其父容器不再计算该元素的高度，从而导致父容器高度塌陷。这会使父容器无法正确包裹浮动元素，影响页面布局。</li>
<li><strong>文字环绕布局问题：</strong> 如果一个浮动元素位于文本的左侧或右侧，文本会环绕在浮动元素的周围，这可能导致排版混乱。</li>
</ol>
<p>解决方案：</p>
<ol>
<li><strong>清除浮动（clearfix）：</strong> 可以在浮动元素后面添加一个空元素，并设置 <code>clear: both;</code> 属性，使父容器正确包裹浮动元素。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.clearfix::after &#123;</span><br><span class="line">  content: &quot;&quot;;</span><br><span class="line">  display: table;</span><br><span class="line">  clear: both;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;clearfix&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;float-box&quot;&gt;浮动元素&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>使用父容器的 overflow 属性：</strong> 将父容器的 <code>overflow</code> 属性设置为 <code>hidden</code> 或 <code>auto</code>，可以触发 BFC（块级格式化上下文），从而包裹浮动元素。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">  overflow: hidden; /* 或 overflow: auto; */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;float-box&quot;&gt;浮动元素&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>使用 Flexbox 布局：</strong> 使用 CSS3 的 Flexbox 布局也可以解决浮动问题，因为 Flexbox 不需要浮动元素。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">  display: flex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;float-box&quot;&gt;浮动元素&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>使用 CSS Grid 布局：</strong> CSS3 中的 Grid 布局也是一种解决浮动问题的方式，它可以轻松实现多列布局。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">  display: grid;</span><br><span class="line">  grid-template-columns: repeat(3, 1fr); /* 3 列等宽布局 */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;float-box&quot;&gt;浮动元素1&lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;float-box&quot;&gt;浮动元素2&lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;float-box&quot;&gt;浮动元素3&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>以上解决方案中，清除浮动（clearfix）和设置父容器的 <code>overflow</code> 属性是传统的方法，在旧浏览器中支持较好。使用 Flexbox 和 CSS Grid 是现代 Web 开发中更推荐的方法，它们可以更灵活地实现复杂的布局需求。</p>
<h4 id="24-line-height-和height的区别"><a href="#24-line-height-和height的区别" class="headerlink" title="24.line-height 和height的区别"></a>24.line-height 和height的区别</h4><p><code>line-height</code> 和 <code>height</code> 是两个 CSS 属性，用于控制元素的高度和行高，它们有一些区别：</p>
<ol>
<li><strong>height（高度）：</strong><ul>
<li><code>height</code> 属性用于设置元素的高度。</li>
<li>它可以接受具体的长度值（像素、百分比等）或者是<code>auto</code>关键字。</li>
<li>当设置为具体的长度值时，元素的高度会被固定为指定的数值，无论其内容是否超过了这个高度。</li>
<li>如果设置为<code>auto</code>，元素的高度会自动根据其内容撑开，以适应内容的高度。</li>
</ul>
</li>
<li><strong>line-height（行高）：</strong><ul>
<li><code>line-height</code> 属性用于设置元素中行框的高度。</li>
<li>它可以接受具体的长度值（像素、百分比等）或者是无单位的数值。</li>
<li>当设置为具体的长度值时，行框的高度会被固定为指定的数值，所有的行框都会具有相同的高度。</li>
<li>如果设置为无单位的数值（如<code>1.5</code>），行框的高度会被设置为字体大小的相对值，例如，如果字体大小为16像素，那么行高将是24像素（16 * 1.5）。</li>
<li><code>line-height</code> 也可以设置为百分比值，此时行高会相对于元素的字体大小进行计算。</li>
</ul>
</li>
</ol>
<p><strong>区别：</strong></p>
<ul>
<li><code>height</code> 用于设置元素的实际高度，可以固定元素的高度。</li>
<li><code>line-height</code> 用于设置行框的高度，影响文本在行内的垂直对齐和行间距。</li>
<li><code>height</code> 设置元素的高度不会影响文本的布局，而 <code>line-height</code> 可以影响文本在行内的垂直居中对齐，或者在多行文本中影响行间距。</li>
</ul>
<p>通常，我们使用 <code>line-height</code> 来调整行间距或实现文本的垂直居中，而使用 <code>height</code> 来设置元素的实际高度。</p>
<h4 id="25-设置一个元素的背景颜色，背景颜色会填充哪些区域"><a href="#25-设置一个元素的背景颜色，背景颜色会填充哪些区域" class="headerlink" title="25.设置一个元素的背景颜色，背景颜色会填充哪些区域?"></a>25.设置一个元素的背景颜色，背景颜色会填充哪些区域?</h4><p>当为一个元素设置背景颜色时，背景颜色会填充以下区域：</p>
<ol>
<li><strong>内容区域（Content Area）：</strong> 背景颜色将填充元素的内容区域，也就是元素内部实际包含的文本、图片或其他元素的区域。这是背景色最主要的填充区域。</li>
<li><strong>内边距区域（Padding Area）：</strong> 如果元素有设置内边距（<code>padding</code>），背景颜色也会延伸到内边距区域。内边距区域是内容区域和边框之间的空白区域。</li>
<li><strong>边框区域（Border Area）：</strong> 背景颜色会填充元素的边框区域，即元素的边框线所占据的区域。</li>
<li><strong>外边距区域（Margin Area）：</strong> 背景颜色不会填充元素的外边距区域，外边距区域是元素与其他元素之间的空白区域，背景颜色不会延伸到这个区域。</li>
</ol>
<p>综上所述，背景颜色将填充元素的内容区域和内边距区域，并且会延伸到边框区域。若想要控制背景颜色的填充范围，可以通过设置元素的内边距和边框来调整。如果希望让背景颜色填充整个元素，可以将元素的内边距和边框设为0。</p>
<h4 id="26-inline-block-inline-和block的区别-为什么img是inline还可以设置宽高"><a href="#26-inline-block-inline-和block的区别-为什么img是inline还可以设置宽高" class="headerlink" title="26.inline-block. inline 和block的区别;为什么img是inline还可以设置宽高"></a>26.inline-block. inline 和block的区别;为什么img是inline还可以设置宽高</h4><p><code>inline-block</code>、<code>inline</code> 和 <code>block</code> 都是CSS中元素的显示属性，它们之间有一些区别：</p>
<p><strong>1. inline（内联元素）：</strong></p>
<ul>
<li><code>inline</code> 元素会在一行内显示，并且不会独占一行。它们会根据内容的大小自动调整宽度，不可以设置宽度和高度属性，设置无效。</li>
<li>典型的 <code>inline</code> 元素有：<code>&lt;span&gt;</code>、<code>&lt;a&gt;</code>、<code>&lt;strong&gt;</code>、<code>&lt;em&gt;</code> 等。</li>
</ul>
<p><strong>2. block（块级元素）：</strong></p>
<ul>
<li><code>block</code> 元素会独占一行，宽度默认是父元素的宽度，可以设置宽度和高度属性。</li>
<li>典型的 <code>block</code> 元素有：<code>&lt;div&gt;</code>、<code>&lt;p&gt;</code>、<code>&lt;h1&gt;</code>～<code>&lt;h6&gt;</code>、<code>&lt;ul&gt;</code>、<code>&lt;li&gt;</code> 等。</li>
</ul>
<p><strong>3. inline-block（内联块级元素）：</strong></p>
<ul>
<li><code>inline-block</code> 元素会在一行内显示，但它可以设置宽度和高度属性，同时不会独占一行。</li>
<li><code>inline-block</code> 元素可以像 <code>inline</code> 元素一样与其他元素在同一行显示，同时又具备像 <code>block</code> 元素一样可以设置宽度和高度的特性。</li>
<li>典型的 <code>inline-block</code> 元素有：<code>&lt;img&gt;</code>、<code>&lt;input&gt;</code> 等。</li>
</ul>
<p><strong>为什么 <code>&lt;img&gt;</code> 是 <code>inline</code> 元素还可以设置宽高：</strong> <code>&lt;img&gt;</code> 标签默认是 <code>inline</code> 元素，但它有固有的宽度和高度，即图片的实际尺寸。因此，尽管 <code>inline</code> 元素不可设置宽度和高度属性，但 <code>&lt;img&gt;</code> 元素可以显示它的实际宽度和高度。当设置 <code>width</code> 和 <code>height</code> 属性时，<code>&lt;img&gt;</code> 元素会按照指定的宽高进行显示，但仍保持在一行内显示，因为它是 <code>inline</code> 元素。这种特性使得在页面中插入图片时，可以通过设置宽高属性来控制图片的显示大小而不破坏文档流布局。</p>
<h4 id="27-什么是重绘-什么是回流-如何减少-如何让文档脱离文档流"><a href="#27-什么是重绘-什么是回流-如何减少-如何让文档脱离文档流" class="headerlink" title="27.什么是重绘?什么是回流?如何减少?如何让文档脱离文档流?"></a>27.什么是重绘?什么是回流?如何减少?如何让文档脱离文档流?</h4><p>重绘（Repaint）和回流（Reflow）是浏览器渲染页面时的两个重要过程，它们的触发和执行会影响页面性能和用户体验。</p>
<p><strong>重绘（Repaint）：</strong></p>
<ul>
<li>重绘是指当元素样式发生变化（例如颜色、背景色、字体颜色等）但不影响其布局的情况下，浏览器会重新绘制该元素的外观，使其更新显示新的样式。重绘不会改变元素的大小和位置，只是重新绘制元素的外观。</li>
</ul>
<p><strong>回流（Reflow）：</strong></p>
<ul>
<li>回流是指当元素的布局发生变化（例如大小、位置、显示或隐藏等）时，浏览器会重新计算并重新构建整个页面的布局树（Layout Tree）。回流会导致页面的重新排列和重绘，是较为消耗性能的操作。</li>
</ul>
<p><strong>如何减少回流和重绘：</strong></p>
<ol>
<li><strong>使用<code>transform</code>属性：</strong> 由于<code>transform</code>属性在GPU上执行，可以减少回流和重绘的次数，适用于移动、旋转和缩放等动画效果。</li>
<li><strong>批量修改样式：</strong> 避免多次单独修改元素的样式，尽量通过添加或移除类名一次性修改样式，以减少回流和重绘的次数。</li>
<li><strong>使用文档片段（DocumentFragment）：</strong> 当需要频繁操作DOM时，可以使用文档片段来进行批量操作，最后再一次性添加到文档中，减少回流。</li>
<li><strong>避免强制同步布局：</strong> 比如读取元素的样式属性（例如offsetTop、offsetWidth等）会导致浏览器强制同步布局，应该避免频繁使用这些属性。</li>
</ol>
<p><strong>如何让文档脱离文档流：</strong></p>
<ul>
<li>要让元素脱离文档流，可以使用CSS的<code>position</code>属性来设置元素的定位方式为<code>absolute</code>（绝对定位）或<code>fixed</code>（固定定位）。这样，元素将不再占据原有的空间，不会影响其他元素的布局。但是，脱离文档流后，元素将根据其定位方式相对于最近的已定位（非<code>static</code>）祖先元素进行定位。</li>
</ul>
<h4 id="28-box-sizing-的作用，如何使用"><a href="#28-box-sizing-的作用，如何使用" class="headerlink" title="28.box-sizing 的作用，如何使用?"></a>28.box-sizing 的作用，如何使用?</h4><p><code>box-sizing</code> 是一个CSS属性，用于控制元素的盒模型计算方式。默认情况下，元素的宽度和高度只包括内容区域（<code>content</code>），而不包括内边距（<code>padding</code>）和边框（<code>border</code>）。这意味着添加内边距和边框会增加元素的总宽度和高度。</p>
<p><code>box-sizing</code> 可以改变盒模型的计算方式，使元素的宽度和高度包括内边距和边框，从而更方便地控制元素的尺寸。<code>box-sizing</code> 可以有以下两个值：</p>
<ol>
<li><code>content-box</code>（默认值）：元素的宽度和高度只包括内容区域（<code>content</code>），内边距（<code>padding</code>）和边框（<code>border</code>）会增加元素的总宽度和高度。</li>
<li><code>border-box</code>：元素的宽度和高度包括内容区域、内边距和边框。换句话说，设置元素的宽度和高度时，内边距和边框的大小不会再增加元素的总宽度和高度，而是会从内容区域减去。</li>
</ol>
<p><strong>如何使用 <code>box-sizing</code>：</strong> 要使用 <code>box-sizing</code> 属性，可以在元素的样式中设置它的值为 <code>content-box</code> 或 <code>border-box</code>。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* 将所有元素的盒模型计算方式设置为 border-box */</span><br><span class="line">* &#123;</span><br><span class="line">  box-sizing: border-box;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 将某个特定元素的盒模型计算方式设置为 border-box */</span><br><span class="line">.my-element &#123;</span><br><span class="line">  box-sizing: border-box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在设置为 <code>border-box</code> 的情况下，当修改元素的宽度或高度时，可以更方便地控制元素的尺寸，因为内边距和边框不会再增加元素的总宽度和高度。这样有助于避免盒模型计算带来的布局问题，特别在处理响应式布局时非常有用。</p>
<h4 id="29-如何实现清除浮动"><a href="#29-如何实现清除浮动" class="headerlink" title="29.如何实现清除浮动"></a>29.如何实现清除浮动</h4><p>在 CSS 中，清除浮动是为了解决由于浮动元素导致的父容器无法正确包裹浮动元素而产生的布局问题。浮动元素会脱离正常的文档流，导致父容器高度塌陷，影响布局。有几种常见的方法可以清除浮动：</p>
<p><strong>1. 使用空元素添加<code>clear</code>属性：</strong> 在浮动元素后面添加一个空元素，并设置 <code>clear: both;</code> 属性，可以清除浮动。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">htmlCopy code&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;float-box&quot;&gt;浮动元素&lt;/div&gt;</span><br><span class="line">  &lt;div style=&quot;clear: both;&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p><strong>2. 使用 clearfix 类：</strong> 定义一个 clearfix 类，将 <code>::after</code> 伪元素应用于父容器，设置 <code>clear: both;</code> 属性，使其成为一个自清除的伪元素。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">  .clearfix::after &#123;</span><br><span class="line">    content: &quot;&quot;;</span><br><span class="line">    display: table;</span><br><span class="line">    clear: both;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;container clearfix&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;float-box&quot;&gt;浮动元素&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p><strong>3. 使用 overflow 属性：</strong> 设置父容器的 <code>overflow</code> 属性为 <code>hidden</code> 或 <code>auto</code>，可以清除浮动。这会使父容器成为一个 BFC（块级格式化上下文），从而包裹浮动元素。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">htmlCopy code&lt;style&gt;</span><br><span class="line">  .container &#123;</span><br><span class="line">    overflow: hidden; /* 或 overflow: auto; */</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;float-box&quot;&gt;浮动元素&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p><strong>4. 使用 flex 布局：</strong> 使用 CSS3 的 Flexbox 布局也可以解决浮动问题，因为 Flexbox 不需要浮动元素。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">htmlCopy code&lt;style&gt;</span><br><span class="line">  .container &#123;</span><br><span class="line">    display: flex;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;float-box&quot;&gt;浮动元素&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>以上方法都可以清除浮动并使父容器正确包裹浮动元素。选择合适的方法取决于具体的布局需求和兼容性考虑。在现代 Web 开发中，通常使用 <code>clearfix</code> 类或 Flexbox 布局来清除浮动。</p>
<h4 id="30-CSS-动画如何实现"><a href="#30-CSS-动画如何实现" class="headerlink" title="30.CSS 动画如何实现"></a>30.CSS 动画如何实现</h4><p>CSS 动画可以通过使用 <code>@keyframes</code> 规则和 CSS 的动画属性来实现。以下是实现 CSS 动画的步骤：</p>
<ol>
<li><strong>定义关键帧（Keyframes）：</strong> 使用 <code>@keyframes</code> 规则来定义动画的关键帧。关键帧是动画的每个阶段的样式状态。在关键帧中，你可以指定元素在动画开始、中间和结束时的样式。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@keyframes myAnimation &#123;</span><br><span class="line">  0% &#123; /* 动画开始时的样式 */ &#125;</span><br><span class="line">  50% &#123; /* 动画中间时的样式 */ &#125;</span><br><span class="line">  100% &#123; /* 动画结束时的样式 */ &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>应用动画属性：</strong> 使用 CSS 的动画属性来将定义好的关键帧应用到元素上。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.element &#123;</span><br><span class="line">  animation-name: myAnimation; /* 指定动画关键帧的名称 */</span><br><span class="line">  animation-duration: 2s; /* 指定动画的持续时间 */</span><br><span class="line">  animation-timing-function: ease; /* 指定动画的时间函数（速度曲线），可选值：ease、linear、ease-in、ease-out、ease-in-out 等 */</span><br><span class="line">  animation-delay: 0s; /* 指定动画延迟开始的时间 */</span><br><span class="line">  animation-iteration-count: infinite; /* 指定动画的循环次数，可以是数字或关键词：infinite（无限循环） */</span><br><span class="line">  animation-direction: normal; /* 指定动画的播放方向，可选值：normal（正向）、reverse（反向）、alternate（交替）等 */</span><br><span class="line">  animation-fill-mode: forwards; /* 指定动画结束时元素的样式状态，可选值：none、forwards、backwards、both */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>触发动画：</strong> 一旦定义了关键帧和应用了动画属性，动画就会在满足触发条件时开始。常见的触发方式有：</li>
</ol>
<ul>
<li>使用 <code>animation</code> 属性的 <code>animation-play-state</code> 设置为 <code>running</code> 或 <code>paused</code> 来控制动画的播放和暂停。</li>
<li>使用 JavaScript 来动态添加或移除类名，从而触发动画。</li>
</ul>
<p>上述步骤可以实现简单的 CSS 动画效果。通过调整关键帧的样式和动画属性的设置，可以实现更复杂和多样化的动画效果。</p>
<h4 id="31-如何实现在某个容器中居中的"><a href="#31-如何实现在某个容器中居中的" class="headerlink" title="31.如何实现在某个容器中居中的?"></a>31.如何实现在某个容器中居中的?</h4><p>要实现在某个容器中居中元素，可以采用以下几种方法：</p>
<p><strong>1. 使用 Flexbox 布局：</strong> 使用 CSS Flexbox 布局是一种简单而强大的居中方法。将容器的 <code>display</code> 属性设置为 <code>flex</code>，并添加 <code>align-items: center; justify-content: center;</code>，即可使容器内部的元素在水平和垂直方向上居中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">  display: flex;</span><br><span class="line">  align-items: center;</span><br><span class="line">  justify-content: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. 使用绝对定位：</strong> 通过将要居中的元素设置为绝对定位，并使用 <code>top</code>、<code>bottom</code>、<code>left</code>、<code>right</code> 属性来将元素定位在容器中间。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">  position: relative;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.centered-element &#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">  top: 50%;</span><br><span class="line">  left: 50%;</span><br><span class="line">  transform: translate(-50%, -50%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. 使用 Grid 布局：</strong> 利用 CSS Grid 布局也可以实现元素居中。将容器的 <code>display</code> 属性设置为 <code>grid</code>，并使用 <code>place-items: center;</code> 属性来将元素居中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">  display: grid;</span><br><span class="line">  place-items: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4. 使用文本对齐：</strong> 对于内联元素（如文本或行内元素），可以使用 <code>text-align: center;</code> 将文本在容器中水平居中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">  text-align: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上方法都可以让元素在其容器中居中。根据具体需求和布局情况，选择适合的方法即可。</p>
<h4 id="32-如何改变一个DOM元素的字体颜色"><a href="#32-如何改变一个DOM元素的字体颜色" class="headerlink" title="32.如何改变一个DOM元素的字体颜色?"></a>32.如何改变一个DOM元素的字体颜色?</h4><p>要改变一个 DOM 元素的字体颜色，可以通过 CSS 或 JavaScript 来实现。以下是两种常用的方法：</p>
<p><strong>1. 使用 CSS：</strong> 可以使用 CSS 的 <code>color</code> 属性来改变元素的字体颜色。将需要改变字体颜色的元素的 CSS <code>color</code> 属性设置为所需的颜色值即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* 在样式表中设置元素字体颜色 */</span><br><span class="line">.element &#123;</span><br><span class="line">  color: red; /* 将元素的字体颜色设置为红色 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. 使用 JavaScript：</strong> 如果希望在特定事件触发时改变元素的字体颜色，可以使用 JavaScript 来动态修改元素的样式。例如，使用 JavaScript 的 <code>style</code> 属性来设置元素的 <code>color</code> 属性。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- HTML --&gt;</span><br><span class="line">&lt;div id=&quot;myElement&quot;&gt;这是一个文本&lt;/div&gt;</span><br><span class="line">&lt;button onclick=&quot;changeColor()&quot;&gt;改变颜色&lt;/button&gt;</span><br><span class="line">// JavaScript</span><br><span class="line">function changeColor() &#123;</span><br><span class="line">  var element = document.getElementById(&#x27;myElement&#x27;);</span><br><span class="line">  element.style.color = &#x27;blue&#x27;; // 将元素的字体颜色设置为蓝色</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上两种方法都可以实现改变元素的字体颜色。如果需要实现动态效果，可以使用 JavaScript 在特定事件触发时改变元素样式。如果只是静态改变，直接使用 CSS 的 <code>color</code> 属性即可。</p>
<h4 id="33-相对布局和绝对布局，position-relative-和obsolute"><a href="#33-相对布局和绝对布局，position-relative-和obsolute" class="headerlink" title="33.相对布局和绝对布局，position:relative 和obsolute"></a>33.相对布局和绝对布局，position:relative 和obsolute</h4><p>相对布局（<code>position: relative</code>）和绝对布局（<code>position: absolute</code>）是 CSS 中两种常见的定位方式，它们用于控制元素在文档流中的位置。</p>
<p><strong>相对布局（position: relative）：</strong></p>
<ol>
<li>相对布局会使元素脱离正常的文档流，但它仍然占据原来的空间，其他元素不会填充其位置。</li>
<li>设置相对布局后，可以通过 <code>top</code>、<code>right</code>、<code>bottom</code> 和 <code>left</code> 属性来相对于元素原来的位置进行偏移。例如，<code>top: 10px; left: 20px;</code> 表示元素相对于原来位置向下偏移 10 像素，向右偏移 20 像素。</li>
<li>相对布局影响其他元素的布局，其他元素仍会按照相对布局元素的原始位置进行排列。</li>
</ol>
<p><strong>绝对布局（position: absolute）：</strong></p>
<ol>
<li>绝对布局会使元素完全脱离文档流，并且不占据任何空间，其他元素会填充其位置。</li>
<li>设置绝对布局后，元素的位置相对于距离它最近的具有定位（position 不是 <code>static</code>）的父元素，如果没有则相对于文档的初始位置进行偏移。</li>
<li>可以通过 <code>top</code>、<code>right</code>、<code>bottom</code> 和 <code>left</code> 属性来控制元素的位置。</li>
</ol>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;relative-box&quot;&gt;相对布局&lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;absolute-box&quot;&gt;绝对布局&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">.container &#123;</span><br><span class="line">  position: relative;</span><br><span class="line">  width: 200px;</span><br><span class="line">  height: 200px;</span><br><span class="line">  border: 1px solid black;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.relative-box &#123;</span><br><span class="line">  position: relative;</span><br><span class="line">  top: 20px;</span><br><span class="line">  left: 30px;</span><br><span class="line">  background-color: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.absolute-box &#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">  top: 50px;</span><br><span class="line">  left: 100px;</span><br><span class="line">  background-color: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>.relative-box</code> 采用相对布局，并相对于原来位置向下偏移 20 像素、向右偏移 30 像素。<code>.absolute-box</code> 采用绝对布局，并相对于父元素 <code>.container</code> 向下偏移 50 像素、向右偏移 100 像素。可以观察到 <code>.absolute-box</code> 完全脱离了文档流，而 <code>.relative-box</code> 仍然占据了原来的空间。</p>
<h4 id="34-什么是弹性盒子flex布局"><a href="#34-什么是弹性盒子flex布局" class="headerlink" title="34.什么是弹性盒子flex布局?"></a>34.什么是弹性盒子flex布局?</h4><p>弹性盒子（Flexbox）布局是 CSS3 引入的一种用于页面布局的模型，旨在提供更加灵活和方便的布局方式。Flexbox 可以使元素在容器内部自由地伸缩、对齐和重新排列，从而实现适应不同屏幕尺寸和设备的响应式布局。</p>
<p>Flexbox 的主要特点包括以下几个方面：</p>
<ol>
<li><strong>主轴和交叉轴：</strong> Flexbox 布局使用一个主轴和一个交叉轴。主轴是元素的排列方向，可以是水平方向（水平主轴）或垂直方向（垂直主轴）。交叉轴是与主轴垂直的轴线。</li>
<li><strong>容器和项目：</strong> Flexbox 的布局模型中，容器（Container）是指应用了 Flexbox 的元素，它的 <code>display</code> 属性设置为 <code>flex</code> 或 <code>inline-flex</code>。容器内部的每个子元素都是项目（Item），也称为弹性项目。</li>
<li><strong>弹性容器属性：</strong> 容器具有一系列属性，用于控制容器内项目的布局方式。常用的容器属性包括：<code>flex-direction</code>（决定主轴的方向）、<code>justify-content</code>（主轴上项目的对齐方式）、<code>align-items</code>（交叉轴上项目的对齐方式）、<code>flex-wrap</code>（项目换行方式）等。</li>
<li><strong>弹性项目属性：</strong> 项目也具有一系列属性，用于控制项目自身在容器内的布局。常用的项目属性包括：<code>flex</code>（设置项目的伸缩比例）、<code>flex-basis</code>（项目在主轴上的初始大小）、<code>align-self</code>（设置项目在交叉轴上的对齐方式）等。</li>
</ol>
<p>使用 Flexbox 布局可以轻松实现水平和垂直居中、等高列布局、自适应布局等复杂的页面结构，减少了传统布局中需要使用大量浮动和定位的情况，使页面的布局更加直观、简单和灵活。因此，Flexbox 布局在现代 Web 开发中得到了广泛的应用。</p>
<h4 id="35-什么是rem布局"><a href="#35-什么是rem布局" class="headerlink" title="35.什么是rem布局?"></a>35.什么是rem布局?</h4><p><code>rem</code> 布局是一种相对于根元素（通常指 <code>&lt;html&gt;</code> 元素）字体大小的布局方式。在 <code>rem</code> 布局中，页面中的元素尺寸和间距都使用相对于根元素的字体大小来表示，而不是使用固定的像素值。这样可以实现页面元素的动态缩放，适应不同屏幕尺寸和设备。</p>
<p>在 <code>rem</code> 布局中，一般会将根元素的字体大小设置为一个相对于屏幕宽度的百分比，通常是使用CSS中的<code>vw</code>（视窗宽度）单位来设置。然后，其他元素的尺寸和间距都使用<code>rem</code> 单位来表示。</p>
<p>例如，假设我们将根元素的字体大小设置为 <code>1vw</code>，并假设设计稿的宽度为 <code>750px</code>。那么 <code>1rem</code> 就等于 <code>7.5px</code>（即 <code>750px * 1vw</code>）。然后，如果我们希望某个元素的宽度为设计稿中的 <code>150px</code>，可以将其设置为 <code>20rem</code>（即 <code>150px / 7.5px</code>）。</p>
<p>优点：</p>
<ul>
<li><code>rem</code> 布局能够实现页面的动态缩放，适应不同屏幕和设备，提供更好的响应式体验。</li>
<li>可以方便地在不同设备上调整根元素字体大小来适应不同屏幕尺寸。</li>
</ul>
<p>注意：</p>
<ul>
<li>使用 <code>rem</code> 布局时，需要合理设置根元素字体大小，避免页面元素过小或过大。</li>
<li>在某些老旧浏览器中，对 <code>rem</code> 单位的支持可能有限，需做相应兼容处理。</li>
</ul>
<p>综上所述，<code>rem</code> 布局是一种相对于根元素字体大小的动态布局方式，可以提供更好的响应式体验。</p>
<h4 id="36-less和scss有什么区别"><a href="#36-less和scss有什么区别" class="headerlink" title="36.less和scss有什么区别?"></a>36.less和scss有什么区别?</h4><p>LESS（Leaner Style Sheets）和 SCSS（Sassy CSS）都是 CSS 预处理器，它们在功能和语法上有一些区别，但目的都是为了增强 CSS 的功能并提高开发效率。</p>
<p><strong>LESS：</strong></p>
<ol>
<li><strong>语法：</strong> LESS 使用较为简洁的语法，使用大括号 <code>&#123;&#125;</code> 和分号 <code>;</code> 来表示代码块和语句。</li>
<li><strong>变量：</strong> LESS 使用 <code>@</code> 符号来定义变量，例如 <code>@color: #ff0000;</code>。</li>
<li><strong>嵌套规则：</strong> 可以在 LESS 中嵌套 CSS 规则，使代码结构更清晰。</li>
<li><strong>混合（Mixins）：</strong> LESS 支持混合功能，允许将一组样式混合到另一个选择器中。</li>
<li><strong>运算：</strong> LESS 允许进行简单的数学运算，如加法、减法等。</li>
<li><strong>导入：</strong> 可以使用 <code>@import</code> 指令引入其他 LESS 文件。</li>
</ol>
<p><strong>SCSS：</strong></p>
<ol>
<li><strong>语法：</strong> SCSS 使用与 CSS 相似的语法，使用大括号 <code>&#123;&#125;</code> 和分号 <code>;</code> 表示代码块和语句。</li>
<li><strong>变量：</strong> SCSS 也使用 <code>@</code> 符号来定义变量，与 LESS 类似，例如 <code>$color: #ff0000;</code>。</li>
<li><strong>嵌套规则：</strong> 与 LESS 类似，SCSS 也支持在选择器中嵌套其他规则。</li>
<li><strong>混合（Mixins）：</strong> SCSS 支持混合功能，使用 <code>@mixin</code> 和 <code>@include</code> 来定义和调用混合。</li>
<li><strong>运算：</strong> 与 LESS 类似，SCSS 也允许进行数学运算。</li>
<li><strong>导入：</strong> 可以使用 <code>@import</code> 指令引入其他 SCSS 文件。</li>
</ol>
<p><strong>区别总结：</strong></p>
<ul>
<li>LESS 和 SCSS 的语法风格有所不同，LESS 更加简洁，SCSS 更接近于标准的 CSS。</li>
<li>变量、嵌套规则、混合等功能在两者中都有支持，但语法稍有差异。</li>
<li>选择使用 LESS 还是 SCSS 取决于个人偏好和项目需求。两者功能基本上相似，选择一种熟悉且适合团队的预处理器即可。</li>
</ul>
<h4 id="37-before-和-after中双冒号和单冒号的区别"><a href="#37-before-和-after中双冒号和单冒号的区别" class="headerlink" title="37.::before 和::after中双冒号和单冒号的区别?"></a>37.::before 和::after中双冒号和单冒号的区别?</h4><p>在 CSS 中，<code>::before</code> 和 <code>::after</code> 是伪元素（pseudo-elements），用于在元素的内容前面或后面插入生成的内容。它们的双冒号和单冒号表示方式有一些历史和语法上的区别：</p>
<ol>
<li><strong>双冒号（<code>::</code>）：</strong><ul>
<li><code>::before</code> 和 <code>::after</code> 使用双冒号 <code>::</code> 表示伪元素的写法，这是 CSS3 引入的新语法。</li>
<li>根据 CSS3 标准，伪元素应该使用双冒号 <code>::</code> 表示。</li>
</ul>
</li>
<li><strong>单冒号（<code>:</code>）：</strong><ul>
<li>在旧的 CSS2 规范中，伪元素使用单冒号 <code>:</code> 表示，例如 <code>:before</code> 和 <code>:after</code>。</li>
<li>单冒号的写法在 CSS3 中仍然被广泛支持，用于保持对旧浏览器的兼容性。</li>
</ul>
</li>
</ol>
<p>所以，使用 <code>::before</code> 和 <code>::after</code> 是更加符合当前 CSS3 标准的写法，但在实际使用中，为了兼容性考虑，可以继续使用 <code>:before</code> 和 <code>:after</code> 这样的单冒号写法。</p>
<p>例如，创建一个在元素内容前插入文本的伪元素样式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* 使用双冒号的写法（CSS3标准） */</span><br><span class="line">.element::before &#123;</span><br><span class="line">  content: &quot;前置内容&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 使用单冒号的写法（兼容旧浏览器） */</span><br><span class="line">.element:before &#123;</span><br><span class="line">  content: &quot;前置内容&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无论使用双冒号还是单冒号，它们的功能都是一样的，只是写法上存在细微的差别。建议在项目中根据实际需求和兼容性考虑选择合适的写法。</p>
<h4 id="38-CSS3新增伪类，以及伪元素"><a href="#38-CSS3新增伪类，以及伪元素" class="headerlink" title="38.CSS3新增伪类，以及伪元素?"></a>38.CSS3新增伪类，以及伪元素?</h4><p>CSS3引入了一些新的伪类和伪元素，让开发者在样式表中更加灵活和精确地选择和样式化HTML元素。以下是CSS3新增的一些伪类和伪元素：</p>
<p><strong>伪类（Pseudo-classes）：</strong></p>
<ol>
<li><code>:nth-child(n)</code>：选择其父元素下的第 n 个子元素。可以用来实现奇偶行效果。</li>
<li><code>:nth-last-child(n)</code>：选择其父元素下的倒数第 n 个子元素。</li>
<li><code>:first-child</code>：选择其父元素下的第一个子元素。</li>
<li><code>:last-child</code>：选择其父元素下的最后一个子元素。</li>
<li><code>:only-child</code>：选择其父元素下仅有的一个子元素。</li>
<li><code>:not(selector)</code>：选择不匹配给定选择器的元素。</li>
<li><code>:checked</code>：选择已选中的表单元素，例如复选框或单选按钮。</li>
<li><code>:focus</code>：选择当前获取焦点的元素。</li>
<li><code>:hover</code>：选择鼠标悬停在其上的元素。</li>
<li><code>:active</code>：选择当前正在被激活（鼠标按下还未释放）的元素。</li>
</ol>
<p><strong>伪元素（Pseudo-elements）：</strong></p>
<ol>
<li><code>::before</code>：在元素的内容之前插入一个伪元素，通常用于添加装饰或图标。</li>
<li><code>::after</code>：在元素的内容之后插入一个伪元素，同样用于添加装饰或图标。</li>
<li><code>::first-line</code>：选择元素的第一行文本。</li>
<li><code>::first-letter</code>：选择元素的第一个字母或字符。</li>
</ol>
<p>请注意，伪类和伪元素的语法不同，伪类使用单冒号（<code>:</code>），而伪元素使用双冒号（<code>::</code>）。但为了向后兼容，可以继续使用单冒号来表示伪元素，例如<code>:before</code>和<code>:after</code>。</p>
<p>这些伪类和伪元素的引入为开发者提供了更多样式化HTML元素的选项和灵活性，使得可以在不添加多余HTML元素的情况下实现一些复杂的样式效果。</p>
<h4 id="39-响应式布局实现方案"><a href="#39-响应式布局实现方案" class="headerlink" title="39.响应式布局实现方案?"></a>39.响应式布局实现方案?</h4><p>实现响应式布局是为了使网站或应用能够适应不同屏幕尺寸和设备，提供更好的用户体验。以下是几种常见的响应式布局实现方案：</p>
<ol>
<li><p><strong>使用CSS Media Queries：</strong> CSS Media Queries 是一种在CSS中根据不同媒体设备的特性来应用不同样式的机制。通过定义不同的断点（例如：手机、平板、桌面屏幕尺寸），可以针对不同屏幕宽度应用不同的样式，从而实现响应式布局。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* 媒体查询，适用于小屏幕（手机） */</span><br><span class="line">@media screen and (max-width: 768px) &#123;</span><br><span class="line">  /* 在这里定义适合小屏幕的样式 */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 媒体查询，适用于中等屏幕（平板） */</span><br><span class="line">@media screen and (min-width: 769px) and (max-width: 1024px) &#123;</span><br><span class="line">  /* 在这里定义适合中等屏幕的样式 */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 媒体查询，适用于大屏幕（桌面） */</span><br><span class="line">@media screen and (min-width: 1025px) &#123;</span><br><span class="line">  /* 在这里定义适合大屏幕的样式 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用CSS Flexbox：</strong> CSS Flexbox 是一种弹性布局模型，可以快速简单地实现响应式布局。通过设置容器的 <code>display: flex</code> 属性，子元素可以根据可用空间自动调整布局。这对于创建适应不同屏幕大小的灵活布局非常有用。</p>
</li>
<li><p><strong>使用CSS Grid：</strong> CSS Grid 是一种二维网格布局系统，也是一种强大的响应式布局工具。它允许开发者以网格形式对元素进行定位和对齐，可以在网格的不同单元格中自由地进行布局调整。</p>
</li>
<li><p><strong>使用流式布局（Fluid Layout）：</strong> 流式布局是一种基于百分比单位的布局方法，可以让元素的宽度和高度随着屏幕大小的变化而自动调整。使用百分比单位来设置元素的宽度，使其在不同屏幕上具有相对的大小。</p>
</li>
<li><p><strong>使用CSS预处理器：</strong> 使用CSS预处理器（如Sass、Less）可以更加方便地管理和组织响应式布局样式。通过定义变量和混合（Mixin），可以简化媒体查询的书写，提高代码的可维护性。</p>
</li>
</ol>
<p>无论采用哪种方案，响应式布局都应该考虑各种屏幕尺寸和设备，并确保在不同分辨率下都能提供良好的用户体验。同时，还可以通过测试和调试来验证响应式布局的效果，并确保在不同设备上显示正常。</p>
<h4 id="40-link-标签和import标签的区别"><a href="#40-link-标签和import标签的区别" class="headerlink" title="40.link 标签和import标签的区别?"></a>40.link 标签和import标签的区别?</h4><p><code>&lt;link&gt;</code>标签和<code>&lt;import&gt;</code>标签是用于在HTML文档中引入外部资源的两种方式，但它们有一些区别和应用场景：</p>
<p><strong><code>&lt;link&gt;</code>标签：</strong></p>
<ul>
<li><code>&lt;link&gt;</code>标签是HTML中的常规标签，主要用于引入外部资源，比如CSS样式表或图标字体等。</li>
<li>通过<code>&lt;link&gt;</code>标签引入的资源是并行加载的，即在浏览器解析HTML时，会同时发起多个请求去加载所有引入的资源。</li>
<li>适用于引入CSS样式表，因为CSS文件的加载不会阻塞DOM的解析，可以并行加载多个CSS文件，从而提高页面加载速度。</li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;styles.css&quot;&gt;</span><br></pre></td></tr></table></figure>

<p><strong><code>&lt;import&gt;</code>标签：</strong></p>
<ul>
<li><code>&lt;import&gt;</code>标签是HTML的扩展标签，在使用Web Components时才会用到。</li>
<li><code>&lt;import&gt;</code>标签用于引入外部的HTML模块，这些模块可以包含自定义元素、样式和脚本等，形成一个封闭的组件。</li>
<li>通过<code>&lt;import&gt;</code>标签引入的HTML模块是串行加载的，即需要等待引入的模块完全加载和解析后才能继续解析后续内容。</li>
<li>适用于使用Web Components构建复杂组件化的应用。</li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;import src=&quot;component.html&quot;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<ol>
<li><code>&lt;import&gt;</code>标签现在已经被废弃，不建议再使用，推荐使用ES6的<code>import</code>语句来引入模块。</li>
<li>在现代的前端开发中，通常使用<code>&lt;link&gt;</code>标签来引入CSS样式表，使用<code>&lt;script&gt;</code>标签来引入JavaScript脚本，而使用模块化的方式（如ES6的<code>import</code>语句或模块打包工具）来引入JavaScript模块。</li>
</ol>
<p>总结起来，<code>&lt;link&gt;</code>标签主要用于引入CSS样式表和外部资源，而<code>&lt;import&gt;</code>标签是HTML的扩展标签，用于引入HTML模块，但在现代开发中已经被废弃，推荐使用其他方式进行模块化的引入。</p>
<h4 id="41-transition-和animation-的区别"><a href="#41-transition-和animation-的区别" class="headerlink" title="41.transition 和animation 的区别?"></a>41.transition 和animation 的区别?</h4><p><code>transition</code> 和 <code>animation</code> 是两种用于实现元素动画效果的CSS属性，它们有以下区别：</p>
<p><strong>1. 触发方式：</strong></p>
<ul>
<li><code>transition</code>：通常由CSS属性的变化触发，比如当元素的颜色、大小、位置等属性发生变化时，可以使用 <code>transition</code> 属性来平滑地过渡到新的状态。</li>
<li><code>animation</code>：在<code>animation</code>中，动画的触发可以通过CSS关键帧的定义，或者通过JavaScript动态添加类来触发。</li>
</ul>
<p><strong>2. 实现方式：</strong></p>
<ul>
<li><code>transition</code>：通过定义元素的起始状态和结束状态，并设置过渡时间和过渡函数（timing function）来实现动画效果。</li>
<li><code>animation</code>：通过定义关键帧（Keyframes），指定元素在不同阶段的样式状态，以及动画的持续时间、循环次数等来实现动画效果。</li>
</ul>
<p><strong>3. 动画的控制：</strong></p>
<ul>
<li><code>transition</code>：过渡动画是受元素属性的变化控制的，一旦触发属性变化，过渡就会自动执行。</li>
<li><code>animation</code>：动画可以通过添加、移除类或者通过JavaScript来控制启动和停止。</li>
</ul>
<p><strong>4. 多步动画：</strong></p>
<ul>
<li><code>transition</code>：<code>transition</code> 属性通常只能实现简单的单步过渡，从一个状态平滑过渡到另一个状态。</li>
<li><code>animation</code>：<code>animation</code> 属性可以定义复杂的多步动画，通过关键帧的方式在不同的时间点指定不同的样式状态。</li>
</ul>
<p><strong>5. 浏览器支持：</strong></p>
<ul>
<li><code>transition</code> 和 <code>animation</code> 属性都得到了广泛支持，但某些旧版本的浏览器可能对一些属性和特性的支持有限。</li>
</ul>
<p><strong>总结：</strong></p>
<ul>
<li><code>transition</code> 适用于简单的属性过渡，比如颜色、大小、位置等的平滑过渡。</li>
<li><code>animation</code> 适用于复杂的多步动画，可以定义更多样化的动画效果，同时提供更灵活的控制方式。</li>
</ul>
<p>在实际应用中，可以根据动画的复杂程度和控制需求来选择使用 <code>transition</code> 还是 <code>animation</code>，有时也可以结合两者来实现更复杂、更丰富的动画效果。</p>
<h4 id="42-说一下块元素、行元素、置换元素"><a href="#42-说一下块元素、行元素、置换元素" class="headerlink" title="42.说一下块元素、行元素、置换元素"></a>42.说一下块元素、行元素、置换元素</h4><p>在HTML和CSS中，元素可以分为块元素（Block-level Elements）、行元素（Inline Elements）和置换元素（Replaced Elements）三类，这些类型决定了元素在文档流中的显示方式和行为。</p>
<p><strong>块元素（Block-level Elements）：</strong></p>
<ol>
<li>块元素独占一行，会自动换行，并且默认情况下会撑满其父元素的宽度。</li>
<li>常见的块元素包括<code>&lt;div&gt;</code>、<code>&lt;p&gt;</code>、<code>&lt;h1&gt;</code>～<code>&lt;h6&gt;</code>、<code>&lt;ul&gt;</code>、<code>&lt;ol&gt;</code>、<code>&lt;li&gt;</code>等。</li>
<li>块元素可以包含其他块元素和行元素。</li>
</ol>
<p><strong>行元素（Inline Elements）：</strong></p>
<ol>
<li>行元素不会独占一行，它们会在一行内根据其内容排列，并不会强制换行。</li>
<li>常见的行元素包括<code>&lt;span&gt;</code>、<code>&lt;a&gt;</code>、<code>&lt;img&gt;</code>、<code>&lt;strong&gt;</code>、<code>&lt;em&gt;</code>等。</li>
<li>行元素只能包含其他行元素或文本，不能包含块元素。</li>
</ol>
<p><strong>置换元素（Replaced Elements）：</strong></p>
<ol>
<li>置换元素是一种特殊类型的元素，其内容由外部资源决定，而不是由元素自身的内容决定。</li>
<li>典型的置换元素包括<code>&lt;img&gt;</code>、<code>&lt;input&gt;</code>、<code>&lt;video&gt;</code>、<code>&lt;audio&gt;</code>等，它们的内容是由其<code>src</code>、<code>type</code>等属性所指定的外部资源。</li>
<li>置换元素通常具有内在尺寸，比如<code>&lt;img&gt;</code>元素的宽度和高度，但可以通过CSS来调整其显示大小。</li>
</ol>
<p>需要注意的是，HTML5中的规范有所更新，增加了一些灵活性。例如，<code>&lt;a&gt;</code>元素在HTML4中是行元素，但在HTML5中可以同时具备行元素和块元素的特性，因此可以在其内部包含块级元素。</p>
<p>理解块元素、行元素和置换元素的区别对于控制元素的布局和样式非常重要，同时也有助于优化页面结构和样式设计。</p>
<h4 id="43-多行元素的文本省略号如何实现？"><a href="#43-多行元素的文本省略号如何实现？" class="headerlink" title="43.多行元素的文本省略号如何实现？"></a>43.多行元素的文本省略号如何实现？</h4><p>在CSS中，可以通过使用<code>text-overflow</code>属性和<code>white-space</code>属性来实现多行元素文本的省略号。以下是实现多行文本省略号的步骤：</p>
<ol>
<li><strong>设置容器的高度和<code>overflow</code>属性：</strong> 首先，将多行文本的容器设置一个固定的高度，并将<code>overflow</code>属性设置为<code>hidden</code>，这样超出容器高度的文本将被隐藏。</li>
<li><strong>设置<code>white-space</code>属性：</strong> 将容器的<code>white-space</code>属性设置为<code>nowrap</code>，这样文本将在一行中显示，不会换行。</li>
<li><strong>设置<code>text-overflow</code>属性：</strong> 使用<code>text-overflow: ellipsis</code>来在文本溢出容器时显示省略号。</li>
</ol>
<p>下面是一个示例的CSS样式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">  height: 60px; /* 设置容器高度 */</span><br><span class="line">  overflow: hidden; /* 隐藏超出容器高度的内容 */</span><br><span class="line">  white-space: nowrap; /* 文本不换行 */</span><br><span class="line">  text-overflow: ellipsis; /* 显示省略号 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，将上述样式应用到包含文本的容器中，这样就能实现多行文本的省略号效果。请注意，这种方法适用于单行文本超出容器高度的情况。</p>
<p>如果希望实现多行文本的省略号，可以结合使用CSS的<code>display: -webkit-box</code> 和 <code>-webkit-line-clamp</code>属性，但这些属性在一些浏览器中的支持可能不稳定。以下是示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">  display: -webkit-box;</span><br><span class="line">  -webkit-line-clamp: 3; /* 设置显示的最大行数 */</span><br><span class="line">  -webkit-box-orient: vertical;</span><br><span class="line">  overflow: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码将文本限制在3行，并在超出时显示省略号。请注意，<code>-webkit-line-clamp</code>属性可能不被所有浏览器支持，而且它是一个非标准的CSS属性。因此，在实际使用时，请谨慎考虑兼容性。</p>
<h4 id="44-Doctype-作用？严格模式与混杂模式如何区分？它们有何意义？"><a href="#44-Doctype-作用？严格模式与混杂模式如何区分？它们有何意义？" class="headerlink" title="44.Doctype 作用？严格模式与混杂模式如何区分？它们有何意义？"></a>44.Doctype 作用？严格模式与混杂模式如何区分？它们有何意义？</h4><p><code>DOCTYPE</code>（文档类型声明）是HTML文档中的一个特殊标记，用于指示浏览器使用哪种HTML版本解析页面。它的作用是告诉浏览器以何种模式来渲染文档，以确保页面在不同浏览器中的显示一致性。</p>
<p><strong>严格模式（Strict Mode）：</strong></p>
<ul>
<li>在严格模式下，浏览器会按照HTML规范的严格标准解析和渲染页面。</li>
<li>要进入严格模式，需要在HTML文档的开头添加以下DOCTYPE声明：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br></pre></td></tr></table></figure>

<p><strong>混杂模式（Quirks Mode）：</strong></p>
<ul>
<li>在混杂模式下，浏览器会以一种与HTML规范不完全兼容的方式解析和渲染页面。</li>
<li>如果HTML文档中没有正确声明DOCTYPE，或者声明了过时的DOCTYPE（比如HTML 4.01的DTD声明），浏览器将进入混杂模式。</li>
</ul>
<p><strong>意义：</strong> 正确使用DOCTYPE声明非常重要，它对页面的渲染和布局产生直接影响。主要意义如下：</p>
<ol>
<li><strong>确定页面渲染模式：</strong> DOCTYPE声明告诉浏览器应该使用哪种渲染模式，是严格模式还是混杂模式。</li>
<li><strong>确保跨浏览器兼容性：</strong> 使用正确的DOCTYPE声明可以确保页面在不同浏览器中以相同的方式显示，避免兼容性问题。</li>
<li><strong>遵循标准规范：</strong> 在严格模式下，浏览器会更严格地按照HTML和CSS规范解析页面，从而避免一些奇怪的行为和布局问题。</li>
</ol>
<p>总之，DOCTYPE声明在HTML文档中的重要性不可忽视。始终建议使用<code>&lt;!DOCTYPE html&gt;</code>声明进入严格模式，并编写符合标准规范的HTML代码，以确保最佳的跨浏览器兼容性和一致的页面渲染效果。</p>
<h4 id="45-css中制作动画为什么人们用translate来改变位置而不是定位？"><a href="#45-css中制作动画为什么人们用translate来改变位置而不是定位？" class="headerlink" title="45.css中制作动画为什么人们用translate来改变位置而不是定位？"></a>45.css中制作动画为什么人们用translate来改变位置而不是定位？</h4><p>1.translate（）是transfrom的一个值。改变transfrom或者opacity不会触发浏览器重新布局（reflow）或重绘（repaint），只会触发复合（compositions）。</p>
<p>2.改变绝对定位会触发重新布局，进而触发重绘和复合。</p>
<p>3.transfrom使浏览器为元素创建一个GPU。但改变绝对定位会使用到GPU。因此translate（）更高效，可以缩短平滑动画的绘制时间。</p>
<p>4.translate改变位置时，元素依旧会占据其原始空间，绝对定位不是。</p>
<h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><h4 id="1-javascript-的数据类型有哪些"><a href="#1-javascript-的数据类型有哪些" class="headerlink" title="1.javascript 的数据类型有哪些?"></a>1.javascript 的数据类型有哪些?</h4><p>在 JavaScript 中，数据类型主要分为两类：基本数据类型（Primitive Data Types）和引用数据类型（Reference Data Types）。以下是 JavaScript 的数据类型：</p>
<p><strong>1. 基本数据类型（Primitive Data Types）：</strong></p>
<ul>
<li><strong>Number（数字）：</strong> 整数或浮点数，如 <code>1</code>、<code>3.14</code> 等。</li>
<li><strong>String（字符串）：</strong> 由字符组成的文本，用单引号 <code>&#39;</code> 或双引号 <code>&quot;</code> 括起来，如 <code>&#39;Hello&#39;</code>、<code>&quot;JavaScript&quot;</code> 等。</li>
<li><strong>Boolean（布尔值）：</strong> 表示真（<code>true</code>）或假（<code>false</code>）。</li>
<li><strong>Undefined（未定义）：</strong> 表示声明了变量但没有赋值的情况，或访问不存在的属性。</li>
<li><strong>Null（空值）：</strong> 表示空值或不存在的对象。</li>
<li><strong>Symbol（符号）：</strong> ES6 中新增的数据类型，表示唯一的、不可变的值，用于对象属性的键。</li>
</ul>
<p><strong>2. 引用数据类型（Reference Data Types）：</strong></p>
<ul>
<li><strong>Object（对象）：</strong> 复杂数据类型，表示一组键值对的集合，可以是普通对象、数组、函数等。</li>
<li><strong>Array（数组）：</strong> 特殊类型的对象，以数字为索引，按顺序存储多个值。</li>
<li><strong>Function（函数）：</strong> 一种特殊的对象，具有可执行的代码块。</li>
<li><strong>Date（日期）：</strong> 表示日期和时间的对象。</li>
<li><strong>RegExp（正则表达式）：</strong> 表示正则表达式的对象，用于字符串匹配和替换。</li>
<li><strong>Map、Set、WeakMap、WeakSet：</strong> ES6 中新增的数据类型，用于更高级的数据存储和操作。</li>
</ul>
<p>JavaScript 是一种动态类型的语言，变量的数据类型在运行时可以改变。同时，JavaScript 也是一种弱类型的语言，可以自动进行类型转换。例如，将数字类型的变量与字符串类型的变量相加，JavaScript 会自动将数字转换为字符串并拼接在一起。</p>
<h4 id="2-javascript-有哪些引用类型"><a href="#2-javascript-有哪些引用类型" class="headerlink" title="2.javascript 有哪些引用类型?"></a>2.javascript 有哪些引用类型?</h4><p>JavaScript 中的引用类型（Reference Data Types）包括以下几种：</p>
<ol>
<li><strong>Object（对象）：</strong> 对象是 JavaScript 中最常见的引用类型。它是一种复杂数据类型，表示一组键值对的集合。对象可以包含多个属性，每个属性由键（属性名）和值（属性值）组成。对象可以通过字面量表示法或构造函数创建。</li>
<li><strong>Array（数组）：</strong> 数组是特殊类型的对象，用于以数字为索引按顺序存储多个值。数组可以包含任意数据类型的元素，长度可以动态调整。</li>
<li><strong>Function（函数）：</strong> 函数也是一种特殊类型的对象，具有可执行的代码块。函数可以接收参数，并返回一个值。JavaScript 中的函数是一等公民，可以像其他数据类型一样进行赋值、传递和返回。</li>
<li><strong>Date（日期）：</strong> Date 对象用于表示日期和时间。它允许操作日期、时间和与日期相关的计算。</li>
<li><strong>RegExp（正则表达式）：</strong> RegExp 对象用于表示正则表达式。它用于在字符串中进行模式匹配和替换。</li>
<li><strong>Map、Set、WeakMap、WeakSet：</strong> ES6 中新增的数据类型。Map 是一种键值对集合，可以使用任意类型的值作为键；Set 是一种值的集合，不允许重复值；WeakMap 和 WeakSet 是一种弱引用集合，不会阻止其引用对象被垃圾回收。</li>
</ol>
<p>除了基本数据类型（Number、String、Boolean、Undefined、Null 和 Symbol），其余的数据类型都属于引用类型。引用类型的值保存在堆内存中，并通过引用的方式访问和操作。在使用引用类型时，需要注意变量存储的是引用地址，而非实际数据本身。因此，引用类型在传递时是按引用传递的，多个变量可能引用同一个对象，修改其中一个变量会影响其他变量的值。</p>
<h4 id="3-如何判断javascript的数据类型"><a href="#3-如何判断javascript的数据类型" class="headerlink" title="3.如何判断javascript的数据类型?"></a>3.如何判断javascript的数据类型?</h4><p>在 JavaScript 中，可以使用以下方法来判断数据的类型：</p>
<ol>
<li><strong>typeof 运算符：</strong> <code>typeof</code> 是一种用于判断数据类型的运算符。它返回一个表示数据类型的字符串。例如：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">codeconsole.log(typeof 42); // &quot;number&quot;</span><br><span class="line">console.log(typeof &quot;Hello&quot;); // &quot;string&quot;</span><br><span class="line">console.log(typeof true); // &quot;boolean&quot;</span><br><span class="line">console.log(typeof undefined); // &quot;undefined&quot;</span><br><span class="line">console.log(typeof null); // &quot;object&quot; （注意：null 被错误地判断为对象类型，这是 JavaScript 的历史遗留问题）</span><br><span class="line">console.log(typeof &#123;&#125;); // &quot;object&quot;</span><br><span class="line">console.log(typeof []); // &quot;object&quot;</span><br><span class="line">console.log(typeof function() &#123;&#125;); // &quot;function&quot;</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>instanceof 运算符：</strong> <code>instanceof</code> 是一种用于判断对象类型的运算符。它检查对象是否属于某个特定类型的构造函数的实例。例如：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">codeconst arr = [];</span><br><span class="line">console.log(arr instanceof Array); // true</span><br><span class="line"></span><br><span class="line">function Person() &#123;&#125;</span><br><span class="line">const person = new Person();</span><br><span class="line">console.log(person instanceof Person	); // true</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>Array.isArray() 方法：</strong> <code>Array.isArray()</code> 是一种专门用于判断是否为数组的方法，返回一个布尔值。例如：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy codeconsole.log(Array.isArray([])); // true</span><br><span class="line">console.log(Array.isArray(&#123;&#125;)); // false</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>Object.prototype.toString.call() 方法：</strong> 这是一种通用的方法，可以判断任意数据类型的具体类型。例如：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">codeconsole.log(Object.prototype.toString.call(42)); // &quot;[object Number]&quot;</span><br><span class="line">console.log(Object.prototype.toString.call(&quot;Hello&quot;)); // &quot;[object String]&quot;</span><br><span class="line">console.log(Object.prototype.toString.call(true)); // &quot;[object Boolean]&quot;</span><br><span class="line">console.log(Object.prototype.toString.call(undefined)); // &quot;[object Undefined]&quot;</span><br><span class="line">console.log(Object.prototype.toString.call(null)); // &quot;[object Null]&quot;</span><br><span class="line">console.log(Object.prototype.toString.call(&#123;&#125;)); // &quot;[object Object]&quot;</span><br><span class="line">console.log(Object.prototype.toString.call([])); // &quot;[object Array]&quot;</span><br><span class="line">console.log(Object.prototype.toString.call(function() &#123;&#125;)); // &quot;[object Function]&quot;</span><br></pre></td></tr></table></figure>

<p>使用这些方法，可以根据不同的需求来判断 JavaScript 中的数据类型，并进行相应的处理</p>
<h4 id="4-怎么判断两个对象相等-如何判断空对象"><a href="#4-怎么判断两个对象相等-如何判断空对象" class="headerlink" title="4.怎么判断两个对象相等?如何判断空对象?"></a>4.怎么判断两个对象相等?如何判断空对象?</h4><p>在 JavaScript 中，判断两个对象相等有两种常见的方法：</p>
<ol>
<li><strong>浅相等（Shallow Equality）：</strong> 使用 <code>===</code> 或 <code>==</code> 运算符来比较两个对象。如果两个对象的引用地址相同，或者两个对象具有相同的属性和属性值，且属性值也相等，则认为两个对象相等。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">codeconst obj1 = &#123; name: &quot;Alice&quot;, age: 30 &#125;;</span><br><span class="line">const obj2 = &#123; name: &quot;Alice&quot;, age: 30 &#125;;</span><br><span class="line">console.log(obj1 === obj2); // false，因为 obj1 和 obj2 引用地址不同</span><br><span class="line">console.log(obj1 == obj2); // false，因为 obj1 和 obj2 引用地址不同</span><br><span class="line"></span><br><span class="line">const obj3 = obj1;</span><br><span class="line">console.log(obj1 === obj3); // true，因为 obj3 和 obj1 引用地址相同</span><br><span class="line"></span><br><span class="line">const obj4 = &#123; name: &quot;Alice&quot;, age: 30 &#125;;</span><br><span class="line">console.log(obj1 === obj4); // false，因为 obj1 和 obj4 引用地址不同</span><br><span class="line">console.log(obj1 == obj4); // false，因为 obj1 和 obj4 引用地址不同</span><br><span class="line"></span><br><span class="line">console.log(obj1.name === obj4.name); // true，因为 name 属性的值相同</span><br><span class="line">console.log(obj1.age === obj4.age); // true，因为 age 属性的值相同</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>深相等（Deep Equality）：</strong> 使用深度比较的方法来判断两个对象是否相等，即逐层比较对象的所有属性和属性值。这可以使用递归函数或第三方库（如 Lodash 的 <code>isEqual</code> 方法）来实现。深相等比较会更准确地判断两个对象是否相等，但也可能比较复杂，特别是在对象嵌套层级很深时。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">codeconst obj1 = &#123; name: &quot;Alice&quot;, age: 30, address: &#123; city: &quot;New York&quot;, zip: 10001 &#125; &#125;;</span><br><span class="line">const obj2 = &#123; name: &quot;Alice&quot;, age: 30, address: &#123; city: &quot;New York&quot;, zip: 10001 &#125; &#125;;</span><br><span class="line"></span><br><span class="line">// 使用递归函数实现深相等比较</span><br><span class="line">function deepEqual(obj1, obj2) &#123;</span><br><span class="line">  if (obj1 === obj2) return true;</span><br><span class="line"></span><br><span class="line">  if (typeof obj1 !== &quot;object&quot; || obj1 === null || typeof obj2 !== &quot;object&quot; || obj2 === null) return false;</span><br><span class="line"></span><br><span class="line">  const keys1 = Object.keys(obj1);</span><br><span class="line">  const keys2 = Object.keys(obj2);</span><br><span class="line"></span><br><span class="line">  if (keys1.length !== keys2.length) return false;</span><br><span class="line"></span><br><span class="line">  for (const key of keys1) &#123;</span><br><span class="line">    if (!keys2.includes(key) || !deepEqual(obj1[key], obj2[key])) &#123;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(deepEqual(obj1, obj2)); // true，因为两个对象的属性和属性值相等</span><br></pre></td></tr></table></figure>

<p>判断空对象的方法是检查对象是否为空，即对象是否没有任何属性。可以使用 <code>Object.keys()</code> 方法来获取对象的所有属性，并检查属性的数量是否为 0。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">codefunction isEmptyObject(obj) &#123;</span><br><span class="line">  return Object.keys(obj).length === 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const obj1 = &#123; name: &quot;Alice&quot;, age: 30 &#125;;</span><br><span class="line">const obj2 = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">console.log(isEmptyObject(obj1)); // false，因为 obj1 不是空对象</span><br><span class="line">console.log(isEmptyObject(obj2)); // true，因为 obj2 是空对象</span><br></pre></td></tr></table></figure>



<h4 id="5-0-1-0-2为什么不等于0-3-解释原理"><a href="#5-0-1-0-2为什么不等于0-3-解释原理" class="headerlink" title="5.0.1 + 0.2为什么不等于0.3 ? (解释原理)"></a>5.0.1 + 0.2为什么不等于0.3 ? (解释原理)</h4><p>0.1 和 0.2 不等于 0.3 的现象是因为 JavaScript 中的数字都采用双精度浮点数格式（64位浮点数）来表示，这是一种近似表示法，并且无法精确表示所有的十进制小数。</p>
<p>在双精度浮点数表示法中，数字被存储为二进制数，而在二进制中，有些小数是无限循环的，例如 0.1 和 0.2，它们在二进制中会出现无限循环小数的情况。当这些无限循环的二进制小数转换回十进制时，会产生微小的舍入误差，导致最终计算结果不精确。</p>
<p>具体来说：</p>
<ul>
<li>0.1 在二进制表示为 0.00011001100110011001100110011001100110011001100110011010…</li>
<li>0.2 在二进制表示为 0.00110011001100110011001100110011001100110011001100110100…</li>
</ul>
<p>当将这些二进制数转换回十进制时，会产生舍入误差，所以在计算 <code>0.1 + 0.2</code> 时，得到的结果是一个近似值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(0.1 + 0.2); // 0.30000000000000004</span><br></pre></td></tr></table></figure>

<p>因此，对于涉及十进制小数计算的情况，尤其是涉及金融计算等需要高精度的场景，建议使用专门的库或算法来处理，而不是直接使用 JavaScript 中的浮点数进行计算。例如，可以使用 <code>toFixed()</code> 方法对结果进行舍入，或使用 <code>BigInt</code> 类型处理整数运算。</p>
<h4 id="6-强制类型转换、隐式类型转换分别是什么，列举场景说明。"><a href="#6-强制类型转换、隐式类型转换分别是什么，列举场景说明。" class="headerlink" title="6.强制类型转换、隐式类型转换分别是什么，列举场景说明。"></a>6.强制类型转换、隐式类型转换分别是什么，列举场景说明。</h4><p>强制类型转换和隐式类型转换都是 JavaScript 中用于处理不同数据类型之间转换的机制。它们的区别在于转换过程是否显式地被开发人员指定。</p>
<ol>
<li><p><strong>强制类型转换（Explicit Type Conversion）：</strong> 也称为显式类型转换，是指开发人员明确地通过特定的函数或操作符来将一个数据类型转换为另一个数据类型。开发人员可以在代码中显式地指定类型转换的规则，从而实现需要的转换。常见的强制类型转换方式有：</p>
<ul>
<li><code>Number()</code> 函数：将一个值转换为数字类型。</li>
<li><code>String()</code> 函数：将一个值转换为字符串类型。</li>
<li><code>Boolean()</code> 函数：将一个值转换为布尔类型。</li>
<li><code>parseInt()</code> 和 <code>parseFloat()</code> 函数：将一个字符串转换为整数或浮点数类型。</li>
<li>自定义的类型转换函数：开发人员可以根据需求定义自己的类型转换函数。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy code// 强制将字符串转换为数字</span><br><span class="line">const numStr = &quot;123&quot;;</span><br><span class="line">const num = Number(numStr);</span><br><span class="line"></span><br><span class="line">// 强制将数字转换为字符串</span><br><span class="line">const number = 456;</span><br><span class="line">const str = String(number);</span><br><span class="line"></span><br><span class="line">// 强制将非空字符串转换为布尔值</span><br><span class="line">const strValue = &quot;Hello&quot;;</span><br><span class="line">const boolValue = Boolean(strValue);</span><br><span class="line"></span><br><span class="line">// 使用自定义函数进行类型转换</span><br><span class="line">function customToNumber(value) &#123;</span><br><span class="line">  return Number(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const result = customToNumber(&quot;789&quot;);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>隐式类型转换（Implicit Type Conversion）：</strong> 也称为自动类型转换，是指在表达式中，JavaScript 引擎自动根据操作符的规则进行类型转换，而无需开发人员明确地指定。隐式类型转换发生在运算符操作、比较操作和逻辑操作等场景中。JavaScript 引擎会根据运算符的规则将操作数转换为合适的数据类型，并返回结果。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy code// 隐式将字符串转换为数字，进行加法运算</span><br><span class="line">const num1 = &quot;10&quot;;</span><br><span class="line">const num2 = 5;</span><br><span class="line">const sum = num1 + num2; // 结果为字符串 &quot;105&quot;</span><br><span class="line"></span><br><span class="line">// 隐式将字符串转换为数字，进行比较操作</span><br><span class="line">const num3 = &quot;15&quot;;</span><br><span class="line">if (num3 &gt; 10) &#123;</span><br><span class="line">  console.log(&quot;num3 is greater than 10&quot;); // 此行代码会执行，因为 &quot;15&quot; 被隐式转换为数字 15，15 大于 10</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 隐式将数字转换为布尔值，进行逻辑操作</span><br><span class="line">const num4 = 0;</span><br><span class="line">if (num4) &#123;</span><br><span class="line">  console.log(&quot;num4 is truthy&quot;); // 此行代码不会执行，因为 0 被隐式转换为布尔值 false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>在实际开发中，了解强制类型转换和隐式类型转换的区别非常重要，可以避免出现意外的结果和错误。同时，在进行类型转换时，应该注意数据的边界情况和可能出现的意外情况，确保转换结果符合预期。</p>
<h4 id="7-创建函数的几种方式"><a href="#7-创建函数的几种方式" class="headerlink" title="7.创建函数的几种方式?"></a>7.创建函数的几种方式?</h4><p>在 JavaScript 中，有多种方式可以创建函数，以下是常见的几种方式：</p>
<ol>
<li><strong>函数声明（Function Declaration）：</strong> 使用 <code>function</code> 关键字声明一个函数，并给函数命名。函数声明在代码执行之前进行了提升，可以在声明之前调用。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function add(a, b) &#123;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>函数表达式（Function Expression）：</strong> 将一个函数赋值给一个变量，形成一个函数表达式。函数表达式在代码执行到达时进行赋值，必须在赋值后才能调用。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const add = function(a, b) &#123;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>箭头函数（Arrow Function）：</strong> ES6 引入的箭头函数是一种更简洁的函数表达式形式，适用于需要短小的函数。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const add = (a, b) =&gt; a + b;</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>Function 构造函数：</strong> 使用 <code>Function</code> 构造函数可以动态地创建函数。它接收一系列参数，最后一个参数为函数体字符串。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const add = new Function(&quot;a&quot;, &quot;b&quot;, &quot;return a + b&quot;);</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>Generator 函数：</strong> Generator 函数是 ES6 中引入的一种特殊函数，可以通过 <code>function*</code> 关键字来声明。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function * generateNumbers() &#123;</span><br><span class="line">  yield 1;</span><br><span class="line">  yield 2;</span><br><span class="line">  yield 3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>异步函数（Async Function）：</strong> 异步函数是 ES8&#x2F;ES2017 中引入的一种特殊函数，可以通过 <code>async</code> 关键字声明。异步函数内部可以使用 <code>await</code> 关键字来等待异步操作完成。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">async function fetchData() &#123;</span><br><span class="line">  const response = await fetch(&#x27;https://api.example.com/data&#x27;);</span><br><span class="line">  const data = await response.json();</span><br><span class="line">  return data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上是常见的创建函数的几种方式，选择哪种方式取决于项目需求和个人偏好。一般情况下，函数声明和函数表达式是最常用的方式，而箭头函数则适用于简单的函数体，让代码更简洁易读。</p>
<h4 id="8-javascript-创建对象的几种方式"><a href="#8-javascript-创建对象的几种方式" class="headerlink" title="8.javascript 创建对象的几种方式?"></a>8.javascript 创建对象的几种方式?</h4><p>在 JavaScript 中，有多种方式可以创建对象，以下是常见的几种方式：</p>
<ol>
<li><strong>对象字面量（Object Literal）：</strong> 使用花括号 <code>&#123;&#125;</code> 来定义一个对象，并在其中定义属性和属性值。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const person = &#123;</span><br><span class="line">  name: &quot;Alice&quot;,</span><br><span class="line">  age: 30,</span><br><span class="line">  gender: &quot;female&quot;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>构造函数（Constructor）：</strong> 使用构造函数创建对象，构造函数是一个普通的函数，用于初始化对象的属性。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Person(name, age, gender) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.age = age;</span><br><span class="line">  this.gender = gender;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const person1 = new Person(&quot;Alice&quot;, 30, &quot;female&quot;);</span><br><span class="line">const person2 = new Person(&quot;Bob&quot;, 25, &quot;male&quot;);</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>Object.create() 方法：</strong> 使用 <code>Object.create()</code> 方法创建一个新对象，并指定该对象的原型对象。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const personPrototype = &#123;</span><br><span class="line">  greet: function() &#123;</span><br><span class="line">    console.log(&quot;Hello!&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const person = Object.create(personPrototype);</span><br><span class="line">person.name = &quot;Alice&quot;;</span><br><span class="line">person.age = 30;</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>类（ES6 中的 Class）：</strong> 使用 <code>class</code> 关键字定义一个类，类中的 <code>constructor</code> 方法用于初始化对象的属性。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">  constructor(name, age, gender) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">    this.gender = gender;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const person1 = new Person(&quot;Alice&quot;, 30, &quot;female&quot;);</span><br><span class="line">const person2 = new Person(&quot;Bob&quot;, 25, &quot;male&quot;);</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>工厂函数（Factory Function）：</strong> 工厂函数是一种返回对象的函数，用于封装对象的创建过程。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function createPerson(name, age, gender) &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    name: name,</span><br><span class="line">    age: age,</span><br><span class="line">    gender: gender</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const person1 = createPerson(&quot;Alice&quot;, 30, &quot;female&quot;);</span><br><span class="line">const person2 = createPerson(&quot;Bob&quot;, 25, &quot;male&quot;);</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>Object() 构造函数：</strong> 使用 <code>Object()</code> 构造函数来创建一个空的对象。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const person = new Object();</span><br><span class="line">person.name = &quot;Alice&quot;;</span><br><span class="line">person.age = 30;</span><br><span class="line">person.gender = &quot;female&quot;;</span><br></pre></td></tr></table></figure>

<p>以上是常见的创建对象的几种方式，选择哪种方式取决于项目需求和个人偏好。在 ES6 中，推荐使用类来定义对象，它更加清晰和易读。而在 ES5 及以下的版本中，构造函数和对象字面量是更常见的创建对象的方式。</p>
<h4 id="9-列举宿主对象、内置对象、原生对象并说明其定义。"><a href="#9-列举宿主对象、内置对象、原生对象并说明其定义。" class="headerlink" title="9.列举宿主对象、内置对象、原生对象并说明其定义。"></a>9.列举宿主对象、内置对象、原生对象并说明其定义。</h4><p>在 JavaScript 中，宿主对象、内置对象和原生对象是三种常见的对象分类：</p>
<ol>
<li><p><strong>宿主对象（Host Objects）：</strong> 宿主对象是由宿主环境（比如浏览器或 Node.js 等）提供的对象。它们并非由 JavaScript 语言规范定义，而是由宿主环境自己实现的。在浏览器环境中，常见的宿主对象包括 <code>window</code>、<code>document</code>、<code>XMLHttpRequest</code> 等。在 Node.js 环境中，常见的宿主对象包括 <code>global</code>、<code>process</code> 等。宿主对象的定义和功能取决于具体的宿主环境。</p>
</li>
<li><p><strong>内置对象（Built-in Objects）：</strong> 内置对象是 JavaScript 语言本身提供的对象，它们存在于全局作用域中，可以直接使用而无需进行特别的导入或引入。内置对象包括 JavaScript 语言核心的对象，如 <code>Object</code>、<code>Array</code>、<code>Function</code>、<code>Date</code> 等，以及一些附加的功能性对象，如 <code>Math</code> 和 <code>JSON</code> 等。</p>
<ul>
<li><code>Object</code>：用于创建一个新的对象。</li>
<li><code>Array</code>：用于创建一个新的数组。</li>
<li><code>Function</code>：用于创建一个新的函数。</li>
<li><code>Date</code>：用于处理日期和时间。</li>
<li><code>Math</code>：提供数学运算方法和常量。</li>
<li><code>JSON</code>：用于解析和序列化 JSON 数据。</li>
</ul>
<p>内置对象的定义和功能是由 ECMAScript 规范（JavaScript 语言的标准）所定义的，因此在任何支持 JavaScript 的环境中，这些内置对象都应该是一样的。</p>
</li>
<li><p><strong>原生对象（Native Objects）：</strong> 原生对象是一种特殊的内置对象，它们是由 JavaScript 引擎使用内建的构造函数实例化得到的对象。例如，通过 <code>new Object()</code>、<code>new Array()</code> 等方式创建的对象就属于原生对象。原生对象与内置对象的区别在于它们的创建方式，内置对象是直接可用的，而原生对象需要通过构造函数实例化后才能使用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const obj1 = new Object(); // 原生对象</span><br><span class="line">const obj2 = &#123;&#125;; // 内置对象</span><br></pre></td></tr></table></figure></li>
</ol>
<p>总结：</p>
<ul>
<li>宿主对象：由宿主环境提供的对象，定义和功能取决于宿主环境。</li>
<li>内置对象：JavaScript 语言本身提供的对象，存在于全局作用域中，由 ECMAScript 规范定义。</li>
<li>原生对象：由 JavaScript 引擎使用内建的构造函数实例化得到的对象。</li>
</ul>
<h4 id="10-x3D-x3D-x3D-和-x3D-x3D-的区别"><a href="#10-x3D-x3D-x3D-和-x3D-x3D-的区别" class="headerlink" title="10.&#x3D;&#x3D;&#x3D;和&#x3D;&#x3D;的区别?"></a>10.&#x3D;&#x3D;&#x3D;和&#x3D;&#x3D;的区别?</h4><p>在 JavaScript 中，<code>===</code> 和 <code>==</code> 是用于比较两个值的运算符，它们有以下区别：</p>
<ol>
<li><strong>类型比较：</strong> <code>===</code> 运算符执行严格的相等比较，不仅比较值是否相等，还要比较数据类型是否相同。而 <code>==</code> 运算符执行松散的相等比较，只比较值是否相等，不进行数据类型的转换。</li>
<li><strong>数据类型转换：</strong> 在执行 <code>==</code> 比较时，如果两个操作数的数据类型不同，JavaScript 会尝试进行数据类型的转换，使它们变得相同，然后再进行比较。这种自动的数据类型转换被称为强制类型转换（Type coercion）。</li>
<li><strong>相等条件：</strong> 使用 <code>===</code> 运算符，只有在两个操作数的值和数据类型完全相等时，才返回 <code>true</code>。而使用 <code>==</code> 运算符，如果两个操作数的值相等或在强制类型转换后相等，就返回 <code>true</code>。</li>
</ol>
<p>在大多数情况下，建议使用 <code>===</code> 运算符进行严格的相等比较，因为它可以避免意外的类型转换，使代码更加可靠和易于理解。只有在特定的需求下，才使用 <code>==</code> 运算符进行松散的相等比较。</p>
<h4 id="11-null-undefined-的区别"><a href="#11-null-undefined-的区别" class="headerlink" title="11.null, undefined 的区别"></a>11.null, undefined 的区别</h4><p><code>null</code> 和 <code>undefined</code> 都是 JavaScript 中表示无值的特殊值，但它们有一些区别：</p>
<ol>
<li><p><strong>null：</strong> <code>null</code> 是一个表示空值的特殊对象。当一个变量被赋值为 <code>null</code>，表示该变量的值为空。<code>null</code> 是一个原始值，不是对象，它是 JavaScript 中的关键字。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const myVariable = null;</span><br><span class="line">console.log(myVariable); // null</span><br><span class="line">console.log(typeof myVariable); // &quot;object&quot;，注意这是历史遗留问题，null 的类型被错误地标记为 &quot;object&quot;，实际上它是一个原始值</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>undefined：</strong> <code>undefined</code> 表示一个变量被声明了但尚未赋值，或者访问对象属性时该属性不存在的情况。在以下情况下，变量的值将是 <code>undefined</code>：</p>
<ul>
<li>声明了变量但没有初始化。</li>
<li>访问对象属性时，属性不存在。</li>
<li>函数没有返回值，默认返回 <code>undefined</code>。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let myVariable;</span><br><span class="line">console.log(myVariable); // undefined</span><br><span class="line"></span><br><span class="line">const myObject = &#123; name: &quot;Alice&quot; &#125;;</span><br><span class="line">console.log(myObject.age); // undefined，myObject 没有名为 &quot;age&quot; 的属性</span><br><span class="line"></span><br><span class="line">function myFunction() &#123;&#125;</span><br><span class="line">const result = myFunction();</span><br><span class="line">console.log(result); // undefined，函数没有明确的返回值，默认返回 undefined</span><br></pre></td></tr></table></figure></li>
</ol>
<p>总结：</p>
<ul>
<li><code>null</code> 是一个表示空值的关键字，表示变量被赋值为空。</li>
<li><code>undefined</code> 表示一个变量被声明但尚未赋值，或者访问对象属性时属性不存在。</li>
</ul>
<p>在实际编程中，我们经常使用 <code>null</code> 来明确地表示变量为空，而 <code>undefined</code> 通常是 JavaScript 引擎在处理变量时产生的值，而不是我们主动设置的。</p>
<h4 id="12-什么情况下会返回undefined值"><a href="#12-什么情况下会返回undefined值" class="headerlink" title="12.什么情况下会返回undefined值?"></a>12.什么情况下会返回undefined值?</h4><p>在 JavaScript 中，有几种情况下会返回 <code>undefined</code> 值：</p>
<ol>
<li><p><strong>声明但未初始化的变量：</strong> 当声明一个变量但没有给它赋值时，这个变量的值将是 <code>undefined</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let myVariable;</span><br><span class="line">console.log(myVariable); // undefined</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>访问对象中不存在的属性：</strong> 当访问一个对象中不存在的属性时，返回的值将是 <code>undefined</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const myObject = &#123; name: &quot;Alice&quot; &#125;;</span><br><span class="line">console.log(myObject.age); // undefined，myObject 没有名为 &quot;age&quot; 的属性</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>函数没有返回值或显式返回 <code>undefined</code>：</strong> 如果一个函数没有明确的 <code>return</code> 语句，或者 <code>return</code> 语句后面没有值，那么该函数默认返回 <code>undefined</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function myFunction() &#123;</span><br><span class="line">  // 没有明确的返回值，默认返回 undefined</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function anotherFunction() &#123;</span><br><span class="line">  return;</span><br><span class="line">  // 没有返回值，默认返回 undefined</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(myFunction()); // undefined</span><br><span class="line">console.log(anotherFunction()); // undefined</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>函数参数缺失：</strong> 如果函数期望传入某个参数但未传入，函数中对该参数的引用将返回 <code>undefined</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function greet(name) &#123;</span><br><span class="line">  console.log(&quot;Hello, &quot; + name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">greet(); // 输出 &quot;Hello, undefined&quot;，name 参数未传入，默认为 undefined</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>函数参数没有使用 <code>arguments</code> 对象或剩余参数（rest parameters）：</strong> 当函数没有使用 <code>arguments</code> 对象或剩余参数（rest parameters）获取传入的参数时，未传入的参数在函数内部将是 <code>undefined</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function sum(a, b) &#123;</span><br><span class="line">  console.log(a + b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum(3); // 输出 &quot;NaN&quot;，因为 b 没有传入，a + undefined 结果为 NaN</span><br></pre></td></tr></table></figure></li>
</ol>
<p>以上是返回 <code>undefined</code> 值的几种常见情况。在编程中，我们要特别注意处理可能返回 <code>undefined</code> 的情况，以避免出现错误。可以使用条件判断或默认值设定等方式来处理这些情况，保证代码的稳定性和可靠性。</p>
<h4 id="13-如何区分数组和对象"><a href="#13-如何区分数组和对象" class="headerlink" title="13.如何区分数组和对象?"></a>13.如何区分数组和对象?</h4><p>在 JavaScript 中，可以通过以下几个特征来区分数组和对象：</p>
<ol>
<li><p><strong>数据类型：</strong> 数组和对象是两种不同的数据类型。数组是一种特殊的对象，它的键（或索引）是整数，表示元素在数组中的位置，而对象的键可以是字符串或符号，表示属性名。</p>
</li>
<li><p><strong>语法：</strong> 数组使用方括号 <code>[]</code> 来表示，而对象使用花括号 <code>&#123;&#125;</code> 来表示。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy codeconst myArray = [1, 2, 3];</span><br><span class="line">const myObject = &#123; name: &quot;Alice&quot;, age: 30 &#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>键（或索引）：</strong> 数组的键是按顺序排列的整数索引，从 0 开始。而对象的键可以是任意字符串或符号。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy codeconst myArray = [1, 2, 3];</span><br><span class="line">console.log(myArray[0]); // 1，使用整数索引访问数组元素</span><br><span class="line"></span><br><span class="line">const myObject = &#123; name: &quot;Alice&quot;, age: 30 &#125;;</span><br><span class="line">console.log(myObject[&quot;name&quot;]); // &quot;Alice&quot;，使用字符串键访问对象属性</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>length 属性：</strong> 数组有一个特殊的 <code>length</code> 属性，用于表示数组中元素的个数。而对象没有 <code>length</code> 属性。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy codeconst myArray = [1, 2, 3];</span><br><span class="line">console.log(myArray.length); // 3，数组有 length 属性</span><br><span class="line"></span><br><span class="line">const myObject = &#123; name: &quot;Alice&quot;, age: 30 &#125;;</span><br><span class="line">console.log(myObject.length); // undefined，对象没有 length 属性</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>操作方法：</strong> 数组具有一些特殊的操作方法，如 <code>push()</code>、<code>pop()</code>、<code>shift()</code>、<code>unshift()</code> 等，用于在数组中添加或删除元素。而对象没有这些特殊的操作方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy codeconst myArray = [1, 2, 3];</span><br><span class="line">myArray.push(4); // 在数组末尾添加元素</span><br><span class="line"></span><br><span class="line">const myObject = &#123; name: &quot;Alice&quot;, age: 30 &#125;;</span><br><span class="line">myObject.push(4); // TypeError: myObject.push is not a function，对象没有 push 方法</span><br></pre></td></tr></table></figure></li>
</ol>
<p>总结：</p>
<ul>
<li>数组是一种特殊的对象，用于有序地存储一组数据，通过整数索引访问元素。</li>
<li>对象用于存储一组键值对数据，通过键（字符串或符号）访问属性。</li>
<li>数组有 <code>length</code> 属性和一些特殊的操作方法，而对象没有。</li>
</ul>
<h4 id="14-多维数组如何降维"><a href="#14-多维数组如何降维" class="headerlink" title="14.多维数组如何降维?"></a>14.多维数组如何降维?</h4><p>降维是将多维数组转换为一维数组的过程。在 JavaScript 中，可以使用递归或数组方法来实现多维数组的降维。</p>
<ol>
<li><strong>递归方法：</strong> 使用递归函数遍历多维数组的每个元素，如果元素是一个子数组，则继续递归遍历子数组，直到将所有元素转换为一维数组。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function flattenArray(arr) &#123;</span><br><span class="line">  const result = [];</span><br><span class="line">  for (let i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">    if (Array.isArray(arr[i])) &#123;</span><br><span class="line">      result.push(...flattenArray(arr[i])); // 递归遍历子数组</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      result.push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const multiDimensionalArray = [1, [2, 3], [4, [5, 6]]];</span><br><span class="line">const flattenedArray = flattenArray(multiDimensionalArray);</span><br><span class="line">console.log(flattenedArray); // [1, 2, 3, 4, 5, 6]</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>数组方法：</strong> 使用数组的 <code>flat()</code> 方法可以快速将多维数组降维为一维数组。<code>flat()</code> 方法可以指定降维的深度，如果没有指定深度，默认为 1。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const multiDimensionalArray = [1, [2, 3], [4, [5, 6]]];</span><br><span class="line">const flattenedArray = multiDimensionalArray.flat(Infinity);</span><br><span class="line">console.log(flattenedArray); // [1, 2, 3, 4, 5, 6]</span><br></pre></td></tr></table></figure>

<p>使用递归方法可以处理任意深度的多维数组，但可能会有一定的性能开销。而使用 <code>flat()</code> 方法可以简化代码，并且在已知深度的情况下，可以提供更好的性能。</p>
<p>注意：在使用 <code>flat()</code> 方法时，需要注意浏览器或 Node.js 环境是否支持该方法，如果不支持，可以使用 polyfill 或其他方式进行降维处理。</p>
<h4 id="15-怎么获取当前日期-年-月-日-时-分-秒"><a href="#15-怎么获取当前日期-年-月-日-时-分-秒" class="headerlink" title="15.怎么获取当前日期(年-月-日 时:分:秒) ?"></a>15.怎么获取当前日期(年-月-日 时:分:秒) ?</h4><p>在 JavaScript 中，可以使用 <code>Date</code> 对象来获取当前日期和时间。以下是获取当前日期和时间的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const currentDate = new Date();</span><br><span class="line"></span><br><span class="line">const year = currentDate.getFullYear();</span><br><span class="line">const month = String(currentDate.getMonth() + 1).padStart(2, &quot;0&quot;); // 月份从0开始，需要加1，然后补零</span><br><span class="line">const day = String(currentDate.getDate()).padStart(2, &quot;0&quot;);</span><br><span class="line">const hours = String(currentDate.getHours()).padStart(2, &quot;0&quot;);</span><br><span class="line">const minutes = String(currentDate.getMinutes()).padStart(2, &quot;0&quot;);</span><br><span class="line">const seconds = String(currentDate.getSeconds()).padStart(2, &quot;0&quot;);</span><br><span class="line"></span><br><span class="line">const currentDateTime = `$&#123;year&#125;-$&#123;month&#125;-$&#123;day&#125; $&#123;hours&#125;:$&#123;minutes&#125;:$&#123;seconds&#125;`;</span><br><span class="line">console.log(currentDateTime); // 格式为：年-月-日 时:分:秒</span><br></pre></td></tr></table></figure>

<p>解释：</p>
<ol>
<li>使用 <code>new Date()</code> 创建一个新的 <code>Date</code> 对象，它将包含当前日期和时间。</li>
<li>通过 <code>Date</code> 对象的方法获取当前年、月、日、时、分、秒。</li>
<li>使用 <code>padStart()</code> 方法对月、日、时、分、秒进行补零操作，确保它们始终是两位数。</li>
<li>将获取到的年、月、日、时、分、秒拼接成所需的日期时间格式。</li>
</ol>
<p>请注意，JavaScript 中的月份是从 0 开始的，所以需要加 1。同时，<code>padStart()</code> 方法是 ES2017 引入的，如果在旧版本的 JavaScript 环境中使用，可以使用其他方式来实现补零操作。</p>
<h4 id="16-什么是类数组-伪数组-，-如何将其转化为真实的数组"><a href="#16-什么是类数组-伪数组-，-如何将其转化为真实的数组" class="headerlink" title="16.什么是类数组(伪数组)， 如何将其转化为真实的数组?"></a>16.什么是类数组(伪数组)， 如何将其转化为真实的数组?</h4><p>类数组（也称为伪数组）是一种对象，它具有类似数组的特性，但不具备数组原型上的方法，也没有数组的 length 属性。常见的类数组包括 DOM 元素集合、函数的 arguments 对象等。</p>
<p>在 JavaScript 中，可以通过以下几种方式将类数组转化为真实的数组：</p>
<ol>
<li><strong>Array.from() 方法：</strong> 使用 <code>Array.from()</code> 方法可以将可迭代对象或类数组对象转化为真实的数组。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const arrayLike = &#123; 0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;, length: 3 &#125;;</span><br><span class="line">const realArray = Array.from(arrayLike);</span><br><span class="line"></span><br><span class="line">console.log(realArray); // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>Array.prototype.slice.call()：</strong> 可以使用 <code>Array.prototype.slice.call()</code> 方法将类数组对象转化为真实的数组。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const arrayLike = &#123; 0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;, length: 3 &#125;;</span><br><span class="line">const realArray = Array.prototype.slice.call(arrayLike);</span><br><span class="line"></span><br><span class="line">console.log(realArray); // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>Spread Operator（展开运算符）：</strong> 使用展开运算符 <code>...</code> 也可以将类数组对象转化为真实的数组。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const arrayLike = &#123; 0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;, length: 3 &#125;;</span><br><span class="line">const realArray = [...arrayLike];</span><br><span class="line"></span><br><span class="line">console.log(realArray); // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>for 循环：</strong> 使用 for 循环遍历类数组对象，并将其逐个添加到一个新数组中。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const arrayLike = &#123; 0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;, length: 3 &#125;;</span><br><span class="line">const realArray = [];</span><br><span class="line"></span><br><span class="line">for (let i = 0; i &lt; arrayLike.length; i++) &#123;</span><br><span class="line">  realArray.push(arrayLike[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(realArray); // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br></pre></td></tr></table></figure>

<p>以上四种方法都可以将类数组对象转化为真实的数组，可以根据实际情况选择其中一种。注意，在转换过程中，类数组对象的索引会被保留，它们将成为新数组的索引。</p>
<h4 id="17-如何遍历对象的属性"><a href="#17-如何遍历对象的属性" class="headerlink" title="17.如何遍历对象的属性?"></a>17.如何遍历对象的属性?</h4><p>在 JavaScript 中，可以使用不同的方法来遍历对象的属性：</p>
<ol>
<li><strong>for…in 循环：</strong> 使用 <code>for...in</code> 循环可以遍历对象的可枚举属性，包括对象自身的属性以及继承的属性（来自原型链）。需要注意的是，<code>for...in</code> 循环也会遍历对象的原型链，因此可以通过 <code>hasOwnProperty()</code> 方法来过滤只遍历对象自身的属性。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const person = &#123;</span><br><span class="line">  name: &quot;Alice&quot;,</span><br><span class="line">  age: 30,</span><br><span class="line">  gender: &quot;female&quot;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">for (let key in person) &#123;</span><br><span class="line">  if (person.hasOwnProperty(key)) &#123;</span><br><span class="line">    console.log(key + &quot;: &quot; + person[key]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>Object.keys() 方法：</strong> 使用 <code>Object.keys()</code> 方法可以获取对象自身的所有可枚举属性，并返回一个包含这些属性的数组。然后可以使用数组的 <code>forEach()</code> 方法来遍历这些属性。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const person = &#123;</span><br><span class="line">  name: &quot;Alice&quot;,</span><br><span class="line">  age: 30,</span><br><span class="line">  gender: &quot;female&quot;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Object.keys(person).forEach((key) =&gt; &#123;</span><br><span class="line">  console.log(key + &quot;: &quot; + person[key]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>Object.values() 方法：</strong> 使用 <code>Object.values()</code> 方法可以获取对象自身的所有可枚举属性的值，并返回一个包含这些值的数组。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const person = &#123;</span><br><span class="line">  name: &quot;Alice&quot;,</span><br><span class="line">  age: 30,</span><br><span class="line">  gender: &quot;female&quot;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Object.values(person).forEach((value) =&gt; &#123;</span><br><span class="line">  console.log(value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>Object.entries() 方法：</strong> 使用 <code>Object.entries()</code> 方法可以获取对象自身的所有可枚举属性的键值对，并返回一个包含这些键值对的数组。可以通过解构赋值来遍历键和值。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const person = &#123;</span><br><span class="line">  name: &quot;Alice&quot;,</span><br><span class="line">  age: 30,</span><br><span class="line">  gender: &quot;female&quot;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Object.entries(person).forEach(([key, value]) =&gt; &#123;</span><br><span class="line">  console.log(key + &quot;: &quot; + value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上述方法可以根据实际需求来选择使用，它们都可以遍历对象的属性，根据情况选择最适合的方法。请注意，<code>for...in</code> 循环可能会遍历到继承的属性，因此需要适当使用 <code>hasOwnProperty()</code> 方法进行过滤，以避免意外的结果。</p>
<h4 id="18-如何给一个按钮绑定两个onclick事件"><a href="#18-如何给一个按钮绑定两个onclick事件" class="headerlink" title="18.如何给一个按钮绑定两个onclick事件?"></a>18.如何给一个按钮绑定两个onclick事件?</h4><p>在 HTML 和 JavaScript 中，给一个按钮绑定两个 <code>onclick</code> 事件可以通过以下几种方式实现：</p>
<ol>
<li><strong>使用addEventListener() 方法：</strong> 使用 <code>addEventListener()</code> 方法可以给元素添加多个事件监听器，从而绑定多个点击事件。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;button id=&quot;myButton&quot;&gt;Click Me&lt;/button&gt;</span><br><span class="line">javascriptCopy codeconst myButton = document.getElementById(&quot;myButton&quot;);</span><br><span class="line"></span><br><span class="line">function handleClick1() &#123;</span><br><span class="line">  console.log(&quot;Event 1&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function handleClick2() &#123;</span><br><span class="line">  console.log(&quot;Event 2&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myButton.addEventListener(&quot;click&quot;, handleClick1);</span><br><span class="line">myButton.addEventListener(&quot;click&quot;, handleClick2);</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>直接在 HTML 属性中添加事件处理函数：</strong> 在 HTML 元素的 <code>onclick</code> 属性中，可以直接添加多个事件处理函数，使用分号 <code>;</code> 分隔它们。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;button id=&quot;myButton&quot; onclick=&quot;handleClick1(); handleClick2();&quot;&gt;Click Me&lt;/button&gt;</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>使用onclick属性绑定一个匿名函数：</strong> 可以将一个匿名函数作为点击事件的处理函数，然后在匿名函数中调用两个不同的函数。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;button id=&quot;myButton&quot; onclick=&quot;handleClick()&quot;&gt;Click Me&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">function handleClick() &#123;</span><br><span class="line">  handleClick1();</span><br><span class="line">  handleClick2();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上三种方法都可以给一个按钮绑定两个 <code>onclick</code> 事件，根据实际情况选择最合适的方式即可。注意，在使用 <code>addEventListener()</code> 方法时，它们的执行顺序将按照绑定的顺序执行。而在直接使用 <code>onclick</code> 属性或匿名函数的方式时，它们的执行顺序将由代码中的顺序决定。</p>
<h4 id="19-变量提升是什么-与函数提升的区别"><a href="#19-变量提升是什么-与函数提升的区别" class="headerlink" title="19.变量提升是什么?与函数提升的区别?"></a>19.变量提升是什么?与函数提升的区别?</h4><p>变量提升（Hoisting）和函数提升是 JavaScript 中的两个重要概念，它们描述了变量和函数在代码执行之前被声明的行为。但它们之间有一些区别。</p>
<ol>
<li><p><strong>变量提升：</strong> 在 JavaScript 中，变量的声明会在代码执行之前进行提升，这意味着可以在变量声明之前访问该变量，并且不会报错，但其值为 <code>undefined</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(myVar); // undefined</span><br><span class="line">var myVar = 10;</span><br><span class="line">console.log(myVar); // 10</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，变量 <code>myVar</code> 在声明之前被访问，但是不会报错，而是输出 <code>undefined</code>，因为变量声明会在代码执行之前被提升，但是赋值操作会保留在原来的位置。</p>
</li>
<li><p><strong>函数提升：</strong> 类似于变量提升，函数的声明也会在代码执行之前被提升。这意味着可以在函数声明之前调用函数，并且不会报错。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sayHello(); // &quot;Hello, there!&quot;</span><br><span class="line"></span><br><span class="line">function sayHello() &#123;</span><br><span class="line">  console.log(&quot;Hello, there!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，函数 <code>sayHello()</code> 在声明之前被调用，但是不会报错，而是输出 “Hello, there!”。函数声明会在代码执行之前被提升，因此可以在代码的任何位置使用函数。</p>
</li>
</ol>
<p>需要注意的是，虽然变量和函数在代码执行之前被提升，但是它们的赋值和具体实现仍然按照原来的顺序执行。所以，尽管在代码的任何位置都可以访问变量和函数的声明，但如果在声明之前使用变量或函数的值，其值将为 <code>undefined</code>。为了避免这种问题，通常建议在代码的开头声明所有的变量和函数，以便更好地理解代码并避免意外行为。</p>
<h4 id="20-什么是作用域链-如何延长"><a href="#20-什么是作用域链-如何延长" class="headerlink" title="20.什么是作用域链?如何延长?"></a>20.什么是作用域链?如何延长?</h4><p>作用域链是在 JavaScript 中用于查找变量和函数的一种机制。当代码执行时，JavaScript 引擎会创建一个作用域链，它是一个由多个执行上下文对象组成的链表。每个执行上下文对象都包含了当前作用域的变量和函数，并且持有对其父级作用域的引用。这些引用形成了作用域链，用于在当前作用域无法找到变量或函数时，沿着链条向上查找。</p>
<p>作用域链的构建方式如下：</p>
<ol>
<li>当进入一个函数时，会创建一个新的执行上下文对象，并将其添加到作用域链的顶端。</li>
<li>每个执行上下文对象都有一个指向其父级执行上下文对象的引用，因此形成了一个链表结构，连接了所有的作用域。</li>
<li>在当前执行上下文对象中查找变量或函数时，首先在当前作用域中查找，如果找到了就直接使用。</li>
<li>如果在当前作用域中找不到，就沿着作用域链向上查找，直到找到为止。如果在最顶层的全局作用域中都没有找到，则会报错。</li>
</ol>
<p>延长作用域链的情况有两种：</p>
<ol>
<li><p><strong>函数的嵌套：</strong> 当一个函数内部包含另一个函数时，内部函数的作用域链会延长到外部函数的作用域，从而可以访问外部函数中的变量。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function outer() &#123;</span><br><span class="line">  const x = 10;</span><br><span class="line"></span><br><span class="line">  function inner() &#123;</span><br><span class="line">    console.log(x); // 可以访问外部函数 outer 中的变量 x</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  inner();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">outer(); // 输出 10</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>try-catch 块：</strong> 在 try-catch 块中，catch 块的作用域链会延长到包含它的外部作用域，以便可以访问外部作用域中的变量。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">  const message = &quot;Hello&quot;;</span><br><span class="line">  throw new Error(&quot;Error occurred&quot;);</span><br><span class="line">&#125; catch (error) &#123;</span><br><span class="line">  console.log(message); // 可以访问包含它的外部作用域中的变量 message</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>在 JavaScript 中，作用域链的正确理解对于理解作用域、变量的查找和作用域的嵌套非常重要。</p>
<h4 id="21-如何实现数组的随机排序"><a href="#21-如何实现数组的随机排序" class="headerlink" title="21.如何实现数组的随机排序?"></a>21.如何实现数组的随机排序?</h4><p>可以使用 Fisher-Yates (Knuth) Shuffle 算法来实现数组的随机排序。这个算法通过遍历数组，随机交换每个位置上的元素，从而得到一个随机排列的数组。</p>
<p>以下是使用 JavaScript 实现 Fisher-Yates Shuffle 算法的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function shuffleArray(arr) &#123;</span><br><span class="line">  for (let i = arr.length - 1; i &gt; 0; i--) &#123;</span><br><span class="line">    const randomIndex = Math.floor(Math.random() * (i + 1));</span><br><span class="line">    // 交换当前位置的元素与随机位置的元素</span><br><span class="line">    [arr[i], arr[randomIndex]] = [arr[randomIndex], arr[i]];</span><br><span class="line">  &#125;</span><br><span class="line">  return arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const myArray = [1, 2, 3, 4, 5];</span><br><span class="line">const shuffledArray = shuffleArray(myArray);</span><br><span class="line">console.log(shuffledArray); // 输出一个随机排序的数组，例如 [3, 5, 2, 1, 4]</span><br></pre></td></tr></table></figure>

<p>解释：</p>
<ol>
<li>使用 <code>for</code> 循环从数组的最后一个元素开始，逐个遍历到第一个元素。</li>
<li>在每次循环中，生成一个随机的索引 <code>randomIndex</code>，范围是当前元素位置到数组开头之间的随机整数。</li>
<li>交换当前位置的元素与随机位置 <code>randomIndex</code> 的元素，从而实现随机排序。</li>
</ol>
<p>通过 Fisher-Yates Shuffle 算法，每个元素在最终的排列中都有相等的概率出现在任何位置，从而实现了数组的随机排序。</p>
<h4 id="22-dom节点的Attribute和Property-有何区别"><a href="#22-dom节点的Attribute和Property-有何区别" class="headerlink" title="22.dom节点的Attribute和Property 有何区别?"></a>22.dom节点的Attribute和Property 有何区别?</h4><p>Attribute 和 Property 是用于操作 DOM 节点的两个不同概念，它们在使用和表现上有一些区别。</p>
<p><strong>Attribute（属性）：</strong></p>
<ol>
<li>Attribute 是 HTML 元素在 HTML 标签中定义的属性，它们可以在 HTML 标签中通过属性的方式设置，例如 <code>&lt;div id=&quot;myDiv&quot; class=&quot;myClass&quot;&gt;</code>。</li>
<li>Attribute 是由 HTML 文档解析而来，属于静态值，一旦设置，通常不会随着 JavaScript 的操作而改变。</li>
<li>通过 JavaScript 的 <code>getAttribute()</code> 方法可以获取元素的属性值，例如 <code>element.getAttribute(&quot;id&quot;)</code>。</li>
<li>使用 <code>setAttribute()</code> 方法可以动态地设置元素的属性值，例如 <code>element.setAttribute(&quot;data-custom&quot;, &quot;value&quot;)</code>。</li>
</ol>
<p><strong>Property（属性）：</strong></p>
<ol>
<li>Property 是 DOM 元素对象的属性，它们是对象的属性，通过 JavaScript 对象的方式进行设置和访问。</li>
<li>Property 是由浏览器解析 HTML 元素后创建的，属于动态值，可以通过 JavaScript 进行改变。</li>
<li>通过 JavaScript 的点语法或方括号语法可以获取和设置元素的属性，例如 <code>element.id</code> 或 <code>element[&quot;id&quot;]</code>。</li>
<li>通过设置 Property 的值，通常可以引起页面的重新渲染或重绘，而 Attribute 的改变不会引起页面重新渲染。</li>
</ol>
<p>虽然 Attribute 和 Property 在某些情况下是相互关联的，但它们的操作方式和作用有所不同。在使用 JavaScript 操作 DOM 时，通常更推荐使用 Property，因为 Property 的操作更加灵活，而且能够触发页面重新渲染。对于一些特殊属性（例如 data 属性），通常使用 Attribute 更合适，因为它们是自定义的、不会影响样式或布局的数据属性。</p>
<h4 id="23-dom结构操作怎样添加、移除、移动、复制、创建和查找节点"><a href="#23-dom结构操作怎样添加、移除、移动、复制、创建和查找节点" class="headerlink" title="23.dom结构操作怎样添加、移除、移动、复制、创建和查找节点?"></a>23.dom结构操作怎样添加、移除、移动、复制、创建和查找节点?</h4><p>在 JavaScript 中，可以使用 DOM 操作来添加、移除、移动、复制、创建和查找节点。下面是一些常用的 DOM 操作方法：</p>
<p><strong>添加节点：</strong></p>
<ol>
<li><code>appendChild()</code>: 将一个已有的节点添加为另一个节点的最后一个子节点。</li>
<li><code>insertBefore()</code>: 将一个已有的节点插入到指定节点的前面。</li>
</ol>
<p><strong>移除节点：</strong></p>
<ol>
<li><code>removeChild()</code>: 从父节点中移除指定的子节点。</li>
<li><code>parentNode.removeChild()</code>: 从父节点中移除当前节点。</li>
</ol>
<p><strong>移动节点：</strong></p>
<ol>
<li><code>appendChild()</code>: 用于将一个节点从一个位置移动到另一个位置（如果该节点已经在文档中存在，则会被自动移动到新位置）。</li>
</ol>
<p><strong>复制节点：</strong></p>
<ol>
<li><code>cloneNode()</code>: 创建一个指定节点的副本，可以选择是否深度复制，即是否同时复制子节点。</li>
</ol>
<p><strong>创建节点：</strong></p>
<ol>
<li><code>document.createElement()</code>: 创建一个新的元素节点。</li>
<li><code>document.createTextNode()</code>: 创建一个包含指定文本的文本节点。</li>
<li><code>document.createDocumentFragment()</code>: 创建一个文档片段，用于在内存中操作一组节点，然后一次性添加到文档中。</li>
</ol>
<p><strong>查找节点：</strong></p>
<ol>
<li><code>getElementById()</code>: 根据元素的 id 属性查找元素节点。</li>
<li><code>getElementsByClassName()</code>: 根据元素的 class 属性查找元素节点，返回一个 HTMLCollection 集合。</li>
<li><code>getElementsByTagName()</code>: 根据元素的标签名查找元素节点，返回一个 HTMLCollection 集合。</li>
<li><code>querySelector()</code>: 根据 CSS 选择器查找第一个匹配的元素节点。</li>
<li><code>querySelectorAll()</code>: 根据 CSS 选择器查找所有匹配的元素节点，返回一个 NodeList 集合。</li>
</ol>
<p>下面是一些示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;parent&quot;&gt;</span><br><span class="line">  &lt;p&gt;Existing child node&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">// 添加节点</span><br><span class="line">const parent = document.getElementById(&quot;parent&quot;);</span><br><span class="line">const newChild = document.createElement(&quot;p&quot;);</span><br><span class="line">newChild.textContent = &quot;New child node&quot;;</span><br><span class="line">parent.appendChild(newChild);</span><br><span class="line"></span><br><span class="line">// 移除节点</span><br><span class="line">const existingChild = parent.querySelector(&quot;p&quot;);</span><br><span class="line">parent.removeChild(existingChild);</span><br><span class="line"></span><br><span class="line">// 移动节点</span><br><span class="line">const targetParent = document.getElementById(&quot;targetParent&quot;);</span><br><span class="line">targetParent.appendChild(existingChild);</span><br><span class="line"></span><br><span class="line">// 复制节点</span><br><span class="line">const clonedChild = existingChild.cloneNode(true); // 深度复制子节点</span><br><span class="line">targetParent.appendChild(clonedChild);</span><br><span class="line"></span><br><span class="line">// 创建节点</span><br><span class="line">const textNode = document.createTextNode(&quot;Some text&quot;);</span><br><span class="line">targetParent.appendChild(textNode);</span><br><span class="line"></span><br><span class="line">// 查找节点</span><br><span class="line">const foundElement = document.querySelector(&quot;#parent p&quot;);</span><br><span class="line">console.log(foundElement.textContent); // 输出: &quot;New child node&quot;</span><br></pre></td></tr></table></figure>

<p>注意，对于查找节点的方法（例如 <code>querySelector()</code> 和 <code>querySelectorAll()</code>），如果没有找到匹配的节点，将返回 <code>null</code> 或空的 NodeList，需要进行合适的判断。</p>
<h4 id="24-什么是事件冒泡，它是如何工作的-如何阻止事件冒泡"><a href="#24-什么是事件冒泡，它是如何工作的-如何阻止事件冒泡" class="headerlink" title="24.什么是事件冒泡，它是如何工作的?如何阻止事件冒泡?"></a>24.什么是事件冒泡，它是如何工作的?如何阻止事件冒泡?</h4><p>事件冒泡是指在 DOM 结构中，当一个元素触发某个事件时，该事件会从触发元素开始向上层级的父元素依次触发，直到达到文档根节点。这意味着事件会先在触发元素上进行处理，然后在其父元素上处理，再然后在其父元素的父元素上处理，以此类推，直到事件冒泡到文档根节点。</p>
<p>例如，当你点击一个按钮时，会依次触发按钮本身的点击事件，然后是按钮所在的父元素的点击事件，再然后是父元素的父元素的点击事件，依此类推。</p>
<p>阻止事件冒泡的方法有两种：</p>
<ol>
<li><p><strong>使用 stopPropagation() 方法：</strong> 在事件处理函数中调用 <code>event.stopPropagation()</code> 可以阻止事件继续冒泡，从而停止事件传播到更高层级的元素。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;parent&quot;&gt;</span><br><span class="line">  &lt;button id=&quot;child&quot;&gt;Click Me&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const parent = document.getElementById(&quot;parent&quot;);</span><br><span class="line">const child = document.getElementById(&quot;child&quot;);</span><br><span class="line"></span><br><span class="line">function handleClick(event) &#123;</span><br><span class="line">  console.log(&quot;Button clicked&quot;);</span><br><span class="line">  event.stopPropagation();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">child.addEventListener(&quot;click&quot;, handleClick);</span><br><span class="line">parent.addEventListener(&quot;click&quot;, () =&gt; &#123;</span><br><span class="line">  console.log(&quot;Parent clicked&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在上述例子中，当点击按钮时，会输出 “Button clicked”，而不会触发父元素的点击事件。</p>
</li>
<li><p><strong>使用事件处理函数的第三个参数：</strong> 在添加事件监听器时，可以将事件处理函数的第三个参数设置为 <code>true</code>，表示在事件捕获阶段处理事件，此时事件不会冒泡。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const parent = document.getElementById(&quot;parent&quot;);</span><br><span class="line">const child = document.getElementById(&quot;child&quot;);</span><br><span class="line"></span><br><span class="line">function handleClick() &#123;</span><br><span class="line">  console.log(&quot;Button clicked&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">child.addEventListener(&quot;click&quot;, handleClick, true); // 使用捕获阶段处理事件</span><br><span class="line">parent.addEventListener(&quot;click&quot;, () =&gt; &#123;</span><br><span class="line">  console.log(&quot;Parent clicked&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在上述例子中，当点击按钮时，会输出 “Button clicked”，而不会触发父元素的点击事件。</p>
</li>
</ol>
<p>需要注意的是，事件捕获和事件冒泡是事件传播的两个阶段。事件捕获是从文档根节点开始，从外到内依次传播到目标元素，而事件冒泡是从目标元素开始，从内到外依次传播到文档根节点。默认情况下，事件处理函数会在事件冒泡阶段触发。如果想在事件捕获阶段触发事件处理函数，可以将事件监听器的第三个参数设置为 <code>true</code>。</p>
<h4 id="25-什么是事件捕获，它是如何工作的"><a href="#25-什么是事件捕获，它是如何工作的" class="headerlink" title="25.什么是事件捕获，它是如何工作的?"></a>25.什么是事件捕获，它是如何工作的?</h4><p>事件捕获是 DOM 事件传播的第一个阶段，用于在事件到达目标元素之前从文档根节点向下传播。在事件捕获阶段，事件会从最外层的父元素开始，逐级向下传递，直到到达目标元素。然后，事件进入第二个阶段，即事件冒泡阶段。</p>
<p>事件捕获的工作方式如下：</p>
<ol>
<li>事件捕获开始于文档根节点（<code>document</code>），然后向下传播到触发事件的元素。</li>
<li>事件从 <code>document</code> 向下传递到目标元素的过程中，会依次触发经过的父元素的事件处理函数，直到达到目标元素。</li>
<li>如果目标元素的父元素也有添加了事件监听器且在捕获阶段处理事件的情况，它们也会在目标元素之前触发。</li>
</ol>
<p>示例代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;parent&quot;&gt;</span><br><span class="line">  &lt;button id=&quot;child&quot;&gt;Click Me&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">const parent = document.getElementById(&quot;parent&quot;);</span><br><span class="line">const child = document.getElementById(&quot;child&quot;);</span><br><span class="line"></span><br><span class="line">function handleCapture() &#123;</span><br><span class="line">  console.log(&quot;Capture phase - Parent&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function handleClick() &#123;</span><br><span class="line">  console.log(&quot;Bubble phase - Child&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">child.addEventListener(&quot;click&quot;, handleClick);</span><br><span class="line">parent.addEventListener(&quot;click&quot;, handleCapture, true); // 使用捕获阶段处理事件</span><br></pre></td></tr></table></figure>

<p>在上述例子中，当点击按钮时，会按照如下顺序输出日志：</p>
<ol>
<li>“Capture phase - Parent” - 这是事件捕获阶段，从文档根节点开始向下传播到父元素。</li>
<li>“Bubble phase - Child” - 这是事件冒泡阶段，从目标元素开始向上冒泡到父元素。</li>
</ol>
<p>默认情况下，事件处理函数会在事件冒泡阶段触发。如果想在事件捕获阶段触发事件处理函数，可以将事件监听器的第三个参数设置为 <code>true</code>。需要注意的是，虽然大部分情况下我们使用事件冒泡，但在某些特定的场景下，事件捕获也可能会派上用场。</p>
<h4 id="26-如何让事件先冒泡后捕获"><a href="#26-如何让事件先冒泡后捕获" class="headerlink" title="26.如何让事件先冒泡后捕获?"></a>26.如何让事件先冒泡后捕获?</h4><p>在标准的 DOM 事件流中，事件首先经历捕获阶段，然后再进入冒泡阶段。如果希望在事件捕获阶段之后再触发事件冒泡阶段，可以通过在事件处理函数中手动触发冒泡阶段的事件。</p>
<p>为了实现这个目标，可以使用 <code>dispatchEvent()</code> 方法在指定的元素上手动触发事件。这个方法接受一个事件对象作为参数，通过创建一个自定义的事件对象，并将 <code>bubbles</code> 属性设置为 <code>true</code> 来模拟冒泡行为。</p>
<p>以下是一个示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;parent&quot;&gt;</span><br><span class="line">  &lt;button id=&quot;child&quot;&gt;Click Me&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">const parent = document.getElementById(&quot;parent&quot;);</span><br><span class="line">const child = document.getElementById(&quot;child&quot;);</span><br><span class="line"></span><br><span class="line">function handleCapture() &#123;</span><br><span class="line">  console.log(&quot;Capture phase - Parent&quot;);</span><br><span class="line">  // 在捕获阶段手动触发冒泡阶段的事件</span><br><span class="line">  const event = new Event(&quot;click&quot;, &#123; bubbles: true &#125;);</span><br><span class="line">  child.dispatchEvent(event);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function handleClick() &#123;</span><br><span class="line">  console.log(&quot;Bubble phase - Child&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">child.addEventListener(&quot;click&quot;, handleClick);</span><br><span class="line">parent.addEventListener(&quot;click&quot;, handleCapture, true); // 使用捕获阶段处理事件</span><br></pre></td></tr></table></figure>

<p>在上述例子中，当点击按钮时，会按照如下顺序输出日志：</p>
<ol>
<li>“Capture phase - Parent” - 这是事件捕获阶段，从文档根节点开始向下传播到父元素。</li>
<li>“Bubble phase - Child” - 这是手动触发的冒泡阶段事件，从目标元素开始向上冒泡到父元素。</li>
</ol>
<p>请注意，在手动触发冒泡阶段事件时，确保不要创建无限循环的事件触发，否则可能会导致浏览器崩溃。这种手动触发冒泡的方式应该谨慎使用，只在特定场景下使用。大部分情况下，使用标准的事件流（先捕获后冒泡）即可满足需求。</p>
<h4 id="27-JavaScript-动画和CSS3动画有什么区别"><a href="#27-JavaScript-动画和CSS3动画有什么区别" class="headerlink" title="27.JavaScript 动画和CSS3动画有什么区别?"></a>27.JavaScript 动画和CSS3动画有什么区别?</h4><p>JavaScript 动画和 CSS3 动画是实现动画效果的两种不同方式，它们在实现方式和使用场景上有一些区别。</p>
<p><strong>JavaScript 动画：</strong></p>
<ol>
<li>实现方式：使用 JavaScript 编程来操作 DOM 元素的属性，从而实现动画效果。</li>
<li>控制灵活性：JavaScript 动画可以实现更复杂和高度定制化的动画效果，因为可以通过编程来控制每一帧的状态和样式。</li>
<li>性能：较复杂的 JavaScript 动画可能会导致性能问题，特别是在移动设备上。</li>
<li>兼容性：较复杂的 JavaScript 动画可能需要更多的兼容性处理，以确保在不同浏览器和设备上正常运行。</li>
</ol>
<p><strong>CSS3 动画：</strong></p>
<ol>
<li>实现方式：使用 CSS3 的动画属性（例如 <code>animation</code> 和 <code>transition</code>）来指定动画效果，浏览器会自动处理动画过程。</li>
<li>控制灵活性：CSS3 动画相对简单，适用于较简单的动画效果。虽然可以使用关键帧动画 (<code>@keyframes</code>) 来实现一些复杂效果，但灵活性相对较低。</li>
<li>性能：CSS3 动画通常比 JavaScript 动画具有更好的性能，因为浏览器会对动画进行硬件加速，并优化动画过程。</li>
<li>兼容性：CSS3 动画在现代浏览器中有很好的支持，但在一些旧版本的浏览器上可能需要添加一些兼容性前缀或提供替代方案。</li>
</ol>
<p>使用哪种动画方式取决于具体的需求和场景。对于简单的动画效果，尽量使用 CSS3 动画，因为它们性能更好且实现更简单。对于复杂的动画效果，可以考虑使用 JavaScript 动画来实现更高度定制化的效果。在实际开发中，通常会根据动画的复杂性和性能需求来选择合适的动画方式。</p>
<h4 id="28-dom的事件模型"><a href="#28-dom的事件模型" class="headerlink" title="28.dom的事件模型"></a>28.dom的事件模型</h4><p>DOM 事件模型描述了浏览器中事件是如何被处理和传递的。DOM 事件模型分为三个阶段：捕获阶段、目标阶段和冒泡阶段。当一个事件在一个元素上触发时，会按照以下顺序经历这三个阶段：</p>
<ol>
<li><strong>捕获阶段（Capture Phase）：</strong><ul>
<li>事件从文档根节点开始传播，从最外层的父元素向下传递到目标元素。</li>
<li>在这个阶段，事件会依次触发所有经过的父元素的捕获阶段事件处理函数。</li>
</ul>
</li>
<li><strong>目标阶段（Target Phase）：</strong><ul>
<li>事件到达目标元素，即触发事件的元素。</li>
<li>事件处理函数会在目标元素上触发。</li>
</ul>
</li>
<li><strong>冒泡阶段（Bubble Phase）：</strong><ul>
<li>事件从目标元素开始向上冒泡，传播回文档根节点。</li>
<li>在这个阶段，事件会依次触发所有经过的父元素的冒泡阶段事件处理函数。</li>
</ul>
</li>
</ol>
<p>下图展示了 DOM 事件模型的三个阶段：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">------------------------------------------------</span><br><span class="line">| Capture Phase (从文档根节点向下传播)          |</span><br><span class="line">|  &lt;html&gt;                                      |</span><br><span class="line">|    &lt;body&gt;                                    |</span><br><span class="line">|      &lt;div id=&quot;parent&quot;&gt;                       |</span><br><span class="line">|        &lt;button id=&quot;child&quot;&gt;Click Me&lt;/button&gt;  |</span><br><span class="line">|      &lt;/div&gt;                                 |</span><br><span class="line">|    &lt;/body&gt;                                  |</span><br><span class="line">|  &lt;/html&gt;                                    |</span><br><span class="line">------------------------------------------------</span><br><span class="line">                 ↓</span><br><span class="line">--------------------------------------------</span><br><span class="line">| Target Phase (目标元素阶段)              |</span><br><span class="line">|  &lt;html&gt;                                |</span><br><span class="line">|    &lt;body&gt;                              |</span><br><span class="line">|      &lt;div id=&quot;parent&quot;&gt;                 |</span><br><span class="line">|        &lt;button id=&quot;child&quot;&gt;Click Me&lt;/button&gt; |</span><br><span class="line">|      &lt;/div&gt;                           |</span><br><span class="line">|    &lt;/body&gt;                            |</span><br><span class="line">|  &lt;/html&gt;                              |</span><br><span class="line">--------------------------------------------</span><br><span class="line">                 ↓</span><br><span class="line">----------------------------------------------</span><br><span class="line">| Bubble Phase (从目标元素向上冒泡传播)         |</span><br><span class="line">|  &lt;html&gt;                                   |</span><br><span class="line">|    &lt;body&gt;                                 |</span><br><span class="line">|      &lt;div id=&quot;parent&quot;&gt;                    |</span><br><span class="line">|        &lt;button id=&quot;child&quot;&gt;Click Me&lt;/button&gt; |</span><br><span class="line">|      &lt;/div&gt;                                |</span><br><span class="line">|    &lt;/body&gt;                                 |</span><br><span class="line">|  &lt;/html&gt;                                   |</span><br><span class="line">----------------------------------------------</span><br></pre></td></tr></table></figure>

<p>在事件传播过程中，可以通过在事件监听器中使用 <code>event.stopPropagation()</code> 来阻止事件的继续传播。如果需要在捕获阶段处理事件，可以将事件监听器的第三个参数设置为 <code>true</code>，例如 <code>element.addEventListener(&quot;click&quot;, handler, true)</code>。默认情况下，事件处理函数会在冒泡阶段触发。</p>
<p>通过了解 DOM 事件模型，开发者可以更好地理解事件的传播过程，灵活地应用事件处理机制。</p>
<h4 id="29-事件三要素是什么"><a href="#29-事件三要素是什么" class="headerlink" title="29.事件三要素是什么?"></a>29.事件三要素是什么?</h4><p>事件的三要素是指在处理事件时需要考虑的三个主要方面，分别是事件源、事件类型和事件处理程序。</p>
<ol>
<li><strong>事件源（Event Source）：</strong> 事件源指触发事件的元素或对象，也就是事件发生的来源。在 HTML 中，事件源可以是 DOM 元素（如按钮、文本框等），也可以是浏览器窗口、文档或其它对象。</li>
<li><strong>事件类型（Event Type）：</strong> 事件类型指事件的种类或类型。在 JavaScript 中，常见的事件类型包括点击事件（click）、键盘事件（keyup、keydown）、鼠标移动事件（mousemove）等。每种类型的事件都有对应的触发条件和特定的事件对象。</li>
<li><strong>事件处理程序（Event Handler）：</strong> 事件处理程序是一段 JavaScript 代码，用于定义事件触发后的响应行为。当事件源上发生指定类型的事件时，会调用对应的事件处理程序来执行相应的操作。可以通过事件监听器（addEventListener）或 HTML 属性（例如 onclick）来指定事件处理程序。</li>
</ol>
<p>综合来说，事件的三要素就是：事件源是触发事件的元素或对象，事件类型是事件的种类或类型，事件处理程序是定义在事件发生后要执行的 JavaScript 代码。通过处理这三个要素，可以实现对事件的控制和响应，从而实现交互性和动态性的网页效果。</p>
<h4 id="30-获取元素位置"><a href="#30-获取元素位置" class="headerlink" title="30.获取元素位置?"></a>30.获取元素位置?</h4><p>要获取元素的位置，可以使用 JavaScript 的 <code>getBoundingClientRect()</code> 方法。这个方法返回一个 DOMRect 对象，包含了元素的位置和尺寸信息，包括元素的左边距、上边距、宽度、高度等。</p>
<p>示例代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;myElement&quot; style=&quot;width: 100px; height: 50px; border: 1px solid black; position: absolute; top: 50px; left: 100px;&quot;&gt;</span><br><span class="line">  This is a sample element.</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">const myElement = document.getElementById(&quot;myElement&quot;);</span><br><span class="line">const rect = myElement.getBoundingClientRect();</span><br><span class="line"></span><br><span class="line">console.log(&quot;Left:&quot;, rect.left); // 元素左边距</span><br><span class="line">console.log(&quot;Top:&quot;, rect.top); // 元素上边距</span><br><span class="line">console.log(&quot;Width:&quot;, rect.width); // 元素宽度</span><br><span class="line">console.log(&quot;Height:&quot;, rect.height); // 元素高度</span><br><span class="line">console.log(&quot;Right:&quot;, rect.right); // 元素右边距</span><br><span class="line">console.log(&quot;Bottom:&quot;, rect.bottom); // 元素下边距</span><br></pre></td></tr></table></figure>

<p>在上述例子中，我们首先通过 <code>getElementById()</code> 方法获取 id 为 “myElement” 的元素，然后使用 <code>getBoundingClientRect()</code> 方法获取该元素的位置和尺寸信息，并打印输出。注意，<code>getBoundingClientRect()</code> 方法返回的位置信息是相对于视口（viewport）的，而不是相对于文档的。如果需要获取相对于文档的位置，可以通过加上 <code>window.scrollX</code> 和 <code>window.scrollY</code> 的值来计算。</p>
<h4 id="31-如何绑定事件，如何解除事件"><a href="#31-如何绑定事件，如何解除事件" class="headerlink" title="31.如何绑定事件，如何解除事件?"></a>31.如何绑定事件，如何解除事件?</h4><p>在 JavaScript 中，可以使用 <code>addEventListener()</code> 方法来绑定事件，使用 <code>removeEventListener()</code> 方法来解除事件。</p>
<p><strong>绑定事件：</strong> 使用 <code>addEventListener()</code> 方法可以在指定的元素上绑定一个事件处理程序。这个方法接受两个参数：要监听的事件类型和事件处理函数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;button id=&quot;myButton&quot;&gt;Click Me&lt;/button&gt;</span><br><span class="line">const myButton = document.getElementById(&quot;myButton&quot;);</span><br><span class="line"></span><br><span class="line">function handleClick() &#123;</span><br><span class="line">  console.log(&quot;Button clicked!&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myButton.addEventListener(&quot;click&quot;, handleClick);</span><br></pre></td></tr></table></figure>

<p>在上述例子中，我们在按钮上绑定了一个点击事件，并指定了 <code>handleClick</code> 函数作为事件处理程序。当按钮被点击时，会触发 <code>handleClick</code> 函数并输出 “Button clicked!”。</p>
<p><strong>解除事件：</strong> 使用 <code>removeEventListener()</code> 方法可以解除已绑定的事件处理程序。为了解除事件，必须使用相同的事件类型和事件处理程序，这样才能正确地解除事件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">myButton.removeEventListener(&quot;click&quot;, handleClick);</span><br></pre></td></tr></table></figure>

<p>在上述例子中，我们使用 <code>removeEventListener()</code> 方法解除了之前绑定的点击事件处理程序 <code>handleClick</code>。这样，在按钮被点击时就不会再触发 <code>handleClick</code> 函数。</p>
<p>需要注意的是，在使用 <code>removeEventListener()</code> 解除事件时，要确保传入的事件处理程序是之前绑定的同一个函数，否则事件是无法正确解除的。如果绑定事件时使用了匿名函数，解除事件时也需要使用同样的匿名函数。如果在解除事件时传入了不同的事件处理程序函数，那么解除操作将不起作用，事件仍然会触发。</p>
<h4 id="32-对事件委托的理解"><a href="#32-对事件委托的理解" class="headerlink" title="32.对事件委托的理解"></a>32.对事件委托的理解</h4><p>事件委托（Event Delegation）是一种常用的前端开发技巧，通过在父元素上监听事件，来代理处理其子元素的事件。具体来说，事件委托利用事件冒泡的特性，将事件的处理交给父元素，而不是直接在每个子元素上添加事件监听器。</p>
<p>事件委托的原理如下：</p>
<ol>
<li>当子元素上的事件触发时，事件会向父元素进行冒泡传播。</li>
<li>在父元素上添加事件监听器，可以捕获所有子元素触发的事件，包括未来添加的子元素。</li>
<li>通过判断触发事件的子元素的类型或属性，可以选择性地执行相应的事件处理逻辑。</li>
</ol>
<p>使用事件委托的好处有很多：</p>
<ol>
<li><strong>减少事件监听器的数量：</strong> 在父元素上添加一个事件监听器，就可以处理所有子元素的事件，无需为每个子元素都添加监听器，从而减少了事件监听器的数量，提高性能和内存效率。</li>
<li><strong>动态元素支持：</strong> 对于通过动态添加的子元素，事件委托也能够处理它们的事件，无需重新绑定事件。</li>
<li><strong>简化代码：</strong> 事件委托可以使代码更简洁和易于维护，尤其在大量子元素的情况下。</li>
</ol>
<p>示例代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;ul id=&quot;myList&quot;&gt;</span><br><span class="line">  &lt;li&gt;Item 1&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;Item 2&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;Item 3&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">const myList = document.getElementById(&quot;myList&quot;);</span><br><span class="line"></span><br><span class="line">function handleItemClick(event) &#123;</span><br><span class="line">  const target = event.target;</span><br><span class="line">  if (target.tagName === &quot;LI&quot;) &#123;</span><br><span class="line">    console.log(&quot;Clicked on item:&quot;, target.textContent);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myList.addEventListener(&quot;click&quot;, handleItemClick);</span><br></pre></td></tr></table></figure>

<p>在上述例子中，我们在父元素 <code>&lt;ul&gt;</code> 上添加了一个点击事件监听器，通过事件委托的方式来处理其子元素 <code>&lt;li&gt;</code> 的点击事件。当点击任何 <code>&lt;li&gt;</code> 元素时，事件会冒泡到父元素 <code>&lt;ul&gt;</code>，然后由事件委托的监听器来处理点击事件，并输出点击的项的内容。这样，无论 <code>&lt;li&gt;</code> 元素的数量如何变化，事件处理都能正常工作。</p>
<h4 id="33-setTimeout-和setInterval的区别及用法是什么"><a href="#33-setTimeout-和setInterval的区别及用法是什么" class="headerlink" title="33.setTimeout 和setInterval的区别及用法是什么?"></a>33.setTimeout 和setInterval的区别及用法是什么?</h4><p><code>setTimeout</code> 和 <code>setInterval</code> 都是 JavaScript 提供的用于定时执行代码的函数，它们之间的区别和用法如下：</p>
<p><strong>setTimeout:</strong></p>
<ul>
<li><code>setTimeout</code> 用于在指定的时间间隔之后执行一次代码。</li>
<li>它接受两个参数：要执行的函数（或函数的代码）和延迟的毫秒数。</li>
<li>代码执行后，<code>setTimeout</code> 不会自动重复执行，只会执行一次。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy codefunction myFunction() &#123;</span><br><span class="line">  console.log(&quot;This is a one-time execution.&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setTimeout(myFunction, 1000); // 1秒后执行 myFunction 函数</span><br></pre></td></tr></table></figure>

<p><strong>setInterval:</strong></p>
<ul>
<li><code>setInterval</code> 用于每隔指定的时间间隔重复执行一次代码。</li>
<li>它接受两个参数：要执行的函数（或函数的代码）和时间间隔的毫秒数。</li>
<li>代码会不断重复执行，直到使用 <code>clearInterval</code> 方法停止执行。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy codefunction myFunction() &#123;</span><br><span class="line">  console.log(&quot;This is a repeated execution.&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const intervalId = setInterval(myFunction, 1000); // 每隔1秒执行 myFunction 函数</span><br><span class="line"></span><br><span class="line">// 5秒后停止执行</span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">  clearInterval(intervalId);</span><br><span class="line">&#125;, 5000);</span><br></pre></td></tr></table></figure>

<p><strong>区别：</strong></p>
<ol>
<li><code>setTimeout</code> 在指定的时间间隔之后执行一次代码，而 <code>setInterval</code> 每隔指定的时间间隔重复执行一次代码。</li>
<li><code>setInterval</code> 会一直重复执行，直到使用 <code>clearInterval</code> 方法停止执行；而 <code>setTimeout</code> 只会执行一次。</li>
</ol>
<p>在使用 <code>setInterval</code> 时要注意，如果代码执行的时间超过了时间间隔，可能会导致函数之间的重叠执行。因此，确保函数执行时间不会超过时间间隔，或者在下次执行前使用 <code>clearInterval</code> 停止执行。</p>
<p>总体来说，<code>setTimeout</code> 用于一次性的延迟执行，而 <code>setInterval</code> 用于重复性的定时执行。根据需求选择适合的方法来实现定时操作。</p>
<h4 id="34-用setTimeout来实现setInterval"><a href="#34-用setTimeout来实现setInterval" class="headerlink" title="34.用setTimeout来实现setInterval"></a>34.用setTimeout来实现setInterval</h4><p>虽然 <code>setTimeout</code> 和 <code>setInterval</code> 是两个不同的函数，但是可以利用 <code>setTimeout</code> 的递归调用来模拟实现类似 <code>setInterval</code> 的功能。实现的关键是在每次函数执行完成后，再次调用 <code>setTimeout</code> 来触发下一次函数执行，从而实现间隔性的重复执行。</p>
<p>下面是使用 <code>setTimeout</code> 模拟实现 <code>setInterval</code> 的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function myInterval(callback, interval) &#123;</span><br><span class="line">  const wrapper = function() &#123;</span><br><span class="line">    callback();</span><br><span class="line">    setTimeout(wrapper, interval); // 递归调用setTimeout，实现重复执行</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  setTimeout(wrapper, interval); // 第一次触发函数执行</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 测试示例</span><br><span class="line">let count = 0;</span><br><span class="line">function printCount() &#123;</span><br><span class="line">  console.log(&quot;Count:&quot;, count);</span><br><span class="line">  count++;</span><br><span class="line"></span><br><span class="line">  if (count === 5) &#123;</span><br><span class="line">    // 停止执行</span><br><span class="line">    console.log(&quot;Stopped.&quot;);</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用自定义的myInterval函数来模拟setInterval</span><br><span class="line">myInterval(printCount, 1000);</span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们定义了 <code>myInterval</code> 函数，它接受一个回调函数 <code>callback</code> 和一个时间间隔 <code>interval</code>，并通过递归调用 <code>setTimeout</code> 来模拟 <code>setInterval</code> 的功能。在 <code>myInterval</code> 函数内部，我们使用了一个闭包 <code>wrapper</code> 来包裹回调函数 <code>callback</code>，每次执行完 <code>callback</code> 后再次调用 <code>setTimeout</code> 来触发下一次的执行。</p>
<p>需要注意的是，这种方式虽然能够模拟 <code>setInterval</code> 的功能，但是和原生的 <code>setInterval</code> 相比，可能存在一些性能和准确性上的差异。在实际开发中，建议优先使用原生的 <code>setInterval</code>，除非有特殊需求需要手动模拟。</p>
<h4 id="35-document-write-和innerHTML的区别"><a href="#35-document-write-和innerHTML的区别" class="headerlink" title="35.document.write 和innerHTML的区别?"></a>35.document.write 和innerHTML的区别?</h4><p><code>document.write</code> 和 <code>innerHTML</code> 都是用于向网页中插入内容的方法，但它们有一些区别：</p>
<p><strong>document.write:</strong></p>
<ul>
<li><code>document.write</code> 是 JavaScript 中最早的一种向文档中插入内容的方法。</li>
<li>它可以在页面加载时直接在文档中写入内容，也可以在页面加载后通过脚本动态写入内容。</li>
<li>当页面已经加载完成后，再使用 <code>document.write</code> 会重写整个文档，导致之前的内容丢失，因此在页面加载完成后使用 <code>document.write</code> 是不推荐的做法。</li>
<li>由于它在加载和解析文档时直接修改 DOM，可能会导致性能问题，而且在某些情况下会破坏页面的结构。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  document.write(&quot;&lt;h1&gt;Hello, World!&lt;/h1&gt;&quot;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><strong>innerHTML:</strong></p>
<ul>
<li><code>innerHTML</code> 是用于获取或设置元素的 HTML 内容的属性。</li>
<li>通过修改元素的 <code>innerHTML</code> 属性，可以向元素内部插入 HTML 内容，包括文本、标签等。</li>
<li><code>innerHTML</code> 是一个字符串属性，因此可以通过赋值来设置元素的内容，也可以通过读取它来获取元素的内容。</li>
<li>与 <code>document.write</code> 不同，<code>innerHTML</code> 只会修改指定元素的内容，而不会影响整个文档结构。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;myDiv&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const myDiv = document.getElementById(&quot;myDiv&quot;);</span><br><span class="line">  myDiv.innerHTML = &quot;&lt;h1&gt;Hello, World!&lt;/h1&gt;&quot;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><strong>区别：</strong></p>
<ul>
<li><code>document.write</code> 是直接向文档写入内容，对整个文档结构产生影响，可能导致性能问题，并且不适合在页面加载后使用。</li>
<li><code>innerHTML</code> 是通过修改元素的属性来插入内容，只对指定元素产生影响，不会重写整个文档，更灵活且性能较好。</li>
</ul>
<p>总的来说，推荐使用 <code>innerHTML</code> 来动态插入内容，而避免使用 <code>document.write</code>。如果需要在页面加载后动态插入内容，可以使用 <code>innerHTML</code> 或其他 DOM 操作方法来实现。</p>
<h4 id="36-元素拖动如何实现，原理是怎样"><a href="#36-元素拖动如何实现，原理是怎样" class="headerlink" title="36.元素拖动如何实现，原理是怎样?"></a>36.元素拖动如何实现，原理是怎样?</h4><p>实现元素拖动的常见方式是使用 JavaScript 监听鼠标事件，并在鼠标移动时更新元素的位置。拖动元素的基本原理如下：</p>
<ol>
<li>在鼠标按下事件（mousedown）中，记录鼠标的初始位置和需要拖动的元素的初始位置。</li>
<li>在鼠标移动事件（mousemove）中，计算鼠标的偏移量（鼠标当前位置减去初始位置），然后将偏移量加上元素的初始位置，从而得到元素的新位置。</li>
<li>将元素的新位置应用到元素的样式中，实现拖动效果。</li>
<li>在鼠标抬起事件（mouseup）中，取消事件监听，结束拖动。</li>
</ol>
<p>下面是一个简单的实现元素拖动的示例：</p>
<p>HTML：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;draggableElement&quot; style=&quot;width: 100px; height: 100px; background-color: red; position: absolute; top: 100px; left: 100px;&quot;&gt;</span><br><span class="line">  Drag me!</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>JavaScript：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const draggableElement = document.getElementById(&quot;draggableElement&quot;);</span><br><span class="line"></span><br><span class="line">let isDragging = false;</span><br><span class="line">let initialX;</span><br><span class="line">let initialY;</span><br><span class="line"></span><br><span class="line">draggableElement.addEventListener(&quot;mousedown&quot;, (event) =&gt; &#123;</span><br><span class="line">  isDragging = true;</span><br><span class="line">  initialX = event.clientX - draggableElement.offsetLeft;</span><br><span class="line">  initialY = event.clientY - draggableElement.offsetTop;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">document.addEventListener(&quot;mousemove&quot;, (event) =&gt; &#123;</span><br><span class="line">  if (isDragging) &#123;</span><br><span class="line">    const xOffset = event.clientX - initialX;</span><br><span class="line">    const yOffset = event.clientY - initialY;</span><br><span class="line">    draggableElement.style.left = xOffset + &quot;px&quot;;</span><br><span class="line">    draggableElement.style.top = yOffset + &quot;px&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">document.addEventListener(&quot;mouseup&quot;, () =&gt; &#123;</span><br><span class="line">  isDragging = false;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们首先获取需要拖动的元素 <code>draggableElement</code>，然后使用三个变量 <code>isDragging</code>、<code>initialX</code> 和 <code>initialY</code> 来记录拖动状态和初始位置。在鼠标按下事件中，我们记录鼠标的初始位置和元素的初始位置。在鼠标移动事件中，我们计算鼠标的偏移量，并将偏移量应用到元素的样式中，实现拖动效果。在鼠标抬起事件中，我们取消拖动状态，结束拖动。</p>
<p>这样，当我们点击并拖动元素时，它会随着鼠标移动而改变位置，实现了元素的拖动效果。</p>
<h4 id="37-什么是重绘-repaint-什么是回流-reflow-如何最小化重绘和回流"><a href="#37-什么是重绘-repaint-什么是回流-reflow-如何最小化重绘和回流" class="headerlink" title="37.什么是重绘(repaint)?什么是回流(reflow)?如何最小化重绘和回流?"></a>37.什么是重绘(repaint)?什么是回流(reflow)?如何最小化重绘和回流?</h4><p>重绘（Repaint）和回流（Reflow）是浏览器渲染页面时的两个重要概念：</p>
<p><strong>重绘（Repaint）：</strong> 重绘是指当元素样式发生改变，但不影响其布局的情况下，浏览器重新绘制元素的过程。重绘不涉及元素的位置和大小的变化，只是重新绘制元素的外观，例如颜色、背景等。</p>
<p><strong>回流（Reflow）：</strong> 回流是指当页面布局发生改变，浏览器重新计算元素的大小和位置，并重新渲染页面的过程。回流涉及页面布局的改变，例如元素的大小、位置、隐藏状态等。</p>
<p><strong>最小化重绘和回流的方法：</strong> 由于重绘和回流可能会引起性能问题，我们应该尽量避免不必要的重绘和回流，以提高页面性能。以下是一些最小化重绘和回流的方法：</p>
<ol>
<li><strong>使用 class 替代 style：</strong> 使用 class 来修改元素样式，而不是直接操作 style 属性。这样可以将多个样式的修改合并为一个 class 的修改，减少重绘和回流的次数。</li>
<li><strong>使用文档片段：</strong> 在插入大量 DOM 元素时，使用文档片段（DocumentFragment）来一次性插入，而不是多次单独插入。这样可以减少回流次数。</li>
<li><strong>使用 CSS3 动画：</strong> 在需要进行动画效果的元素上，尽量使用 CSS3 动画，而不是 JavaScript 控制样式。CSS3 动画在很多情况下使用了 GPU 加速，效率更高。</li>
<li><strong>避免强制同步布局：</strong> 如果需要获取元素的位置或尺寸等信息，尽量使用异步的方式，避免强制同步布局，以减少回流。</li>
<li><strong>使用 transform 替代 top&#x2F;left：</strong> 如果需要移动元素，尽量使用 CSS3 的 transform 属性，而不是直接修改 top 和 left 属性。transform 属性不会引起回流。</li>
<li><strong>避免 table 布局：</strong> 使用 table 布局会导致回流，尽量使用 CSS 布局代替。</li>
<li><strong>缓存布局信息：</strong> 当需要多次获取元素的布局信息时，应该缓存这些信息，避免重复触发回流。</li>
</ol>
<p>以上方法都有助于减少重绘和回流，提高页面性能和用户体验。在实际开发中，尽量遵循这些最佳实践，以优化页面性能。</p>
<h4 id="38-延迟加载的方式有哪些"><a href="#38-延迟加载的方式有哪些" class="headerlink" title="38.延迟加载的方式有哪些?"></a>38.延迟加载的方式有哪些?</h4><p>延迟加载（Lazy Loading）是一种优化网页性能的技术，它可以延迟加载页面中的资源（如图片、脚本、样式等），直到这些资源在用户视图中可见或需要使用时再进行加载。这样可以减少页面的初始加载时间，提高网页的加载速度和用户体验。以下是常见的延迟加载方式：</p>
<ol>
<li><strong>图片延迟加载：</strong> 将页面上的图片的 <code>src</code> 属性设为占位符（如一张空白的图片），然后使用自定义的属性（如 <code>data-src</code>）保存真实的图片地址。当图片进入用户视图时（如滚动到可见区域），再将真实的图片地址赋值给 <code>src</code> 属性，从而实现图片的延迟加载。</li>
<li><strong>懒加载脚本：</strong> 将不是页面初始加载必需的脚本标记为异步或延迟加载，可以通过将 <code>async</code> 或 <code>defer</code> 属性添加到 <code>&lt;script&gt;</code> 标签来实现。<code>async</code> 属性会异步加载并立即执行脚本，不会阻塞页面加载；<code>defer</code> 属性会在页面加载完成后顺序执行脚本，但不会阻塞 DOM 的解析。</li>
<li><strong>懒加载样式：</strong> 对于不是页面初始加载必需的样式（如页面上的一些特定样式或主题样式），可以将其标记为异步加载，或通过 JavaScript 动态插入样式表。</li>
<li><strong>无限滚动：</strong> 对于包含大量数据的列表或瀑布流布局等，可以使用无限滚动的方式，当用户滚动到列表底部时，再加载更多的数据，以避免一次性加载过多的内容。</li>
<li><strong>按需加载模块：</strong> 对于模块化的前端代码（如通过 ES6 模块导入的脚本），可以使用动态 <code>import()</code> 方法来按需加载模块，当模块需要使用时再进行加载。</li>
<li><strong>分片加载：</strong> 将页面中的内容分为多个块（chunks），按需加载块中的内容。这种方式常用于 Webpack 或其他打包工具的代码拆分功能。</li>
</ol>
<p>使用延迟加载的方式可以显著提高网页的初始加载速度，特别对于包含大量资源或数据的页面。在实际开发中，根据页面的需求和性能优化目标，选择合适的延迟加载方式，有助于提升网页性能，减少用户等待时间。</p>
<h4 id="39-垃圾回收机制有哪些-具体怎么如何执行"><a href="#39-垃圾回收机制有哪些-具体怎么如何执行" class="headerlink" title="39.垃圾回收机制有哪些?具体怎么如何执行?"></a>39.垃圾回收机制有哪些?具体怎么如何执行?</h4><p>在计算机科学中，垃圾回收（Garbage Collection）是一种自动管理内存的机制，它负责检测不再使用的内存对象（垃圾），并释放这些内存，以供其他对象使用。常见的垃圾回收机制有以下几种：</p>
<ol>
<li><strong>引用计数垃圾回收（Reference Counting Garbage Collection）：</strong> 这是最简单的垃圾回收算法。它通过对每个对象维护一个引用计数器，记录有多少个引用指向该对象。当引用计数为 0 时，表示该对象不再被引用，可以被释放。但是引用计数垃圾回收无法处理循环引用的情况，因为循环引用会导致对象之间的引用计数不为 0。</li>
<li><strong>标记-清除垃圾回收（Mark and Sweep Garbage Collection）：</strong> 这是一种常用的垃圾回收算法。它通过从根对象开始，标记所有可达的对象（即根对象引用的对象及其引用的对象，依次类推）。标记完成后，未被标记的对象即为垃圾，可以被清除。标记-清除垃圾回收能够处理循环引用的情况，并清除不再使用的对象。</li>
<li><strong>标记-整理垃圾回收（Mark and Compact Garbage Collection）：</strong> 这是标记-清除算法的改进版。除了标记和清除不再使用的对象外，标记-整理还会将存活的对象紧凑排列在内存中，从而减少内存碎片，提高内存使用效率。</li>
<li><strong>分代垃圾回收（Generational Garbage Collection）：</strong> 分代垃圾回收将对象按照其生命周期划分为多个代（Generation）。一般情况下，新创建的对象属于新生代，生命周期较短；而存活时间较长的对象属于老生代。分代垃圾回收针对不同代采用不同的回收策略，例如，针对新生代采用较频繁但速度较快的回收策略，针对老生代采用较少但速度较慢的回收策略，以提高回收效率。</li>
</ol>
<p>垃圾回收的执行步骤通常包括以下几个阶段：</p>
<ol>
<li><strong>标记（Mark）：</strong> 从根对象出发，递归地标记所有可达的对象。</li>
<li><strong>清除（Sweep）：</strong> 遍历整个堆内存，清除所有未标记的对象，将其内存释放。</li>
<li><strong>整理（Compact，可选）：</strong> 将存活的对象紧凑排列在内存中，减少内存碎片。</li>
</ol>
<p>在实际应用中，不同编程语言和运行环境会采用不同的垃圾回收算法和策略，以适应不同的场景和需求。垃圾回收机制的优化是提高应用性能和资源利用率的重要手段。</p>
<h4 id="40-什么是内存泄漏"><a href="#40-什么是内存泄漏" class="headerlink" title="40.什么是内存泄漏?"></a>40.什么是内存泄漏?</h4><p>内存泄漏（Memory Leak）是指程序在运行过程中，由于错误的内存管理导致一些不再使用的内存无法被及时释放，从而造成内存的持续占用，最终导致可用内存逐渐减少，直至耗尽系统的内存资源。</p>
<p>内存泄漏通常是由于程序中存在一些无法访问到的内存对象占用了内存空间，而无法回收这些对象的内存。这些未释放的内存会逐渐累积，导致程序的内存使用量逐渐增加，直至达到系统的内存限制，进而引发程序崩溃、运行缓慢或导致其他系统性能问题。</p>
<p>内存泄漏可能由以下原因引起：</p>
<ol>
<li><strong>未及时释放动态分配的内存：</strong> 当程序动态分配内存（如使用 <code>new</code> 或 <code>malloc</code>）后，应及时使用 <code>delete</code> 或 <code>free</code> 释放内存。如果未释放，这些内存将一直占用，造成内存泄漏。</li>
<li><strong>循环引用：</strong> 当两个或多个对象之间存在相互引用关系，并且这些对象不再被使用时没有及时解除引用，会导致这些对象无法被垃圾回收，从而引发内存泄漏。</li>
<li><strong>全局变量：</strong> 全局变量在程序的整个生命周期内都存在，如果不再使用时没有释放或清除这些全局变量的引用，会导致内存泄漏。</li>
<li><strong>未关闭的资源：</strong> 如果程序打开了文件、网络连接或数据库连接等资源，在不再使用时没有正确关闭这些资源，会造成资源泄漏，最终导致内存泄漏。</li>
</ol>
<p>解决内存泄漏的方法包括：</p>
<ul>
<li>在使用完动态分配的内存后，及时释放它们。</li>
<li>避免循环引用，确保对象之间的引用关系能够正确地被垃圾回收。</li>
<li>尽量避免使用全局变量，使用局部变量或限制作用域来控制变量的生命周期。</li>
<li>在使用资源（如文件、网络连接等）后，及时关闭或释放这些资源。</li>
</ul>
<p>通过合理的内存管理，开发者可以避免内存泄漏问题，确保程序正常运行，并减少资源浪费。</p>
<h4 id="41-数组遍历的方法有哪些，分别有什么特点，性能如何"><a href="#41-数组遍历的方法有哪些，分别有什么特点，性能如何" class="headerlink" title="41.数组遍历的方法有哪些，分别有什么特点，性能如何?"></a>41.数组遍历的方法有哪些，分别有什么特点，性能如何?</h4><p>数组遍历的方法有多种，下面列举常见的数组遍历方法，以及它们的特点和性能：</p>
<ol>
<li><p><strong>for 循环：</strong> 这是最基本的数组遍历方法，通过索引逐个访问数组元素。它的特点是简单直接，适用于所有类型的数组，但写法相对繁琐，需要手动管理索引。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const arr = [1, 2, 3, 4, 5];</span><br><span class="line">for (let i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">  console.log(arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>性能：</strong> for 循环的性能是最好的，因为它直接通过索引访问数组元素，没有额外的函数调用和迭代过程。</p>
</li>
<li><p><strong>forEach 方法：</strong> forEach 是数组的内置方法，可以直接对数组进行遍历，对每个元素执行指定的回调函数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const arr = [1, 2, 3, 4, 5];</span><br><span class="line">arr.forEach((item) =&gt; &#123;</span><br><span class="line">  console.log(item);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>特点：</strong> forEach 方法简化了遍历过程，不需要手动管理索引，直接对数组元素执行操作。</p>
<p><strong>性能：</strong> forEach 方法的性能较好，但在某些情况下可能比 for 循环略慢，因为它使用了回调函数，可能会涉及函数的创建和执行。</p>
</li>
<li><p><strong>for…of 循环：</strong> for…of 循环是 ES6 引入的一种新的遍历方式，它可以遍历可迭代对象，包括数组。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const arr = [1, 2, 3, 4, 5];</span><br><span class="line">for (const item of arr) &#123;</span><br><span class="line">  console.log(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>特点：</strong> for…of 循环简洁易读，遍历过程中无需处理索引，直接访问元素。</p>
<p><strong>性能：</strong> for…of 循环的性能通常和 forEach 方法相当，也会因使用回调函数而略慢于 for 循环。</p>
</li>
<li><p><strong>map 方法：</strong> map 方法是数组的内置方法，用于遍历数组，并返回一个新的数组，新数组的每个元素都是对原数组元素的处理结果。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const arr = [1, 2, 3, 4, 5];</span><br><span class="line">const newArr = arr.map((item) =&gt; item * 2);</span><br><span class="line">console.log(newArr);</span><br></pre></td></tr></table></figure>

<p><strong>特点：</strong> map 方法在遍历的同时生成一个新的数组，对原数组的元素进行处理并映射到新数组中。</p>
<p><strong>性能：</strong> map 方法和 forEach 方法类似，性能较好，但会因使用回调函数而略慢于 for 循环。</p>
</li>
<li><p><strong>其他方法：</strong> 还有一些其他的数组遍历方法，如 filter、reduce、every、some 等，它们都有不同的用途，适用于不同的场景。</p>
<ul>
<li>filter 方法：返回符合条件的元素组成的新数组。</li>
<li>reduce 方法：累加器，将数组元素按指定规则聚合为一个值。</li>
<li>every 方法：检查数组中是否所有元素都满足某个条件。</li>
<li>some 方法：检查数组中是否有至少一个元素满足某个条件。</li>
</ul>
<p>这些方法在功能上各有不同，使用时需要根据实际需求选择适当的方法。</p>
</li>
</ol>
<p>总体来说，for 循环在性能上是最好的，但 forEach、for…of 和 map 方法在代码的可读性和简洁性上更好。在大多数情况下，这些方法的性能差异并不明显，可以根据具体场景选择最适合的遍历方法。</p>
<h4 id="42-ES5-和ES6的区别，ES6新增了什么"><a href="#42-ES5-和ES6的区别，ES6新增了什么" class="headerlink" title="42.ES5 和ES6的区别，ES6新增了什么?"></a>42.ES5 和ES6的区别，ES6新增了什么?</h4><p>ES5（ECMAScript 5）和ES6（ECMAScript 2015，也称为ES6）是 JavaScript 的两个主要版本，它们之间有许多区别。ES6是ES5的升级版本，引入了许多新的特性和语法，以便使 JavaScript 语言更加现代化、灵活和易用。以下是ES5和ES6之间的主要区别以及ES6新增的一些功能：</p>
<ol>
<li><strong>let 和 const 声明：</strong> ES6引入了块级作用域的变量声明，使用<code>let</code>声明的变量具有块级作用域，而使用<code>const</code>声明的变量是常量，不可重新赋值。</li>
<li><strong>箭头函数：</strong> ES6引入了箭头函数语法，使得函数的定义更加简洁，并且箭头函数没有自己的<code>this</code>和<code>arguments</code>，继承了外部作用域的<code>this</code>和<code>arguments</code>。</li>
<li><strong>模板字面量：</strong> ES6引入了模板字面量，使用反引号（&#96;）包围字符串，可以在字符串中插入变量和表达式，使得字符串的拼接更加简洁和方便。</li>
<li><strong>解构赋值：</strong> ES6引入了解构赋值语法，可以快速地从数组或对象中提取值，并赋值给变量，以简化代码。</li>
<li><strong>Promise：</strong> ES6引入了Promise对象，用于处理异步操作，避免了回调地狱，使得异步代码更加可读和易于管理。</li>
<li><strong>类和继承：</strong> ES6引入了类的概念，使用<code>class</code>关键字声明类，并通过<code>extends</code>关键字实现类的继承。</li>
<li><strong>模块化：</strong> ES6引入了模块化的语法，使用<code>import</code>和<code>export</code>关键字导入和导出模块，使得代码的组织和管理更加清晰和灵活。</li>
<li><strong>扩展运算符：</strong> ES6引入了扩展运算符（<code>...</code>），可以将数组或对象展开成逗号分隔的参数序列，方便地传递参数或合并数组、对象。</li>
<li><strong>Set 和 Map 数据结构：</strong> ES6引入了Set和Map两种新的数据结构，Set是一种无重复元素的集合，Map是一种键值对的映射。</li>
<li><strong>默认参数：</strong> ES6允许函数的参数设置默认值，当函数调用时没有传递对应的参数时，将使用默认值。</li>
<li><strong>Rest 参数：</strong> ES6引入了Rest参数，允许将不确定数量的参数表示为一个数组。</li>
<li><strong>Symbol：</strong> ES6引入了Symbol数据类型，用于创建唯一的、不可变的值，可以用作对象的属性名。</li>
</ol>
<p>除了上述功能之外，ES6还增加了许多其他功能和语法改进，如迭代器、生成器、模块的动态导入、Proxy、Reflect等，这些都为JavaScript语言的使用和开发带来了更多便利和可能性。由于ES6的广泛支持，现在越来越多的前端开发者开始使用ES6来编写现代化的JavaScript代码。</p>
<h4 id="43-ES6的继承和ES5的继承有什么区别"><a href="#43-ES6的继承和ES5的继承有什么区别" class="headerlink" title="43.ES6的继承和ES5的继承有什么区别?"></a>43.ES6的继承和ES5的继承有什么区别?</h4><p>ES6的继承和ES5的继承在实现方式和语法上有较大的区别。主要的区别如下：</p>
<p><strong>ES6的继承（Class 继承）：</strong></p>
<ol>
<li><strong>关键字：</strong> ES6使用<code>class</code>关键字来声明类和继承关系。</li>
<li><strong>构造函数：</strong> 在ES6的继承中，使用<code>constructor</code>方法来定义类的构造函数，而不是像ES5中使用函数来定义构造函数。</li>
<li><strong>继承：</strong> 使用<code>extends</code>关键字来实现继承，子类通过<code>extends</code>关键字继承父类的属性和方法。</li>
<li><strong>super 关键字：</strong> 在子类的构造函数中，使用<code>super</code>关键字来调用父类的构造函数，以便初始化父类的属性。</li>
<li><strong>方法定义：</strong> 在类的定义中，可以直接通过方法名来定义类的方法，不需要使用<code>prototype</code>关键字。</li>
<li><strong>静态方法：</strong> ES6引入了静态方法的概念，使用<code>static</code>关键字来定义静态方法，静态方法属于类本身而不是实例。</li>
</ol>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy codeclass Animal &#123;</span><br><span class="line">  constructor(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  speak() &#123;</span><br><span class="line">    console.log(this.name + &#x27; makes a sound&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dog extends Animal &#123;</span><br><span class="line">  constructor(name, breed) &#123;</span><br><span class="line">    super(name);</span><br><span class="line">    this.breed = breed;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  speak() &#123;</span><br><span class="line">    console.log(this.name + &#x27; barks&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static info() &#123;</span><br><span class="line">    console.log(&#x27;This is a Dog class&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const dog = new Dog(&#x27;Buddy&#x27;, &#x27;Golden Retriever&#x27;);</span><br><span class="line">dog.speak(); // Output: Buddy barks</span><br><span class="line">Dog.info(); // Output: This is a Dog class</span><br></pre></td></tr></table></figure>

<p><strong>ES5的继承（原型链继承）：</strong></p>
<ol>
<li><strong>构造函数：</strong> 在ES5的继承中，通过构造函数创建对象，使用<code>new</code>关键字调用构造函数。</li>
<li><strong>原型链：</strong> 在原型链继承中，通过将子类的原型对象指向父类的实例来实现继承，子类将继承父类的属性和方法。</li>
<li><strong>调用父类构造函数：</strong> 在子类的构造函数中，通过<code>Parent.call(this, ...)</code>调用父类的构造函数，以便初始化父类的属性。</li>
<li><strong>方法定义：</strong> 在构造函数的<code>prototype</code>上定义类的方法。</li>
</ol>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Animal(name) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Animal.prototype.speak = function() &#123;</span><br><span class="line">  console.log(this.name + &#x27; makes a sound&#x27;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function Dog(name, breed) &#123;</span><br><span class="line">  Animal.call(this, name);</span><br><span class="line">  this.breed = breed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Dog.prototype = Object.create(Animal.prototype);</span><br><span class="line">Dog.prototype.constructor = Dog;</span><br><span class="line"></span><br><span class="line">Dog.prototype.speak = function() &#123;</span><br><span class="line">  console.log(this.name + &#x27; barks&#x27;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var dog = new Dog(&#x27;Buddy&#x27;, &#x27;Golden Retriever&#x27;);</span><br><span class="line">dog.speak(); // Output: Buddy barks</span><br></pre></td></tr></table></figure>

<p>总的来说，ES6的继承更加简洁、易读，使用<code>class</code>关键字和<code>extends</code>关键字可以更直观地描述类的继承关系，而且引入了静态方法的概念。相比之下，ES5的继承通过原型链和构造函数来实现，语法相对复杂一些。由于ES6的继承更加符合现代JavaScript开发的需求，推荐在新项目中使用ES6的继承方式。</p>
<h4 id="44-var、-let、-const-之间的区别-暂时性死区如何理解"><a href="#44-var、-let、-const-之间的区别-暂时性死区如何理解" class="headerlink" title="44.var、 let、 const 之间的区别?暂时性死区如何理解?"></a>44.var、 let、 const 之间的区别?暂时性死区如何理解?</h4><p><code>var</code>、<code>let</code>和<code>const</code>是 JavaScript 中用于声明变量的关键字，它们之间有一些重要的区别：</p>
<ol>
<li><strong>var：</strong><ul>
<li>在ES5中引入的关键字，具有函数作用域（function scope）。</li>
<li>声明的变量会被提升到函数的顶部，这就是所谓的”变量提升”（hoisting），在声明之前就可以访问到变量，但值为<code>undefined</code>。</li>
<li>可以重复声明同名的变量，后面的声明会覆盖前面的声明。</li>
<li>不受块级作用域控制，可能会导致意外的变量覆盖或泄漏。</li>
</ul>
</li>
<li><strong>let：</strong><ul>
<li>在ES6中引入的关键字，具有块级作用域（block scope）。</li>
<li>声明的变量不会被提升，只有在声明之后才能访问到变量。</li>
<li>不允许重复声明同名的变量，重复声明会导致错误。</li>
<li>在块级作用域内有效，避免了变量覆盖和泄漏的问题。</li>
</ul>
</li>
<li><strong>const：</strong><ul>
<li>也是在ES6中引入的关键字，具有块级作用域。</li>
<li>声明的是常量，一旦赋值后就不能再改变。</li>
<li>声明的同时必须进行初始化，否则会导致错误。</li>
<li>对于基本数据类型，常量的值是不可变的，但对于复杂数据类型（如对象和数组），可以修改其内部的属性或元素。</li>
</ul>
</li>
</ol>
<p>暂时性死区（Temporal Dead Zone，简称TDZ）是指在块级作用域中，使用<code>let</code>和<code>const</code>声明的变量在声明之前是不可访问的，并且如果尝试访问这些变量会导致运行时错误。这是因为在块级作用域内，变量在声明之前处于一个”暂时性死区”，只有在变量的声明语句执行完成之后，变量才会被创建并可以正常访问。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(a); // ReferenceError: a is not defined</span><br><span class="line">let a = 10;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，变量<code>a</code>虽然已经声明了，但由于处于暂时性死区，尝试访问<code>a</code>会导致运行时错误。</p>
<p>暂时性死区的引入是为了解决<code>var</code>声明的变量提升问题，使得变量的作用域更加清晰和可控。在编写代码时，应尽量将变量声明放在作用域的顶部，以避免因暂时性死区导致的错误。</p>
<h4 id="45-Class、-extends-是什么，有什么作用"><a href="#45-Class、-extends-是什么，有什么作用" class="headerlink" title="45.Class、 extends 是什么，有什么作用?"></a>45.Class、 extends 是什么，有什么作用?</h4><p>在 JavaScript 中，<code>class</code>是一个关键字，<code>extends</code>是另一个关键字，它们用于实现面向对象编程中的类和继承。</p>
<p><strong>Class：</strong> <code>class</code>关键字用于定义一个类，类是一种抽象的数据类型，用于描述具有相同属性和方法的对象的集合。类是面向对象编程的基本概念，它允许我们将数据和行为封装在一起，并通过实例化来创建具体的对象。类提供了一种创建对象的模板，可以用来创建多个具有相同属性和方法的对象。</p>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">  constructor(name, species) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.species = species;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  speak() &#123;</span><br><span class="line">    console.log(this.name + &#x27; makes a sound&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const dog = new Animal(&#x27;Buddy&#x27;, &#x27;Dog&#x27;);</span><br><span class="line">console.log(dog.species); // Output: Dog</span><br><span class="line">dog.speak(); // Output: Buddy makes a sound</span><br></pre></td></tr></table></figure>

<p><strong>Extends：</strong> <code>extends</code>关键字用于在一个类中创建另一个类的子类，实现继承关系。子类继承了父类的属性和方法，并可以在子类中定义新的属性和方法，或覆盖父类的方法。继承允许我们创建一个类的层次结构，通过共享通用的属性和方法来减少重复代码，并在子类中实现特定的功能。</p>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">  constructor(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  speak() &#123;</span><br><span class="line">    console.log(this.name + &#x27; makes a sound&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dog extends Animal &#123;</span><br><span class="line">  constructor(name, breed) &#123;</span><br><span class="line">    super(name);</span><br><span class="line">    this.breed = breed;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  bark() &#123;</span><br><span class="line">    console.log(this.name + &#x27; barks&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const dog = new Dog(&#x27;Buddy&#x27;, &#x27;Golden Retriever&#x27;);</span><br><span class="line">console.log(dog.breed); // Output: Golden Retriever</span><br><span class="line">dog.speak(); // Output: Buddy makes a sound</span><br><span class="line">dog.bark(); // Output: Buddy barks</span><br></pre></td></tr></table></figure>

<p>通过继承，<code>Dog</code>类继承了<code>Animal</code>类的<code>name</code>属性和<code>speak</code>方法，并在<code>Dog</code>类中添加了新的<code>breed</code>属性和<code>bark</code>方法。</p>
<p>总结：<code>class</code>和<code>extends</code>关键字是 JavaScript 中实现面向对象编程的重要特性。<code>class</code>用于定义类，<code>extends</code>用于实现类的继承，它们共同为我们提供了一种简洁、灵活和可扩展的方式来组织和管理代码。</p>
<h4 id="46-什么是JS包"><a href="#46-什么是JS包" class="headerlink" title="46.什么是JS包"></a>46.什么是JS包</h4><p>在 JavaScript 中，”包”（Package）通常是指一组相关的代码文件和资源，以及一个描述文件，用于将这些文件和资源打包成一个单独的、可重用的单元。包的概念主要用于模块化开发，可以将代码和资源按照功能或业务逻辑进行组织，以便于管理和复用。</p>
<p>常见的 JavaScript 包管理工具是 npm（Node Package Manager），它是 Node.js 生态系统中的包管理工具，也是最大的开源软件注册表，拥有数以百万计的包供开发者使用。通过 npm，开发者可以轻松地安装、发布、更新和管理 JavaScript 包。</p>
<p>一个典型的 JavaScript 包通常包含以下内容：</p>
<ol>
<li><strong>代码文件：</strong> 包含实现特定功能的 JavaScript 代码文件，可以是单个文件或多个文件的组合。</li>
<li><strong>资源文件：</strong> 包含其他类型的资源文件，如图片、样式表、配置文件等。</li>
<li><strong>package.json：</strong> 是包的描述文件，其中包含了关于包的信息，比如名称、版本、作者、依赖项等。</li>
<li><strong>README：</strong> 包的说明文件，通常包含包的用法、示例代码等。</li>
<li><strong>LICENSE：</strong> 包的许可证文件，规定了使用该包的许可协议。</li>
</ol>
<p>JavaScript 包的优势在于它们可以封装代码和资源，并提供良好的模块化开发体验。通过使用包管理工具，我们可以方便地在项目中引用其他开源包，并且可以将自己的代码和资源打包成包，方便其他开发者使用。这种模块化的开发方式提高了代码的复用性、可维护性和可扩展性，是现代 JavaScript 开发中的重要实践。</p>
<h4 id="47-说一下类的创建和继承，列举一下你所知道的继承方式"><a href="#47-说一下类的创建和继承，列举一下你所知道的继承方式" class="headerlink" title="47.说一下类的创建和继承，列举一下你所知道的继承方式"></a>47.说一下类的创建和继承，列举一下你所知道的继承方式</h4><p>在 JavaScript 中，类的创建和继承是面向对象编程的重要概念。ES6引入了<code>class</code>关键字用于创建类和继承关系，而继承可以通过<code>extends</code>关键字实现。</p>
<p><strong>类的创建：</strong> 在ES6中，可以使用<code>class</code>关键字来定义一个类，类是一个模板，描述了一类对象的共同属性和方法。类中使用<code>constructor</code>方法来定义类的构造函数，其他方法则直接定义在类的原型上。</p>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">  constructor(name, species) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.species = species;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  speak() &#123;</span><br><span class="line">    console.log(this.name + &#x27; makes a sound&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const dog = new Animal(&#x27;Buddy&#x27;, &#x27;Dog&#x27;);</span><br><span class="line">dog.speak(); // Output: Buddy makes a sound</span><br></pre></td></tr></table></figure>

<p><strong>继承：</strong> 继承是一种创建类之间关系的方式，使得一个类可以从另一个类继承属性和方法。在ES6中，可以使用<code>extends</code>关键字来实现继承，子类通过<code>extends</code>关键字继承父类的属性和方法，并可以在子类中添加新的属性和方法，或者覆盖父类的方法。</p>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">  constructor(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  speak() &#123;</span><br><span class="line">    console.log(this.name + &#x27; makes a sound&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dog extends Animal &#123;</span><br><span class="line">  constructor(name, breed) &#123;</span><br><span class="line">    super(name); // 调用父类的构造函数</span><br><span class="line">    this.breed = breed;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  bark() &#123;</span><br><span class="line">    console.log(this.name + &#x27; barks&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const dog = new Dog(&#x27;Buddy&#x27;, &#x27;Golden Retriever&#x27;);</span><br><span class="line">dog.speak(); // Output: Buddy makes a sound</span><br><span class="line">dog.bark(); // Output: Buddy barks</span><br></pre></td></tr></table></figure>

<p>以上就是使用ES6中的<code>class</code>和<code>extends</code>关键字创建类和实现继承的方式。除此之外，JavaScript还有其他几种继承方式：</p>
<ol>
<li><strong>原型链继承：</strong> 使用原型链来实现继承，子类的原型对象指向父类的实例，从而继承父类的属性和方法。</li>
<li><strong>构造函数继承：</strong> 在子类的构造函数中使用<code>Parent.call(this, ...)</code>调用父类的构造函数，实现继承父类的属性。</li>
<li><strong>组合继承：</strong> 结合原型链继承和构造函数继承，通过原型链继承父类的方法，通过构造函数继承父类的属性。</li>
<li><strong>原型式继承：</strong> 利用一个中间对象作为桥梁，将父类的原型对象赋值给子类的原型对象，实现继承。</li>
<li><strong>寄生式继承：</strong> 在原型式继承的基础上，增强了新的方法或属性，返回一个新的对象。</li>
<li><strong>寄生组合式继承：</strong> 使用寄生式继承来继承父类的原型对象，并修正子类的构造函数指向。</li>
</ol>
<p>其中，ES6的<code>class</code>和<code>extends</code>关键字是最常用和推荐的继承方式，因为它们提供了更简洁、易读的语法来定义类和继承关系。</p>
<h4 id="48-如何解决异步回调地狱"><a href="#48-如何解决异步回调地狱" class="headerlink" title="48.如何解决异步回调地狱"></a>48.如何解决异步回调地狱</h4><p>异步回调地狱是指在 JavaScript 中，多个异步操作嵌套在彼此之中，导致代码结构混乱、难以理解和维护的情况。为了解决异步回调地狱，可以采用以下几种方法：</p>
<ol>
<li><strong>使用 Promise：</strong> Promise 是 JavaScript 中的一种处理异步操作的方式，它可以避免回调地狱，使得异步操作可以更加简洁和可读。通过 Promise，可以链式调用多个异步操作，使用<code>.then()</code>和<code>.catch()</code>方法处理异步操作的结果和错误。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">asyncFunction1()</span><br><span class="line">  .then(result1 =&gt; &#123;</span><br><span class="line">    // 处理结果</span><br><span class="line">    return asyncFunction2();</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(result2 =&gt; &#123;</span><br><span class="line">    // 处理结果</span><br><span class="line">    return asyncFunction3();</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(result3 =&gt; &#123;</span><br><span class="line">    // 处理结果</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(error =&gt; &#123;</span><br><span class="line">    // 处理错误</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>使用 async&#x2F;await：</strong> async&#x2F;await 是 ES2017 中引入的语法糖，用于简化 Promise 的使用，使得异步操作可以更像同步操作一样的写法。通过 async&#x2F;await，可以以同步的方式编写异步代码，避免了回调地狱。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">async function asyncOperation() &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    const result1 = await asyncFunction1();</span><br><span class="line">    // 处理结果</span><br><span class="line">    const result2 = await asyncFunction2();</span><br><span class="line">    // 处理结果</span><br><span class="line">    const result3 = await asyncFunction3();</span><br><span class="line">    // 处理结果</span><br><span class="line">  &#125; catch (error) &#123;</span><br><span class="line">    // 处理错误</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>使用第三方库或工具：</strong> 有一些第三方库或工具可以帮助简化异步代码的编写，比如 <code>async.js</code>、<code>q</code>、<code>bluebird</code> 等。这些库提供了更多的功能和方法，使得异步操作可以更加灵活和易于管理。</li>
<li><strong>模块化和拆分：</strong> 将复杂的异步操作拆分成多个独立的函数或模块，使得代码结构更清晰，每个函数只负责一个特定的异步操作，可以减少回调地狱的问题。</li>
<li><strong>使用 Generator：</strong> Generator 是 ES2015 中引入的一种迭代器，它可以用于控制异步操作的流程，也可以减少回调地狱。不过，使用 Generator 需要更多的学习和理解，相比 Promise 和 async&#x2F;await，使用场景相对较少。</li>
</ol>
<p>以上方法都可以有效地解决异步回调地狱的问题，具体使用哪种方式取决于项目的需求和开发团队的技术栈。Promise 和 async&#x2F;await 是目前最常用的解决方案，它们可以显著提高代码的可读性和可维护性，使得异步操作更加优雅和简洁。</p>
<h4 id="49-说一下图片的懒加载和预加载"><a href="#49-说一下图片的懒加载和预加载" class="headerlink" title="49.说一下图片的懒加载和预加载"></a>49.说一下图片的懒加载和预加载</h4><p>图片的懒加载和预加载是优化网页性能的常用技术，它们都是针对图片加载进行的优化处理。</p>
<p><strong>图片的懒加载：</strong> 图片的懒加载是指延迟加载图片，只有当图片进入用户的可视区域时才开始加载。通常情况下，网页中的图片都是在页面加载时同时请求加载的，如果页面中有很多图片或图片较大，会导致页面加载速度变慢，影响用户体验。通过图片的懒加载，可以避免一次性加载过多图片，节省带宽和加载时间。</p>
<p>实现图片懒加载的方式有很多种，常见的方法包括：</p>
<ol>
<li>使用 Intersection Observer API：该 API 可以监听元素进入视口或离开视口的状态，当图片进入视口时，再进行图片的加载。</li>
<li>自定义 JavaScript 实现：可以通过监听滚动事件，判断图片是否进入视口，再进行图片的加载。</li>
<li>使用第三方库：很多 JavaScript 懒加载的第三方库可以帮助实现图片懒加载，比如 <code>LazyLoad</code>、<code>lozad.js</code> 等。</li>
</ol>
<p><strong>图片的预加载：</strong> 图片的预加载是指提前加载图片，在用户需要查看图片时可以更快地呈现图片，提高用户体验。预加载通常用于图片轮播、相册等场景，保证用户在切换图片时不会看到加载的过程。</p>
<p>实现图片预加载的方式有以下几种：</p>
<ol>
<li>使用 JavaScript 的 Image 对象：可以通过创建 Image 对象，并设置图片的 <code>src</code> 属性来实现预加载。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">econst image = new Image();</span><br><span class="line">image.src = &#x27;image.jpg&#x27;;</span><br><span class="line">image.onload = () =&gt; &#123;</span><br><span class="line">  // 图片加载完成后的操作</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol>
<li>在 HTML 中使用 <code>link</code> 元素：可以在页面的 <code>head</code> 部分添加 <code>link</code> 元素，通过设置 <code>rel</code> 属性为 <code>preload</code>，并指定图片的 URL，来实现预加载。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;link rel=&quot;preload&quot; as=&quot;image&quot; href=&quot;image.jpg&quot;&gt;</span><br><span class="line">&lt;/head&gt;</span><br></pre></td></tr></table></figure>

<ol>
<li>使用 CSS 的 <code>background-image</code> 属性：可以使用 CSS 来预加载图片，将图片设置为元素的背景图片，然后隐藏该元素。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.preload-image &#123;</span><br><span class="line">  background-image: url(&#x27;image.jpg&#x27;);</span><br><span class="line">  width: 0;</span><br><span class="line">  height: 0;</span><br><span class="line">  visibility: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上就是图片的懒加载和预加载的简要介绍和实现方式。这两种技术可以很好地优化图片加载，提高网页的性能和用户体验。在实际开发中，可以根据项目需求选择适合的方案来实现图片的懒加载和预加载。</p>
<h4 id="50-mouseover和mouseenter的区别"><a href="#50-mouseover和mouseenter的区别" class="headerlink" title="50.mouseover和mouseenter的区别"></a>50.mouseover和mouseenter的区别</h4><p><code>mouseover</code> 和 <code>mouseenter</code> 是 JavaScript 中常用的鼠标事件，它们在触发时有一些区别。</p>
<p><strong><code>mouseover</code> 事件：</strong> <code>mouseover</code> 事件在鼠标指针进入元素或元素的子元素时触发。当鼠标指针从一个元素移动到其子元素上时，也会触发 <code>mouseover</code> 事件。这意味着，如果一个元素有嵌套的子元素，当鼠标从父元素进入子元素时，会触发两次 <code>mouseover</code> 事件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">element.addEventListener(&#x27;mouseover&#x27;, function(event) &#123;</span><br><span class="line">  // 鼠标指针进入元素时触发</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong><code>mouseenter</code> 事件：</strong> <code>mouseenter</code> 事件在鼠标指针进入元素时触发，但不会在进入元素的子元素时触发。它只会在鼠标进入元素的边界时触发一次，而不管鼠标是否进入元素的子元素。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">element.addEventListener(&#x27;mouseenter&#x27;, function(event) &#123;</span><br><span class="line">  // 鼠标指针进入元素时触发，不会在进入子元素时触发</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>综上所述，<code>mouseover</code> 事件会在鼠标进入元素及其子元素时触发，而 <code>mouseenter</code> 事件只会在鼠标进入元素的边界时触发，不会在进入子元素时触发。因此，如果需要在鼠标进入元素时触发一次事件而不受子元素影响，可以使用 <code>mouseenter</code> 事件。如果需要在鼠标进入元素及其子元素时触发事件，可以使用 <code>mouseover</code> 事件。</p>
<h4 id="51-new操作符做了哪些事情"><a href="#51-new操作符做了哪些事情" class="headerlink" title="51.new操作符做了哪些事情"></a>51.new操作符做了哪些事情</h4><p><code>new</code> 操作符是 JavaScript 中用于创建对象实例的关键字，它做了以下几个主要的事情：</p>
<ol>
<li><strong>创建一个空对象：</strong> 在执行 <code>new</code> 操作符时，会创建一个新的空对象，这个对象即将成为实例对象。</li>
<li><strong>将构造函数的作用域赋给新对象：</strong> 将构造函数中的 <code>this</code> 指向新创建的空对象，使得构造函数中的属性和方法可以在新对象上访问和操作。</li>
<li><strong>执行构造函数的代码：</strong> 将新对象作为 <code>this</code>，执行构造函数中的代码，初始化实例对象的属性。</li>
<li><strong>返回新对象：</strong> 如果构造函数中没有返回其他对象，那么 <code>new</code> 操作符会返回新创建的对象作为实例。</li>
</ol>
<p>简化的示例代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Person(name, age) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const person1 = new Person(&#x27;Alice&#x27;, 30);</span><br><span class="line">console.log(person1); // Output: Person &#123; name: &#x27;Alice&#x27;, age: 30 &#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，使用 <code>new</code> 操作符创建了一个 <code>Person</code> 类的实例 <code>person1</code>，<code>new</code> 操作符在后台做了以上的四个步骤：</p>
<ol>
<li>创建了一个空对象 <code>person1</code>。</li>
<li>将 <code>Person</code> 构造函数中的 <code>this</code> 指向 <code>person1</code>，使得 <code>name</code> 和 <code>age</code> 属性可以添加到 <code>person1</code> 对象上。</li>
<li>执行 <code>Person</code> 构造函数中的代码，设置 <code>person1</code> 的属性。</li>
<li>返回 <code>person1</code> 作为实例。</li>
</ol>
<p>需要注意的是，如果构造函数中有返回其他对象，那么 <code>new</code> 操作符会返回该对象，而不是新创建的实例对象。示例代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Person(name, age) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.age = age;</span><br><span class="line">  return &#123; greeting: &#x27;Hello&#x27; &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const person1 = new Person(&#x27;Alice&#x27;, 30);</span><br><span class="line">console.log(person1); // Output: &#123; greeting: &#x27;Hello&#x27; &#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>Person</code> 构造函数中返回了一个对象 <code>&#123; greeting: &#39;Hello&#39; &#125;</code>，因此 <code>new</code> 操作符返回了该对象，而不是 <code>Person</code> 类的实例。</p>
<h4 id="52-改变函数内部this指针的指向函数-bind-apply-call-的区别-，内在分别是如何实现的"><a href="#52-改变函数内部this指针的指向函数-bind-apply-call-的区别-，内在分别是如何实现的" class="headerlink" title="52.改变函数内部this指针的指向函数(bind, apply, call 的区别)，内在分别是如何实现的?"></a>52.改变函数内部this指针的指向函数(bind, apply, call 的区别)，内在分别是如何实现的?</h4><p>在 JavaScript 中，可以使用 <code>bind</code>、<code>apply</code> 和 <code>call</code> 来改变函数内部的 <code>this</code> 指向。它们的作用都是为了在调用函数时明确指定函数内部的 <code>this</code> 的值，并且可以传递参数给函数。</p>
<p><strong>bind 方法：</strong> <code>bind</code> 方法会创建一个新的函数，并将原函数绑定到指定的对象上，返回一个新函数。新函数的 <code>this</code> 指向会被绑定到指定的对象，而不会被调用的位置决定。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const person = &#123;</span><br><span class="line">  name: &#x27;Alice&#x27;,</span><br><span class="line">  sayHello: function() &#123;</span><br><span class="line">    console.log(`Hello, $&#123;this.name&#125;`);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const greet = person.sayHello.bind(person);</span><br><span class="line">greet(); // Output: Hello, Alice</span><br></pre></td></tr></table></figure>

<p><strong>apply 和 call 方法：</strong> <code>apply</code> 和 <code>call</code> 方法的作用相似，都是用于改变函数的 <code>this</code> 指向，并立即执行函数。它们的区别在于传递参数的方式：</p>
<ul>
<li><code>apply</code> 方法接收两个参数：一个是要绑定的对象，另一个是一个数组或类数组对象，用于作为参数传递给函数。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const person = &#123;</span><br><span class="line">  name: &#x27;Alice&#x27;,</span><br><span class="line">  sayHello: function(greeting) &#123;</span><br><span class="line">    console.log(`$&#123;greeting&#125;, $&#123;this.name&#125;`);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">person.sayHello.apply(person, [&#x27;Hi&#x27;]); // Output: Hi, Alice</span><br></pre></td></tr></table></figure>

<ul>
<li><code>call</code> 方法接收的参数和 <code>apply</code> 方法一样，但是是逐个传递而不是数组。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const person = &#123;</span><br><span class="line">  name: &#x27;Alice&#x27;,</span><br><span class="line">  sayHello: function(greeting) &#123;</span><br><span class="line">    console.log(`$&#123;greeting&#125;, $&#123;this.name&#125;`);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">person.sayHello.call(person, &#x27;Hello&#x27;); // Output: Hello, Alice</span><br></pre></td></tr></table></figure>

<p><strong>内部实现：</strong> 这些方法的实现原理可以通过 JavaScript 的函数原型对象来理解。在每个函数对象上，都有 <code>bind</code>、<code>apply</code> 和 <code>call</code> 这三个方法。这些方法在被调用时，会改变函数内部的 <code>this</code> 指向，并在指定的上下文中执行函数。</p>
<ul>
<li><code>bind</code> 方法创建一个新函数，并返回这个新函数。新函数内部会调用原函数，并在其中使用指定的对象作为 <code>this</code> 指向。</li>
<li><code>apply</code> 方法和 <code>call</code> 方法在被调用时立即执行函数，并在执行函数时指定函数内部的 <code>this</code> 指向。它们通过传递指定的对象来改变函数内部的 <code>this</code> 指向，同时可以传递其他参数给函数。</li>
</ul>
<p>实现 <code>bind</code> 方法的简化示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Function.prototype.myBind = function(context) &#123;</span><br><span class="line">  const fn = this;</span><br><span class="line">  return function(...args) &#123;</span><br><span class="line">    return fn.apply(context, args);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>通过以上的自定义 <code>myBind</code> 方法，可以实现类似 <code>bind</code> 的功能。类似地，也可以实现 <code>apply</code> 和 <code>call</code> 方法的自定义版本。但是要注意，在实际开发中，通常直接使用 JavaScript 内置的 <code>bind</code>、<code>apply</code> 和 <code>call</code> 方法就可以满足大多数需求。</p>
<h4 id="53-JS的各种位置-比如clientHeight-scrollHeight-offsetHeight-以及scrollTop-offsetTop-clientTop的区别"><a href="#53-JS的各种位置-比如clientHeight-scrollHeight-offsetHeight-以及scrollTop-offsetTop-clientTop的区别" class="headerlink" title="53.JS的各种位置,比如clientHeight, scrollHeight, offsetHeight ,以及scrollTop,offsetTop, clientTop的区别?"></a>53.JS的各种位置,比如clientHeight, scrollHeight, offsetHeight ,以及scrollTop,offsetTop, clientTop的区别?</h4><p>这些属性是用于获取和设置元素在页面中的位置和尺寸的相关信息。它们之间的区别如下：</p>
<ol>
<li><strong>clientHeight：</strong><ul>
<li>获取元素可见区域的高度，包括内容区和内边距，但不包括边框和滚动条。</li>
<li>不包括元素的外边距和边框。</li>
<li>对于行内元素和空元素，<code>clientHeight</code> 始终为0。</li>
</ul>
</li>
<li><strong>scrollHeight：</strong><ul>
<li>获取元素内容区的实际高度，包括可见区域和溢出隐藏部分的内容。</li>
<li>不包括元素的内边距、边框和外边距。</li>
<li>如果元素的内容没有溢出，<code>scrollHeight</code> 等于 <code>clientHeight</code>。</li>
</ul>
</li>
<li><strong>offsetHeight：</strong><ul>
<li>获取元素在页面中占据的总高度，包括内容区、内边距、边框和滚动条（如果有）。</li>
<li>不包括元素的外边距。</li>
</ul>
</li>
<li><strong>scrollTop：</strong><ul>
<li>获取或设置元素内容区域滚动条的垂直偏移量，表示元素内容向上滚动的距离。</li>
</ul>
</li>
<li><strong>offsetTop：</strong><ul>
<li>获取元素的上边缘相对于视口顶部的距离，即元素在文档流中的位置。</li>
</ul>
</li>
<li><strong>clientTop：</strong><ul>
<li>获取元素的上边框宽度。</li>
</ul>
</li>
</ol>
<p>总结一下：</p>
<ul>
<li><code>clientHeight</code>：元素内容区的可见高度，包括内边距，不包括滚动条和边框。</li>
<li><code>scrollHeight</code>：元素内容区的实际高度，包括内边距和溢出隐藏的内容。</li>
<li><code>offsetHeight</code>：元素在页面中占据的总高度，包括内容区、内边距、边框和滚动条（如果有）。</li>
<li><code>scrollTop</code>：元素内容区的垂直滚动偏移量。</li>
<li><code>offsetTop</code>：元素的上边缘相对于视口顶部的距离。</li>
<li><code>clientTop</code>：元素上边框的宽度。</li>
</ul>
<p>这些属性在测量和操作元素的位置和尺寸时非常有用，在进行布局和滚动等操作时经常会用到。需要注意的是，这些属性的值可能受到元素的样式和父元素的影响，因此在使用时应该谨慎考虑可能的影响。</p>
<h4 id="54-异步加载JS的方法"><a href="#54-异步加载JS的方法" class="headerlink" title="54.异步加载JS的方法"></a>54.异步加载JS的方法</h4><p>异步加载 JavaScript 是一种优化网页性能的常见方法，它可以在页面加载时并行加载 JavaScript 文件，避免阻塞页面的渲染和交互。以下是几种异步加载 JavaScript 的方法：</p>
<ol>
<li><p><strong>使用 async 属性：</strong> 使用 <code>&lt;script&gt;</code> 标签并设置 <code>async</code> 属性，浏览器会异步加载并执行脚本，不会阻塞页面的渲染。当脚本加载完成后，会立即执行，但不会保证执行顺序。适用于独立的、不依赖其他脚本的情况。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script src=&quot;your-script.js&quot; async&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用 defer 属性：</strong> 使用 <code>&lt;script&gt;</code> 标签并设置 <code>defer</code> 属性，浏览器会异步加载脚本，但会等到整个文档解析完毕后再执行。多个带有 <code>defer</code> 属性的脚本会按照它们在文档中的顺序依次执行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script src=&quot;your-script.js&quot; defer&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>动态创建 script 标签：</strong> 使用 JavaScript 动态创建 <code>&lt;script&gt;</code> 标签，并设置其 <code>src</code> 属性，然后将标签插入到页面中。这样脚本会异步加载，不会阻塞页面渲染。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const script = document.createElement(&#x27;script&#x27;);</span><br><span class="line">script.src = &#x27;your-script.js&#x27;;</span><br><span class="line">document.body.appendChild(script);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用模块化加载：</strong> 使用模块化加载工具如 <code>import</code>、<code>require</code>，或使用 ES6 的模块化语法 <code>import</code> 来导入需要的模块。这样可以实现异步加载，并根据需要动态加载模块。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// CommonJS</span><br><span class="line">const module = require(&#x27;./your-module&#x27;);</span><br><span class="line"></span><br><span class="line">// ES6</span><br><span class="line">import module from &#x27;./your-module&#x27;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用异步加载库：</strong> 可以使用一些异步加载库或模块加载器，如 RequireJS、SystemJS、Webpack 等，来管理和加载 JavaScript 文件，实现按需加载和异步加载的控制。</p>
</li>
</ol>
<p>以上方法中，<code>async</code> 和 <code>defer</code> 属性主要用于在 HTML 中进行异步加载，而动态创建 <code>&lt;script&gt;</code> 标签和模块化加载方法更灵活，可以在 JavaScript 中根据条件和需要进行动态加载。选择适合项目需求和场景的方法可以提高网页性能和用户体验。</p>
<h4 id="55-Ajax-解决浏览器缓存问题"><a href="#55-Ajax-解决浏览器缓存问题" class="headerlink" title="55.Ajax 解决浏览器缓存问题"></a>55.Ajax 解决浏览器缓存问题</h4><p>在使用 Ajax 请求数据时，有时会遇到浏览器缓存的问题，导致请求返回的数据并不是最新的。为了解决这个问题，可以采取以下几种方法：</p>
<ol>
<li><p><strong>添加随机参数：</strong> 在每次发送 Ajax 请求时，可以在请求的 URL 后面添加一个随机参数，确保每次请求都是唯一的，从而避免浏览器缓存。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy code</span><br><span class="line">const url = &#x27;your-api-url?&#x27; + Date.now();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用时间戳：</strong> 类似于添加随机参数，可以将当前时间戳添加到请求的 URL 中，保证每次请求都是不同的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy code</span><br><span class="line">const url = &#x27;your-api-url?&#x27; + new Date().getTime();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>禁用缓存：</strong> 在请求的请求头中添加禁用缓存的字段，通常使用 <code>Cache-Control</code> 或 <code>Pragma</code> 来禁用缓存。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy codeconst xhr = new XMLHttpRequest();</span><br><span class="line">xhr.open(&#x27;GET&#x27;, &#x27;your-api-url&#x27;, true);</span><br><span class="line">xhr.setRequestHeader(&#x27;Cache-Control&#x27;, &#x27;no-cache&#x27;);</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>修改请求方式：</strong> 将原来的 GET 请求改为 POST 请求，或者在 URL 中添加参数，确保每次请求的 URL 不同。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy codeconst xhr = new XMLHttpRequest();</span><br><span class="line">xhr.open(&#x27;POST&#x27;, &#x27;your-api-url&#x27;, true);</span><br><span class="line">xhr.send(&#x27;data=&#x27; + Date.now());</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用 Fetch API：</strong> 在使用 Fetch API 进行数据请求时，默认会忽略浏览器缓存，因此可以直接使用 Fetch API 来解决缓存问题。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy codefetch(&#x27;your-api-url&#x27;)</span><br><span class="line">  .then(response =&gt; response.json())</span><br><span class="line">  .then(data =&gt; &#123;</span><br><span class="line">    // 处理返回的数据</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(error =&gt; &#123;</span><br><span class="line">    // 处理错误</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure></li>
</ol>
<p>通过以上方法，可以有效地解决浏览器缓存问题，确保每次请求都能得到最新的数据。选择适合项目需求的方法可以提高数据的准确性和用户体验。</p>
<h4 id="56-节流和防抖"><a href="#56-节流和防抖" class="headerlink" title="56.节流和防抖"></a>56.节流和防抖</h4><p>节流（Throttle）和防抖（Debounce）都是用于控制事件触发频率的技术，常用于优化性能和减少资源消耗。它们的作用是避免某些事件触发过于频繁而导致性能问题。</p>
<p><strong>节流（Throttle）：</strong> 节流是指在一段时间内只执行一次特定的操作，无论事件触发多少次。在这段时间内，如果事件再次触发，将被忽略，直到该时间段过去。节流可以保证特定操作在指定时间内只执行一次。</p>
<p>常见场景：用户频繁滚动页面，但我们只需要在用户停止滚动时执行某个操作，而不是在每次滚动时都执行。</p>
<p><strong>防抖（Debounce）：</strong> 防抖是指在事件触发后等待一段时间后再执行特定的操作。如果在等待时间内再次触发事件，那么计时会重置，等待新的一段时间。防抖可以保证特定操作只在最后一次事件触发后执行。</p>
<p>常见场景：用户在输入框中输入内容，我们希望在用户停止输入一段时间后再执行搜索操作，而不是在每次输入时都立即执行搜索。</p>
<p>下面是节流和防抖的实现示例：</p>
<p><strong>节流（Throttle）的实现：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function throttle(func, delay) &#123;</span><br><span class="line">  let lastTime = 0;</span><br><span class="line">  return function(...args) &#123;</span><br><span class="line">    const now = Date.now();</span><br><span class="line">    if (now - lastTime &gt;= delay) &#123;</span><br><span class="line">      func.apply(this, args);</span><br><span class="line">      lastTime = now;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用示例</span><br><span class="line">const throttledFunction = throttle(() =&gt; &#123;</span><br><span class="line">  console.log(&#x27;Throttle example&#x27;);</span><br><span class="line">&#125;, 1000);</span><br><span class="line"></span><br><span class="line">window.addEventListener(&#x27;scroll&#x27;, throttledFunction);</span><br></pre></td></tr></table></figure>

<p><strong>防抖（Debounce）的实现：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function debounce(func, delay) &#123;</span><br><span class="line">  let timerId;</span><br><span class="line">  return function(...args) &#123;</span><br><span class="line">    clearTimeout(timerId);</span><br><span class="line">    timerId = setTimeout(() =&gt; &#123;</span><br><span class="line">      func.apply(this, args);</span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用示例</span><br><span class="line">const debouncedFunction = debounce(() =&gt; &#123;</span><br><span class="line">  console.log(&#x27;Debounce example&#x27;);</span><br><span class="line">&#125;, 1000);</span><br><span class="line"></span><br><span class="line">window.addEventListener(&#x27;input&#x27;, debouncedFunction);</span><br></pre></td></tr></table></figure>

<p>根据实际需求，选择适合的节流或防抖策略可以提高性能和用户体验。</p>
<h4 id="57-eval-是做什么的"><a href="#57-eval-是做什么的" class="headerlink" title="57.eval 是做什么的"></a>57.eval 是做什么的</h4><p><code>eval()</code> 是 JavaScript 中的一个全局函数，其作用是将传入的字符串作为 JavaScript 代码进行解析和执行。它的语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eval(string)</span><br></pre></td></tr></table></figure>

<p>其中，<code>string</code> 是要执行的 JavaScript 代码的字符串表示。<code>eval()</code> 函数会将传入的字符串作为动态的 JavaScript 代码，在运行时将其解析为实际的 JavaScript 代码并执行。</p>
<p><strong>注意：</strong> 由于 <code>eval()</code> 可以执行任意传入的代码，包括用户输入的内容，因此在使用 <code>eval()</code> 时要格外小心。不当使用 <code>eval()</code> 可能导致安全漏洞和不可预测的行为，因此不推荐在生产环境中使用 <code>eval()</code>。通常情况下，可以使用其他更安全的方法来实现相同的功能，例如使用 JSON.parse() 解析 JSON 数据，使用 Function 构造函数来动态创建函数等。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 不推荐的使用方式</span><br><span class="line">const x = 10;</span><br><span class="line">const y = 20;</span><br><span class="line">const code = &#x27;console.log(x + y)&#x27;;</span><br><span class="line">eval(code); // Output: 30</span><br><span class="line"></span><br><span class="line">// 推荐使用方式</span><br><span class="line">const x = 10;</span><br><span class="line">const y = 20;</span><br><span class="line">const code = new Function(&#x27;x&#x27;, &#x27;y&#x27;, &#x27;console.log(x + y)&#x27;);</span><br><span class="line">code(x, y); // Output: 30</span><br></pre></td></tr></table></figure>

<p>总之，<code>eval()</code> 函数是一个功能强大但也非常危险的函数，应该谨慎使用，特别是在处理不可信的数据时要避免使用它。</p>
<h4 id="58-对象深拷贝的简单实现"><a href="#58-对象深拷贝的简单实现" class="headerlink" title="58.对象深拷贝的简单实现"></a>58.对象深拷贝的简单实现</h4><p>对象的深拷贝是指创建一个新的对象，并且将原始对象中的所有属性和属性值都复制到新对象中，而且如果原始对象的属性值是引用类型（如对象或数组），则还需要对这些引用类型进行递归拷贝，确保新对象与原始对象完全独立，互不影响。以下是一个简单的实现深拷贝的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function deepClone(obj) &#123;</span><br><span class="line">  if (obj === null || typeof obj !== &#x27;object&#x27;) &#123;</span><br><span class="line">    return obj;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  let clone = Array.isArray(obj) ? [] : &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  for (let key in obj) &#123;</span><br><span class="line">    if (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">      clone[key] = deepClone(obj[key]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return clone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用该函数进行深拷贝：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const originalObj = &#123;</span><br><span class="line">  name: &#x27;John&#x27;,</span><br><span class="line">  age: 30,</span><br><span class="line">  address: &#123;</span><br><span class="line">    city: &#x27;New York&#x27;,</span><br><span class="line">    country: &#x27;USA&#x27;</span><br><span class="line">  &#125;,</span><br><span class="line">  hobbies: [&#x27;reading&#x27;, &#x27;swimming&#x27;]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const clonedObj = deepClone(originalObj);</span><br><span class="line"></span><br><span class="line">console.log(clonedObj);</span><br></pre></td></tr></table></figure>

<p>上述代码中的 <code>deepClone</code> 函数通过递归地遍历对象的属性，并将每个属性的值复制到新的对象中，确保了原始对象与克隆对象之间的完全独立性。这样做可以确保在对克隆对象进行修改时不会影响到原始对象。</p>
<h4 id="59-实现JS中所有对象的深度克隆-包装对象，-Date-对象，正则对象"><a href="#59-实现JS中所有对象的深度克隆-包装对象，-Date-对象，正则对象" class="headerlink" title="59.实现JS中所有对象的深度克隆(包装对象， Date 对象，正则对象)"></a>59.实现JS中所有对象的深度克隆(包装对象， Date 对象，正则对象)</h4><p>要实现 JS 中所有对象的深度克隆，我们需要处理各种不同类型的对象，包括基本数据类型、引用类型、Date 对象、正则对象等。以下是一个能够实现深度克隆所有对象的函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function deepClone(obj, hash = new WeakMap()) &#123;</span><br><span class="line">  if (obj === null || typeof obj !== &#x27;object&#x27;) &#123;</span><br><span class="line">    return obj;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (hash.has(obj)) &#123;</span><br><span class="line">    return hash.get(obj);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  let clone;</span><br><span class="line"></span><br><span class="line">  if (obj instanceof Date) &#123;</span><br><span class="line">    clone = new Date(obj.getTime());</span><br><span class="line">  &#125; else if (obj instanceof RegExp) &#123;</span><br><span class="line">    clone = new RegExp(obj);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    clone = Array.isArray(obj) ? [] : &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  hash.set(obj, clone);</span><br><span class="line"></span><br><span class="line">  for (let key in obj) &#123;</span><br><span class="line">    if (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">      clone[key] = deepClone(obj[key], hash);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return clone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用该函数进行深度克隆：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const originalObj = &#123;</span><br><span class="line">  name: &#x27;John&#x27;,</span><br><span class="line">  age: 30,</span><br><span class="line">  date: new Date(),</span><br><span class="line">  regExp: /abc/g,</span><br><span class="line">  address: &#123;</span><br><span class="line">    city: &#x27;New York&#x27;,</span><br><span class="line">    country: &#x27;USA&#x27;</span><br><span class="line">  &#125;,</span><br><span class="line">  hobbies: [&#x27;reading&#x27;, &#x27;swimming&#x27;]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const clonedObj = deepClone(originalObj);</span><br><span class="line"></span><br><span class="line">console.log(clonedObj);</span><br></pre></td></tr></table></figure>

<p>该函数使用了一个 <code>WeakMap</code> 对象来记录已经克隆过的对象，避免对同一个对象重复进行深度克隆，确保克隆后的对象中不包含循环引用。同时，对于 Date 对象和 RegExp 对象，分别进行了特殊处理，以确保它们的克隆也是正确的。</p>
<p>请注意，该函数处理了大多数常见的数据类型，但并不是对所有情况都适用。在实际应用中，还需要根据具体的需求进一步优化和扩展。</p>
<h4 id="60-实现一个once函数，传入函数参数只执行一次"><a href="#60-实现一个once函数，传入函数参数只执行一次" class="headerlink" title="60.实现一个once函数，传入函数参数只执行一次"></a>60.实现一个once函数，传入函数参数只执行一次</h4><p>可以实现一个 <code>once</code> 函数，使得传入的函数参数只执行一次。我们可以通过一个闭包来实现该功能，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function once(fn) &#123;</span><br><span class="line">  let executed = false;</span><br><span class="line">  let result;</span><br><span class="line"></span><br><span class="line">  return function (...args) &#123;</span><br><span class="line">    if (!executed) &#123;</span><br><span class="line">      executed = true;</span><br><span class="line">      result = fn.apply(this, args);</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 <code>once</code> 函数，可以确保传入的函数参数只执行一次：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function showMessage() &#123;</span><br><span class="line">  console.log(&#x27;Hello, this message will only show once!&#x27;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const showOnce = once(showMessage);</span><br><span class="line"></span><br><span class="line">showOnce(); // Output: Hello, this message will only show once!</span><br><span class="line">showOnce(); // No output, the function won&#x27;t execute again</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，<code>once</code> 函数接受一个函数 <code>fn</code> 作为参数，并返回一个新的函数。每次调用新返回的函数时，它会检查 <code>executed</code> 变量是否为 <code>false</code>，如果是，则执行原始的函数 <code>fn</code> 并将 <code>executed</code> 设置为 <code>true</code>，这样保证了原始函数只会执行一次。如果多次调用新函数，则不会再执行原始的函数，而是直接返回之前执行过的结果。这样就实现了传入函数参数只执行一次的功能。</p>
<h4 id="61-将原生的ajax封装成promise"><a href="#61-将原生的ajax封装成promise" class="headerlink" title="61.将原生的ajax封装成promise"></a>61.将原生的ajax封装成promise</h4><p>可以将原生的 Ajax 请求封装成 Promise，使得在进行异步请求时更加便捷和符合现代 JavaScript 的异步处理方式。下面是一个简单的封装示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function ajax(url, method = &#x27;GET&#x27;, data = null) &#123;</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    const xhr = new XMLHttpRequest();</span><br><span class="line"></span><br><span class="line">    xhr.open(method, url);</span><br><span class="line"></span><br><span class="line">    xhr.onload = function () &#123;</span><br><span class="line">      if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) &#123;</span><br><span class="line">        resolve(xhr.responseText);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        reject(new Error(xhr.statusText));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    xhr.onerror = function () &#123;</span><br><span class="line">      reject(new Error(&#x27;Network error&#x27;));</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    xhr.send(data);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用封装后的函数进行 Ajax 请求：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const url = &#x27;https://api.example.com/data&#x27;;</span><br><span class="line"></span><br><span class="line">ajax(url)</span><br><span class="line">  .then(response =&gt; &#123;</span><br><span class="line">    console.log(&#x27;Success:&#x27;, response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(error =&gt; &#123;</span><br><span class="line">    console.error(&#x27;Error:&#x27;, error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>在封装函数中，我们创建了一个新的 Promise，并在 Promise 的 executor 函数中执行原生的 Ajax 请求。当请求成功时，我们调用 <code>resolve</code> 并传递响应数据；当请求失败时，我们调用 <code>reject</code> 并传递错误信息。这样，在调用封装后的函数时，我们可以通过 <code>.then()</code> 处理成功的回调，通过 <code>.catch()</code> 处理错误的回调，实现更加清晰和简洁的异步代码。</p>
<h4 id="62-JS监听对象属性的改变"><a href="#62-JS监听对象属性的改变" class="headerlink" title="62.JS监听对象属性的改变"></a>62.JS监听对象属性的改变</h4><p>在 JavaScript 中，可以使用对象的 <code>Proxy</code> 来监听对象属性的改变。<code>Proxy</code> 是 ES6 中引入的特性，它可以拦截并自定义对象的各种操作，包括属性的读取、设置、删除等。通过使用 <code>Proxy</code>，我们可以实现对对象属性的监听和响应。</p>
<p>下面是一个使用 <code>Proxy</code> 监听对象属性改变的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const obj = &#123;</span><br><span class="line">  name: &#x27;John&#x27;,</span><br><span class="line">  age: 30</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const handler = &#123;</span><br><span class="line">  set(target, key, value) &#123;</span><br><span class="line">    console.log(`Property $&#123;key&#125; changed from $&#123;target[key]&#125; to $&#123;value&#125;`);</span><br><span class="line">    target[key] = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const proxy = new Proxy(obj, handler);</span><br><span class="line"></span><br><span class="line">proxy.name = &#x27;Jane&#x27;; // Output: Property name changed from John to Jane</span><br><span class="line">proxy.age = 35;      // Output: Property age changed from 30 to 35</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们创建了一个对象 <code>obj</code> 和一个 <code>Proxy</code> 对象 <code>proxy</code>。通过定义一个 <code>handler</code> 对象，并在其中实现 <code>set</code> 方法，我们可以拦截对 <code>proxy</code> 对象的属性赋值操作。当对 <code>proxy</code> 对象的属性进行赋值时，<code>set</code> 方法会被触发，并输出属性改变的信息。</p>
<p>注意：<code>Proxy</code> 不是所有环境都支持，特别是在一些较老的浏览器中可能不支持。在使用 <code>Proxy</code> 时，最好先进行兼容性检查或使用降级方案。如果不需要考虑兼容性问题，<code>Proxy</code> 是一个强大且方便的特性，可以用于实现很多高级功能，包括对象属性的监听和拦截。</p>
<h4 id="63-如何实现一个私有变量，用get可以访问，不能直接访问"><a href="#63-如何实现一个私有变量，用get可以访问，不能直接访问" class="headerlink" title="63.如何实现一个私有变量，用get可以访问，不能直接访问"></a>63.如何实现一个私有变量，用get可以访问，不能直接访问</h4><p>在 JavaScript 中，没有真正的私有变量概念，但可以通过闭包和作用域来模拟私有变量。通过使用闭包，在对象的内部创建一个函数作用域，将需要隐藏的变量放在该函数作用域内，外部无法直接访问，但通过使用 <code>get</code> 方法，可以间接地访问这些变量。</p>
<p>下面是一个示例，演示如何使用闭包实现一个私有变量：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function createObject() &#123;</span><br><span class="line">  let privateVariable = 10; // 私有变量</span><br><span class="line"></span><br><span class="line">  return &#123;</span><br><span class="line">    getPrivateVariable() &#123;</span><br><span class="line">      return privateVariable;</span><br><span class="line">    &#125;,</span><br><span class="line">    setPrivateVariable(value) &#123;</span><br><span class="line">      privateVariable = value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const obj = createObject();</span><br><span class="line"></span><br><span class="line">console.log(obj.getPrivateVariable()); // Output: 10</span><br><span class="line">obj.setPrivateVariable(20);</span><br><span class="line">console.log(obj.getPrivateVariable()); // Output: 20</span><br><span class="line"></span><br><span class="line">// 无法直接访问 privateVariable</span><br><span class="line">console.log(obj.privateVariable); // Output: undefined</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们通过 <code>createObject</code> 函数创建了一个包含私有变量的对象。<code>privateVariable</code> 是一个私有变量，外部无法直接访问，但我们通过在返回的对象中暴露 <code>getPrivateVariable</code> 方法，可以间接地访问和修改 <code>privateVariable</code>。</p>
<p>请注意，这种方式并不是真正意义上的私有变量，因为 JavaScript 中没有真正的私有性。但通过使用闭包和函数作用域，我们可以模拟私有变量，避免直接暴露在全局作用域中，提高代码的封装性和安全性。</p>
<h4 id="64-怎么控制一次加载一张图片，加载完后再加载下一张"><a href="#64-怎么控制一次加载一张图片，加载完后再加载下一张" class="headerlink" title="64.怎么控制一次加载一张图片，加载完后再加载下一张"></a>64.怎么控制一次加载一张图片，加载完后再加载下一张</h4><p>要实现一次加载一张图片，并在加载完成后再加载下一张图片，可以通过递归和事件监听来实现。具体步骤如下：</p>
<ol>
<li>创建一个包含所有图片 URL 的数组。</li>
<li>创建一个加载图片的函数，该函数接受一个图片 URL 作为参数，并返回一个 Promise 对象，用于表示图片加载的状态。</li>
<li>使用递归方式依次加载数组中的每张图片，确保每张图片在上一张图片加载完成后再加载下一张图片。</li>
<li>在图片加载完成时，触发加载下一张图片的操作。</li>
</ol>
<p>以下是示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const imageUrls = [</span><br><span class="line">  &#x27;url1.jpg&#x27;,</span><br><span class="line">  &#x27;url2.jpg&#x27;,</span><br><span class="line">  &#x27;url3.jpg&#x27;,</span><br><span class="line">  // Add more image URLs here...</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">function loadImage(url) &#123;</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    const img = new Image();</span><br><span class="line"></span><br><span class="line">    img.onload = function () &#123;</span><br><span class="line">      resolve(img);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    img.onerror = function () &#123;</span><br><span class="line">      reject(new Error(`Failed to load image: $&#123;url&#125;`));</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    img.src = url;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function loadImagesSequentially(urls) &#123;</span><br><span class="line">  const promises = [];</span><br><span class="line"></span><br><span class="line">  function loadNextImage(index) &#123;</span><br><span class="line">    if (index &gt;= urls.length) &#123;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const url = urls[index];</span><br><span class="line">    const promise = loadImage(url);</span><br><span class="line"></span><br><span class="line">    promises.push(promise);</span><br><span class="line"></span><br><span class="line">    promise.then(() =&gt; &#123;</span><br><span class="line">      // Image loaded successfully, load the next one</span><br><span class="line">      loadNextImage(index + 1);</span><br><span class="line">    &#125;).catch(error =&gt; &#123;</span><br><span class="line">      console.error(error);</span><br><span class="line">      // If an error occurs, we can choose to handle it or continue with the next image</span><br><span class="line">      loadNextImage(index + 1);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Start loading the images sequentially</span><br><span class="line">  loadNextImage(0);</span><br><span class="line"></span><br><span class="line">  // Return a promise that resolves when all images are loaded</span><br><span class="line">  return Promise.all(promises);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">loadImagesSequentially(imageUrls)</span><br><span class="line">  .then(() =&gt; &#123;</span><br><span class="line">    console.log(&#x27;All images loaded successfully!&#x27;);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(error =&gt; &#123;</span><br><span class="line">    console.error(&#x27;Failed to load images:&#x27;, error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，<code>loadImage</code> 函数负责加载单张图片，并返回一个 Promise 对象。<code>loadImagesSequentially</code> 函数负责递归地依次加载所有图片，并确保在每张图片加载完成后再加载下一张图片。最后，使用 <code>Promise.all()</code> 来等待所有图片加载完成。</p>
<p>注意：以上代码仅为示例，实际使用时，需要根据具体的场景和需求进行适当的调整和优化。</p>
<h4 id="65-如何实现sleep的效果-es5-或者es6"><a href="#65-如何实现sleep的效果-es5-或者es6" class="headerlink" title="65.如何实现sleep的效果(es5 或者es6)"></a>65.如何实现sleep的效果(es5 或者es6)</h4><p>在 JavaScript 中实现 <code>sleep</code> 的效果，可以使用 <code>setTimeout</code> 或者 <code>async/await</code> 来模拟等待的效果。下面分别给出 ES5 和 ES6 的实现方式：</p>
<p>ES5（使用 <code>setTimeout</code>）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function sleep(ms) &#123;</span><br><span class="line">  return new Promise(resolve =&gt; setTimeout(resolve, ms));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用示例</span><br><span class="line">console.log(&#x27;Start&#x27;);</span><br><span class="line">sleep(2000).then(() =&gt; &#123;</span><br><span class="line">  console.log(&#x27;After 2 seconds&#x27;);</span><br><span class="line">&#125;);</span><br><span class="line">console.log(&#x27;End&#x27;);</span><br></pre></td></tr></table></figure>

<p>ES6（使用 <code>async/await</code>）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function sleep(ms) &#123;</span><br><span class="line">  return new Promise(resolve =&gt; setTimeout(resolve, ms));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用示例</span><br><span class="line">async function example() &#123;</span><br><span class="line">  console.log(&#x27;Start&#x27;);</span><br><span class="line">  await sleep(2000);</span><br><span class="line">  console.log(&#x27;After 2 seconds&#x27;);</span><br><span class="line">  console.log(&#x27;End&#x27;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">example();</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，<code>sleep</code> 函数返回一个 Promise 对象，在指定的时间后通过 <code>resolve</code> 方法来完成 Promise，从而实现等待的效果。在 ES5 中，使用 <code>setTimeout</code> 来延迟执行 <code>resolve</code>，而在 ES6 中，可以通过 <code>async/await</code> 来更简洁地实现等待效果。</p>
<p>请注意，在使用 <code>async/await</code> 的方式时，<code>await</code> 只能在 <code>async</code> 函数中使用，因此需要将整个等待过程包裹在一个 <code>async</code> 函数中。在调用 <code>await sleep(ms)</code> 时，函数会暂停执行，直到 <code>sleep</code> 函数返回的 Promise 被完成（即等待的时间到达），然后继续执行后面的代码。</p>
<h4 id="66-Function-proto-getPrototypeOf-是什么"><a href="#66-Function-proto-getPrototypeOf-是什么" class="headerlink" title="66.Function._ proto_ (getPrototypeOf)是什么?"></a>66.Function._ proto_ (getPrototypeOf)是什么?</h4><p>在 JavaScript 中，<code>Function.prototype</code> 是一个内置对象，它是所有函数对象的原型。每个函数在创建时都会自动关联到 <code>Function.prototype</code>，它是一个函数对象，因此它本身也有自己的原型对象，即 <code>Function.prototype.__proto__</code>。</p>
<p>可以通过 <code>Object.getPrototypeOf(Function)</code> 或 <code>Function.__proto__</code> 来访问 <code>Function.prototype</code> 的原型对象。这个原型对象包含了一些内置的方法和属性，可以被所有函数对象共享。</p>
<p>一些常见的在 <code>Function.prototype</code> 上定义的方法包括 <code>call</code>、<code>apply</code> 和 <code>bind</code>，这些方法用于改变函数的执行上下文或绑定函数的上下文。另外，<code>Function.prototype</code> 上还有一些用于原型链的方法，比如 <code>toString</code>、<code>valueOf</code> 等。</p>
<p>实际使用中，我们一般不需要直接访问 <code>Function.prototype.__proto__</code>，而是通过函数对象的原型链来间接使用这些方法和属性。例如，当我们调用 <code>func.toString()</code> 时，实际上是访问了 <code>Function.prototype</code> 上的 <code>toString</code> 方法。</p>
<p>需要注意的是，尽管可以访问 <code>Function.prototype.__proto__</code>，但修改它可能会导致不稳定的行为和兼容性问题。在正常开发中，应该避免直接修改内置对象的原型链，以免影响其他代码的正确性。</p>
<h4 id="67-箭头函数中this-指向"><a href="#67-箭头函数中this-指向" class="headerlink" title="67.箭头函数中this 指向"></a>67.箭头函数中this 指向</h4><p>箭头函数中的 <code>this</code> 指向在定义时确定，并且是词法作用域（lexical scope）下的 <code>this</code> 值。这意味着箭头函数没有自己的 <code>this</code> 绑定，而是继承了其所在的外层作用域的 <code>this</code> 值。</p>
<p>在箭头函数中，<code>this</code> 的指向与其声明位置相关，而不是在函数被调用时确定的。这与普通函数不同，普通函数的 <code>this</code> 值在调用时由调用者决定。</p>
<p>下面是一个简单的示例，说明箭头函数中的 <code>this</code> 指向：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const person = &#123;</span><br><span class="line">  name: &#x27;John&#x27;,</span><br><span class="line">  sayHello: function () &#123;</span><br><span class="line">    console.log(`Hello, I&#x27;m $&#123;this.name&#125;`);</span><br><span class="line">  &#125;,</span><br><span class="line">  sayHelloArrow: () =&gt; &#123;</span><br><span class="line">    console.log(`Hello, I&#x27;m $&#123;this.name&#125;`);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">person.sayHello();      // Output: Hello, I&#x27;m John</span><br><span class="line">person.sayHelloArrow(); // Output: Hello, I&#x27;m undefined</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，<code>person</code> 对象包含两个函数：<code>sayHello</code> 和 <code>sayHelloArrow</code>。在 <code>sayHello</code> 函数中，我们使用普通的函数表达式，它的 <code>this</code> 指向由调用者（即 <code>person</code> 对象）决定，因此输出了正确的结果。而在 <code>sayHelloArrow</code> 中，我们使用了箭头函数，它继承了其所在作用域的 <code>this</code>，在这个例子中是全局作用域，因此输出了 <code>undefined</code>，因为全局作用域中并没有定义 <code>name</code>。请注意，这里的 <code>this</code> 不是指向 <code>person</code> 对象。</p>
<p>需要注意的是，箭头函数不适合作为对象的方法，因为箭头函数的 <code>this</code> 值是固定的，不会根据调用者而变化。通常情况下，箭头函数更适合用于简洁的函数定义，或者在需要保留外层作用域的 <code>this</code> 值时使用。而对于对象的方法，应该优先考虑使用普通的函数表达式，以保证正确的 <code>this</code> 指向。</p>
<h4 id="68-数组常用方法有哪些"><a href="#68-数组常用方法有哪些" class="headerlink" title="68.数组常用方法有哪些"></a>68.数组常用方法有哪些</h4><p>JavaScript 中数组有很多常用的方法，可以用于添加、删除、修改和查询数组中的元素。以下是一些常见的数组方法：</p>
<ol>
<li>添加元素：<ul>
<li><code>push()</code>: 在数组末尾添加一个或多个元素，并返回新数组的长度。</li>
<li><code>unshift()</code>: 在数组开头添加一个或多个元素，并返回新数组的长度。</li>
<li><code>splice(index, 0, element1, element2, ...)</code>: 在指定位置插入一个或多个元素。</li>
</ul>
</li>
<li>删除元素：<ul>
<li><code>pop()</code>: 移除数组末尾的元素，并返回移除的元素。</li>
<li><code>shift()</code>: 移除数组开头的元素，并返回移除的元素。</li>
<li><code>splice(index, count)</code>: 从指定位置开始删除指定数量的元素。</li>
</ul>
</li>
<li>修改元素：<ul>
<li>直接通过索引对数组元素进行赋值：<code>arr[index] = value</code></li>
</ul>
</li>
<li>查询元素：<ul>
<li><code>indexOf(element)</code>: 返回指定元素在数组中的第一个匹配项的索引，若不存在则返回 -1。</li>
<li><code>lastIndexOf(element)</code>: 返回指定元素在数组中的最后一个匹配项的索引，若不存在则返回 -1。</li>
<li><code>includes(element)</code>: 判断数组是否包含指定元素，返回一个布尔值。</li>
</ul>
</li>
<li>数组转换：<ul>
<li><code>toString()</code>: 将数组转换成字符串，各元素用逗号分隔。</li>
<li><code>join(separator)</code>: 将数组元素转换成字符串，使用指定的分隔符连接。</li>
</ul>
</li>
<li>数组拷贝：<ul>
<li><code>slice(start, end)</code>: 返回指定起始和结束位置的子数组，不包括结束位置的元素。</li>
<li><code>concat(arr1, arr2, ...)</code>: 将多个数组合并成一个新数组。</li>
</ul>
</li>
<li>数组遍历：<ul>
<li><code>forEach(callback)</code>: 遍历数组中的每个元素，并执行指定的回调函数。</li>
<li><code>map(callback)</code>: 创建一个新数组，其中的元素是原数组经过指定的回调函数处理后的结果。</li>
<li><code>filter(callback)</code>: 创建一个新数组，其中的元素是原数组中符合指定条件的元素。</li>
<li><code>reduce(callback, initialValue)</code>: 对数组中的元素进行累积操作，返回一个最终的结果。</li>
</ul>
</li>
<li>数组长度：<ul>
<li><code>length</code>: 获取或设置数组的长度。</li>
</ul>
</li>
</ol>
<p>以上只是数组方法的一部分，还有许多其他方法，可以根据具体需求选择适合的方法来操作数组。需要注意的是，很多数组方法会改变原数组，而不是返回新的数组。如果需要保持原数组的不变性，可以通过数组拷贝等方式避免修改原数组。</p>
<h4 id="69-数组去重有哪些方法"><a href="#69-数组去重有哪些方法" class="headerlink" title="69.数组去重有哪些方法?"></a>69.数组去重有哪些方法?</h4><p>数组去重是常见的操作，可以通过多种方法实现。以下是几种常用的数组去重方法：</p>
<ol>
<li>使用 Set 数据结构（ES6 特性）：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const arr = [1, 2, 2, 3, 4, 4, 5];</span><br><span class="line">const uniqueArr = [...new Set(arr)];</span><br><span class="line">console.log(uniqueArr); // Output: [1, 2, 3, 4, 5]</span><br></pre></td></tr></table></figure>

<ol>
<li>使用 indexOf 方法：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const arr = [1, 2, 2, 3, 4, 4, 5];</span><br><span class="line">const uniqueArr = [];</span><br><span class="line">for (let i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">  if (uniqueArr.indexOf(arr[i]) === -1) &#123;</span><br><span class="line">    uniqueArr.push(arr[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(uniqueArr); // Output: [1, 2, 3, 4, 5]</span><br></pre></td></tr></table></figure>

<ol>
<li>使用 includes 方法（ES7 特性）：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const arr = [1, 2, 2, 3, 4, 4, 5];</span><br><span class="line">const uniqueArr = [];</span><br><span class="line">for (let i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">  if (!uniqueArr.includes(arr[i])) &#123;</span><br><span class="line">    uniqueArr.push(arr[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(uniqueArr); // Output: [1, 2, 3, 4, 5]</span><br></pre></td></tr></table></figure>

<ol>
<li>使用 reduce 方法：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const arr = [1, 2, 2, 3, 4, 4, 5];</span><br><span class="line">const uniqueArr = arr.reduce((result, current) =&gt; &#123;</span><br><span class="line">  if (!result.includes(current)) &#123;</span><br><span class="line">    result.push(current);</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;, []);</span><br><span class="line">console.log(uniqueArr); // Output: [1, 2, 3, 4, 5]</span><br></pre></td></tr></table></figure>

<ol>
<li>使用 filter 方法：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const arr = [1, 2, 2, 3, 4, 4, 5];</span><br><span class="line">const uniqueArr = arr.filter((item, index, self) =&gt; &#123;</span><br><span class="line">  return self.indexOf(item) === index;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(uniqueArr); // Output: [1, 2, 3, 4, 5]</span><br></pre></td></tr></table></figure>

<p>以上方法都可以实现数组去重，具体使用哪种方法可以根据实际情况和性能需求进行选择。注意，对于复杂的对象数组，使用 Set 方法可能会更高效，因为 Set 使用了哈希表来存储唯一值，查找速度更快。而对于简单的原始值数组，使用 indexOf、includes、reduce 或者 filter 方法也能满足需求。</p>
<h4 id="70-如何去除字符串首尾空格"><a href="#70-如何去除字符串首尾空格" class="headerlink" title="70.如何去除字符串首尾空格"></a>70.如何去除字符串首尾空格</h4><p>要去除字符串的首尾空格，可以使用 JavaScript 的 <code>trim()</code> 方法。<code>trim()</code> 方法会去除字符串的开头和结尾的所有空格（包括空格、制表符、换行符等），并返回一个新的字符串，原始字符串不会改变。</p>
<p>以下是示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const str = &#x27;  Hello, World!  &#x27;;</span><br><span class="line">const trimmedStr = str.trim();</span><br><span class="line">console.log(trimmedStr); // Output: &quot;Hello, World!&quot;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，原始字符串 <code>str</code> 的开头和结尾都有空格，使用 <code>trim()</code> 方法后，返回的 <code>trimmedStr</code> 就是去除了开头和结尾空格的新字符串。</p>
<p>请注意，<code>trim()</code> 方法只会去除首尾的空格，而不会去除字符串中间的空格。如果需要去除字符串中间的空格，可以使用其他方法，比如 <code>replace()</code> 方法结合正则表达式来实现。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const str = &#x27;  Hello,   World!  &#x27;;</span><br><span class="line">const trimmedStr = str.replace(/\s+/g, &#x27;&#x27;);</span><br><span class="line">console.log(trimmedStr); // Output: &quot;Hello,World!&quot;</span><br></pre></td></tr></table></figure>

<p>上述代码中的正则表达式 <code>\s+</code> 会匹配一个或多个连续的空格字符，使用 <code>replace()</code> 方法将其替换为空字符串，从而去除了字符串中间的空格。</p>
<h4 id="71-说说你所知道的JS语言特性"><a href="#71-说说你所知道的JS语言特性" class="headerlink" title="71.说说你所知道的JS语言特性?"></a>71.说说你所知道的JS语言特性?</h4><p>JavaScript 是一种高级、动态、弱类型的编程语言，它在 Web 开发中扮演着重要的角色。以下是一些 JavaScript 的语言特性：</p>
<ol>
<li>动态类型：JavaScript 是一种弱类型语言，变量的数据类型在运行时可以动态改变。同一个变量可以在不同的上下文中保存不同类型的值。</li>
<li>面向对象：JavaScript 支持面向对象编程，可以使用原型继承和构造函数来创建对象，并通过原型链实现继承。</li>
<li>原型继承：JavaScript 中的对象可以通过原型链继承其他对象的属性和方法，使得代码可以重用和组织。</li>
<li>闭包：JavaScript 支持闭包，即函数可以访问其外部作用域中的变量，即使函数在外部作用域之外执行。</li>
<li>函数作为一等公民：函数在 JavaScript 中是一等公民，可以像其他数据类型一样赋值给变量、作为参数传递和作为返回值返回。</li>
<li>异步编程：JavaScript 支持异步编程，通过回调函数、Promise、async&#x2F;await 等机制实现非阻塞的异步操作。</li>
<li>事件驱动：在浏览器环境中，JavaScript 是事件驱动的，通过监听事件来响应用户的交互。</li>
<li>单线程：JavaScript 是单线程语言，意味着在同一时刻只能执行一个任务。这使得编写并发代码变得复杂，但通过异步编程可以实现非阻塞的并发操作。</li>
<li>变量提升：JavaScript 中的变量和函数声明会被提升到当前作用域的顶部，在声明之前就可以使用。</li>
<li>动态创建和修改HTML：JavaScript 可以通过 DOM 操作动态地创建、修改和删除 HTML 元素，实现页面内容的动态更新。</li>
<li>JSON 格式：JavaScript 对象表示法（JSON）是一种轻量级的数据交换格式，用于在客户端和服务器之间传输数据。</li>
<li>模块化：ES6 引入了模块化的语法，使得 JavaScript 可以以模块的方式组织代码，提高了代码的可维护性和复用性。</li>
<li>模板字面量：ES6 中引入了模板字面量（Template Literals），使得字符串拼接更加方便，支持多行字符串和插值表达式。</li>
<li>箭头函数：ES6 中引入了箭头函数，提供了更简洁的函数定义语法，并且继承外部作用域的 <code>this</code> 值。</li>
<li>解构赋值：ES6 中引入了解构赋值语法，可以方便地从数组或对象中提取值并赋给变量。</li>
</ol>
<p>这些是 JavaScript 的一些重要特性，JavaScript 不断发展，新的语言特性和功能不断加入，使得 JavaScript 在 Web 开发中越来越强大和灵活。</p>
<h4 id="72-如何判断一个数组"><a href="#72-如何判断一个数组" class="headerlink" title="72.如何判断一个数组?"></a>72.如何判断一个数组?</h4><p>判断一个变量是否为数组，可以使用多种方法。以下是常见的几种方式：</p>
<ol>
<li>使用 Array.isArray() 方法（推荐）：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const arr = [1, 2, 3];</span><br><span class="line">if (Array.isArray(arr)) &#123;</span><br><span class="line">  console.log(&#x27;arr 是数组&#x27;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  console.log(&#x27;arr 不是数组&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>使用 instanceof 操作符：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const arr = [1, 2, 3];</span><br><span class="line">if (arr instanceof Array) &#123;</span><br><span class="line">  console.log(&#x27;arr 是数组&#x27;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  console.log(&#x27;arr 不是数组&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>使用 Object.prototype.toString.call() 方法：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const arr = [1, 2, 3];</span><br><span class="line">if (Object.prototype.toString.call(arr) === &#x27;[object Array]&#x27;) &#123;</span><br><span class="line">  console.log(&#x27;arr 是数组&#x27;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  console.log(&#x27;arr 不是数组&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述三种方法中，推荐使用 Array.isArray() 方法来判断数组，因为它是专门用于判断变量是否为数组的标准方法，而且对于多窗口（iframe）环境中的数组也能正确判断。而使用 instanceof 操作符和 Object.prototype.toString.call() 方法也可以判断数组，但有一些限制，例如在多窗口环境下可能会失效。</p>
<p>需要注意的是，由于 JavaScript 是动态类型语言，所以在判断数组之前最好先确保变量不是 null 或 undefined。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const arr = [1, 2, 3];</span><br><span class="line">if (arr &amp;&amp; Array.isArray(arr)) &#123;</span><br><span class="line">  console.log(&#x27;arr 是数组&#x27;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  console.log(&#x27;arr 不是数组或为 null/undefined&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用这些方法可以准确地判断一个变量是否为数组，根据实际情况选择最合适的方式进行判断。</p>
<h4 id="73-JS的全排列"><a href="#73-JS的全排列" class="headerlink" title="73.JS的全排列"></a>73.JS的全排列</h4><p>全排列是一种组合算法，可以将一组元素按照不同的顺序进行排列。在 JavaScript 中，可以通过递归和交换元素的方式来实现全排列。以下是一个实现全排列的 JavaScript 函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function permute(nums) &#123;</span><br><span class="line">  const result = [];</span><br><span class="line"></span><br><span class="line">  function backtrack(start) &#123;</span><br><span class="line">    if (start === nums.length - 1) &#123;</span><br><span class="line">      result.push([...nums]);</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (let i = start; i &lt; nums.length; i++) &#123;</span><br><span class="line">      // 交换元素，使得当前元素变为第一个元素</span><br><span class="line">      [nums[start], nums[i]] = [nums[i], nums[start]];</span><br><span class="line">      // 递归进入下一层，继续排列后面的元素</span><br><span class="line">      backtrack(start + 1);</span><br><span class="line">      // 回溯，恢复数组原来的状态</span><br><span class="line">      [nums[start], nums[i]] = [nums[i], nums[start]];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  backtrack(0);</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 示例</span><br><span class="line">const nums = [1, 2, 3];</span><br><span class="line">console.log(permute(nums));</span><br></pre></td></tr></table></figure>

<p>在上述代码中，<code>permute</code> 函数通过 <code>backtrack</code> 函数进行递归排列。<code>backtrack</code> 函数接收一个参数 <code>start</code>，表示从数组的第 <code>start</code> 个元素开始进行排列。当 <code>start</code> 等于数组的长度减 1 时，表示所有元素都已经排列完毕，将当前排列结果加入 <code>result</code> 数组中。否则，从 <code>start</code> 开始循环遍历数组，并依次将当前元素交换到第一个位置，然后递归进入下一层，继续排列后面的元素。完成递归后，需要回溯，恢复数组原来的状态，以便进行下一轮排列。</p>
<p>使用该函数可以得到数组 <code>[1, 2, 3]</code> 的全排列：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [1, 2, 3],</span><br><span class="line">  [1, 3, 2],</span><br><span class="line">  [2, 1, 3],</span><br><span class="line">  [2, 3, 1],</span><br><span class="line">  [3, 2, 1],</span><br><span class="line">  [3, 1, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>全排列是一种经典的组合算法，在编程中经常会用到，可以用于解决很多问题，如字符串的所有排列、数组的所有组合等。</p>
<h4 id="74-谈谈你所理解的跨域，为什么会有这个问题-如何解决"><a href="#74-谈谈你所理解的跨域，为什么会有这个问题-如何解决" class="headerlink" title="74.谈谈你所理解的跨域，为什么会有这个问题?如何解决?"></a>74.谈谈你所理解的跨域，为什么会有这个问题?如何解决?</h4><p>跨域（Cross-Origin）是指在浏览器中，当前网页所在的域（协议 + 域名 + 端口）与请求资源所在的域不同，导致浏览器限制了从当前网页向其他域发送跨域请求的能力。这是由于浏览器的同源策略（Same-Origin Policy）所导致的。</p>
<p>同源策略是一种安全机制，用于阻止一个网页上的脚本或资源（如 XMLHttpRequest 或 Fetch）与不同域的服务器进行通信。具体来说，同源策略要求请求的协议、域名和端口必须完全一致，否则就会产生跨域问题。</p>
<p>例如，当一个网页的 URL 是 <code>http://example.com/index.html</code>，如果该页面向 <code>http://api.example.com/data</code> 发送请求，就会触发跨域问题，因为二者的域名不同。</p>
<p>解决跨域问题有以下几种方法：</p>
<ol>
<li>JSONP：利用 <code>&lt;script&gt;</code> 标签的跨域特性，通过动态创建 <code>&lt;script&gt;</code> 元素并设置其 <code>src</code> 属性来请求跨域数据。JSONP 依赖于后端服务器的支持，在服务器端返回一个回调函数调用的包装数据，前端通过回调函数来处理数据。</li>
<li>CORS（Cross-Origin Resource Sharing）：CORS 是一种现代的跨域解决方案，通过服务器设置响应头来授权特定的域名访问资源。在服务器端设置 <code>Access-Control-Allow-Origin</code> 头部，允许指定的域名进行跨域访问。</li>
<li>代理：在同域下设置一个代理服务器，将跨域请求转发给目标服务器，并将响应返回给前端。这种方法需要在后端进行配置。</li>
<li>iframe + postMessage：使用 iframe 加载目标页面，并通过 <code>postMessage</code> 方法进行跨域通信。通过在目标页面中监听消息事件，实现跨域数据的传递。</li>
<li>WebSocket：WebSocket 协议不受同源策略的限制，可以在客户端与服务器之间建立长连接，实现实时通信。</li>
<li>Nginx 反向代理：通过在 Nginx 配置中添加反向代理规则，将跨域请求转发给目标服务器，同时在服务器端设置 CORS 头部来允许跨域访问。</li>
</ol>
<p>注意：在开发过程中，跨域问题通常不会在本地测试环境中出现，因为浏览器会对本地文件进行放宽限制。跨域问题主要出现在生产环境或真实的网络环境中。解决跨域问题时，需要根据具体情况选择合适的方法，并确保服务器端的安全性和正确配置跨域头部。</p>
<h4 id="75-null-x3D-x3D-undefined输出什么-null-x3D-x3D-x3D-undefined呢"><a href="#75-null-x3D-x3D-undefined输出什么-null-x3D-x3D-x3D-undefined呢" class="headerlink" title="75.null &#x3D;&#x3D; undefined输出什么? null &#x3D;&#x3D;&#x3D; undefined呢?"></a>75.null &#x3D;&#x3D; undefined输出什么? null &#x3D;&#x3D;&#x3D; undefined呢?</h4><p>在 JavaScript 中，null 和 undefined 是两种特殊的值，它们都代表着”没有值”的含义。但它们的数据类型和内部表示是不同的。</p>
<ol>
<li><p>null &#x3D;&#x3D; undefined： 当使用双等号（&#x3D;&#x3D;）进行比较时，JavaScript 会进行类型转换。在比较 null 和 undefined 时，它们会被视为相等，因此结果为 true。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy code</span><br><span class="line">console.log(null == undefined); // 输出: true</span><br></pre></td></tr></table></figure>
</li>
<li><p>null &#x3D;&#x3D;&#x3D; undefined： 当使用三等号（&#x3D;&#x3D;&#x3D;）进行比较时，JavaScript 不进行类型转换，只有在数据类型和值都相同的情况下，才会被视为相等。由于 null 和 undefined 的数据类型不同，一个是 object，另一个是 undefined，所以它们不相等，结果为 false。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy code</span><br><span class="line">console.log(null === undefined); // 输出: false</span><br></pre></td></tr></table></figure></li>
</ol>
<p>总结：</p>
<ul>
<li>双等号（&#x3D;&#x3D;）会进行类型转换，null 和 undefined 会被视为相等，其他数据类型会进行相应的类型转换再进行比较。</li>
<li>三等号（&#x3D;&#x3D;&#x3D;）不会进行类型转换，只有在数据类型和值都相同的情况下才会被视为相等。对于 null 和 undefined，因为它们的数据类型不同，所以不相等。</li>
</ul>
<h4 id="76-什么是按需加载"><a href="#76-什么是按需加载" class="headerlink" title="76.什么是按需加载"></a>76.什么是按需加载</h4><p>按需加载（Lazy Loading），也称为延迟加载，是一种优化前端性能的技术。它的主要目的是将网页的初始加载时间缩短，提高页面的加载速度和用户体验。</p>
<p>在按需加载中，不是一次性将所有的资源（如 JavaScript、CSS、图片等）都加载到页面中，而是根据页面的实际需求，在需要的时候再进行加载。这样可以减少初始加载时的资源大小，加快页面的显示速度，特别是在移动端网络条件不理想的情况下，效果更为明显。</p>
<p>常见的按需加载方式有：</p>
<ol>
<li>图片懒加载：将页面上的图片的真实地址替换为占位图，当图片进入可视区域时再加载真实图片，提高页面加载速度。</li>
<li>异步加载 JavaScript：将不必要的 JavaScript 代码通过异步加载的方式延迟加载，当需要使用该代码时再动态加载进来。</li>
<li>动态加载 CSS：根据页面需要加载特定的 CSS 文件，而不是一次性加载所有样式。</li>
<li>分包加载：将页面中的不同功能模块或页面组件拆分成独立的模块，按需加载，用户访问不同页面时只加载当前页面所需的模块。</li>
</ol>
<p>通过按需加载，可以减少页面的加载时间和资源消耗，提高网站性能和用户体验。</p>
<h4 id="77-简单介绍一下symbol"><a href="#77-简单介绍一下symbol" class="headerlink" title="77.简单介绍一下symbol"></a>77.简单介绍一下symbol</h4><p>Symbol 是 ES6 引入的一种新的原始数据类型，它表示一个独一无二的值，用于创建唯一的标识符。</p>
<p>Symbol 的定义方式为 <code>Symbol()</code>，每次调用 <code>Symbol()</code> 都会返回一个新的、不同的 Symbol 值。这意味着 Symbol 是永远不会相等的，即使它们的值相同。</p>
<p>Symbol 有以下特点：</p>
<ol>
<li>独一无二：每个 Symbol 都是独一无二的，不会与其他任何值相等。</li>
<li>不可变性：Symbol 值一旦被创建，就不能修改其值或属性。</li>
<li>作为属性名：Symbol 可以用作对象的属性名，由于独一无二的特性，可以防止属性名冲突。</li>
<li>隐藏性：由于 Symbol 值在外部代码中无法获取到具体值，因此可以用于隐藏对象的私有属性和方法。</li>
</ol>
<p>常见用法：</p>
<ol>
<li>作为对象属性名：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy codeconst mySymbol = Symbol(&#x27;mySymbol&#x27;);</span><br><span class="line">const obj = &#123;</span><br><span class="line">  [mySymbol]: &#x27;This is a symbol property&#x27;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(obj[mySymbol]); // Output: This is a symbol property</span><br></pre></td></tr></table></figure>

<ol>
<li>防止属性名冲突：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy codeconst mySymbol1 = Symbol(&#x27;mySymbol&#x27;);</span><br><span class="line">const mySymbol2 = Symbol(&#x27;mySymbol&#x27;);</span><br><span class="line"></span><br><span class="line">const obj = &#123;</span><br><span class="line">  [mySymbol1]: &#x27;Property 1&#x27;,</span><br><span class="line">  [mySymbol2]: &#x27;Property 2&#x27;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(obj[mySymbol1]); // Output: Property 1</span><br><span class="line">console.log(obj[mySymbol2]); // Output: Property 2</span><br></pre></td></tr></table></figure>

<ol>
<li>使用内置 Symbol 值：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy codeconst symToStringTag = Symbol.toStringTag;</span><br><span class="line"></span><br><span class="line">const myObject = &#123;</span><br><span class="line">  [symToStringTag]: &#x27;MyObject&#x27;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(myObject.toString()); // Output: [object MyObject]</span><br></pre></td></tr></table></figure>

<p>Symbol 是一种非常有用的数据类型，特别适合用于创建唯一的属性名和标识符，同时也有助于增强对象的封装和隐藏性。</p>
<h4 id="78-介绍下promise-及其底层如何实现"><a href="#78-介绍下promise-及其底层如何实现" class="headerlink" title="78.介绍下promise,及其底层如何实现"></a>78.介绍下promise,及其底层如何实现</h4><p>Promise 是 ES6 中新增的一种处理异步操作的机制，用于解决回调地狱的问题，让异步操作更加易读和可维护。它表示一个异步操作的最终完成或失败，并可以处理其结果。</p>
<p>Promise 有三种状态：Pending（进行中）、Fulfilled（已完成）和Rejected（已失败）。当一个 Promise 对象处于 Pending 状态时，表示异步操作还在进行中；当操作完成后，会进入 Fulfilled 状态，表示操作成功；如果操作失败，则会进入 Rejected 状态，表示操作失败。</p>
<p>Promise 的基本用法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy codeconst promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  // 异步操作</span><br><span class="line">  // 如果操作成功，则调用 resolve() 并传递结果</span><br><span class="line">  // 如果操作失败，则调用 reject() 并传递错误信息</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise</span><br><span class="line">  .then((result) =&gt; &#123;</span><br><span class="line">    // 操作成功的回调函数</span><br><span class="line">    console.log(&#x27;Success:&#x27;, result);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch((error) =&gt; &#123;</span><br><span class="line">    // 操作失败的回调函数</span><br><span class="line">    console.error(&#x27;Error:&#x27;, error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>底层实现原理：</p>
<p>Promise 的底层实现涉及到了一些异步编程的概念，主要是利用了事件循环机制和回调函数。</p>
<ol>
<li>创建一个 Promise 对象时，会立即执行传入的 executor 函数，并传入两个回调函数：resolve 和 reject。</li>
<li>在 executor 函数中，通常会执行一些异步操作，一旦操作完成，可以调用 resolve 方法传递操作的结果，或者调用 reject 方法传递操作失败的原因。</li>
<li>当 Promise 进入 Fulfilled 状态时，会触发 then 方法中的成功回调函数；当 Promise 进入 Rejected 状态时，会触发 catch 方法中的失败回调函数。</li>
<li>如果 Promise 在 executor 函数中出现异常或者调用了 reject 方法，则会直接进入 Rejected 状态，并触发 catch 方法中的失败回调函数。</li>
<li>Promise 的 then 和 catch 方法返回的是一个新的 Promise 对象，使得可以链式调用。</li>
</ol>
<p>实际上，Promise 的底层实现涉及了更复杂的细节，包括状态的变化、回调队列的管理等，但以上是其基本原理的简单描述。Promise 的出现极大地简化了异步编程，并提供了更加优雅和直观的处理方式。</p>
<h4 id="79-JS原型链，原型链的顶端是什么-Object-的原型是什么-Object的原型的原型是什么"><a href="#79-JS原型链，原型链的顶端是什么-Object-的原型是什么-Object的原型的原型是什么" class="headerlink" title="79.JS原型链，原型链的顶端是什么? Object 的原型是什么? Object的原型的原型是什么?"></a>79.JS原型链，原型链的顶端是什么? Object 的原型是什么? Object的原型的原型是什么?</h4><p>在 JavaScript 中，原型链是一种对象之间通过原型链接起来的继承关系。每个对象都有一个原型（prototype），并且对象可以通过原型链来访问其原型的属性和方法。</p>
<p>原型链的顶端是 <code>Object.prototype</code>，它是 JavaScript 中所有对象的原型的最终原型。也就是说，所有对象（包括函数、数组、字符串等）都是继承自 <code>Object.prototype</code>。</p>
<p>具体来说：</p>
<ol>
<li>对象的原型是通过 <code>__proto__</code> 属性指向其原型对象的，这个原型对象就是该对象的原型。例如：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy codeconst obj = &#123;&#125;;</span><br><span class="line">console.log(obj.__proto__ === Object.prototype); // true</span><br></pre></td></tr></table></figure>

<ol>
<li><code>Object.prototype</code> 的原型是 <code>null</code>，即 <code>Object.prototype.__proto__</code> 为 <code>null</code>。这意味着 <code>Object.prototype</code> 是原型链的顶端。</li>
<li>当我们访问一个对象的属性时，如果对象本身没有这个属性，JavaScript 就会沿着原型链向上查找该属性。如果在原型链中找到了该属性，就会返回它；如果找不到，则返回 <code>undefined</code>。</li>
</ol>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy codeconst obj = &#123;&#125;;</span><br><span class="line">console.log(obj.toString()); // Object.prototype 上的 toString 方法被调用</span><br></pre></td></tr></table></figure>

<ol>
<li>对于构造函数创建的对象，它们的原型是构造函数的 <code>prototype</code> 属性所指向的对象。构造函数可以通过 <code>prototype</code> 属性定义一些公共的属性和方法，这些属性和方法会被所有通过该构造函数创建的对象继承。</li>
</ol>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy codefunction Person(name) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.sayHello = function() &#123;</span><br><span class="line">  console.log(`Hello, I&#x27;m $&#123;this.name&#125;.`);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const john = new Person(&#x27;John&#x27;);</span><br><span class="line">john.sayHello(); // Hello, I&#x27;m John.</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>Person.prototype</code> 是 <code>john</code> 对象的原型，因此 <code>john</code> 对象可以调用 <code>sayHello</code> 方法。</p>
<p>总结：原型链的顶端是 <code>Object.prototype</code>，所有对象都继承自它。对象的原型通过 <code>__proto__</code> 属性指向其原型对象，而原型对象的原型是通过 <code>__proto__</code> 属性指向 <code>Object.prototype</code>，形成了原型链的继承关系。</p>
<h4 id="80-promise-Generator-Async-的使用"><a href="#80-promise-Generator-Async-的使用" class="headerlink" title="80.promise+Generator+Async 的使用"></a>80.promise+Generator+Async 的使用</h4><p><code>Promise</code>, <code>Generator</code>, 和 <code>Async/Await</code> 都是用于处理异步编程的特性，它们在 JavaScript 中都可以用于优雅地处理异步操作。</p>
<ol>
<li>Promise: <code>Promise</code> 是一种用于异步编程的对象，可以在异步操作完成后返回结果或错误。使用 <code>Promise</code> 可以避免回调地狱，并使代码更加清晰和可读。<code>Promise</code> 有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy code// Promise 的基本用法</span><br><span class="line">const myPromise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  // 异步操作</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    const randomNum = Math.random();</span><br><span class="line">    if (randomNum &lt; 0.5) &#123;</span><br><span class="line">      resolve(&#x27;Success&#x27;); // 成功时调用 resolve</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      reject(&#x27;Error&#x27;); // 失败时调用 reject</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">myPromise</span><br><span class="line">  .then((result) =&gt; &#123;</span><br><span class="line">    console.log(&#x27;Resolved:&#x27;, result); // 成功时执行 then 回调</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch((error) =&gt; &#123;</span><br><span class="line">    console.error(&#x27;Rejected:&#x27;, error); // 失败时执行 catch 回调</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<ol>
<li>Generator: <code>Generator</code> 是一种函数，可以通过 <code>function*</code> 关键字定义。它可以通过 <code>yield</code> 关键字将函数的执行过程暂停，并可以通过 <code>next()</code> 方法恢复执行。<code>Generator</code> 在异步编程中常与 <code>Promise</code> 结合使用，可以实现更灵活的控制流程。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy code// Generator 的基本用法</span><br><span class="line">function* myGenerator() &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    const value1 = yield Promise.resolve(1);</span><br><span class="line">    console.log(value1); // 1</span><br><span class="line">    const value2 = yield Promise.resolve(2);</span><br><span class="line">    console.log(value2); // 2</span><br><span class="line">    const value3 = yield Promise.resolve(3);</span><br><span class="line">    console.log(value3); // 3</span><br><span class="line">  &#125; catch (error) &#123;</span><br><span class="line">    console.error(&#x27;Error:&#x27;, error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const gen = myGenerator();</span><br><span class="line">gen.next().then((result1) =&gt; &#123;</span><br><span class="line">  gen.next(result1.value).then((result2) =&gt; &#123;</span><br><span class="line">    gen.next(result2.value).then((result3) =&gt; &#123;</span><br><span class="line">      gen.next(result3.value); // 依次输出 1, 2, 3</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ol>
<li>Async&#x2F;Await: <code>Async/Await</code> 是 <code>Promise</code> 的一种更简洁的语法糖，它使得异步代码看起来更像同步代码，使得异步流程更易读和维护。在 <code>Async</code> 函数内部使用 <code>await</code> 关键字可以暂停函数的执行，等待 <code>Promise</code> 的状态变为 <code>fulfilled</code>，然后获取其返回值。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy code// Async/Await 的基本用法</span><br><span class="line">async function myAsyncFunction() &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    const result1 = await Promise.resolve(1);</span><br><span class="line">    console.log(result1); // 1</span><br><span class="line">    const result2 = await Promise.resolve(2);</span><br><span class="line">    console.log(result2); // 2</span><br><span class="line">    const result3 = await Promise.resolve(3);</span><br><span class="line">    console.log(result3); // 3</span><br><span class="line">  &#125; catch (error) &#123;</span><br><span class="line">    console.error(&#x27;Error:&#x27;, error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myAsyncFunction(); // 依次输出 1, 2, 3</span><br></pre></td></tr></table></figure>

<p>以上是三种处理异步编程的常用方式，它们都可以有效地处理异步操作，使代码更加简洁和易读。根据具体的场景和需求，可以选择使用其中的一种或多种。</p>
<h4 id="81-JS中string的startwith和indexof两种方法的区别"><a href="#81-JS中string的startwith和indexof两种方法的区别" class="headerlink" title="81.JS中string的startwith和indexof两种方法的区别"></a>81.JS中string的startwith和indexof两种方法的区别</h4><p><code>startsWith</code> 和 <code>indexOf</code> 都是用于在字符串中查找子字符串的方法，但它们之间有一些区别。</p>
<ol>
<li><pre><code>startsWith
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"> 方法:</span><br><span class="line"></span><br><span class="line">- `startsWith` 是 ES6 中新增的字符串方法，用于检查一个字符串是否以指定的子字符串开头。</span><br><span class="line">- 它返回一个布尔值，如果字符串以指定的子字符串开头，则返回 `true`，否则返回 `false`。</span><br><span class="line">- `startsWith` 方法可以接受两个参数：要查找的子字符串和可选的搜索起始位置。</span><br><span class="line">- 该方法不会改变原始字符串，它是一个纯粹的查询操作。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
javascriptCopy codeconst str = &#39;Hello, world!&#39;;
</code></pre>
</li>
</ol>
<p>console.log(str.startsWith(‘Hello’)); &#x2F;&#x2F; true<br>console.log(str.startsWith(‘hello’)); &#x2F;&#x2F; false (区分大小写)<br>console.log(str.startsWith(‘world’, 7)); &#x2F;&#x2F; true (从索引 7 开始搜索)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">1. ```</span><br><span class="line">   indexOf</span><br></pre></td></tr></table></figure>

<pre><code>方法:
</code></pre>
<ul>
<li><code>indexOf</code> 是 JavaScript 中原生的字符串方法，用于查找一个字符串中指定子字符串的位置。</li>
<li>它返回第一个匹配的子字符串的索引，如果没有找到，则返回 <code>-1</code>。</li>
<li><code>indexOf</code> 方法可以接受两个参数：要查找的子字符串和可选的搜索起始位置。</li>
<li>该方法不会改变原始字符串，它也是一个纯粹的查询操作。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy codeconst str = &#x27;Hello, world!&#x27;;</span><br><span class="line"></span><br><span class="line">console.log(str.indexOf(&#x27;Hello&#x27;)); // 0 (从索引 0 开始找到匹配的子字符串)</span><br><span class="line">console.log(str.indexOf(&#x27;hello&#x27;)); // -1 (未找到，区分大小写)</span><br><span class="line">console.log(str.indexOf(&#x27;world&#x27;, 7)); // 7 (从索引 7 开始找到匹配的子字符串)</span><br></pre></td></tr></table></figure>

<p>总结:</p>
<ul>
<li><code>startsWith</code> 适用于判断一个字符串是否以指定的子字符串开头，返回布尔值。</li>
<li><code>indexOf</code> 适用于查找一个字符串中指定子字符串的位置，返回第一个匹配的子字符串的索引。</li>
</ul>
<h4 id="82-JS字符串转数字的方法"><a href="#82-JS字符串转数字的方法" class="headerlink" title="82.JS字符串转数字的方法"></a>82.JS字符串转数字的方法</h4><p>在 JavaScript 中，有几种方法可以将字符串转换为数字：</p>
<ol>
<li>使用 <code>parseInt()</code> 函数：<code>parseInt()</code> 函数将字符串转换为整数。它从字符串的开始位置解析整数，并忽略字符串中的非数字字符，直到遇到第一个非数字字符为止。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy codeconst str = &#x27;123&#x27;;</span><br><span class="line">const number = parseInt(str);</span><br><span class="line">console.log(number); // 123</span><br></pre></td></tr></table></figure>

<ol>
<li>使用 <code>parseFloat()</code> 函数：<code>parseFloat()</code> 函数将字符串转换为浮点数。它从字符串的开始位置解析浮点数，并忽略字符串中的非数字字符，直到遇到第一个非数字字符为止。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy codeconst str = &#x27;3.14&#x27;;</span><br><span class="line">const number = parseFloat(str);</span><br><span class="line">console.log(number); // 3.14</span><br></pre></td></tr></table></figure>

<ol>
<li>使用 <code>Number()</code> 函数：<code>Number()</code> 函数可以将字符串转换为数字，包括整数和浮点数。如果字符串中包含非数字字符（除了空格和正负号之外），则转换结果为 <code>NaN</code>（Not a Number）。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy codeconst str1 = &#x27;42&#x27;;</span><br><span class="line">const str2 = &#x27;3.14&#x27;;</span><br><span class="line">const str3 = &#x27;abc&#x27;;</span><br><span class="line"></span><br><span class="line">const number1 = Number(str1);</span><br><span class="line">const number2 = Number(str2);</span><br><span class="line">const number3 = Number(str3);</span><br><span class="line"></span><br><span class="line">console.log(number1); // 42</span><br><span class="line">console.log(number2); // 3.14</span><br><span class="line">console.log(number3); // NaN</span><br></pre></td></tr></table></figure>

<ol>
<li>使用加号 <code>+</code> 运算符：将字符串与空字符串相加，可以将其转换为数字。这种方法适用于只包含数字的字符串，如果字符串中包含非数字字符，结果将是 <code>NaN</code>。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy codeconst str = &#x27;42&#x27;;</span><br><span class="line">const number = +str;</span><br><span class="line">console.log(number); // 42</span><br></pre></td></tr></table></figure>

<p>注意：以上方法都可以将合法的数字字符串转换为数字。如果字符串不能表示有效的数字，转换结果将是 <code>NaN</code>。在进行字符串转换为数字的操作时，要注意字符串中是否包含非数字字符以及是否符合合理的数字格式。</p>
<h4 id="83-平时是怎么调试JS的"><a href="#83-平时是怎么调试JS的" class="headerlink" title="83.平时是怎么调试JS的"></a>83.平时是怎么调试JS的</h4><h4 id="84-怎么获得对象上的属性"><a href="#84-怎么获得对象上的属性" class="headerlink" title="84.怎么获得对象上的属性"></a>84.怎么获得对象上的属性</h4><p>可以通过以下几种方式获得对象上的属性：</p>
<ol>
<li>使用点符号（<code>.</code>）：通过对象的属性名来访问属性值。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy codeconst person = &#123; name: &#x27;John&#x27;, age: 30 &#125;;</span><br><span class="line">console.log(person.name); // &quot;John&quot;</span><br><span class="line">console.log(person.age); // 30</span><br></pre></td></tr></table></figure>

<ol>
<li>使用方括号（<code>[]</code>）：通过属性名的字符串形式来访问属性值。适用于属性名包含特殊字符或动态生成的情况。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy codeconst person = &#123; name: &#x27;John&#x27;, age: 30 &#125;;</span><br><span class="line">console.log(person[&#x27;name&#x27;]); // &quot;John&quot;</span><br><span class="line">console.log(person[&#x27;age&#x27;]); // 30</span><br><span class="line"></span><br><span class="line">const propertyName = &#x27;name&#x27;;</span><br><span class="line">console.log(person[propertyName]); // &quot;John&quot;</span><br></pre></td></tr></table></figure>

<ol>
<li>使用变量来获取属性值：当属性名保存在变量中时，可以使用变量来获取属性值。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy codeconst person = &#123; name: &#x27;John&#x27;, age: 30 &#125;;</span><br><span class="line">const propertyName = &#x27;name&#x27;;</span><br><span class="line">console.log(person[propertyName]); // &quot;John&quot;</span><br></pre></td></tr></table></figure>

<p>注意：如果对象上不存在指定的属性，使用点符号访问该属性会返回 <code>undefined</code>，使用方括号访问该属性会返回 <code>undefined</code> 或引起 <code>TypeError</code> 错误（如果对象是 <code>null</code> 或 <code>undefined</code>）。在访问属性值之前，最好先检查对象是否包含该属性，可以使用 <code>in</code> 运算符或 <code>hasOwnProperty()</code> 方法来检查。</p>
<h4 id="85-async和await具体该怎么用"><a href="#85-async和await具体该怎么用" class="headerlink" title="85.async和await具体该怎么用?"></a>85.async和await具体该怎么用?</h4><h4 id="86-知道哪些ES6，ES7-的语法"><a href="#86-知道哪些ES6，ES7-的语法" class="headerlink" title="86.知道哪些ES6，ES7 的语法"></a>86.知道哪些ES6，ES7 的语法</h4><p>ES6和ES7（ES2016）引入了许多新的语法特性，以下是其中一些常见的特性：</p>
<p>ES6（ECMAScript 2015）的语法特性：</p>
<ol>
<li>块级作用域：使用 <code>let</code> 和 <code>const</code> 声明变量，使得变量在块级作用域内有效。</li>
<li>箭头函数：使用箭头函数定义函数，简化函数的语法。</li>
<li>解构赋值：从对象或数组中提取值并赋值给变量。</li>
<li>模板字符串：使用反引号 &#96;&#96; 来创建多行字符串，并可以在字符串中插入变量。</li>
<li>类和对象：使用 <code>class</code> 关键字定义类，使用 <code>constructor</code> 构造函数创建对象。</li>
<li>模块化：使用 <code>import</code> 和 <code>export</code> 来进行模块的导入和导出。</li>
<li>Promise：用于处理异步操作的一种机制，解决了回调地狱的问题。</li>
<li>箭头函数：一种更简洁的函数写法，自动绑定上下文，不绑定 <code>this</code>。</li>
</ol>
<p>ES7（ECMAScript 2016）的语法特性：</p>
<ol>
<li>Array.prototype.includes()：用于判断数组是否包含某个元素，返回布尔值。</li>
<li>指数运算符（Exponentiation Operator）：用于求幂运算。</li>
</ol>
<p>还有许多其他的语法特性，在不断的更新迭代中，JavaScript语言会持续发展，提供更多方便和强大的功能。</p>
<h4 id="87-promise-和await-x2F-async的关系"><a href="#87-promise-和await-x2F-async的关系" class="headerlink" title="87.promise 和await&#x2F;async的关系"></a>87.promise 和await&#x2F;async的关系</h4><p>Promise和async&#x2F;await是两种处理异步操作的方式，它们之间有一定的关系。</p>
<ol>
<li>Promise：是一种用于处理异步操作的对象，可以将异步操作封装成一个Promise对象，并通过<code>then</code>和<code>catch</code>方法来处理异步操作的结果或错误。Promise的语法相对较为简单，但在多个异步操作需要串行执行或并行执行时，会出现嵌套的问题，也称为”回调地狱”。</li>
<li>async&#x2F;await：是ES2017（ES8）中引入的异步编程的新特性，它建立在Promise之上，提供了更简洁和清晰的异步代码写法。使用<code>async</code>关键字来声明一个异步函数，异步函数内部可以使用<code>await</code>关键字来等待一个Promise对象的返回结果，而不需要使用<code>.then</code>来处理。在async函数内部，可以像写同步代码一样编写异步操作，使得代码更易于阅读和维护，避免了回调地狱的问题。</li>
</ol>
<p>实际上，async&#x2F;await只是Promise的一种语法糖，它并没有改变异步操作的本质，只是让异步代码看起来更像同步代码。async&#x2F;await的使用依赖于Promise，async函数内部可以返回一个Promise对象，通过<code>await</code>等待该Promise的结果。</p>
<p>简而言之，async&#x2F;await是Promise的一种更直观、更优雅的写法，让异步代码更易于编写和维护。</p>
<h4 id="88-JS加载过程阻塞，解决方法。"><a href="#88-JS加载过程阻塞，解决方法。" class="headerlink" title="88.JS加载过程阻塞，解决方法。"></a>88.JS加载过程阻塞，解决方法。</h4><p>JavaScript加载过程阻塞指的是当浏览器遇到<code>&lt;script&gt;</code>标签时，会暂停页面的解析和渲染，先加载和执行JavaScript代码，然后再继续解析和渲染页面，这可能会导致页面加载速度变慢和用户体验下降。</p>
<p>解决JavaScript加载过程阻塞的方法有以下几种：</p>
<ol>
<li>异步加载：将<code>&lt;script&gt;</code>标签的<code>async</code>或<code>defer</code>属性设置为<code>true</code>，使得JavaScript文件在后台异步加载，不会阻塞页面的解析和渲染。<code>async</code>和<code>defer</code>的区别在于<code>async</code>表示异步加载且加载完成后立即执行，<code>defer</code>表示异步加载但会等到页面解析完成后按顺序执行。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">htmlCopy code&lt;!-- 异步加载 --&gt;</span><br><span class="line">&lt;script async src=&quot;your-script.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 延迟执行 --&gt;</span><br><span class="line">&lt;script defer src=&quot;your-script.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<ol>
<li>动态加载：使用JavaScript动态创建<code>&lt;script&gt;</code>标签并插入到DOM中，这样可以在需要的时候再加载JavaScript文件，避免阻塞页面加载。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy codeconst script = document.createElement(&#x27;script&#x27;);</span><br><span class="line">script.src = &#x27;your-script.js&#x27;;</span><br><span class="line">document.body.appendChild(script);</span><br></pre></td></tr></table></figure>

<ol>
<li>懒加载：将页面中不需要立即执行的JavaScript代码进行拆分，将其作为独立的模块，当需要时再加载和执行。可以使用<code>import()</code>（动态导入）或使用工具如Webpack进行代码分割。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy code// 动态导入模块</span><br><span class="line">import(&#x27;./your-module.js&#x27;).then(module =&gt; &#123;</span><br><span class="line">  // 模块加载完成后的处理</span><br><span class="line">&#125;).catch(error =&gt; &#123;</span><br><span class="line">  // 加载出错的处理</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ol>
<li>缓存：使用合适的HTTP缓存策略，让浏览器在第一次加载完JavaScript文件后，能够缓存起来，之后再次访问同一页面时可以直接使用缓存的JavaScript文件，加快加载速度。</li>
</ol>
<p>注意，虽然异步加载和懒加载可以减少阻塞，但过度使用也可能导致多个脚本并行加载，产生过多的HTTP请求，因此需要权衡使用场景。</p>
<h4 id="89-JS对象类型，基本对象类型以及引用对象类型的区别"><a href="#89-JS对象类型，基本对象类型以及引用对象类型的区别" class="headerlink" title="89.JS对象类型，基本对象类型以及引用对象类型的区别"></a>89.JS对象类型，基本对象类型以及引用对象类型的区别</h4><p>在JavaScript中，数据类型可以分为三类：基本数据类型、引用数据类型和特殊数据类型（null和undefined）。</p>
<ol>
<li>基本数据类型：<ul>
<li>字符串（String）：表示文本数据，用单引号或双引号括起来。</li>
<li>数字（Number）：表示数值，包括整数和浮点数。</li>
<li>布尔值（Boolean）：表示真或假，只有两个值：true和false。</li>
<li>null：表示空值，表示一个空对象指针。</li>
<li>undefined：表示未定义，表示一个未初始化的变量。</li>
</ul>
</li>
<li>引用数据类型：<ul>
<li>对象（Object）：表示复杂的数据结构，可以包含多个属性和方法。对象可以通过大括号 <code>&#123;&#125;</code> 创建。</li>
<li>数组（Array）：是一种特殊的对象，用于存储多个值。数组可以通过方括号 <code>[]</code> 创建。</li>
<li>函数（Function）：是一种特殊的对象，用于执行代码块。函数可以通过关键字 <code>function</code> 创建。</li>
</ul>
</li>
</ol>
<p>基本数据类型是按值访问的，它们的值直接存储在变量中，变量直接访问值。例如，当你将一个基本数据类型的值赋给另一个变量时，它们是相互独立的，修改一个变量的值不会影响另一个变量。</p>
<p>引用数据类型是按引用访问的，它们的值存储在内存中，变量中存储的是对象在内存中的地址。当你将一个引用类型的值赋给另一个变量时，它们实际上是共享同一个对象，修改一个变量的值会影响到另一个变量。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy code// 基本数据类型</span><br><span class="line">let a = 10;</span><br><span class="line">let b = a;</span><br><span class="line">a = 20;</span><br><span class="line">console.log(b); // 输出 10，b的值不受a的影响</span><br><span class="line"></span><br><span class="line">// 引用数据类型</span><br><span class="line">let obj1 = &#123; name: &#x27;John&#x27; &#125;;</span><br><span class="line">let obj2 = obj1;</span><br><span class="line">obj1.name = &#x27;Alice&#x27;;</span><br><span class="line">console.log(obj2.name); // 输出 &#x27;Alice&#x27;，obj2和obj1引用同一个对象</span><br></pre></td></tr></table></figure>

<p>在理解JavaScript的数据类型时，要注意基本数据类型和引用数据类型的区别，以及它们在内存中的存储方式。</p>
<h4 id="90-轮播的实现原理-假如一个页面上有两个轮播，你会怎么实现"><a href="#90-轮播的实现原理-假如一个页面上有两个轮播，你会怎么实现" class="headerlink" title="90.轮播的实现原理?假如一个页面上有两个轮播，你会怎么实现?"></a>90.轮播的实现原理?假如一个页面上有两个轮播，你会怎么实现?</h4><p>轮播是一种常见的前端组件，实现原理可以简要描述如下：</p>
<ol>
<li>HTML结构：轮播通常由一个容器元素包裹多个轮播项元素（图片或其他内容）组成。</li>
<li>CSS样式：通过CSS样式设置容器元素的宽度和高度，使轮播项在容器中水平排列，并设置overflow:hidden，隐藏超出容器范围的轮播项。</li>
<li>JavaScript逻辑：轮播的核心逻辑是实现轮播项的切换。可以通过定时器、事件绑定或者其他交互方式触发切换效果。</li>
</ol>
<p>具体实现步骤：</p>
<ol>
<li>在HTML中创建轮播容器和轮播项：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">htmlCopy code&lt;div class=&quot;carousel&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;carousel-item&quot;&gt;Item 1&lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;carousel-item&quot;&gt;Item 2&lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;carousel-item&quot;&gt;Item 3&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<ol>
<li>使用CSS样式设置轮播容器和轮播项的样式：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cssCopy code.carousel &#123;</span><br><span class="line">  width: 300px;</span><br><span class="line">  height: 200px;</span><br><span class="line">  overflow: hidden;</span><br><span class="line">  position: relative;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.carousel-item &#123;</span><br><span class="line">  width: 300px;</span><br><span class="line">  height: 200px;</span><br><span class="line">  float: left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>使用JavaScript实现轮播效果：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy code// 获取轮播容器和轮播项元素</span><br><span class="line">const carousel = document.querySelector(&#x27;.carousel&#x27;);</span><br><span class="line">const carouselItems = document.querySelectorAll(&#x27;.carousel-item&#x27;);</span><br><span class="line"></span><br><span class="line">let currentIndex = 0; // 当前轮播项索引</span><br><span class="line"></span><br><span class="line">function showNextSlide() &#123;</span><br><span class="line">  currentIndex = (currentIndex + 1) % carouselItems.length;</span><br><span class="line">  carousel.style.transform = `translateX(-$&#123;currentIndex * 300&#125;px)`;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setInterval(showNextSlide, 3000); // 每隔3秒切换一次轮播项</span><br></pre></td></tr></table></figure>

<p>对于页面上有多个轮播的情况，可以根据需求给不同的轮播容器添加不同的类名或id，然后使用相应的选择器进行操作。例如，可以通过类名来选择不同的轮播容器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">htmlCopy code&lt;div class=&quot;carousel carousel1&quot;&gt;</span><br><span class="line">  &lt;!-- 轮播项内容 --&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;carousel carousel2&quot;&gt;</span><br><span class="line">  &lt;!-- 轮播项内容 --&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">javascriptCopy codeconst carousel1 = document.querySelector(&#x27;.carousel1&#x27;);</span><br><span class="line">const carousel2 = document.querySelector(&#x27;.carousel2&#x27;);</span><br><span class="line"></span><br><span class="line">// 实现不同的轮播逻辑</span><br></pre></td></tr></table></figure>



<h4 id="91-解释一下JS的事件循环"><a href="#91-解释一下JS的事件循环" class="headerlink" title="91.解释一下JS的事件循环"></a>91.解释一下JS的事件循环</h4><p>JavaScript的事件循环（Event Loop）是一种用于处理异步操作的机制，它是JavaScript实现异步非阻塞的核心原理。在单线程的JavaScript中，事件循环负责管理任务队列（Task Queue）和执行栈（Execution Stack）。</p>
<p>事件循环的过程如下：</p>
<ol>
<li>执行栈（主线程）：首先，JavaScript代码从上到下依次执行，将同步任务压入执行栈中。</li>
<li>异步任务的注册和执行：当遇到异步任务（例如定时器、网络请求、事件监听等）时，它们不会立即执行，而是将回调函数注册到对应的事件队列中。</li>
<li>任务队列：事件队列分为宏任务队列（Macro Task Queue）和微任务队列（Micro Task Queue）。在每一轮事件循环中，会优先处理微任务队列中的任务。</li>
<li>执行栈清空：当执行栈中的同步任务执行完毕后，JavaScript引擎会检查微任务队列中是否有任务，如果有，就依次执行所有微任务直到微任务队列为空。</li>
<li>宏任务处理：接着，JavaScript引擎会从宏任务队列中选择一个最早进入队列的任务，推入执行栈中执行。这个过程会一直重复，直到所有的任务都被执行完毕。</li>
<li>回到步骤2：当宏任务执行完毕后，JavaScript引擎会再次查看微任务队列，执行所有的微任务。然后，继续从宏任务队列中选择任务执行。</li>
</ol>
<p>在每个宏任务执行完毕后，如果有必要，浏览器会对页面进行重新渲染，然后再开始下一轮事件循环。</p>
<p>常见的微任务有Promise的<code>then</code>、<code>catch</code>和<code>finally</code>，以及<code>MutationObserver</code>。常见的宏任务有定时器（<code>setTimeout</code>、<code>setInterval</code>）、I&#x2F;O操作、DOM事件等。</p>
<p>事件循环的特点是：同步任务先于异步任务执行，异步任务按照注册的顺序依次执行，微任务优先级高于宏任务。</p>
<p>JavaScript的事件循环机制使得我们可以实现非阻塞的异步编程，提高了程序的效率和用户体验。但也需要注意合理使用异步任务，避免出现回调地狱或产生深层嵌套的异步代码。</p>
<h4 id="92-Localstorage、-sessionStorage、-cookie-的区别"><a href="#92-Localstorage、-sessionStorage、-cookie-的区别" class="headerlink" title="92.Localstorage、 sessionStorage、 cookie 的区别"></a>92.Localstorage、 sessionStorage、 cookie 的区别</h4><p>Localstorage、SessionStorage和Cookie是浏览器提供的三种用于在客户端存储数据的方式，它们之间有一些区别：</p>
<ol>
<li>存储时效性：<ul>
<li>Cookie：可以设置过期时间，在过期时间之前一直有效，即使关闭浏览器也不会失效，除非用户手动删除或过期。</li>
<li>LocalStorage：数据永久保存在客户端，除非用户主动删除，否则数据会一直存在。</li>
<li>SessionStorage：数据只在当前会话（当前窗口或标签页）有效，关闭窗口或标签页后数据会被清除。</li>
</ul>
</li>
<li>存储大小：<ul>
<li>Cookie：最大存储大小为4KB。</li>
<li>LocalStorage：最大存储大小为5MB或更大，不同浏览器可能会有所不同。</li>
<li>SessionStorage：最大存储大小也为5MB或更大。</li>
</ul>
</li>
<li>与服务器通信：<ul>
<li>Cookie：每次请求都会携带Cookie，会增加请求的数据量。</li>
<li>LocalStorage和SessionStorage：仅在客户端使用，不会携带到服务器。</li>
</ul>
</li>
<li>API调用：<ul>
<li>Cookie：使用<code>document.cookie</code>进行操作。</li>
<li>LocalStorage和SessionStorage：使用<code>localStorage</code>和<code>sessionStorage</code>进行操作。</li>
</ul>
</li>
<li>共享性：<ul>
<li>Cookie：可以设置为跨域共享。</li>
<li>LocalStorage和SessionStorage：只能在同一域名下共享。</li>
</ul>
</li>
<li>安全性：<ul>
<li>Cookie：由于携带在请求头中，可能被恶意获取，容易遭受跨站脚本攻击（XSS）。</li>
<li>LocalStorage和SessionStorage：不会随着请求携带，但也不是完全安全，也可能受到XSS攻击。</li>
</ul>
</li>
</ol>
<p>基于上述区别，我们可以根据不同的需求选择合适的存储方式：</p>
<ul>
<li>如果需要在不同窗口或标签页中共享数据，且数据较小，可以使用LocalStorage。</li>
<li>如果需要在同一会话中共享数据，可以使用SessionStorage。</li>
<li>如果需要与服务器通信或设置过期时间，可以使用Cookie。但要注意数据大小和安全性问题。</li>
</ul>
<p>一般情况下，LocalStorage和SessionStorage是更常用的客户端存储方式，而Cookie主要用于一些需要与服务器交互的场景。</p>
<h4 id="93-解释一下HTML5DragAPI"><a href="#93-解释一下HTML5DragAPI" class="headerlink" title="93.解释一下HTML5DragAPI"></a>93.解释一下HTML5DragAPI</h4><p>HTML5 Drag API 是 HTML5 中新增的一组 API，用于实现拖拽和拖放功能。它包含了两个主要事件和一些相关的方法和属性，用于在网页中实现元素的拖拽和拖放操作。</p>
<p>主要事件：</p>
<ol>
<li>dragstart：当开始拖动一个元素时触发，可以在此事件中设置要拖动的数据。</li>
<li>dragend：当拖动结束时触发，无论是成功拖放到目标区域还是取消拖放，都会触发该事件。</li>
</ol>
<p>主要方法和属性：</p>
<ol>
<li>setData：在 dragstart 事件中使用，用于设置拖动的数据。</li>
<li>getData：在 dragover 或 drop 事件中使用，用于获取拖动的数据。</li>
<li>setDragImage：在 dragstart 事件中使用，用于设置自定义的拖动图像。</li>
<li>dropEffect：用于设置拖放操作的反馈效果，例如拖动时的鼠标样式。</li>
</ol>
<p>使用 HTML5 Drag API 实现拖拽和拖放功能的基本步骤如下：</p>
<ol>
<li>给需要拖拽的元素添加 dragstart 事件监听器，设置要拖动的数据。</li>
<li>给目标区域添加 dragover 事件监听器，阻止默认行为，并在其中设置 dropEffect。</li>
<li>给目标区域添加 drop 事件监听器，获取拖动的数据并进行相应的处理。</li>
</ol>
<p>HTML5 Drag API 提供了一种原生的方式来实现拖拽和拖放功能，比起传统的拖放实现，它更加灵活和强大，并且能够与其他 HTML5 特性很好地结合使用，提供更好的用户体验和交互效果。</p>
<h4 id="94-解释一下webworker"><a href="#94-解释一下webworker" class="headerlink" title="94.解释一下webworker"></a>94.解释一下webworker</h4><p>Web Worker 是 HTML5 提供的一种在后台运行 JavaScript 的机制，它允许在主线程之外创建一个独立的线程，用于执行耗时的计算或处理大量数据，从而不会阻塞主线程，保持页面的响应性。</p>
<p>主要特点和用法如下：</p>
<ol>
<li>独立线程：Web Worker 在主线程之外运行，拥有自己的全局作用域，不会影响主线程的执行。</li>
<li>无法访问 DOM：由于 Web Worker 在独立线程中运行，因此它无法访问 DOM、BOM 和主线程的变量，也不能直接操作页面元素。</li>
<li>通信：Web Worker 与主线程之间通过消息传递来进行通信。主线程可以向 Web Worker 发送消息，Web Worker 处理后再将结果返回给主线程。</li>
<li>不能同步编程：Web Worker 是异步的，不能像主线程那样通过同步的方式编程，因此不适合处理需要立即响应的用户交互。</li>
<li>文件加载：Web Worker 需要通过一个独立的 JavaScript 文件创建，并且只能加载同源的脚本文件。</li>
</ol>
<p>Web Worker 的创建和使用步骤如下：</p>
<ol>
<li>创建 Web Worker：通过创建一个独立的 JavaScript 文件，并在该文件中编写 Web Worker 的代码。</li>
<li>加载 Web Worker：在主线程中通过调用 <code>new Worker()</code> 方法加载 Web Worker。</li>
<li>通信：主线程通过 <code>postMessage()</code> 方法向 Web Worker 发送消息，Web Worker 通过监听 <code>onmessage</code> 事件接收主线程发送的消息。</li>
<li>处理消息：Web Worker 收到消息后，进行相应的处理，并通过 <code>postMessage()</code> 方法将结果返回给主线程。</li>
</ol>
<p>Web Worker 在处理一些耗时的计算或大量数据处理的任务时非常有用，可以提高页面的性能和用户体验。但需要注意，由于 Web Worker 不能访问 DOM，它只适合用于处理计算密集型的任务，而不适合用于处理需要直接操作页面元素的任务。</p>
<h4 id="95-和-的valueOf和toString-的结果是什么"><a href="#95-和-的valueOf和toString-的结果是什么" class="headerlink" title="95.{} 和[]的valueOf和toString 的结果是什么?"></a>95.{} 和[]的valueOf和toString 的结果是什么?</h4><p>在 JavaScript 中，<code>valueOf</code> 和 <code>toString</code> 是对象的两个方法，用于返回对象的原始值。</p>
<ol>
<li>对于空对象 <code>&#123;&#125;</code> 和空数组 <code>[]</code>：</li>
</ol>
<ul>
<li><code>valueOf</code> 方法返回的是对象本身。</li>
<li><code>toString</code> 方法会将对象转换为字符串。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy codeconst emptyObj = &#123;&#125;;</span><br><span class="line">const emptyArr = [];</span><br><span class="line"></span><br><span class="line">console.log(emptyObj.valueOf()); // 输出：&#123;&#125;</span><br><span class="line">console.log(emptyObj.toString()); // 输出：&quot;[object Object]&quot;</span><br><span class="line"></span><br><span class="line">console.log(emptyArr.valueOf()); // 输出：[]</span><br><span class="line">console.log(emptyArr.toString()); // 输出：&quot;&quot;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，<code>valueOf</code> 方法返回了对象本身，而 <code>toString</code> 方法将对象转换为字符串。对于空数组，<code>toString</code> 方法返回了一个空字符串，因为数组没有任何元素。</p>
<h4 id="96-三种事件模型是什么"><a href="#96-三种事件模型是什么" class="headerlink" title="96.三种事件模型是什么?"></a>96.三种事件模型是什么?</h4><p>JavaScript 中的事件模型分为三种：</p>
<ol>
<li>冒泡事件模型（Bubbling Event Model）：事件从最内层的元素开始触发，然后逐级向上传播，直到根节点。换句话说，事件会沿着 DOM 树从目标元素冒泡到父元素，直到最终到达根节点。</li>
<li>捕获事件模型（Capturing Event Model）：与冒泡事件模型相反，事件从根节点开始触发，然后逐级向下传播，直到目标元素。换句话说，事件会沿着 DOM 树从根节点捕获到目标元素。</li>
<li>DOM0 事件模型：这是最早期的事件模型，它使用 <code>element.onclick</code> 这样的方式来绑定事件。在 DOM0 事件模型中，事件只能通过指定特定的事件处理函数来绑定到元素上。</li>
</ol>
<p>在现代的 Web 开发中，主要使用冒泡事件模型。大多数情况下，我们通过 <code>addEventListener</code> 方法来绑定事件，该方法默认以冒泡模式注册事件。如果需要使用捕获事件模型，可以通过 <code>addEventListener</code> 的第三个参数设置为 <code>true</code> 来实现。</p>
<h4 id="97-介绍一下V8隐藏类"><a href="#97-介绍一下V8隐藏类" class="headerlink" title="97.介绍一下V8隐藏类"></a>97.介绍一下V8隐藏类</h4><p>V8 是 JavaScript 的引擎，由 Google 开发，用于执行 JavaScript 代码。V8 引擎在优化 JavaScript 代码的执行速度方面做了很多工作，其中一个重要的优化技术就是隐藏类（Hidden Class）。</p>
<p>隐藏类是 V8 引擎中用于优化对象访问的一种数据结构。在 JavaScript 中，对象的属性可以动态添加或删除，这就导致了对象的内部结构可能会频繁地变化。为了高效地访问对象的属性，V8 引擎使用隐藏类来跟踪对象的属性结构。</p>
<p>当 V8 引擎第一次创建一个对象时，会生成一个对应的隐藏类，并根据对象的属性结构来初始化这个隐藏类。当对象的属性结构发生变化时（比如添加或删除属性），V8 会创建一个新的隐藏类来反映这种变化。这样，当访问对象的属性时，V8 引擎就可以根据隐藏类的信息快速定位到属性的位置，而不需要遍历整个对象。</p>
<p>隐藏类的使用可以大幅提高对象属性访问的性能，因为它避免了频繁地进行属性搜索。但是需要注意的是，如果对象的属性结构变化过于频繁，V8 引擎可能会频繁地创建新的隐藏类，从而导致一些性能损失。</p>
<p>总结起来，V8 引擎中的隐藏类是一种用于优化对象属性访问的数据结构，它通过跟踪对象的属性结构，帮助 V8 引擎快速定位对象属性，从而提高 JavaScript 代码的执行性能。</p>
<h4 id="98-AMD和CMD规范的区别-说一下CommonJS、AMD和CMD"><a href="#98-AMD和CMD规范的区别-说一下CommonJS、AMD和CMD" class="headerlink" title="98.AMD和CMD规范的区别?说一下CommonJS、AMD和CMD?"></a>98.AMD和CMD规范的区别?说一下CommonJS、AMD和CMD?</h4><p>CommonJS、AMD 和 CMD 都是用于组织和管理 JavaScript 模块的规范。它们在模块加载和定义方面有不同的特点和用法。</p>
<ol>
<li>CommonJS:<ul>
<li>CommonJS 是一种同步加载模块的规范，适用于服务器端开发。</li>
<li>在 CommonJS 中，使用 <code>require()</code> 方法同步加载模块，模块中的代码会立即执行，并将 <code>module.exports</code> 对象返回给调用者。</li>
<li>模块的加载和执行是同步的，适用于在服务器端，因为服务器端通常拥有较快的加载速度。</li>
<li>在浏览器端使用 CommonJS 规范时，需要使用工具（如 Browserify 或 Webpack）将模块转换为符合浏览器环境的代码。</li>
</ul>
</li>
<li>AMD (Asynchronous Module Definition):<ul>
<li>AMD 是一种异步加载模块的规范，适用于浏览器端开发。</li>
<li>在 AMD 中，使用 <code>define()</code> 方法定义模块，使用 <code>require()</code> 方法异步加载模块，模块的加载和执行是异步的，不会阻塞页面加载。</li>
<li>AMD 规范允许在模块加载完成后再执行模块代码，适用于浏览器端，因为浏览器需要异步加载模块，不会阻塞页面渲染。</li>
</ul>
</li>
<li>CMD (Common Module Definition):<ul>
<li>CMD 是一种异步加载模块的规范，类似于 AMD，适用于浏览器端开发。</li>
<li>CMD 和 AMD 的主要区别在于对模块的执行时机有不同的处理方式。</li>
<li>在 CMD 中，使用 <code>define()</code> 方法定义模块，使用 <code>require()</code> 方法异步加载模块，但在加载模块后并不立即执行模块代码，而是等到调用 <code>require()</code> 方法时再执行模块代码。</li>
</ul>
</li>
</ol>
<p>综上所述，CommonJS 是一种同步加载模块的规范，适用于服务器端开发；AMD 和 CMD 是一种异步加载模块的规范，适用于浏览器端开发。在浏览器端开发中，AMD 和 CMD 都可以实现模块的异步加载，但它们对于模块的定义和执行时机有所不同。常见的模块加载器如 RequireJS 遵循 AMD 规范，而 SeaJS 遵循 CMD 规范。在实际开发中，根据项目需求和开发习惯选择合适的模块化规范和模块加载器。</p>
<h4 id="99-谈谈JS的运行机制"><a href="#99-谈谈JS的运行机制" class="headerlink" title="99.谈谈JS的运行机制"></a>99.谈谈JS的运行机制</h4><p>JavaScript 的运行机制主要涉及以下几个方面：</p>
<ol>
<li>解析器（Parser）：解析器是 JavaScript 引擎的一部分，它负责将 JavaScript 代码转换为可执行的内部表示（通常是抽象语法树 AST 或字节码）。</li>
<li>执行上下文（Execution Context）：执行上下文是 JavaScript 运行时的一个抽象概念，用于管理代码的执行。每当 JavaScript 代码执行时，都会创建一个执行上下文，并将其推入执行上下文栈（Execution Context Stack）中。</li>
<li>作用域（Scope）：作用域是一套规则，用于确定在何处以及如何查找变量。JavaScript 采用词法作用域（Lexical Scope），即变量的作用域由它们在代码中的位置决定。</li>
<li>闭包（Closure）：当一个函数内部的函数引用了外部函数的变量时，就创建了一个闭包。闭包允许在函数执行后继续访问其作用域中的变量。</li>
<li>事件循环（Event Loop）：事件循环是 JavaScript 实现异步编程的关键机制。JavaScript 是单线程的，但通过事件循环可以处理异步任务，避免阻塞主线程。</li>
</ol>
<p>JavaScript 运行机制可以简单概括为以下步骤：</p>
<ol>
<li>解析器解析 JavaScript 代码，创建全局执行上下文，并将全局执行上下文推入执行上下文栈。</li>
<li>全局执行上下文中的代码开始执行，遇到函数调用时，会创建新的执行上下文，并将其推入执行上下文栈。</li>
<li>函数内部的代码开始执行，根据词法作用域规则查找变量，并创建闭包（如果有需要）。</li>
<li>在执行过程中，如果遇到异步任务（例如定时器、事件监听、Ajax 请求等），会将异步任务放入事件队列（Event Queue）中。</li>
<li>当全局执行上下文和所有函数执行上下文执行完毕后，事件循环开始工作。它会从事件队列中取出异步任务，放入执行栈中执行。</li>
<li>异步任务执行完毕后，对应的回调函数会被调用，从而继续执行相应的逻辑。</li>
</ol>
<p>这样，通过事件循环和回调函数，JavaScript 实现了非阻塞式的异步编程，从而可以处理各种异步任务，提高了程序的响应性和性能。</p>
<h2 id="Vue生态"><a href="#Vue生态" class="headerlink" title="Vue生态"></a>Vue生态</h2><h4 id="1-说说你对Vue的理解，有何优缺点"><a href="#1-说说你对Vue的理解，有何优缺点" class="headerlink" title="1.说说你对Vue的理解，有何优缺点?"></a>1.说说你对Vue的理解，有何优缺点?</h4><p>Vue是一种流行的JavaScript前端框架，用于构建交互性强、响应式的单页面应用（SPA）和复杂的用户界面。它具有以下优点和缺点：</p>
<p>优点：</p>
<ol>
<li>简单易学：Vue的设计非常简洁，易于学习和上手。它提供了清晰的API和文档，使得开发者可以快速掌握并使用Vue进行开发。</li>
<li>响应式数据绑定：Vue使用双向数据绑定来保持数据和视图之间的同步。当数据发生变化时，视图会自动更新，大大简化了数据驱动视图的过程。</li>
<li>组件化开发：Vue采用了组件化的架构，将用户界面划分为多个可重用和独立的组件。这样可以提高代码的可维护性和复用性，使开发过程更加模块化。</li>
<li>轻量级：Vue的体积相对较小，加载速度快，对于移动端和性能要求较高的应用来说，这是一个优势。</li>
<li>生态系统丰富：Vue拥有强大的生态系统，包括Vue Router用于管理路由、Vuex用于状态管理、Vue CLI用于快速搭建项目等。这些工具和插件使得Vue更加灵活和强大。</li>
<li>渐进式框架：Vue被设计为渐进式框架，允许开发者逐步引入Vue的功能，可以与现有项目或其他框架很好地集成。</li>
</ol>
<p>缺点：</p>
<ol>
<li>小团队：相比于Angular和React，Vue的团队相对较小。尽管社区非常活跃，但由于团队规模有限，可能会导致一些功能更新的延迟。</li>
<li>生态系统相对较新：虽然Vue的生态系统不断发展，但与React和Angular相比，它的生态系统可能还相对较新和不成熟。</li>
<li>兼容性问题：由于Vue使用了一些现代的Web技术，可能会导致在一些旧版本的浏览器中出现兼容性问题。但是，这在现代项目中已经不再是主要问题。</li>
<li>插件质量不一：尽管Vue拥有丰富的插件和库，但有些插件的质量可能不一，需要开发者选择合适的插件。</li>
</ol>
<p>总的来说，Vue是一款优秀的前端框架，它的简洁、响应式数据绑定、组件化开发等特性使得开发者可以更高效地构建现代化的Web应用。然而，根据具体的项目需求和团队情况，选择合适的框架是很重要的。</p>
<h4 id="2-Vue和React有什么不同"><a href="#2-Vue和React有什么不同" class="headerlink" title="2.Vue和React有什么不同?"></a>2.Vue和React有什么不同?</h4><p>Vue 和 React 是两个流行的前端框架，它们有很多相似之处，同时也有一些不同点。以下是 Vue 和 React 的主要不同之处：</p>
<ol>
<li><strong>模板语法 vs JSX：</strong><ul>
<li>Vue 使用模板语法，通过在模板中使用指令（如 v-if、v-for 等）来操作 DOM 和渲染数据。</li>
<li>React 使用 JSX，将组件的结构和逻辑写在 JavaScript 中，通过类似于 HTML 的语法来描述 UI。</li>
</ul>
</li>
<li><strong>数据绑定和响应式系统：</strong><ul>
<li>Vue 使用双向数据绑定，通过 v-model 指令实现数据的自动双向同步。</li>
<li>React 使用单向数据流，数据流动是单向的，通过 props 来向子组件传递数据，通过 state 来管理组件的状态。</li>
</ul>
</li>
<li><strong>组件通信：</strong><ul>
<li>在 Vue 中，组件之间可以通过 props、自定义事件（$emit）以及 Vuex（状态管理库）进行通信。</li>
<li>在 React 中，组件之间通常通过 props 进行通信，也可以使用 Context API、Redux（状态管理库）等进行状态共享。</li>
</ul>
</li>
<li><strong>生命周期：</strong><ul>
<li>Vue 和 React 都有生命周期，但名称和使用方式上有所不同。Vue 的生命周期钩子是一些特定的函数名，例如 created、mounted 等。React 使用 useEffect Hook 来处理副作用，代替了传统的生命周期钩子。</li>
</ul>
</li>
<li><strong>过滤器和插槽：</strong><ul>
<li>在 Vue 中，可以使用过滤器（filters）来格式化数据，也可以使用插槽（slots）来插入内容到组件中。</li>
<li>在 React 中，没有直接的过滤器的概念，通常使用纯函数或其他库来处理数据。而 React 的插槽可以通过 props 来实现，称为 render props 或者 children props。</li>
</ul>
</li>
<li><strong>状态管理：</strong><ul>
<li>在 Vue 中，可以使用 Vuex 进行全局状态管理。</li>
<li>在 React 中，可以使用 Context API 或 Redux 进行全局状态管理。</li>
</ul>
</li>
<li><strong>学习曲线：</strong><ul>
<li>Vue 的学习曲线相对较低，容易上手，特别适合初学者。</li>
<li>React 的学习曲线较陡峭，对于有一定 JavaScript 和编程经验的开发者更容易上手。</li>
</ul>
</li>
</ol>
<p>总的来说，Vue 和 React 都是优秀的前端框架，选择使用哪个取决于个人喜好、团队经验和项目需求。Vue 更注重简洁和易用，适合快速开发；React 更注重灵活性和组件化，适合复杂的应用场景。</p>
<h4 id="3-什么是虚拟DOM"><a href="#3-什么是虚拟DOM" class="headerlink" title="3.什么是虚拟DOM?"></a>3.什么是虚拟DOM?</h4><p>虚拟DOM（Virtual DOM）是一种编程概念和技术，用于优化前端框架的性能和更新渲染的效率。它是由React框架首先引入并广泛使用的，后来也被其他框架如Vue等采用。</p>
<p>在传统的前端开发中，当数据发生变化时，直接操作实际的DOM（Document Object Model）来进行更新和重新渲染。这种操作可能会导致频繁的DOM操作，而DOM操作是相对较慢的，特别是在大型、复杂的应用中，频繁的DOM操作会严重影响性能。</p>
<p>虚拟DOM的核心思想是：不直接操作实际的DOM，而是先在内存中创建一个虚拟的DOM树，这个虚拟DOM树与实际DOM树一一对应。当数据发生变化时，首先更新虚拟DOM，然后通过算法将新的虚拟DOM与旧的虚拟DOM进行比较，找出变化的部分，最后只更新变化的部分到实际的DOM树上。这样避免了直接操作实际DOM的频繁性，大大提高了更新和渲染的效率。</p>
<p>虚拟DOM的优势在于：</p>
<ol>
<li>提高性能：通过批量更新和局部更新，减少实际DOM操作，提高了渲染性能和响应速度。</li>
<li>简化开发：开发者不需要手动操作DOM来更新页面，而是通过操作数据和虚拟DOM来实现更新，简化了开发过程。</li>
<li>跨平台：由于虚拟DOM的中间层，使得框架可以在不同的平台上使用，如浏览器、移动端、服务器等。</li>
<li>方便调试：虚拟DOM可以提供更好的调试工具和开发者工具，方便追踪更新和渲染过程。</li>
</ol>
<p>虚拟DOM虽然带来了很多优势，但也并非没有成本。由于引入了虚拟DOM层，会占用一定的内存和计算资源。但在大多数情况下，虚拟DOM带来的性能提升远远大于其本身的开销，因此被广泛应用于现代的前端框架中。</p>
<h4 id="4-描述下vue的生命周期有哪些-分别做了什么事情"><a href="#4-描述下vue的生命周期有哪些-分别做了什么事情" class="headerlink" title="4.描述下vue的生命周期有哪些?分别做了什么事情?"></a>4.描述下vue的生命周期有哪些?分别做了什么事情?</h4><p>Vue的生命周期是组件在创建、更新和销毁过程中触发的一系列钩子函数。这些钩子函数允许开发者在不同的生命周期阶段执行自定义逻辑。Vue的生命周期可以分为以下几个阶段：</p>
<ol>
<li>创建阶段（Creation）：<ul>
<li>beforeCreate：在实例刚刚被创建，数据观测和事件还未初始化。此时无法访问组件的数据和方法。</li>
<li>created：在实例已经完成数据观测和事件初始化，但尚未挂载到DOM上。此时组件的数据和方法已经可以使用。</li>
<li>beforeMount：在组件挂载到DOM之前被调用。此时模板编译完成，但尚未将组件插入到页面中。</li>
</ul>
</li>
<li>挂载阶段（Mounting）：<ul>
<li>mounted：在组件挂载到DOM后被调用。此时组件已经被插入到页面中，可以访问到DOM元素。</li>
</ul>
</li>
<li>更新阶段（Updating）：<ul>
<li>beforeUpdate：在组件数据更新之前被调用。此时数据还未更新，DOM也还未重新渲染。</li>
<li>updated：在组件数据更新后被调用。此时数据已更新，DOM也已重新渲染。</li>
</ul>
</li>
<li>销毁阶段（Destruction）：<ul>
<li>beforeDestroy：在组件销毁之前被调用。此时组件仍然可用，可以执行一些清理工作。</li>
<li>destroyed：在组件销毁后被调用。此时组件已被销毁，事件监听和数据观测都已被移除。</li>
</ul>
</li>
</ol>
<p>在这些生命周期钩子函数中，beforeCreate和created用于初始化组件的数据和方法，beforeMount和mounted用于处理DOM相关的操作，beforeUpdate和updated用于处理数据更新后的操作，beforeDestroy和destroyed用于清理资源和执行一些清理工作。</p>
<p>在实际开发中，可以根据需要在不同的生命周期阶段使用这些钩子函数来执行一些逻辑，比如在created阶段发起网络请求，或者在beforeDestroy阶段清除定时器等。了解和使用Vue的生命周期可以帮助我们更好地掌握组件的创建、更新和销毁过程，从而更好地优化和管理Vue应用。</p>
<h4 id="5-watch-怎么深度监听对象变化"><a href="#5-watch-怎么深度监听对象变化" class="headerlink" title="5.watch 怎么深度监听对象变化"></a>5.watch 怎么深度监听对象变化</h4><p>在Vue中，通过<code>watch</code>选项可以对组件的数据进行监听，当数据变化时触发相应的操作。默认情况下，<code>watch</code>只会对对象的引用进行浅层比较，即只会检测对象的第一层属性变化。如果要深度监听对象的变化，可以通过设置<code>deep</code>选项为<code>true</code>来实现。</p>
<p>在上述示例中，我们在<code>watch</code>选项中定义了一个对<code>myObject</code>的深度监听。当点击按钮后，<code>myObject</code>的属性a和属性b发生变化时，<code>watch</code>中的<code>handler</code>函数将会被调用，并输出新值和旧值。由于我们设置了<code>deep: true</code>，所以Vue会递归遍历<code>myObject</code>的所有嵌套属性，深度监听对象的变化。</p>
<p>需要注意的是，深度监听对象的变化会带来一定的性能损耗，因为Vue需要递归遍历对象的所有属性。因此，只有在必要时才使用<code>deep: true</code>。在大多数情况下，浅层监听已经足够满足需求。</p>
<h4 id="6-删除数组用delete和Vue-delete有什么区别"><a href="#6-删除数组用delete和Vue-delete有什么区别" class="headerlink" title="6.删除数组用delete和Vue.delete有什么区别?"></a>6.删除数组用delete和Vue.delete有什么区别?</h4><p>在JavaScript中，删除数组元素通常有两种方法：使用<code>delete</code>操作符和使用<code>splice</code>方法。而在Vue中，还可以使用<code>Vue.delete</code>方法来删除数组元素。</p>
<p>1.使用<code>delete</code>操作符：</p>
<ul>
<li><code>delete</code>操作符用于删除对象的属性，在数组中删除元素时，并不会改变数组的长度，而是将删除元素的位置设置为<code>undefined</code>。这样可能导致数组出现稀疏（sparse）的情况，即数组中有一些位置的值是<code>undefined</code>，而不是真正的元素。例如：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const arr = [1, 2, 3, 4];</span><br><span class="line">delete arr[1]; // arr变为 [1, undefined, 3, 4]</span><br></pre></td></tr></table></figure>

<p>2.使用<code>splice</code>方法：</p>
<ul>
<li><code>splice</code>方法用于删除数组中的元素，并且会改变数组的长度。它可以接收两个参数，第一个参数是删除元素的起始位置，第二个参数是要删除的元素个数。例如：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy codeconst arr = [1, 2, 3, 4];</span><br><span class="line">arr.splice(1, 1); // arr变为 [1, 3, 4]</span><br></pre></td></tr></table></figure>

<p>3.使用<code>Vue.delete</code>方法：</p>
<ul>
<li>在Vue中，如果要删除数组中的元素，特别是响应式数组（由Vue进行数据劫持），应该使用<code>Vue.delete</code>方法。<code>Vue.delete</code>方法是专门用于在Vue响应式数组中删除元素的。它能够正确地更新视图和响应式数据，确保删除元素后页面正确地更新。例如：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy codeconst vm = new Vue(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    arr: [1, 2, 3, 4],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Vue.delete(vm.arr, 1); // arr变为 [1, 3, 4]</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li><code>delete</code>操作符适用于普通数组，但不会对Vue的响应式数组进行正确处理，可能会导致不符合预期的结果。</li>
<li><code>splice</code>方法适用于普通数组，并且可以在Vue的响应式数组中使用，但需要手动更新视图和响应式数据。</li>
<li><code>Vue.delete</code>方法是专门用于Vue响应式数组的删除操作，它会正确处理视图和响应式数据，推荐在Vue中使用。</li>
</ul>
<h4 id="7-watch-和computed有什么区别"><a href="#7-watch-和computed有什么区别" class="headerlink" title="7.watch 和computed有什么区别?"></a>7.watch 和computed有什么区别?</h4><p><code>watch</code>和<code>computed</code>是Vue中用于监听数据变化的两种不同的方式，它们有以下区别：</p>
<ol>
<li>用途：<ul>
<li><code>watch</code>：用于监听指定的数据变化，当被监听的数据发生变化时，触发相应的回调函数执行自定义的操作。</li>
<li><code>computed</code>：用于计算衍生的数据（计算属性），它根据其他响应式数据的值计算而来，并且会将计算结果缓存起来，只有依赖的数据发生变化时才会重新计算。</li>
</ul>
</li>
<li>返回值：<ul>
<li><code>watch</code>：没有返回值，仅用于监听数据变化，不会返回计算结果。</li>
<li><code>computed</code>：有返回值，返回计算属性的结果，计算结果会被缓存，多次访问同一计算属性时，不会重新计算。</li>
</ul>
</li>
<li>监听方式：<ul>
<li><code>watch</code>：可以监听一个或多个数据的变化，也可以通过<code>deep</code>选项深度监听对象或数组的变化。</li>
<li><code>computed</code>：依赖于其他响应式数据，当被依赖的数据发生变化时，计算属性会自动更新。</li>
</ul>
</li>
<li>使用场景：<ul>
<li><code>watch</code>：适用于对数据变化做一些复杂或异步处理的场景，例如监听输入框的输入，然后进行实时搜索；监听数组的变化，然后触发网络请求等。</li>
<li><code>computed</code>：适用于根据已有的响应式数据计算出一个新的值，例如计算商品总价、过滤、排序等。</li>
</ul>
</li>
</ol>
<p>示例代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">htmlCopy code&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;input v-model=&quot;name&quot; /&gt;</span><br><span class="line">    &lt;p&gt;计算属性：&#123;&#123; fullName &#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      name: &#x27;&#x27;,</span><br><span class="line">      lastName: &#x27;Doe&#x27;,</span><br><span class="line">      firstName: &#x27;John&#x27;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    name(newVal, oldVal) &#123;</span><br><span class="line">      console.log(&#x27;输入框的值发生变化：&#x27;, newVal, oldVal);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    fullName() &#123;</span><br><span class="line">      return this.firstName + &#x27; &#x27; + this.lastName;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>watch</code>用于监听输入框的值变化，<code>computed</code>用于计算全名。每次输入框的值发生变化时，<code>watch</code>会触发回调函数输出变化的值，而<code>computed</code>会自动计算新的全名，并且只有在<code>firstName</code>和<code>lastName</code>发生变化时才会重新计算全名。</p>
<h4 id="8-v-for没有key会发生什么问题"><a href="#8-v-for没有key会发生什么问题" class="headerlink" title="8.v-for没有key会发生什么问题?"></a>8.v-for没有key会发生什么问题?</h4><p>如果在使用<code>v-for</code>指令时没有设置<code>key</code>，Vue会发出一个警告，提示开发者最好为每个<code>v-for</code>循环提供一个唯一的<code>key</code>值。虽然不设置<code>key</code>并不会导致错误，但它可能会引发一些不希望出现的问题：</p>
<ol>
<li>重复利用DOM元素：Vue使用<code>key</code>来跟踪虚拟DOM中每个节点的身份，在每次<code>v-for</code>更新时，通过<code>key</code>来判断哪些元素需要更新、删除或新增。如果没有<code>key</code>，Vue无法区分各个元素，可能会出现重复利用DOM元素的情况，导致不正确的渲染结果。</li>
<li>错误的更新行为：没有设置<code>key</code>时，Vue可能会出现意外的更新行为。例如，某个数据项被删除了，但没有设置<code>key</code>，导致Vue无法正确识别删除的元素，从而可能导致删除操作没有生效或产生错误的渲染结果。</li>
<li>性能问题：没有设置<code>key</code>可能导致Vue在更新时需要对所有元素进行比较和重新渲染，而不是根据<code>key</code>来识别哪些元素是相同的。这会导致不必要的性能开销，特别是在大型列表中。</li>
</ol>
<p>因此，为每个<code>v-for</code>循环提供一个唯一的<code>key</code>是一个良好的实践。通常，推荐使用具有唯一标识符的属性作为<code>key</code>，例如数据中的<code>id</code>属性。这样可以确保每个元素在循环中具有唯一的标识，避免可能出现的问题，并优化Vue的更新性能。示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">htmlCopy code&lt;div v-for=&quot;item in items&quot; :key=&quot;item.id&quot;&gt;</span><br><span class="line">  &lt;!-- 循环内容 --&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>



<h4 id="9-谈谈Vue双向绑定原理"><a href="#9-谈谈Vue双向绑定原理" class="headerlink" title="9.谈谈Vue双向绑定原理"></a>9.谈谈Vue双向绑定原理</h4><p>Vue的双向绑定是其核心特性之一，它使得数据和视图之间保持同步，让开发者能够更便捷地处理用户输入和数据更新。Vue的双向绑定原理主要依赖于以下两个机制：</p>
<ol>
<li>数据劫持和观察者模式：<ul>
<li>当Vue实例化时，会对数据进行劫持（Object.defineProperty或Proxy），通过劫持数据的<code>get</code>和<code>set</code>方法，在数据被访问或修改时触发相应的操作。这样Vue就能够捕获到对数据的访问和修改，并进行响应。</li>
<li>Vue还实现了观察者模式（Observer），通过定义一个Dep（Dependency）依赖管理器来收集依赖（观察者）和通知变化。每个数据属性都会有一个对应的Watcher观察者对象，当数据发生变化时，观察者会收到通知并更新视图。</li>
</ul>
</li>
<li>模板编译：<ul>
<li>Vue使用模板编译将模板（template）转换为渲染函数（render function）。渲染函数是一个函数，它接收数据并返回虚拟DOM（Virtual DOM）。</li>
<li>在模板编译的过程中，会解析模板中的指令（如v-bind、v-on、v-model等），当遇到v-model指令时，会将数据属性和表单元素进行绑定。</li>
<li>在绑定过程中，对于表单元素，会监听其<code>input</code>事件，当用户输入时触发<code>input</code>事件，然后更新数据属性的值。同时，对于数据属性，也会在<code>set</code>方法中触发更新视图的操作。</li>
</ul>
</li>
</ol>
<p>综合上述机制，当用户输入表单元素时，会触发<code>input</code>事件，更新绑定的数据属性的值；而数据属性的更新又会触发观察者的通知，通知相关的Watcher进行更新操作，最终更新视图。这样就实现了双向绑定，数据的变化会影响视图的更新，同时视图的变化也会反过来影响数据。</p>
<p>需要注意的是，Vue的双向绑定是基于数据劫持和观察者模式实现的，而并非真正的双向绑定。真正的双向绑定是在数据变化时，视图会自动更新，同时在视图变化时，数据也会自动更新。而Vue的双向绑定是通过触发事件和更新机制来实现的，并非实时的自动双向同步。</p>
<h4 id="10-v-model-是什么-有什么用呢"><a href="#10-v-model-是什么-有什么用呢" class="headerlink" title="10.v-model 是什么?有什么用呢?"></a>10.v-model 是什么?有什么用呢?</h4><p><code>v-model</code>是Vue.js提供的一个指令，用于在表单元素和数据之间建立双向数据绑定。它是Vue中实现双向绑定的一种简便方式。</p>
<p>使用<code>v-model</code>指令，可以将表单元素的值和Vue实例的数据属性绑定在一起。当用户在表单元素上输入数据时，<code>v-model</code>会自动将用户的输入更新到Vue实例的对应数据属性中；同时，当Vue实例的数据属性发生变化时，<code>v-model</code>也会自动将更新的数据反映到表单元素上，保持数据和视图之间的同步。</p>
<p><code>v-model</code>可以用在常见的表单元素上，如文本输入框、多行文本框、复选框、单选按钮和下拉框等。根据不同的表单元素类型，<code>v-model</code>的使用方式略有不同。</p>
<p>例如，对于文本输入框，可以这样使用<code>v-model</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">htmlCopy code&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; v-model=&quot;message&quot; /&gt;</span><br><span class="line">    &lt;p&gt;输入的内容：&#123;&#123; message &#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      message: &#x27;&#x27;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>v-model=&quot;message&quot;</code>将文本输入框和Vue实例的<code>message</code>数据属性进行了双向绑定。当用户在文本输入框中输入内容时，<code>message</code>会自动更新为输入的内容，并且在页面上展示出来；反之，当<code>message</code>的值发生变化时，文本输入框的内容也会相应地更新。</p>
<p><code>v-model</code>使得数据的输入和展示变得简单高效，能够方便地处理用户输入和数据更新，是Vue.js中一个非常实用的特性。</p>
<h4 id="11-在vue项目中如何引入第三方库-有哪些具体操作方法"><a href="#11-在vue项目中如何引入第三方库-有哪些具体操作方法" class="headerlink" title="11.在vue项目中如何引入第三方库?有哪些具体操作方法?"></a>11.在vue项目中如何引入第三方库?有哪些具体操作方法?</h4><p>在Vue项目中引入第三方库可以通过以下几种具体操作方法：</p>
<ol>
<li><p>使用CDN链接：</p>
<ul>
<li>对于一些常用的第三方库，可以直接使用CDN链接来引入，将链接添加到项目的HTML文件中。例如，在<code>index.html</code>文件中添加以下代码：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;!-- 引入第三方库的CDN链接 --&gt;</span><br><span class="line">  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br></pre></td></tr></table></figure>

<p>这样就可以直接在项目中使用Vue库了。</p>
</li>
<li><p>使用npm安装并导入：</p>
<ul>
<li>对于一些复杂或需要频繁使用的第三方库，可以使用npm进行安装，然后在需要的地方通过<code>import</code>或<code>require</code>语句来导入。例如，使用npm安装axios库：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install axios</span><br></pre></td></tr></table></figure>

<p>在需要使用axios的地方导入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 使用ES6的import语法</span><br><span class="line">import axios from &#x27;axios&#x27;;</span><br><span class="line"></span><br><span class="line">// 或者使用CommonJS的require语法</span><br><span class="line">// const axios = require(&#x27;axios&#x27;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用Vue插件：</p>
<ul>
<li>一些第三方库为了在Vue项目中更方便地使用，可能会提供Vue插件的形式。通过引入Vue插件，可以将库集成到Vue实例中，使得在Vue组件中更加方便地使用该库的功能。具体使用方法可以查看第三方库的文档。</li>
</ul>
</li>
<li><p>使用全局变量：</p>
<ul>
<li>一些第三方库可能在引入后会在全局环境中暴露一个全局变量，可以直接在Vue组件中使用该全局变量。例如，在<code>index.html</code>中引入第三方库：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">htmlCopy code&lt;head&gt;</span><br><span class="line">  &lt;!-- 引入第三方库 --&gt;</span><br><span class="line">  &lt;script src=&quot;path/to/library.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br></pre></td></tr></table></figure>

<p>然后在Vue组件中使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy codeexport default &#123;</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    // 使用全局变量来调用第三方库的功能</span><br><span class="line">    libraryFunction();</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>以上是引入第三方库的几种常见方法，具体使用哪种方法取决于第三方库的提供方式以及项目的需求。在引入第三方库时，建议查阅相应库的文档以了解具体的用法和配置。</p>
<h4 id="12-Vue3-0-里为什么要用Proxy-API替代defineProperty-API"><a href="#12-Vue3-0-里为什么要用Proxy-API替代defineProperty-API" class="headerlink" title="12.Vue3.0 里为什么要用Proxy API替代defineProperty API?"></a>12.Vue3.0 里为什么要用Proxy API替代defineProperty API?</h4><p>Vue 3.0 使用 Proxy API 替代 defineProperty API 的主要原因是 Proxy API 具有更强大的功能和更好的性能，能够更好地满足 Vue 的响应式系统的需求。</p>
<ol>
<li><strong>功能更强大：</strong> Proxy API 相比于 defineProperty API，提供了更丰富的拦截方法。通过 Proxy，可以拦截更多种类的操作，包括对属性的读取、赋值、删除等，还可以拦截函数的调用和构造函数的调用等。这使得 Vue 3.0 的响应式系统更加灵活和全面。</li>
<li><strong>更直观：</strong> Proxy API 的用法更直观和简洁，不需要像 defineProperty API 那样深入研究属性描述符，只需要定义一个处理器对象，通过拦截方法来定义对目标对象的操作行为。这样使得代码更易于理解和维护。</li>
<li><strong>性能更好：</strong> Proxy API 拥有更好的性能。在 defineProperty API 中，对于每个属性需要逐个设置 getter 和 setter，对于大量属性的对象，会产生较大的开销。而 Proxy API 只需要创建一个代理对象，通过处理器对象来统一处理所有的操作，避免了逐个设置属性的开销，性能更高。</li>
<li><strong>嵌套属性处理：</strong> Proxy API 对于深层嵌套的属性具有更好的处理能力。在 defineProperty API 中，对于深层嵌套的属性需要逐层设置 getter 和 setter，而 Proxy API 可以一次性拦截所有层次的属性访问和操作。</li>
</ol>
<p>总体而言，Proxy API 提供了更现代和强大的响应式机制，使得 Vue 3.0 的响应式系统更加高效、灵活和易用。通过使用 Proxy API，Vue 3.0 实现了更优雅的响应式数据追踪机制，为开发者提供了更好的开发体验和性能优势。</p>
<h4 id="13-Vue3-0-编译做了哪些优化"><a href="#13-Vue3-0-编译做了哪些优化" class="headerlink" title="13.Vue3.0 编译做了哪些优化?"></a>13.Vue3.0 编译做了哪些优化?</h4><p>Vue 3.0 在编译方面进行了一系列优化，旨在提高编译性能和减少生成的代码量。以下是 Vue 3.0 在编译方面做的一些优化：</p>
<ol>
<li><strong>静态标记（Static Markup）：</strong> Vue 3.0 使用了静态标记来标记那些静态节点和属性，这些静态节点和属性在每次重新渲染时都不会发生变化。通过静态标记，Vue 3.0 在每次渲染时可以跳过这些静态节点和属性的比对过程，减少了渲染的时间和开销。</li>
<li><strong>hoist 静态节点（静态提升）：</strong> Vue 3.0 在编译过程中会将一些静态节点提升到 render 函数的外部，这样可以避免在每次渲染时重新创建这些静态节点，从而减少了生成的代码量和渲染的开销。</li>
<li><strong>Patch Flag（补丁标记）：</strong> Vue 3.0 使用 Patch Flag 来标记那些需要进行比对的节点类型和属性。通过 Patch Flag，Vue 3.0 可以在进行 DOM 操作时跳过对不需要比对的节点的处理，减少了比对的时间和开销。</li>
<li><strong>Block Tree（块级树）：</strong> Vue 3.0 使用 Block Tree 来表示模板中的块级元素，例如 v-for 和 v-if。Block Tree 可以更精确地表示模板的结构，减少了不必要的操作和生成的代码量。</li>
<li><strong>静态提升（静态节点编译）：</strong> Vue 3.0 通过静态提升将静态节点从模板中剥离出来，使得每次渲染只需要处理动态节点，减少了渲染的开销。</li>
<li><strong>源码优化：</strong> Vue 3.0 在编译器的源码上进行了优化和重构，使得编译器更加高效和灵活。</li>
</ol>
<p>总体而言，Vue 3.0 在编译方面进行了多方面的优化，从静态标记、hoist 静态节点到 Patch Flag 和 Block Tree，都使得编译过程更高效，生成的代码更精简，减少了运行时的开销，提高了应用的性能。这些编译优化使得 Vue 3.0 成为一个更加高效和现代的前端框架，为开发者提供更好的开发体验和用户体验。</p>
<h4 id="14-Vue3-0-新特性一-Composition-API与React-js中Hooks的异同点"><a href="#14-Vue3-0-新特性一-Composition-API与React-js中Hooks的异同点" class="headerlink" title="14.Vue3.0 新特性一-Composition API与React.js中Hooks的异同点"></a>14.Vue3.0 新特性一-Composition API与React.js中Hooks的异同点</h4><p>Vue 3.0 的 Composition API 与 React.js 中的 Hooks 具有一些相似之处，同时也有一些不同点。下面是它们的异同点：</p>
<p><strong>相似点：</strong></p>
<ol>
<li><strong>逻辑复用：</strong> 两者都可以通过抽取逻辑到自定义函数中，实现逻辑的复用。在 Vue 3.0 中，Composition API 允许开发者将组件的逻辑划分为多个功能性模块，从而更好地组织和重用代码。而 React.js 的 Hooks 也提供了各种 Hook 函数（如 useState、useEffect 等）来实现逻辑的复用。</li>
<li><strong>无需嵌套：</strong> 在 Vue 3.0 的 Composition API 和 React.js 的 Hooks 中，可以在函数组件中直接使用这些功能，无需嵌套。</li>
<li><strong>可读性：</strong> 两者都可以使代码更具可读性，因为相关逻辑被分组到自定义函数中，从而使组件更加简洁。</li>
</ol>
<p><strong>不同点：</strong></p>
<ol>
<li><strong>API 名称：</strong> Vue 3.0 使用的是 Composition API，而 React.js 使用的是 Hooks。虽然名称不同，但实质上都是实现了逻辑复用的功能。</li>
<li><strong>状态管理：</strong> 在 Vue 3.0 的 Composition API 中，可以使用 reactive 和 ref 来处理组件的响应式状态。而 React.js 的 Hooks 则使用 useState 来处理状态。React.js 的 useContext 和 useReducer 等 Hook 也提供了更灵活的状态管理方式。</li>
<li><strong>生命周期：</strong> 在 Vue 3.0 的 Composition API 中，可以通过 onMounted、onUpdated、onUnmounted 等函数来代替 Vue 2.x 中的生命周期钩子。React.js 的 useEffect Hook 可以用来处理组件的副作用，相当于 Vue 2.x 中的生命周期钩子的合并。</li>
<li><strong>跨组件状态共享：</strong> 在 Vue 3.0 的 Composition API 中，可以使用 provide 和 inject 来实现组件之间的状态共享。而 React.js 通过 useContext 来实现类似的跨组件状态共享。</li>
</ol>
<p>总的来说，Vue 3.0 的 Composition API 和 React.js 的 Hooks 都提供了逻辑复用的能力，并且让组件代码更具可读性。它们在某些方面有一些不同的实现，但都是为了让开发者能够更好地组织和重用组件逻辑。</p>
<h4 id="15-Vue3-0-如何变得更快的-dom-diff-算法有何优化"><a href="#15-Vue3-0-如何变得更快的-dom-diff-算法有何优化" class="headerlink" title="15.Vue3.0 如何变得更快的? dom diff 算法有何优化?"></a>15.Vue3.0 如何变得更快的? dom diff 算法有何优化?</h4><p>Vue 3.0 通过一系列优化来提高性能，其中 DOM Diff 算法也得到了优化。以下是 Vue 3.0 在提高性能方面的一些措施和 DOM Diff 算法的优化：</p>
<ol>
<li><strong>虚拟 DOM 的优化：</strong> Vue 3.0 使用了更高效的虚拟 DOM 实现，通过静态标记、hoist 静态节点和优化的 Patch 策略，减少了虚拟 DOM 的创建和比对的成本，提高了渲染性能。</li>
<li><strong>编译器优化：</strong> Vue 3.0 中的编译器进行了改进，生成更优化的渲染函数代码，减少了生成的代码量，提高了编译性能。</li>
<li><strong>响应式系统优化：</strong> Vue 3.0 中的响应式系统进行了重写，使用 Proxy 代替 Object.defineProperty，使得响应式数据的追踪更加高效和精确，减少了响应式系统的开销。</li>
<li><strong>Tree-shaking 支持：</strong> Vue 3.0 支持 Tree-shaking，通过标记组件、指令和编译器的来源，使得打包时只包含使用到的代码，减少了打包体积，提高了性能。</li>
<li><strong>Fragment 支持：</strong> Vue 3.0 支持使用 Fragment（片段）渲染多个根节点，减少了不必要的 DOM 包裹，提高了渲染性能。</li>
<li><strong>合并事件监听器优化：</strong> Vue 3.0 在合并事件监听器时进行了优化，避免了不必要的监听器合并，减少了事件处理的开销。</li>
<li><strong>缓存事件处理器：</strong> Vue 3.0 对事件处理器进行了缓存，减少了重复创建和销毁事件处理器的开销。</li>
<li><strong>事件侦听器优化：</strong> Vue 3.0 对事件侦听器进行了优化，减少了事件侦听器的数量，提高了性能。</li>
<li><strong>更新算法优化：</strong> Vue 3.0 在组件更新算法上进行了优化，减少了不必要的更新操作，提高了更新性能。</li>
</ol>
<p>总体而言，Vue 3.0 在性能方面进行了全面的优化和改进，从虚拟 DOM 到响应式系统，再到编译器和打包支持，都使得应用的性能得到显著提升。这些优化使得 Vue 3.0 成为一个更加高效、快速和现代的前端框架，带来更好的用户体验和开发体验。</p>
<h4 id="16-vue-要做权限管理该怎么做-如果控制到按钮级别的权限怎么做"><a href="#16-vue-要做权限管理该怎么做-如果控制到按钮级别的权限怎么做" class="headerlink" title="16.vue 要做权限管理该怎么做?如果控制到按钮级别的权限怎么做?"></a>16.vue 要做权限管理该怎么做?如果控制到按钮级别的权限怎么做?</h4><p>在 Vue 中进行权限管理，通常可以采用以下几种方法：</p>
<ol>
<li><strong>路由权限管理：</strong> 在路由定义时，根据用户的角色或权限信息来动态生成可访问的路由，只加载用户有权限的路由组件。这样可以在页面级别进行权限控制，用户无权限的页面将无法访问。</li>
<li><strong>组件级别权限控制：</strong> 在组件内部根据用户的角色或权限信息来动态显示或隐藏组件中的某些内容。这可以通过 v-if 或 v-show 指令来实现。</li>
<li><strong>按钮级别权限控制：</strong> 对于按钮级别的权限控制，可以在组件内部根据用户的角色或权限信息，动态决定是否显示或禁用按钮。这可以通过 v-if 或 v-show 指令来实现，或者通过绑定 disabled 属性来禁用按钮。</li>
<li><strong>权限指令：</strong> 自定义一个权限指令，通过传入用户的角色或权限信息和目标权限，判断用户是否有权限操作某个元素。如果用户没有权限，可以隐藏或禁用元素。例如，在指令中使用 Vue.directive 钩子来进行权限控制。</li>
<li><strong>权限管理插件：</strong> 使用现有的权限管理插件，例如 vue-router、v-permission 等，来实现权限管理。这些插件通常提供了方便的配置和管理权限的方式。</li>
</ol>
<p>在以上方法中，路由权限管理是最常见且较为常用的方法，它能够有效地控制页面级别的权限，保护用户不应该访问的页面。组件级别和按钮级别权限控制则可以更细粒度地控制页面内的操作权限。无论选择哪种方法，都需要在前端和后端进行配合，前端控制显示和操作的权限，后端进行数据和接口的访问权限控制，以保障整体系统的安全性。</p>
<h4 id="17-vue-在created和mounted这两个生命周期中请求数据有什么区别呢"><a href="#17-vue-在created和mounted这两个生命周期中请求数据有什么区别呢" class="headerlink" title="17.vue 在created和mounted这两个生命周期中请求数据有什么区别呢?"></a>17.vue 在created和mounted这两个生命周期中请求数据有什么区别呢?</h4><p>在 Vue 组件的生命周期中，<code>created</code>和<code>mounted</code>是两个常用的生命周期钩子函数，它们分别在组件实例创建和组件挂载到页面上时触发。在这两个生命周期中请求数据的主要区别如下：</p>
<ol>
<li><strong>触发时机：</strong><ul>
<li><code>created</code>生命周期在组件实例创建后立即触发，此时组件的实例已经创建，但尚未挂载到页面上，DOM 还没有生成。</li>
<li><code>mounted</code>生命周期在组件挂载到页面后触发，此时组件已经被添加到页面中，DOM 元素已经生成，可以进行DOM相关的操作。</li>
</ul>
</li>
<li><strong>适用场景：</strong><ul>
<li><code>created</code>适用于在组件实例创建后，进行一些初始化的操作，例如设置默认数据、创建定时器、绑定事件监听器等。此时还不能进行依赖于DOM的操作，因为DOM还没有生成。</li>
<li><code>mounted</code>适用于在组件已经挂载到页面后，进行DOM相关的操作，例如获取DOM元素、操作DOM元素、请求数据等。因为在<code>mounted</code>生命周期中，DOM已经生成，可以安全地进行DOM操作。</li>
</ul>
</li>
<li><strong>数据请求：</strong><ul>
<li>在<code>created</code>生命周期中，可以发起数据请求，但需要注意异步请求的处理。因为<code>created</code>生命周期中的异步请求是在组件创建期间进行的，如果数据请求耗时较长，可能会导致组件在挂载前还未完成，页面上无法显示请求的数据。</li>
<li>在<code>mounted</code>生命周期中，可以安全地发起数据请求，并对请求结果进行处理。此时，组件已经挂载到页面上，可以确保请求的数据能够正确显示在页面中。</li>
</ul>
</li>
</ol>
<p>总结：在<code>created</code>生命周期中可以进行一些初始化操作，但需要注意异步请求的处理；在<code>mounted</code>生命周期中，可以进行DOM相关的操作和数据请求，因为此时组件已经挂载到页面上，可以安全地进行DOM操作和显示数据。根据需求的不同，选择适合的生命周期钩子来请求数据和进行其他操作，可以使组件的逻辑更加清晰和合理。</p>
<h4 id="18-说说你对Proxy的理解。"><a href="#18-说说你对Proxy的理解。" class="headerlink" title="18.说说你对Proxy的理解。"></a>18.说说你对Proxy的理解。</h4><p>Proxy是JavaScript的一个高级特性，它是ES6引入的一个内置对象，用于创建一个代理对象，可以拦截对目标对象的访问和操作。通过Proxy，我们可以在目标对象上定义自定义的行为，实现对对象的拦截、过滤、监听等操作，从而实现更加灵活和高级的编程模式。</p>
<p>Proxy 对象的创建需要两个参数：目标对象（target）和一个处理器对象（handler）。处理器对象是一个包含各种拦截方法的对象，用于定义对目标对象的各种操作的自定义行为。</p>
<p>Proxy 支持的拦截方法包括：</p>
<ol>
<li><code>get(target, property, receiver)</code>: 拦截对目标对象属性的读取操作。</li>
<li><code>set(target, property, value, receiver)</code>: 拦截对目标对象属性的赋值操作。</li>
<li><code>has(target, property)</code>: 拦截对in操作符的操作。</li>
<li><code>deleteProperty(target, property)</code>: 拦截对delete操作符的操作。</li>
<li><code>apply(target, thisArg, argumentsList)</code>: 拦截函数的调用操作。</li>
<li><code>construct(target, argumentsList, newTarget)</code>: 拦截对构造函数的调用操作。</li>
<li>等等…</li>
</ol>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jsCopy codeconst target = &#123;</span><br><span class="line">  name: &#x27;John&#x27;,</span><br><span class="line">  age: 30,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const handler = &#123;</span><br><span class="line">  get(target, property) &#123;</span><br><span class="line">    console.log(`读取属性：$&#123;property&#125;`);</span><br><span class="line">    return target[property];</span><br><span class="line">  &#125;,</span><br><span class="line">  set(target, property, value) &#123;</span><br><span class="line">    console.log(`设置属性：$&#123;property&#125;，值：$&#123;value&#125;`);</span><br><span class="line">    target[property] = value;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const proxy = new Proxy(target, handler);</span><br><span class="line"></span><br><span class="line">console.log(proxy.name); // 读取属性：name，输出：John</span><br><span class="line">proxy.age = 31; // 设置属性：age，值：31</span><br><span class="line">console.log(proxy.age); // 读取属性：age，输出：31</span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们使用Proxy创建了一个代理对象proxy，并定义了一个处理器对象handler来拦截对target对象的读取和设置属性操作。通过Proxy，我们可以在控制台输出读取和设置属性的信息。</p>
<p>Proxy 在前端开发中广泛应用于数据劫持、数据监听、表单校验、数据代理等场景。它提供了一种强大的机制，使得开发者可以对目标对象的访问和操作进行自定义处理，从而实现更加灵活和强大的编程功能。</p>
<h4 id="19-Vue3-0性能提升主要是体现在哪些方面"><a href="#19-Vue3-0性能提升主要是体现在哪些方面" class="headerlink" title="19.Vue3.0性能提升主要是体现在哪些方面?"></a>19.Vue3.0性能提升主要是体现在哪些方面?</h4><p>Vue 3.0 在性能方面主要体现在以下几个方面：</p>
<ol>
<li><strong>虚拟 DOM 优化：</strong> Vue 3.0 在虚拟 DOM 层面进行了优化，通过使用静态标记和hoist静态节点等技术，减少了虚拟 DOM 的创建和比对的成本，提高了渲染性能。</li>
<li><strong>编译器优化：</strong> Vue 3.0 中的编译器进行了改进，生成更优化的渲染函数代码，减少了生成的代码量，提高了编译性能。</li>
<li><strong>响应式系统优化：</strong> Vue 3.0 中的响应式系统进行了重写，使用 Proxy 代替 Object.defineProperty，使得响应式数据的追踪更加高效和精确，减少了响应式系统的开销。</li>
<li><strong>Tree-shaking 支持：</strong> Vue 3.0 支持 Tree-shaking，通过标记组件、指令和编译器的来源，使得打包时只包含使用到的代码，减少了打包体积，提高了性能。</li>
<li><strong>组件初始化优化：</strong> Vue 3.0 在组件初始化阶段进行了优化，通过标记组件内部的静态节点，减少了组件的初始化时间，提高了渲染性能。</li>
<li><strong>合并事件监听器：</strong> Vue 3.0 在合并事件监听器时进行了优化，避免了不必要的监听器合并，减少了事件处理的开销。</li>
<li><strong>Fragment 支持：</strong> Vue 3.0 支持使用 Fragment（片段）渲染多个根节点，减少了不必要的 DOM 包裹，提高了渲染性能。</li>
<li><strong>新的异步组件：</strong> Vue 3.0 中支持 Suspense（占位符）和异步组件，使得异步加载组件更加高效和灵活。</li>
</ol>
<p>总体而言，Vue 3.0 在性能方面进行了全面的优化和改进，从虚拟 DOM 到响应式系统，再到编译器和打包支持，都使得应用的性能得到显著提升。这些优化使得 Vue 3.0 成为一个更加高效、快速和现代的前端框架，带来更好的用户体验和开发体验。</p>
<h4 id="20-vue3有哪些新的组件"><a href="#20-vue3有哪些新的组件" class="headerlink" title="20.vue3有哪些新的组件?"></a>20.vue3有哪些新的组件?</h4><p>在 Vue 3 中，并没有新增特定的组件，因为 Vue 3 的主要改进集中在性能优化、Composition API、Tree-shaking 支持以及一些语法上的变化。Vue 3 主要聚焦于整体框架的改进和优化，而没有新增大量的特定组件。</p>
<p>然而，Vue 3 引入了一些新的特性和语法，让组件的编写更加灵活和方便。例如：</p>
<ol>
<li><strong>Fragment（片段）：</strong> Vue 3 中支持使用<code>&lt;template&gt;</code>标签作为片段，允许在不需要额外包裹 DOM 元素的情况下渲染多个根节点。</li>
<li><strong>Teleport（传送门）：</strong> Vue 3 中引入了 Teleport 特性，允许开发者在组件外部渲染内容，例如弹出窗口等。</li>
<li><strong>Suspense（占位符）：</strong> Vue 3 中支持使用<code>&lt;suspense&gt;</code>标签来处理异步组件的占位符和错误处理。</li>
<li><strong>v-model 改进：</strong> Vue 3 中的 v-model 支持自定义组件中的多个值绑定，通过<code>v-model:value</code>和<code>v-model:xxx</code>进行绑定。</li>
<li><strong>新的事件 API：</strong> Vue 3 中引入了新的事件 API，使用<code>emits</code>选项来替代 Vue 2 中的<code>$listeners</code>和<code>$emit</code>。</li>
<li><strong>全局 API 修改：</strong> Vue 3 中修改了全局 API 的名称，例如<code>Vue.directive</code>变为<code>app.directive</code>，<code>Vue.mixin</code>变为<code>app.mixin</code>。</li>
</ol>
<p>需要注意的是，虽然 Vue 3 没有新增大量特定的组件，但是它在整体性能和开发体验方面带来了许多改进，使得开发者能够更轻松地构建高性能、灵活和可维护的应用程序。同时，Vue 3 也提供了更多新特性和优化，让开发者能够更好地利用 Vue.js 的功能。</p>
<h4 id="21-Vue2-0-和Vue3-0有什么区别"><a href="#21-Vue2-0-和Vue3-0有什么区别" class="headerlink" title="21.Vue2.0 和Vue3.0有什么区别?"></a>21.Vue2.0 和Vue3.0有什么区别?</h4><p>Vue 3.0 是 Vue.js 框架的一个重大升级版本，带来了一系列的改进和新增功能。以下是 Vue 2.0 和 Vue 3.0 的主要区别：</p>
<ol>
<li><strong>性能优化：</strong> Vue 3.0 通过优化虚拟 DOM 和编译器，提高了渲染性能，包括更高效的响应式系统和更少的内存使用。</li>
<li><strong>Composition API：</strong> Vue 3.0 引入了 Composition API，允许开发者将组件的逻辑划分为多个功能性模块，更好地组织和重用代码，取代了 Vue 2.0 中的 Options API。</li>
<li><strong>Tree-shaking 支持：</strong> Vue 3.0 使得项目更容易进行 Tree-shaking，减少了项目的体积，提高了性能。</li>
<li><strong>Fragments：</strong> Vue 3.0 支持 Fragments（片段），可以在不需要额外包裹 DOM 元素的情况下渲染多个根节点。</li>
<li><strong>Teleport（传送门）：</strong> Vue 3.0 引入了 Teleport，允许开发者在组件外部渲染内容，例如弹出窗口等。</li>
<li><strong>全局 API 修改：</strong> Vue 3.0 修改了全局 API 的名称，例如<code>Vue.directive</code>变为<code>app.directive</code>，<code>Vue.mixin</code>变为<code>app.mixin</code>。</li>
<li><strong>v-model 的改进：</strong> Vue 3.0 中的 v-model 支持自定义组件中的多个值绑定，通过<code>v-model:value</code>和<code>v-model:xxx</code>进行绑定。</li>
<li><strong>Fragment 标签变更：</strong> Vue 3.0 中 Fragment 使用的标签变更为<code>&lt;template&gt;</code>，而不再是 Vue 2.0 中的特殊标签<code>&lt;fragment&gt;</code>。</li>
<li><strong>新增事件 API：</strong> Vue 3.0 引入了新的事件 API，使用<code>emits</code>选项来替代 Vue 2.0 中的<code>$listeners</code>和<code>$emit</code>。</li>
<li><strong>全局API Tree-shaking：</strong> Vue 3.0 支持全局API的按需导入，减少了打包体积。</li>
</ol>
<p>需要注意的是，虽然 Vue 3.0 带来了很多改进，但与 Vue 2.0 相比，它在某些方面可能不兼容，因此在升级到 Vue 3.0 时，需要仔细阅读官方的升级指南和文档，确保代码能够平稳迁移到新版本。</p>
<h4 id="22-Composition-Api与Options-Api有什么不同"><a href="#22-Composition-Api与Options-Api有什么不同" class="headerlink" title="22.Composition Api与Options Api有什么不同?"></a>22.Composition Api与Options Api有什么不同?</h4><p>Composition API 和 Options API 是 Vue.js 中两种不同的组件编写风格。</p>
<p>Options API 是 Vue.js 2.x 默认使用的组件编写方式，它通过一个选项对象来定义组件的数据、方法、生命周期钩子等。</p>
<p>示例（Options API）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">htmlCopy code&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;button @click=&quot;increment&quot;&gt;Increment&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      message: &#x27;Hello&#x27;,</span><br><span class="line">      count: 0,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    increment() &#123;</span><br><span class="line">      this.count++;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>Composition API 是 Vue.js 3.x 引入的一种新的组件编写方式，它将组件的逻辑划分为多个功能性的模块，使得逻辑复用更加灵活和方便。</p>
<p>示例（Composition API）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">htmlCopy code&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;button @click=&quot;increment&quot;&gt;Increment&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; reactive, ref &#125; from &#x27;vue&#x27;;</span><br><span class="line"></span><br><span class="line">const state = reactive(&#123;</span><br><span class="line">  message: &#x27;Hello&#x27;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">const count = ref(0);</span><br><span class="line"></span><br><span class="line">function increment() &#123;</span><br><span class="line">  count.value++;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>主要的不同点有：</p>
<ol>
<li>组织代码方式：<ul>
<li>Options API 将组件的选项（data、methods、computed等）放在一个对象中，组织代码较为传统，但随着组件逻辑的复杂化，可能导致代码臃肿。</li>
<li>Composition API 将组件的逻辑拆分为功能性的模块，使得代码更具可读性和维护性，特别适用于大型复杂组件。</li>
</ul>
</li>
<li>响应式数据：<ul>
<li>Options API 使用 <code>data</code> 函数来定义组件的响应式数据，需要通过 <code>this</code> 来访问。</li>
<li>Composition API 使用 <code>reactive</code> 或 <code>ref</code> 来定义响应式数据，使得响应式定义更加灵活和直观。</li>
</ul>
</li>
<li>生命周期钩子：<ul>
<li>Options API 使用生命周期钩子函数来处理组件的生命周期事件，代码较为分散。</li>
<li>Composition API 使用 <code>setup</code> 函数来处理组件的生命周期，使得逻辑集中在一个地方，更易于理解和管理。</li>
</ul>
</li>
<li>逻辑复用：<ul>
<li>Options API 使用 mixins 来实现逻辑复用，但可能导致命名冲突和难以追踪问题。</li>
<li>Composition API 通过函数模块化的方式实现逻辑复用，更加灵活和可控，没有命名冲突的问题。</li>
</ul>
</li>
</ol>
<p>总体而言，Composition API 提供了更灵活、组织更清晰的组件编写方式，特别适合大型复杂组件或希望更好地组织代码的场景。而 Options API 仍然是合法的，对于一些简单组件或者遗留项目，Options API 仍然可以继续使用。</p>
<h4 id="23-对Vue项目你做过哪些性能优化"><a href="#23-对Vue项目你做过哪些性能优化" class="headerlink" title="23.对Vue项目你做过哪些性能优化?"></a>23.对Vue项目你做过哪些性能优化?</h4><p>作为AI语言模型，我没有直接参与实际的Vue项目，无法进行具体的性能优化。但是，我可以提供一些常见的Vue项目性能优化策略，供你参考：</p>
<ol>
<li>使用Vue的异步组件：将页面按需加载，减少首次加载的资源量，提高页面加载速度。</li>
<li>使用路由懒加载：将路由页面拆分为多个异步加载的模块，只在需要时加载，避免一次性加载过多的页面代码。</li>
<li>合理使用v-if和v-show：v-if在条件满足时才会渲染元素，v-show通过CSS控制元素的显示与隐藏。根据场景选择合适的指令来优化渲染性能。</li>
<li>避免不必要的响应式数据：只将必要的数据声明为响应式，避免过多的数据监听和响应，提高性能。</li>
<li>使用Object.freeze()：对于静态数据对象，使用Object.freeze()冻结对象，避免响应式系统对其进行深度监听，提高性能。</li>
<li>合理使用v-for：避免在v-for中使用复杂的表达式，尽量避免频繁地操作DOM。</li>
<li>使用key属性：在v-for循环中使用key属性，帮助Vue跟踪每个节点的身份，优化列表渲染性能。</li>
<li>避免不必要的计算属性和监听器：只在必要时使用计算属性和监听器，避免无谓的计算开销。</li>
<li>使用Vue Devtools：使用Vue Devtools工具来分析组件的性能瓶颈和调试问题。</li>
<li>使用缓存：对于重复的计算或API请求，使用缓存来避免重复计算和请求，减少服务器负担。</li>
<li>图片优化：对图片进行压缩和懒加载，减少页面加载时间。</li>
<li>服务端渲染（SSR）：对于SEO要求较高的项目，可以考虑使用服务端渲染，提高首屏渲染速度。</li>
</ol>
<p>这些优化策略并不是全部，实际项目中可能需要根据具体情况进行更多的优化。性能优化是一个持续的过程，需要不断地进行监测和改进，以提供更好的用户体验。</p>
<h4 id="24-Vue组件通信的方式有哪些"><a href="#24-Vue组件通信的方式有哪些" class="headerlink" title="24.Vue组件通信的方式有哪些?"></a>24.Vue组件通信的方式有哪些?</h4><p>Vue组件通信有以下几种方式：</p>
<ol>
<li>父子组件通信：通过props和$emit实现父组件向子组件传递数据和子组件向父组件发送事件。</li>
<li>子组件访问父组件：通过this.$parent可以在子组件中访问父组件的数据和方法。</li>
<li>使用事件总线：创建一个Vue实例作为事件总线，在任意组件中使用$on和$emit来进行事件的监听和触发，实现非父子组件之间的通信。</li>
<li>使用Vuex：Vuex是Vue的状态管理库，用于在应用中管理共享状态。通过Vuex可以在任意组件中访问和修改全局状态，实现组件之间的数据共享和通信。</li>
<li>使用$refs：在父组件中通过ref属性给子组件添加引用，在父组件中可以直接通过this.$refs访问子组件的数据和方法。</li>
<li>使用provide和inject：在Vue 2.2.0及以上版本中，可以使用provide和inject来实现祖先组件向后代组件传递数据。</li>
<li>使用$attrs和$listeners：在Vue 2.4.0及以上版本中，可以通过$attrs和$listeners来实现父组件向子组件传递属性和事件监听器。</li>
</ol>
<p>不同的场景和需求可能会选择不同的通信方式。在简单的父子组件通信中，props和$emit是最常用的方式。对于大规模复杂应用，使用Vuex进行状态管理可能更为合适。使用事件总线可以在非父子组件之间进行灵活的通信，而使用provide和inject可以在祖先和后代组件之间传递数据。选择适当的通信方式可以使代码结构更加清晰和维护性更好。</p>
<h4 id="25-Vue常用的修饰符有哪些"><a href="#25-Vue常用的修饰符有哪些" class="headerlink" title="25.Vue常用的修饰符有哪些?"></a>25.Vue常用的修饰符有哪些?</h4><p>在Vue中，修饰符是在指令后面使用的特殊标记，用于修改指令的行为或添加额外的功能。以下是Vue常用的修饰符：</p>
<ol>
<li><p><code>.prevent</code>：阻止默认事件的触发，相当于调用<code>event.preventDefault()</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;a v-on:click.prevent=&quot;doSomething&quot;&gt;Click Me&lt;/a&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>.stop</code>：阻止事件冒泡，相当于调用<code>event.stopPropagation()</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div @click.stop=&quot;handleDivClick&quot;&gt;</span><br><span class="line">  &lt;button @click=&quot;handleButtonClick&quot;&gt;Button&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>.capture</code>：添加事件侦听器时使用事件捕获模式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div @click.capture=&quot;handleDivClick&quot;&gt;</span><br><span class="line">  &lt;button @click=&quot;handleButtonClick&quot;&gt;Button&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>.self</code>：只当事件是从触发事件的元素自身触发时才触发回调。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div @click.self=&quot;handleDivClick&quot;&gt;</span><br><span class="line">  &lt;button @click=&quot;handleButtonClick&quot;&gt;Button&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>.once</code>：指令只会触发一次，然后自动解绑。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;button @click.once=&quot;handleButtonClick&quot;&gt;Click Me&lt;/button&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>.native</code>：监听组件根元素的原生事件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;my-custom-component @click.native=&quot;handleClick&quot;&gt;&lt;/my-custom-component&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>.passive</code>：告诉浏览器该事件监听器不会调用<code>event.preventDefault()</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div @scroll.passive=&quot;handleScroll&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>这些修饰符可以组合使用，例如：<code>@click.stop.prevent</code>用于阻止默认事件和阻止事件冒泡。使用修饰符可以在不改变事件处理函数逻辑的情况下，灵活地调整事件的行为，提高代码的可读性和维护性。</p>
<p>还有v-model中的lazy，trim，</p>
<p>绑定的 message 总是string类型，即使在我们设置 type 为 number 也是 string 类型</p>
<p>如果希望转换为数字类型，那么可以使用 .number 修饰符：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> v-model.<span class="property">number</span>=<span class="string">&quot;counter&quot;</span>&gt;</span><br></pre></td></tr></table></figure>

<p>在进行逻辑判断时，如果是一个string和数字类型对比，在可以转化的情况下会进行隐式转换</p>
<p>但typeof 查询的还是字符类型</p>
<h4 id="26-Vue中的-nextTick有什么作用-底层如何实现"><a href="#26-Vue中的-nextTick有什么作用-底层如何实现" class="headerlink" title="26.Vue中的$nextTick有什么作用?底层如何实现?"></a>26.Vue中的$nextTick有什么作用?底层如何实现?</h4><p><code>$nextTick</code>是Vue.js提供的一个方法，用于在DOM更新之后执行回调函数。它的作用是在当前代码执行周期结束后，等待DOM更新完成，然后执行回调函数，以确保在更新后对DOM进行操作或获取最新的DOM状态。</p>
<p><code>$nextTick</code>的主要作用有：</p>
<ol>
<li>更新后DOM操作：当需要在Vue实例数据发生变化后对DOM进行操作时，使用<code>$nextTick</code>可以确保DOM已经更新，避免出现获取旧的DOM状态的情况。</li>
<li>异步操作：Vue中的数据更新和DOM更新是异步进行的。使用<code>$nextTick</code>可以在下一次DOM更新之后执行回调，保证回调函数中的代码执行时已经是最新的DOM状态。</li>
</ol>
<p>底层实现原理：</p>
<p>在底层，<code>$nextTick</code>的实现利用了JavaScript中的微任务（Microtask）。微任务是一种高优先级的任务，它会在当前执行周期的末尾执行，而在下一个事件循环之前完成。这使得在微任务中执行的回调函数可以在DOM更新之后执行。</p>
<p>具体实现原理如下：</p>
<ol>
<li>当调用<code>$nextTick(callback)</code>时，Vue会将<code>callback</code>函数添加到一个队列中，标记为需要执行的回调。</li>
<li>在当前执行周期的末尾，当所有同步代码执行完毕后，JavaScript引擎会检查是否有微任务需要执行。</li>
<li>如果有微任务（即<code>$nextTick</code>的回调），则执行微任务队列中的所有回调函数。</li>
<li>等待微任务执行完毕后，下一个事件循环开始，此时DOM更新已经完成，回调函数中的代码可以获取到最新的DOM状态。</li>
</ol>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">htmlCopy code&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;button @click=&quot;updateMessage&quot;&gt;更新消息&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      message: &#x27;Hello&#x27;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    updateMessage() &#123;</span><br><span class="line">      // 更新数据</span><br><span class="line">      this.message = &#x27;Updated Message&#x27;;</span><br><span class="line"></span><br><span class="line">      // 在DOM更新后执行回调函数</span><br><span class="line">      this.$nextTick(() =&gt; &#123;</span><br><span class="line">        // 获取更新后的DOM状态</span><br><span class="line">        const updatedElement = document.querySelector(&#x27;p&#x27;);</span><br><span class="line">        console.log(updatedElement.textContent); // Output: &quot;Updated Message&quot;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，当点击按钮更新数据后，我们使用<code>$nextTick</code>来确保在DOM更新之后执行回调函数。这样就可以获取到更新后的DOM状态，避免在数据更新后立即获取到旧的DOM状态。</p>
<h4 id="27-v-show和v-if有什么区别"><a href="#27-v-show和v-if有什么区别" class="headerlink" title="27.v-show和v-if有什么区别?"></a>27.v-show和v-if有什么区别?</h4><p><code>v-show</code> 和 <code>v-if</code> 都是 Vue.js 中用于条件渲染的指令，但它们有不同的工作原理和适用场景。</p>
<p><strong><code>v-show</code>：</strong></p>
<ul>
<li><code>v-show</code> 是一种 CSS 属性控制的条件渲染指令。</li>
<li>当表达式的值为真（truthy）时，元素会被设置为 <code>display: block</code>，从而显示在页面上。</li>
<li>当表达式的值为假（falsy）时，元素会被设置为 <code>display: none</code>，从而在页面上隐藏。</li>
<li>即使元素被隐藏，它依然在 DOM 中保留着，并且不会被销毁和重新创建，因此切换时的开销较小。</li>
<li>适用于频繁切换显示和隐藏的情况。</li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">htmlCopy code</span><br><span class="line">&lt;div v-show=&quot;isShown&quot;&gt;This is shown with v-show&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p><strong><code>v-if</code>：</strong></p>
<ul>
<li><code>v-if</code> 是一种条件渲染指令，根据表达式的值来动态地添加或移除元素。</li>
<li>当表达式的值为真（truthy）时，元素会被添加到 DOM 中，从而显示在页面上。</li>
<li>当表达式的值为假（falsy）时，元素会从 DOM 中移除，从而在页面上隐藏。</li>
<li>在切换时，会销毁和重新创建元素，因此切换时的开销较大。</li>
<li>适用于在渲染时不经常改变的内容。</li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">htmlCopy code</span><br><span class="line">&lt;div v-if=&quot;shouldBeRendered&quot;&gt;This is rendered with v-if&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p><strong>选择使用 <code>v-show</code> 还是 <code>v-if</code> 取决于实际需求：</strong></p>
<ul>
<li>如果元素的显示状态频繁变化（例如：通过按钮点击切换显示），而且元素内容不会改变，则可以使用 <code>v-show</code>，因为它只是简单地控制 <code>display</code> 属性，切换时的开销较小。</li>
<li>如果元素的显示状态较少改变（例如：根据用户权限显示不同内容），或者元素内容会频繁改变（例如：列表根据条件动态加载），则建议使用 <code>v-if</code>，因为它会根据表达式动态添加或移除元素，切换时的开销较大但可以减少不必要的渲染和内存占用。</li>
</ul>
<h4 id="28-有用过keep-alive吗-它有什么作用"><a href="#28-有用过keep-alive吗-它有什么作用" class="headerlink" title="28.有用过keep-alive吗? 它有什么作用?"></a>28.有用过keep-alive吗? 它有什么作用?</h4><p>是的，我有使用过<code>keep-alive</code>在Vue.js中。<code>keep-alive</code>是Vue.js提供的一个内置组件，用于缓存和重用组件，以提高性能和用户体验。它的主要作用是在组件切换时保持组件的状态，而不是在组件被切换到其他页面时销毁和重新创建。</p>
<p><code>keep-alive</code>组件的工作原理是将组件实例进行缓存，当组件被隐藏时（不在屏幕上显示），它会被保留在内存中。这样，当组件再次被激活或重新显示时，它可以从缓存中快速获取并显示，无需重新渲染或重新初始化。</p>
<p>使用<code>keep-alive</code>的主要优点有：</p>
<ol>
<li>提高性能：通过缓存组件，减少了重新渲染和重新初始化的次数，从而提高了渲染速度和整体性能。</li>
<li>保持状态：当组件被隐藏和重新激活时，它会保留之前的状态，包括数据和用户交互。这有助于在切换页面时无缝保持用户体验，而不会丢失用户输入或操作。</li>
<li>减少API调用：对于从API获取数据或进行复杂计算的组件，使用<code>keep-alive</code>可以避免在组件重新显示时进行重复的API调用和计算。</li>
</ol>
<p>使用示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">htmlCopy code&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;keep-alive&gt;</span><br><span class="line">      &lt;!-- 被包裹在&lt;keep-alive&gt;中的组件会被缓存 --&gt;</span><br><span class="line">      &lt;your-component v-if=&quot;showComponent&quot; /&gt;</span><br><span class="line">    &lt;/keep-alive&gt;</span><br><span class="line"></span><br><span class="line">    &lt;button @click=&quot;toggleComponent&quot;&gt;切换组件&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import YourComponent from &#x27;./YourComponent.vue&#x27;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    YourComponent,</span><br><span class="line">  &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      showComponent: true,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    toggleComponent() &#123;</span><br><span class="line">      this.showComponent = !this.showComponent;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，当<code>showComponent</code>为<code>false</code>时，<code>YourComponent</code>会被缓存并保持在内存中。当<code>showComponent</code>再次为<code>true</code>时，之前缓存的<code>YourComponent</code>实例会被重用，保留了之前的状态。这样，组件不需要重新创建和初始化，提供了更流畅的用户体验。</p>
<h4 id="29-如何实现一个虚拟DOM吗"><a href="#29-如何实现一个虚拟DOM吗" class="headerlink" title="29.如何实现一个虚拟DOM吗?"></a>29.如何实现一个虚拟DOM吗?</h4><p>实现一个完整的虚拟DOM系统是一个复杂的任务，但是可以通过简化的方式来演示其基本原理。下面是一个简化的虚拟DOM实现：</p>
<ol>
<li>定义虚拟DOM节点：<ul>
<li>首先，需要定义一个虚拟DOM节点的数据结构，可以使用JavaScript对象来表示，包含节点类型、属性、子节点等信息。</li>
</ul>
</li>
<li>创建虚拟DOM：<ul>
<li>当需要渲染一个新的视图时，首先根据数据生成虚拟DOM树，将整个视图表示为一个虚拟DOM树的结构。</li>
</ul>
</li>
<li>渲染虚拟DOM：<ul>
<li>将虚拟DOM树渲染成真实的DOM树。可以使用递归遍历虚拟DOM树，创建对应的真实DOM节点，并将其添加到DOM中。</li>
</ul>
</li>
<li>对比和更新：<ul>
<li>当数据发生变化时，会生成一个新的虚拟DOM树。这时，需要对比新旧两棵虚拟DOM树的差异，找出需要更新的节点。</li>
<li>对比可以使用深度优先遍历算法来进行，找出新增、删除和修改的节点。</li>
<li>然后根据差异来更新真实DOM，使其与最新的虚拟DOM树保持一致。</li>
</ul>
</li>
</ol>
<p>简化实现示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy code// 定义虚拟DOM节点</span><br><span class="line">class VNode &#123;</span><br><span class="line">  constructor(tag, props, children) &#123;</span><br><span class="line">    this.tag = tag;</span><br><span class="line">    this.props = props;</span><br><span class="line">    this.children = children;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 创建虚拟DOM</span><br><span class="line">const vnode = new VNode(&#x27;div&#x27;, &#123; class: &#x27;container&#x27; &#125;, [</span><br><span class="line">  new VNode(&#x27;h1&#x27;, &#123; class: &#x27;title&#x27; &#125;, [&#x27;Hello, Virtual DOM&#x27;]),</span><br><span class="line">  new VNode(&#x27;p&#x27;, &#123; class: &#x27;content&#x27; &#125;, [&#x27;This is a simple Virtual DOM implementation.&#x27;]),</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">// 渲染虚拟DOM</span><br><span class="line">function render(vnode) &#123;</span><br><span class="line">  if (typeof vnode === &#x27;string&#x27;) &#123;</span><br><span class="line">    return document.createTextNode(vnode);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const element = document.createElement(vnode.tag);</span><br><span class="line">  for (const key in vnode.props) &#123;</span><br><span class="line">    element.setAttribute(key, vnode.props[key]);</span><br><span class="line">  &#125;</span><br><span class="line">  vnode.children.forEach((child) =&gt; &#123;</span><br><span class="line">    element.appendChild(render(child));</span><br><span class="line">  &#125;);</span><br><span class="line">  return element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 对比和更新</span><br><span class="line">function updateElement(parent, oldVnode, newVnode) &#123;</span><br><span class="line">  if (oldVnode === newVnode) &#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (oldVnode == null) &#123;</span><br><span class="line">    parent.appendChild(render(newVnode));</span><br><span class="line">  &#125; else if (newVnode == null) &#123;</span><br><span class="line">    parent.removeChild(parent.firstChild);</span><br><span class="line">  &#125; else if (oldVnode.tag === newVnode.tag) &#123;</span><br><span class="line">    for (const key in newVnode.props) &#123;</span><br><span class="line">      parent.setAttribute(key, newVnode.props[key]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const oldChildren = Array.from(oldVnode.children);</span><br><span class="line">    const newChildren = Array.from(newVnode.children);</span><br><span class="line">    const commonLength = Math.min(oldChildren.length, newChildren.length);</span><br><span class="line"></span><br><span class="line">    for (let i = 0; i &lt; commonLength; i++) &#123;</span><br><span class="line">      updateElement(parent.childNodes[i], oldChildren[i], newChildren[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (oldChildren.length &gt; newChildren.length) &#123;</span><br><span class="line">      for (let i = commonLength; i &lt; oldChildren.length; i++) &#123;</span><br><span class="line">        updateElement(parent.childNodes[i], oldChildren[i], null);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      for (let i = commonLength; i &lt; newChildren.length; i++) &#123;</span><br><span class="line">        updateElement(parent, null, newChildren[i]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    parent.replaceChild(render(newVnode), parent.firstChild);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 实现简单的数据更新</span><br><span class="line">const root = document.getElementById(&#x27;app&#x27;);</span><br><span class="line">updateElement(root, null, vnode);</span><br><span class="line"></span><br><span class="line">// 模拟数据更新</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">  const newVnode = new VNode(&#x27;div&#x27;, &#123; class: &#x27;container&#x27; &#125;, [</span><br><span class="line">    new VNode(&#x27;h1&#x27;, &#123; class: &#x27;title&#x27; &#125;, [&#x27;Hello, Updated Virtual DOM&#x27;]),</span><br><span class="line">    new VNode(&#x27;p&#x27;, &#123; class: &#x27;content&#x27; &#125;, [&#x27;This is an updated Virtual DOM implementation.&#x27;]),</span><br><span class="line">  ]);</span><br><span class="line">  updateElement(root, vnode, newVnode);</span><br><span class="line">&#125;, 3000);</span><br></pre></td></tr></table></figure>

<p>在上述简化示例中，我们实现了一个简单的虚拟DOM系统。虽然这个实现非常简单，并没有考虑性能优化等复杂情况，但它展示了虚拟DOM的基本原理：通过构建虚拟DOM树来描述视图，对比新旧虚拟DOM树的差异，然后更新真实DOM来保持视图的同步。在实际场景中，虚拟DOM系统会更加复杂和高效。</p>
<h4 id="30-为什么data属性是一个函数而不是一个对象，-具体原因是什么"><a href="#30-为什么data属性是一个函数而不是一个对象，-具体原因是什么" class="headerlink" title="30.为什么data属性是一个函数而不是一个对象， 具体原因是什么?"></a>30.为什么data属性是一个函数而不是一个对象， 具体原因是什么?</h4><p>在Vue中，组件的<code>data</code>属性可以是一个函数，也可以是一个对象。但推荐将<code>data</code>属性设置为一个函数，而不是一个对象。具体原因如下：</p>
<ol>
<li>数据隔离：<ul>
<li>将<code>data</code>设置为函数可以实现数据的隔离。每个组件实例都会有自己独立的数据副本，互不影响。这样可以避免多个组件实例之间共享同一个数据对象导致的数据混乱问题。</li>
</ul>
</li>
<li>数据响应式：<ul>
<li>当<code>data</code>属性是一个函数时，Vue在实例化组件时会将<code>data</code>函数执行，并将其返回的对象转换为响应式的。这样每个组件实例的数据都会成为响应式的，当数据发生变化时，视图会自动更新。</li>
</ul>
</li>
<li>优化性能：<ul>
<li>将<code>data</code>设置为函数还可以优化性能。如果<code>data</code>是一个对象，那么该对象会被所有组件实例共享，即所有实例都指向同一个引用。当一个组件实例修改了该对象的数据时，其他组件实例也会受到影响，可能导致意外的数据变化。</li>
<li>但当<code>data</code>是一个函数时，每个组件实例都会调用<code>data</code>函数获取独立的数据副本，相互之间不会影响，可以更好地保证组件的隔离性和数据独立性。</li>
</ul>
</li>
</ol>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">htmlCopy code&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123; count &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;button @click=&quot;increment&quot;&gt;Increment&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      count: 0,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    increment() &#123;</span><br><span class="line">      this.count++;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>data</code>属性被设置为一个函数，每个组件实例都会调用<code>data</code>函数获取独立的<code>count</code>属性，使得每个组件实例都拥有自己的<code>count</code>数据。这样在不同组件实例之间修改<code>count</code>属性时互不影响，实现了数据的隔离和响应式更新。</p>
<h4 id="31-Vue2的初始化过程你有过了解吗，做了哪些事情"><a href="#31-Vue2的初始化过程你有过了解吗，做了哪些事情" class="headerlink" title="31.Vue2的初始化过程你有过了解吗，做了哪些事情?"></a>31.Vue2的初始化过程你有过了解吗，做了哪些事情?</h4><p>是的，我了解Vue 2的初始化过程。Vue 2的初始化过程涉及几个关键步骤：</p>
<ol>
<li><strong>Vue实例的创建：</strong> 创建新的Vue实例时，它会经历一个初始化过程。在此过程中，Vue会初始化实例的数据、方法、计算属性和生命周期钩子。</li>
<li><strong>数据观察：</strong> Vue使用<code>Object.defineProperty</code>方法来设置数据观察，从而能够跟踪数据属性的变化并触发响应式更新。</li>
<li><strong>模板编译：</strong> Vue将提供给Vue实例的模板编译成一个渲染函数。渲染函数用于生成模板的虚拟DOM（VNode）表示。</li>
<li><strong>虚拟DOM的创建：</strong> Vue创建模板的虚拟DOM（VNode）表示。虚拟DOM是真实DOM结构的轻量级内存表示，用于在数据变化时高效比较和更新真实DOM。</li>
<li><strong>挂载：</strong> 在创建虚拟DOM后，Vue将实例挂载到真实DOM中的特定元素上。通常在创建Vue实例时使用<code>el</code>选项来指定挂载的元素。</li>
<li><strong>渲染和修补：</strong> Vue使用渲染函数触发初始渲染，并从虚拟DOM创建真实DOM树。然后，Vue跟踪数据属性和模板元素之间的依赖关系，每当数据发生变化时，通过“修补”（patching）的过程只更新受影响的DOM部分。</li>
<li><strong>数据响应性：</strong> 当访问或修改数据属性时，Vue的响应性系统会自动检测这些变化，并使用新值更新关联的模板元素。</li>
<li><strong>事件处理：</strong> Vue设置事件监听器来处理用户交互。它还处理指令和其他模板特性，如<code>v-if</code>、<code>v-for</code>等。</li>
<li><strong>生命周期钩子：</strong> Vue在实例的生命周期中特定时刻调用生命周期钩子，如<code>beforeCreate</code>、<code>created</code>、<code>beforeMount</code>、<code>mounted</code>等，允许开发者在组件生命周期的不同阶段插入自定义逻辑。</li>
<li><strong>观察者和依赖：</strong> Vue为每个响应式数据属性创建一个观察者。观察者负责在数据变化时更新关联的模板元素。依赖追踪机制使用依赖（Dep）对象来跟踪数据属性与观察者之间的依赖关系。</li>
</ol>
<p>Vue 2的初始化过程对于创建一个完全响应式和高性能的应用程序至关重要。它为Vue的响应性系统、渲染和事件处理机制奠定了基础，使其成为Vue设计和架构的关键方面之一。</p>
<h4 id="32-Vue3初始化的一个大概流程"><a href="#32-Vue3初始化的一个大概流程" class="headerlink" title="32.Vue3初始化的一个大概流程?"></a>32.Vue3初始化的一个大概流程?</h4><p>Vue 3的初始化流程相比Vue 2有所不同，它使用了Composition API，其中包含了<code>setup</code>函数来进行组件的初始化。下面是Vue 3初始化的大概流程：</p>
<ol>
<li>解析组件选项：<ul>
<li>Vue 3首先解析组件的选项，包括<code>template</code>、<code>data</code>、<code>methods</code>、<code>computed</code>等选项。</li>
</ul>
</li>
<li>创建组件实例：<ul>
<li>根据解析的组件选项，Vue 3创建组件的实例对象。在创建实例时，会先执行<code>setup</code>函数来初始化组件的数据和行为。</li>
</ul>
</li>
<li><code>setup</code>函数执行：<ul>
<li><code>setup</code>函数是Vue 3中新引入的一个函数，用于在组件创建阶段执行。在<code>setup</code>函数中，可以使用Vue 3的响应式API（如<code>reactive</code>、<code>ref</code>等）来处理组件的数据和行为。</li>
</ul>
</li>
<li>编译模板：<ul>
<li>在组件初始化阶段，Vue 3会将<code>template</code>模板编译成渲染函数（render function）。这个渲染函数会生成虚拟DOM（Virtual DOM）。</li>
</ul>
</li>
<li>创建和更新虚拟DOM：<ul>
<li>当组件初始化完成后，Vue 3会根据渲染函数生成虚拟DOM，并将虚拟DOM挂载到真实DOM上。</li>
</ul>
</li>
<li>响应式侦听：<ul>
<li>Vue 3会监听组件的响应式数据变化，当数据发生变化时，Vue 3会触发虚拟DOM的更新。</li>
</ul>
</li>
<li>视图更新：<ul>
<li>当虚拟DOM发生更新时，Vue 3会进行DOM Diff算法的比较，找出需要更新的部分，并进行DOM更新，保持视图和数据的同步。</li>
</ul>
</li>
<li>组件挂载：<ul>
<li>最后，Vue 3会将组件挂载到DOM上，完成组件的初始化和渲染。</li>
</ul>
</li>
</ol>
<p>总结： Vue 3的初始化流程主要包括解析组件选项、创建组件实例、执行<code>setup</code>函数、编译模板、创建和更新虚拟DOM、响应式侦听、视图更新和组件挂载等步骤。其中，<code>setup</code>函数是Vue 3中新的初始化阶段，用于处理组件的数据和行为。通过<code>setup</code>函数，Vue 3提供了更灵活和方便的方式来管理组件的状态和行为。</p>
<h4 id="33-vue3响应式api如何编写"><a href="#33-vue3响应式api如何编写" class="headerlink" title="33.vue3响应式api如何编写?"></a>33.vue3响应式api如何编写?</h4><p>在Vue 3中，响应式API与Vue 2有所不同。Vue 3使用了Composition API，其中包含了一些新的函数和模块来处理响应式数据。主要的响应式API函数是<code>reactive</code>、<code>ref</code>和<code>toRefs</code>。下面简要介绍它们的用法：</p>
<ol>
<li><p><code>reactive</code>函数：</p>
<ul>
<li><code>reactive</code>函数用于将一个普通对象转换为响应式对象。这个函数会递归地将对象的所有属性转换为响应式的，包括对象的嵌套属性。</li>
<li>示例：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy codeimport &#123; reactive &#125; from &#x27;vue&#x27;;</span><br><span class="line"></span><br><span class="line">const state = reactive(&#123;</span><br><span class="line">  count: 0,</span><br><span class="line">  message: &#x27;Hello&#x27;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>ref</code>函数：</p>
<ul>
<li><code>ref</code>函数用于将一个普通值转换为响应式的引用对象（Ref）。Ref对象包装了普通值，当Ref对象的值发生变化时，会触发视图更新。</li>
<li>示例：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy codeimport &#123; ref &#125; from &#x27;vue&#x27;;</span><br><span class="line"></span><br><span class="line">const count = ref(0);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>toRefs</code>函数：</p>
<ul>
<li><code>toRefs</code>函数用于将一个响应式对象转换为普通对象，并且每个属性都是一个单独的Ref对象。这个函数在将响应式对象的属性传递给子组件时非常有用。</li>
<li>示例：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy codeimport &#123; reactive, toRefs &#125; from &#x27;vue&#x27;;</span><br><span class="line"></span><br><span class="line">const state = reactive(&#123;</span><br><span class="line">  count: 0,</span><br><span class="line">  message: &#x27;Hello&#x27;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 将state对象转换为普通对象，其中每个属性都是一个Ref对象</span><br><span class="line">const stateRefs = toRefs(state);</span><br></pre></td></tr></table></figure></li>
</ol>
<p>这些响应式API函数可以与Vue 3的<code>setup</code>函数一起使用，<code>setup</code>函数是在组件创建阶段执行的一个函数，用于设置组件的数据和行为。在<code>setup</code>函数中，可以使用这些响应式API来处理组件的数据。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">htmlCopy code&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;p&gt;Count: &#123;&#123; count &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;button @click=&quot;increment&quot;&gt;Increment&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; ref &#125; from &#x27;vue&#x27;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    // 使用ref定义响应式数据</span><br><span class="line">    const count = ref(0);</span><br><span class="line"></span><br><span class="line">    // 定义组件的行为</span><br><span class="line">    function increment() &#123;</span><br><span class="line">      count.value++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 返回需要暴露给模板的数据和行为</span><br><span class="line">    return &#123;</span><br><span class="line">      count,</span><br><span class="line">      increment,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，使用<code>ref</code>函数定义了<code>count</code>响应式数据和<code>increment</code>行为，并将它们返回给模板进行使用。</p>
<p>使用Vue 3的Composition API可以更灵活和方便地处理组件的数据和逻辑，推荐在Vue 3中使用Composition API来编写响应式数据。</p>
<h4 id="34-在Vue项目中你是如何做的SSR渲染"><a href="#34-在Vue项目中你是如何做的SSR渲染" class="headerlink" title="34.在Vue项目中你是如何做的SSR渲染?"></a>34.在Vue项目中你是如何做的SSR渲染?</h4><p>在Vue项目中实现SSR（服务器端渲染）需要进行以下步骤：</p>
<ol>
<li><strong>设置服务器环境：</strong> 首先，您需要设置服务器环境，可以选择使用Node.js或其他支持Vue SSR的服务器框架。</li>
<li><strong>创建服务端入口：</strong> 在服务器端，您需要创建一个服务端入口文件，用于处理来自客户端的请求。</li>
<li><strong>创建Vue实例：</strong> 在服务端入口文件中，您需要创建一个Vue实例，并将其设置为服务器渲染模式。</li>
<li><strong>获取数据：</strong> 在服务器渲染模式下，您需要在渲染之前获取组件所需的数据。可以使用Vuex或其他数据管理工具来获取数据并预取组件所需的状态。</li>
<li><strong>路由处理：</strong> 处理服务器端的路由匹配，根据请求的URL确定渲染哪个组件。</li>
<li><strong>渲染组件：</strong> 使用Vue的<code>renderToString</code>或<code>renderToNodeStream</code>方法将匹配的组件渲染为HTML字符串或流。</li>
<li><strong>将HTML返回给客户端：</strong> 将渲染好的HTML字符串或流返回给客户端，并在客户端上继续进行交互。</li>
<li><strong>客户端激活：</strong> 在客户端，您需要激活Vue实例，以便在前端继续处理交互和动态更新。</li>
</ol>
<p>以上步骤涉及到了很多细节和配置，因此在实际项目中，通常会使用现有的Vue SSR框架（如Nuxt.js）来简化和自动化SSR的过程。Nuxt.js是一个流行的Vue SSR框架，它提供了一系列配置和工具，使得SSR渲染更加方便和易于使用。</p>
<p>请注意，实施SSR需要考虑到很多因素，包括性能、服务器资源、SEO等。因此，在开始实施SSR之前，建议仔细研究和规划，确保选择适合您项目需求的SSR方案。</p>
<h4 id="35-在vue中怎么确定引入的方法或库需要加"><a href="#35-在vue中怎么确定引入的方法或库需要加" class="headerlink" title="35.在vue中怎么确定引入的方法或库需要加{}"></a>35.在vue中怎么确定引入的方法或库需要加{}</h4><p>在Vue中，如果要引入的方法或库是通过<code>export default</code>导出的，那么在导入时可以不需要使用大括号<code>&#123;&#125;</code>，直接通过<code>import</code>语句导入即可。这是因为<code>export default</code>只能导出一个默认值，所以在导入时直接获取该默认值即可。</p>
<p>例如，在使用Vue Router时，可以直接这样导入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import VueRouter from &#x27;vue-router&#x27;;</span><br></pre></td></tr></table></figure>

<p>这里的<code>VueRouter</code>是通过<code>export default</code>导出的，默认导出了VueRouter的实例，因此可以直接导入使用。</p>
<p>然而，如果要引入的方法或库是通过命名导出（Named Export）的，那么在导入时需要使用大括号<code>&#123;&#125;</code>，并指定要导入的具体项。</p>
<p>例如，在使用Vuex时，可以这样导入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; createStore &#125; from &#x27;vuex&#x27;;</span><br></pre></td></tr></table></figure>

<p>这里的<code>createStore</code>是通过命名导出的，所以需要使用大括号指定要导入的项。</p>
<p>总结：</p>
<ul>
<li>对于通过<code>export default</code>导出的方法或库，可以直接使用<code>import</code>导入，不需要使用大括号<code>&#123;&#125;</code>。</li>
<li>对于通过命名导出的方法或库，需要使用大括号<code>&#123;&#125;</code>指定要导入的具体项。</li>
</ul>
<p>在Vue项目中引入方法或库时，根据导出方式来使用正确的导入语法是很重要的，以确保代码的正确性和可读性。如果不确定是否需要使用大括号<code>&#123;&#125;</code>，可以查阅相关库或模块的文档，或者查看其源代码来了解导出方式。</p>
<h2 id="常用框架"><a href="#常用框架" class="headerlink" title="常用框架"></a>常用框架</h2><h3 id="Echarts"><a href="#Echarts" class="headerlink" title="Echarts"></a>Echarts</h3><h4 id="1-echarts-的基本用法"><a href="#1-echarts-的基本用法" class="headerlink" title="1.echarts 的基本用法?"></a>1.echarts 的基本用法?</h4><p>ECharts 是一个基于 JavaScript 的开源可视化库，用于绘制各种图表和图形，如折线图、柱状图、饼图等。以下是 ECharts 的基本用法：</p>
<ol>
<li>引入 ECharts 库：首先在 HTML 文件中引入 ECharts 库的 JavaScript 文件。</li>
<li>创建容器：在 HTML 文件中创建一个容器元素，用于展示图表。</li>
<li>初始化图表：在 JavaScript 中使用 <code>echarts.init()</code> 方法初始化一个图表实例，并传入容器元素。</li>
<li>配置图表：使用图表实例的 <code>setOption()</code> 方法配置图表的样式、数据和交互等。</li>
<li>渲染图表：最后调用图表实例的 <code>render()</code> 方法将图表渲染到页面上。</li>
</ol>
<p>以下是一个简单的示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">htmlCopy code&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;title&gt;ECharts 示例&lt;/title&gt;</span><br><span class="line">  &lt;!-- 引入 ECharts 库 --&gt;</span><br><span class="line">  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/echarts@5.1.2/dist/echarts.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;!-- 创建容器 --&gt;</span><br><span class="line">  &lt;div id=&quot;chart&quot; style=&quot;width: 600px; height: 400px;&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    // 初始化图表</span><br><span class="line">    var chart = echarts.init(document.getElementById(&#x27;chart&#x27;));</span><br><span class="line"></span><br><span class="line">    // 配置图表</span><br><span class="line">    var option = &#123;</span><br><span class="line">      title: &#123;</span><br><span class="line">        text: &#x27;折线图示例&#x27;</span><br><span class="line">      &#125;,</span><br><span class="line">      xAxis: &#123;</span><br><span class="line">        type: &#x27;category&#x27;,</span><br><span class="line">        data: [&#x27;周一&#x27;, &#x27;周二&#x27;, &#x27;周三&#x27;, &#x27;周四&#x27;, &#x27;周五&#x27;, &#x27;周六&#x27;, &#x27;周日&#x27;]</span><br><span class="line">      &#125;,</span><br><span class="line">      yAxis: &#123;</span><br><span class="line">        type: &#x27;value&#x27;</span><br><span class="line">      &#125;,</span><br><span class="line">      series: [&#123;</span><br><span class="line">        type: &#x27;line&#x27;,</span><br><span class="line">        data: [120, 200, 150, 80, 70, 110, 130]</span><br><span class="line">      &#125;]</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    // 渲染图表</span><br><span class="line">    chart.setOption(option);</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>通过以上步骤，就可以在页面上绘制一个简单的折线图。ECharts 提供了丰富的配置选项和交互功能，可以根据需求来创建各种复杂的图表和可视化效果。</p>
<h4 id="2-如何在vue中引入"><a href="#2-如何在vue中引入" class="headerlink" title="2.如何在vue中引入?"></a>2.如何在vue中引入?</h4><p>在 Vue 中引入 ECharts 有两种常用的方法：通过 <code>&lt;script&gt;</code> 标签直接引入和通过 npm 安装。</p>
<ol>
<li>通过 <code>&lt;script&gt;</code> 标签直接引入：</li>
</ol>
<p>在 HTML 文件中通过 <code>&lt;script&gt;</code> 标签引入 ECharts 的 JavaScript 文件，然后在 Vue 组件中使用全局变量 <code>echarts</code> 访问 ECharts 对象。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">htmlCopy code&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;title&gt;Vue ECharts 示例&lt;/title&gt;</span><br><span class="line">  &lt;!-- 引入 ECharts 库 --&gt;</span><br><span class="line">  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/echarts@5.1.2/dist/echarts.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    // Vue 实例</span><br><span class="line">    new Vue(&#123;</span><br><span class="line">      el: &#x27;#app&#x27;,</span><br><span class="line">      data: &#123;&#125;,</span><br><span class="line">      mounted() &#123;</span><br><span class="line">        // 在 mounted 钩子中创建图表</span><br><span class="line">        var chart = echarts.init(document.getElementById(&#x27;app&#x27;));</span><br><span class="line"></span><br><span class="line">        // 配置图表</span><br><span class="line">        var option = &#123;</span><br><span class="line">          // 配置项...</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        // 渲染图表</span><br><span class="line">        chart.setOption(option);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<ol>
<li>通过 npm 安装：</li>
</ol>
<p>在项目中使用 npm 安装 ECharts：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bashCopy code</span><br><span class="line">npm install echarts --save</span><br></pre></td></tr></table></figure>

<p>然后在 Vue 组件中使用 <code>import</code> 导入 ECharts：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vueCopy code&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import echarts from &#x27;echarts&#x27;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    // 在 mounted 钩子中创建图表</span><br><span class="line">    var chart = echarts.init(document.getElementById(&#x27;app&#x27;));</span><br><span class="line"></span><br><span class="line">    // 配置图表</span><br><span class="line">    var option = &#123;</span><br><span class="line">      // 配置项...</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    // 渲染图表</span><br><span class="line">    chart.setOption(option);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>通过这两种方法，你就可以在 Vue 中使用 ECharts 来绘制图表。</p>
<h4 id="3-如何绘制条形图"><a href="#3-如何绘制条形图" class="headerlink" title="3.如何绘制条形图?"></a>3.如何绘制条形图?</h4><p>要绘制条形图，你可以使用 ECharts 来实现。ECharts 是一个强大的图表库，支持多种图表类型，包括条形图。</p>
<p>以下是在 Vue 中使用 ECharts 绘制条形图的基本步骤：</p>
<ol>
<li>安装 ECharts：如果你还没有安装 ECharts，可以通过 npm 安装：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bashCopy code</span><br><span class="line">npm install echarts --save</span><br></pre></td></tr></table></figure>

<ol>
<li>导入 ECharts：在 Vue 组件中，使用 <code>import</code> 导入 ECharts：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vueCopy code&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;barChart&quot; style=&quot;width: 600px; height: 400px;&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import echarts from &#x27;echarts&#x27;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    // 在 mounted 钩子中创建图表</span><br><span class="line">    var chart = echarts.init(document.getElementById(&#x27;barChart&#x27;));</span><br><span class="line"></span><br><span class="line">    // 配置条形图数据</span><br><span class="line">    var option = &#123;</span><br><span class="line">      title: &#123;</span><br><span class="line">        text: &#x27;柱状图示例&#x27;</span><br><span class="line">      &#125;,</span><br><span class="line">      xAxis: &#123;</span><br><span class="line">        type: &#x27;category&#x27;,</span><br><span class="line">        data: [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;]</span><br><span class="line">      &#125;,</span><br><span class="line">      yAxis: &#123;</span><br><span class="line">        type: &#x27;value&#x27;</span><br><span class="line">      &#125;,</span><br><span class="line">      series: [&#123;</span><br><span class="line">        data: [10, 20, 15, 30, 25],</span><br><span class="line">        type: &#x27;bar&#x27;</span><br><span class="line">      &#125;]</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    // 渲染图表</span><br><span class="line">    chart.setOption(option);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>以上代码会在 Vue 组件中绘制一个简单的条形图，其中 x 轴代表类别，y 轴代表值。你可以根据实际数据和需求调整图表的配置。确保将图表的容器大小设置为适当的值，以便显示完整的图表。</p>
<h4 id="4-切换时卡顿如何解决"><a href="#4-切换时卡顿如何解决" class="headerlink" title="4.切换时卡顿如何解决?"></a>4.切换时卡顿如何解决?</h4><p>切换时卡顿通常是由于页面加载过多资源或执行复杂计算导致的。以下是一些常见的解决方法，可以帮助减少页面切换时的卡顿：</p>
<ol>
<li>优化代码：检查页面中是否有冗余或不必要的代码，尽量避免执行复杂的计算或操作，优化算法和逻辑。</li>
<li>图片压缩：对页面中的图片进行压缩，尽量使用适当大小的图片，并使用适当的图片格式，如 WebP。</li>
<li>懒加载：将页面中的图片、视频等资源设置为懒加载，在页面滚动到可见区域时再加载，减少初始加载时的负担。</li>
<li>分块加载：将页面分块加载，只加载当前页面所需的资源，而不是一次性加载全部资源。</li>
<li>异步加载：使用异步加载脚本，将不影响页面显示的脚本推迟加载，提高页面的响应速度。</li>
<li>使用缓存：合理使用浏览器缓存，对于不经常变化的资源，尽量设置缓存，减少重复加载。</li>
<li>使用虚拟列表：对于大量数据的列表展示，使用虚拟列表技术，只渲染可见区域的内容，减少页面渲染时间。</li>
<li>Web Worker：将一些计算密集型的任务放在 Web Worker 中执行，避免阻塞主线程。</li>
<li>减少重绘和回流：避免频繁的 DOM 操作，尽量一次性修改样式或内容，减少浏览器的重绘和回流。</li>
<li>使用 CSS3 动画：尽量使用 CSS3 动画代替 JavaScript 动画，利用 GPU 加速提高动画性能。</li>
</ol>
<p>以上方法可以根据具体情况选择使用，帮助优化页面性能，减少切换时的卡顿现象。</p>
<h4 id="5-echarts图表自适应div-resize问题"><a href="#5-echarts图表自适应div-resize问题" class="headerlink" title="5.echarts图表自适应div resize问题?"></a>5.echarts图表自适应div resize问题?</h4><p>在使用 ECharts 图表时，确保图表能够自适应 div 的 resize 是非常重要的，这样能够保证图表在不同尺寸的容器中正常显示。以下是解决 ECharts 图表自适应 div resize 问题的方法：</p>
<ol>
<li>使用 resize 事件：ECharts 提供了 resize 事件，在 div 尺寸发生变化时触发。你可以监听该事件，然后在事件回调函数中重新调用图表的 resize 方法，实现图表的自适应。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy code// 监听resize事件</span><br><span class="line">window.addEventListener(&#x27;resize&#x27;, function () &#123;</span><br><span class="line">  // 调用图表的resize方法</span><br><span class="line">  myChart.resize();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ol>
<li>debounce 函数优化：为了避免频繁调用 resize 方法，可以使用 debounce 函数进行优化。debounce 函数可以限制事件回调的频率，当 resize 事件触发时，只有在一定的延迟之后才会执行回调函数。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy code// 引入lodash库</span><br><span class="line">import &#123; debounce &#125; from &#x27;lodash&#x27;;</span><br><span class="line"></span><br><span class="line">// 监听resize事件，并使用debounce进行优化</span><br><span class="line">window.addEventListener(&#x27;resize&#x27;, debounce(function () &#123;</span><br><span class="line">  // 调用图表的resize方法</span><br><span class="line">  myChart.resize();</span><br><span class="line">&#125;, 200)); // 延迟时间200毫秒</span><br></pre></td></tr></table></figure>

<ol>
<li>使用 CSS 控制 div 的大小：在 HTML 和 CSS 中，使用百分比或者 rem&#x2F;vw 单位来设置 div 的大小，这样 div 大小会根据父元素或者屏幕大小自动调整，从而实现图表的自适应。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">htmlCopy code</span><br><span class="line">&lt;div id=&quot;chart&quot; style=&quot;width: 100%; height: 400px;&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<ol>
<li>使用 flex 布局：在父容器中使用 flex 布局，设置图表的宽度和高度为 100%。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cssCopy code.parent-container &#123;</span><br><span class="line">  display: flex;</span><br><span class="line">  flex-direction: column;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#chart &#123;</span><br><span class="line">  flex: 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上方法中，第一种方法是最常用的，在图表初始化时监听 resize 事件，确保图表在 div 尺寸变化时能够自动调整大小。使用 debounce 函数优化可以避免频繁调用 resize 方法，提高性能。同时，合理使用 CSS 控制 div 大小和使用 flex 布局也可以有效实现图表的自适应。根据具体情况选择最合适的方法来解决图表自适应 div resize 问题。</p>
<h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><h4 id="1-什么是Ajax-Ajax-都有哪些优点和缺点"><a href="#1-什么是Ajax-Ajax-都有哪些优点和缺点" class="headerlink" title="1.什么是Ajax, Ajax 都有哪些优点和缺点?"></a>1.什么是Ajax, Ajax 都有哪些优点和缺点?</h4><p>Ajax（Asynchronous JavaScript and XML）是一种用于在Web应用中进行异步数据交互的技术，它可以在不重新加载整个页面的情况下，通过JavaScript向服务器发送请求，并在获取到响应后更新页面的局部内容。</p>
<p>优点：</p>
<ol>
<li>异步请求：Ajax可以实现异步请求，不需要刷新整个页面，提升了用户体验和页面加载速度。</li>
<li>减少带宽：由于只更新局部内容，可以减少数据传输量，节省带宽。</li>
<li>提高页面响应速度：由于数据交互是异步进行的，页面可以更快地响应用户操作。</li>
<li>支持多种数据格式：除了XML，Ajax还支持JSON等多种数据格式，适应各种场景。</li>
<li>增强交互性：通过Ajax，可以实现动态加载数据，实现更丰富的交互效果。</li>
</ol>
<p>缺点：</p>
<ol>
<li>兼容性：早期的浏览器对Ajax支持不完善，需要处理跨浏览器兼容性问题。</li>
<li>安全性：由于Ajax可以在客户端发起请求，容易受到跨站请求伪造（CSRF）攻击，需要采取一定的安全措施。</li>
<li>SEO问题：搜索引擎爬虫不会执行JavaScript，如果页面内容主要由Ajax动态加载，可能会导致搜索引擎无法获取完整的页面内容，影响SEO。</li>
<li>可维护性：由于数据请求和处理逻辑可能分散在不同的地方，代码的可维护性较差。</li>
</ol>
<p>总结： Ajax是一种非常有用的技术，可以提升用户体验和页面加载速度，但在使用时需要注意兼容性、安全性和SEO等方面的问题，同时合理使用Ajax，避免滥用，以确保代码的可维护性和稳定性。</p>
<h4 id="2-请介绍一下XMLHTTPrequest对象及常用方法和属性"><a href="#2-请介绍一下XMLHTTPrequest对象及常用方法和属性" class="headerlink" title="2.请介绍一下XMLHTTPrequest对象及常用方法和属性"></a>2.请介绍一下XMLHTTPrequest对象及常用方法和属性</h4><p>XMLHttpRequest（XHR）对象是浏览器提供的用于在客户端发起HTTP请求的JavaScript API。它可以实现异步数据交互，用于获取数据、发送数据等操作，是实现AJAX的核心。</p>
<p>常用的XMLHttpRequest对象的方法和属性如下：</p>
<p>方法：</p>
<ol>
<li>open(method, url, async)：初始化一个请求，指定请求的方法（GET、POST等）、URL和是否异步。</li>
<li>send(data)：发送HTTP请求，可以传递参数和数据。</li>
<li>setRequestHeader(header, value)：设置HTTP请求头。</li>
<li>abort()：中止当前的HTTP请求。</li>
</ol>
<p>属性：</p>
<ol>
<li>onreadystatechange：表示处理请求的回调函数，当请求状态发生变化时被触发。</li>
<li>readyState：表示请求状态的属性，包含以下值：<ul>
<li>0：未初始化。XMLHttpRequest对象已创建，但未调用open()方法。</li>
<li>1：正在加载。open()方法已调用，但send()方法未调用。</li>
<li>2：加载完成。send()方法已调用，且已接收到全部响应数据。</li>
<li>3：交互。正在解析响应内容。</li>
<li>4：完成。响应内容已解析完成，可以在客户端使用。</li>
</ul>
</li>
<li>status：表示HTTP响应状态码，如200表示成功，404表示未找到资源等。</li>
<li>statusText：表示HTTP响应状态描述，如”OK”、”Not Found”等。</li>
<li>responseText：表示响应的文本内容。</li>
<li>responseXML：表示响应的XML内容，如果响应是XML格式的。</li>
<li>timeout：设置请求的超时时间，单位为毫秒。</li>
<li>withCredentials：指定是否跨域请求时发送凭据信息（如cookie）。</li>
</ol>
<p>这些方法和属性可以帮助我们在客户端通过JavaScript与服务器进行数据交互，并实现动态更新页面内容，提升用户体验。</p>
<h4 id="3-Ajax-的实现流程是怎样的"><a href="#3-Ajax-的实现流程是怎样的" class="headerlink" title="3.Ajax 的实现流程是怎样的?"></a>3.Ajax 的实现流程是怎样的?</h4><p>Ajax（Asynchronous JavaScript and XML）是一种利用JavaScript和XML进行异步数据交互的技术。它允许在不重新加载整个页面的情况下，通过异步方式向服务器发送请求并获取数据，然后用JavaScript来更新页面的部分内容。</p>
<p>Ajax的实现流程如下：</p>
<ol>
<li>创建XMLHttpRequest对象：首先，通过JavaScript创建一个XMLHttpRequest对象，该对象允许发送HTTP请求和接收服务器响应。</li>
<li>设置回调函数：然后，我们需要设置一个回调函数，用于处理服务器返回的响应数据。当服务器响应数据返回后，会触发该回调函数，从而处理响应数据并更新页面。</li>
<li>发送请求：使用XMLHttpRequest对象的open()方法和send()方法，向服务器发送HTTP请求。open()方法用于设置请求的方法、URL和是否采用异步方式，send()方法用于发送请求。</li>
<li>接收响应：当服务器返回响应数据时，XMLHttpRequest对象会触发onreadystatechange事件，并调用设置的回调函数来处理响应数据。</li>
<li>更新页面：在回调函数中，我们可以获取服务器返回的数据，然后利用JavaScript来更新页面的内容，例如将数据插入到指定的HTML元素中，或者更新页面的样式等。</li>
<li>错误处理：在发送请求时，还需要注意处理可能出现的错误情况，例如网络连接问题、服务器错误等，可以设置onerror事件来处理这些错误。</li>
</ol>
<p>总结：Ajax的实现流程主要包括创建XMLHttpRequest对象、设置回调函数、发送请求、接收响应和更新页面等步骤，通过这些步骤，可以实现异步数据交互，提升用户体验和页面性能。</p>
<h4 id="4-Ajax-接收到的数据类型有哪些，数据如何处理"><a href="#4-Ajax-接收到的数据类型有哪些，数据如何处理" class="headerlink" title="4.Ajax 接收到的数据类型有哪些，数据如何处理?"></a>4.Ajax 接收到的数据类型有哪些，数据如何处理?</h4><p>Ajax 接收到的数据类型可以有多种，常见的数据类型包括：</p>
<ol>
<li>JSON：服务器返回的数据为 JSON 格式，在前端通过 <code>JSON.parse()</code> 方法将 JSON 字符串转换为 JavaScript 对象进行处理。</li>
<li>XML：服务器返回的数据为 XML 格式，可以通过 DOM 或者使用 XML 解析库进行处理。</li>
<li>HTML：服务器返回的数据为 HTML 格式，可以直接插入到页面中显示。</li>
<li>Text：服务器返回的数据为普通文本，可以直接展示或进一步处理。</li>
</ol>
<p>对于接收到的数据，通常需要根据 <code>dataType</code> 参数指定的数据类型进行处理。例如，如果指定 <code>dataType: &quot;json&quot;</code>，则应该通过 <code>JSON.parse()</code> 方法将接收到的 JSON 字符串转换为 JavaScript 对象；如果指定 <code>dataType: &quot;xml&quot;</code>，则可以使用 DOM 或者 XML 解析库处理接收到的 XML 数据。</p>
<p>在处理数据时，可以根据具体的业务需求进行逻辑处理、渲染页面或其他操作。一般情况下，成功的回调函数 (<code>success</code>) 中处理服务器返回的数据，并更新页面内容；失败的回调函数 (<code>error</code>) 中处理请求失败的情况，并给用户适当的提示。</p>
<p>总的来说，根据接收到的数据类型，我们可以使用不同的方式将数据解析和处理，以满足业务需求。</p>
<h4 id="5-封装好的Ajax里的常见参数及其代表的含义"><a href="#5-封装好的Ajax里的常见参数及其代表的含义" class="headerlink" title="5.封装好的Ajax里的常见参数及其代表的含义"></a>5.封装好的Ajax里的常见参数及其代表的含义</h4><p>在封装好的 Ajax 函数中，常见的参数及其代表的含义如下：</p>
<ol>
<li><code>url</code>：请求的 URL 地址，指定要发送 Ajax 请求的目标地址。</li>
<li><code>method</code>：请求方法，指定请求类型，通常为 GET 或 POST。</li>
<li><code>data</code>：请求参数，用于传递需要提交的数据，可以是对象、字符串或 FormData。</li>
<li><code>headers</code>：请求头，用于设置自定义的请求头信息，如 Content-Type 等。</li>
<li><code>dataType</code>：返回数据类型，指定服务器返回的数据格式，可以是 “json”、”text”、”xml” 等。</li>
<li><code>timeout</code>：超时时间，设置请求超时的时间限制。</li>
<li><code>async</code>：是否异步，默认为 true，表示异步请求，false 表示同步请求。</li>
<li><code>beforeSend</code>：发送请求前的回调函数，可以在该函数中添加一些处理逻辑，如显示加载动画。</li>
<li><code>success</code>：请求成功时的回调函数，可以处理服务器返回的数据。</li>
<li><code>error</code>：请求失败时的回调函数，可以处理请求失败的情况。</li>
<li><code>complete</code>：请求完成后的回调函数，无论请求成功或失败，都会执行该回调。</li>
</ol>
<p>这些参数可以根据实际需求进行配置，用于控制 Ajax 请求的行为和处理请求返回的数据。封装好的 Ajax 函数可以简化 Ajax 请求的操作，提高代码复用性和可维护性。</p>
<h4 id="6-Ajax注意事项及适用和不适用场景"><a href="#6-Ajax注意事项及适用和不适用场景" class="headerlink" title="6.Ajax注意事项及适用和不适用场景"></a>6.Ajax注意事项及适用和不适用场景</h4><p>Ajax 是一种用于创建异步请求的技术，它可以在不刷新整个页面的情况下与服务器进行通信，从而实现局部更新页面的效果。在使用 Ajax 时，需要注意以下几点：</p>
<p>注意事项：</p>
<ol>
<li>跨域问题：由于同源策略的限制，Ajax 请求不能跨域进行。需要使用 JSONP、CORS、代理等方式解决跨域问题。</li>
<li>安全性：在使用 Ajax 时，应当注意防止 XSS 攻击和 CSRF 攻击，确保传输的数据安全。</li>
<li>异步回调：由于 Ajax 是异步的，所以要注意处理异步回调，确保在请求成功后正确处理返回的数据。</li>
<li>错误处理：需要正确处理请求失败的情况，避免用户在无网络或请求错误时出现问题。</li>
</ol>
<p>适用场景：</p>
<ol>
<li>局部刷新：适用于局部内容的更新，可以提高用户体验，减少页面刷新。</li>
<li>表单提交：通过 Ajax 可以异步提交表单，不刷新整个页面，实现表单验证和提交。</li>
<li>动态加载数据：通过 Ajax 可以异步加载数据，实现动态更新内容。</li>
</ol>
<p>不适用场景：</p>
<ol>
<li>对 SEO 重要的页面：由于搜索引擎爬虫不会执行 JavaScript，使用 Ajax 加载内容的页面可能对 SEO 不友好。</li>
<li>大量数据处理：当需要处理大量数据时，使用 Ajax 可能会导致页面响应较慢，影响用户体验。</li>
</ol>
<p>总体来说，Ajax 是前端开发中非常常用的技术，可以优化用户体验和页面性能，但在使用时需要注意跨域、安全性和异步处理等问题，并根据具体场景选择合适的方式使用。</p>
<h4 id="7-HTTP状态码以及代表的意义"><a href="#7-HTTP状态码以及代表的意义" class="headerlink" title="7.HTTP状态码以及代表的意义"></a>7.HTTP状态码以及代表的意义</h4><p>HTTP状态码是服务器在响应请求时返回的三位数字代码，用于表示服务器对请求的处理结果。状态码分为五类，每一类代表不同的意义：</p>
<p>1xx（信息性状态码）：表示请求已接收，继续处理。</p>
<ul>
<li>100 Continue：服务器已收到请求的头部，客户端应继续发送请求的主体部分。</li>
<li>101 Switching Protocols：服务器已经理解并接受了客户端的请求，正在切换协议。</li>
</ul>
<p>2xx（成功状态码）：表示请求已成功处理。</p>
<ul>
<li>200 OK：请求成功，服务器返回所请求的数据。</li>
<li>201 Created：请求成功，服务器新建了资源。</li>
<li>204 No Content：请求成功，但响应报文中不含实体的主体部分。</li>
</ul>
<p>3xx（重定向状态码）：表示需要进行附加操作以完成请求。</p>
<ul>
<li>301 Moved Permanently：请求的资源已永久移动到新的URL。</li>
<li>302 Found：请求的资源临时从不同的URL响应请求。</li>
<li>304 Not Modified：客户端发送附带条件的请求，且未满足条件的情况下，服务器允许返回该状态码，表示资源未修改。</li>
</ul>
<p>4xx（客户端错误状态码）：表示客户端错误，请求包含语法错误或无法完成请求。</p>
<ul>
<li>400 Bad Request：请求报文存在语法错误。</li>
<li>401 Unauthorized：请求需要用户身份验证。</li>
<li>403 Forbidden：服务器拒绝执行请求。</li>
<li>404 Not Found：请求的资源不存在。</li>
</ul>
<p>5xx（服务器错误状态码）：表示服务器端错误，服务器无法完成合法请求。</p>
<ul>
<li>500 Internal Server Error：服务器在执行请求时发生错误。</li>
<li>502 Bad Gateway：服务器作为网关或代理，从上游服务器收到无效的响应。</li>
<li>503 Service Unavailable：服务器当前无法处理请求，一段时间后可能恢复正常。</li>
</ul>
<p>通过状态码，客户端能够了解服务器处理请求的结果，从而进行相应的处理和错误处理。</p>
<h4 id="8-301-302-303状态码的区别"><a href="#8-301-302-303状态码的区别" class="headerlink" title="8.301 302 303状态码的区别?"></a>8.301 302 303状态码的区别?</h4><p>301、302 和 303 状态码都是用于HTTP重定向的，它们之间的区别在于重定向的方式和语义含义。</p>
<ol>
<li>301 Moved Permanently：表示请求的资源已经被永久移动到了新的URL，并且以后的所有请求都应该使用新的URL。这意味着搜索引擎会将原始URL的权重转移到新的URL，同时浏览器会自动缓存新的URL，下次请求时直接跳转到新的URL，不再请求原始URL。</li>
<li>302 Found：表示请求的资源临时被移动到了新的URL。这个状态码是临时性的，浏览器和搜索引擎会继续使用原始URL，不会缓存新的URL。换句话说，搜索引擎不会将原始URL的权重转移到新的URL。</li>
<li>303 See Other：表示请求的资源存在另一个URL，客户端应该使用GET方法去请求这个新的URL。这个状态码通常用于POST请求之后的重定向，让客户端使用GET请求获取重定向的资源。</li>
</ol>
<p>总结：</p>
<ul>
<li>301 是永久重定向，浏览器和搜索引擎都会缓存新的URL；</li>
<li>302 是临时重定向，浏览器和搜索引擎不会缓存新的URL；</li>
<li>303 是将POST请求转为GET请求的重定向。</li>
</ul>
<h4 id="9-什么是同源策略"><a href="#9-什么是同源策略" class="headerlink" title="9.什么是同源策略"></a>9.什么是同源策略</h4><p>同源策略（Same-Origin Policy）是浏览器的一种安全策略，用于限制一个网页中的脚本只能与来自相同协议、域名和端口的资源进行交互。换句话说，同源策略要求网页中的脚本只能与同一站点下的资源进行通信，而不能与其他站点的资源进行通信。</p>
<p>具体来说，同源策略限制了以下几种行为：</p>
<ol>
<li>Cookie、LocalStorage 和 IndexDB 等存储性数据：这些数据在浏览器中是以域名为单位进行存储的，不同域名之间的数据不能相互访问。</li>
<li>DOM：JavaScript脚本可以获取和修改当前页面的DOM，但不能获取和修改其他域名下的DOM。</li>
<li>Ajax 请求：XMLHttpRequest 和 Fetch 等网络请求在发送请求时受到同源策略的限制，只能向同一域名下的接口发送请求。</li>
</ol>
<p>同源策略的存在是为了保护用户的隐私和安全，防止恶意网站通过脚本获取用户的敏感信息或执行恶意操作。然而，有时候跨域是必要的，比如前后端分离的开发中需要与不同域名的接口进行交互。为了解决这个问题，可以使用CORS（跨域资源共享）、JSONP、代理等方式来实现跨域通信，前面我已经提到过了。</p>
<h4 id="10-为什么会有跨域的问题出现，如何解决跨域问题"><a href="#10-为什么会有跨域的问题出现，如何解决跨域问题" class="headerlink" title="10.为什么会有跨域的问题出现，如何解决跨域问题"></a>10.为什么会有跨域的问题出现，如何解决跨域问题</h4><p>跨域问题是由于浏览器的同源策略(Same-Origin Policy)引起的。同源策略要求网页只能向与其本身相同协议、域名和端口的服务器发送请求，而不能向其他域名发送请求。如果跨域请求不受限制，那么网页就可以通过脚本获取其他网站的数据，这样就会带来安全风险。</p>
<p>跨域问题可以通过以下几种方式进行解决：</p>
<ol>
<li>JSONP：通过动态添加<code>&lt;script&gt;</code>标签，以JSONP的形式进行跨域请求。JSONP利用了<code>&lt;script&gt;</code>标签没有同源限制的特性，服务器返回一段JavaScript代码，客户端通过执行该代码来获取数据。</li>
<li>CORS（跨域资源共享）：CORS是一种机制，通过在服务器设置响应头中的<code>Access-Control-Allow-Origin</code>字段来允许指定域名的请求。当浏览器发现请求的响应头中包含了合法的<code>Access-Control-Allow-Origin</code>字段时，就允许跨域请求。</li>
<li>代理：通过在同源服务器上设置代理，将跨域请求转发到目标服务器。前端请求同源服务器的接口，同源服务器再去请求目标服务器的数据，然后将数据返回给前端。</li>
<li>postMessage：使用HTML5中的<code>postMessage</code>方法，可以在不同窗口（包括不同域名的窗口）之间进行跨文档通信。</li>
<li>WebSocket：WebSocket是一种基于TCP的协议，它不受同源策略的限制，可以实现跨域通信。</li>
<li>Nginx反向代理：通过Nginx服务器作为代理服务器，将跨域请求转发到目标服务器，并将响应返回给客户端。</li>
</ol>
<p>需要根据具体的业务需求和安全性考虑选择合适的解决方案。常见的解决跨域问题的方式是使用CORS和JSONP。</p>
<h4 id="11-Get-和Post的区别以及使用场景"><a href="#11-Get-和Post的区别以及使用场景" class="headerlink" title="11.Get 和Post的区别以及使用场景"></a>11.Get 和Post的区别以及使用场景</h4><p>GET和POST是HTTP协议中的两种常用请求方法，它们有以下区别和适用场景：</p>
<ol>
<li>参数传递方式：<ul>
<li>GET：通过URL的查询字符串传递参数，参数会显示在URL中，形式为<code>key=value</code>，多个参数之间用<code>&amp;</code>连接。例如：<code>https://example.com/?username=John&amp;age=25</code></li>
<li>POST：通过请求体传递参数，参数不会显示在URL中，而是以键值对的形式在请求体中传递。POST请求适用于传递大量数据或敏感信息，更安全。</li>
</ul>
</li>
<li>参数长度限制：<ul>
<li>GET：由于参数在URL中传递，URL的长度是有限制的，通常不能超过2KB左右，因此GET请求适合传递较少的参数。</li>
<li>POST：由于参数在请求体中传递，没有长度限制，适合传递大量数据。</li>
</ul>
</li>
<li>安全性：<ul>
<li>GET：由于参数显示在URL中，可能会被缓存、浏览器历史记录等泄露信息，因此不适合传递敏感信息。</li>
<li>POST：由于参数在请求体中传递，相对于GET请求更加安全，适合传递敏感信息。</li>
</ul>
</li>
<li>缓存：<ul>
<li>GET：GET请求可以被缓存，多次相同的GET请求会返回相同的结果。</li>
<li>POST：POST请求不会被缓存，每次请求都是实时的。</li>
</ul>
</li>
<li>使用场景：<ul>
<li>GET：适合获取数据，获取资源，不涉及状态的改变。例如获取文章列表、搜索内容等。</li>
<li>POST：适合提交表单数据，进行资源的创建、更新和删除，涉及状态的改变。例如提交用户注册信息、上传文件等。</li>
</ul>
</li>
</ol>
<p>总结：GET和POST是HTTP协议中常用的请求方法，GET适合获取数据，不涉及状态改变，参数显示在URL中；POST适合提交数据，进行资源的创建、更新和删除，参数在请求体中传递，更加安全。根据具体的场景需求选择合适的请求方法。</p>
<h4 id="12-解释jsonp的原理"><a href="#12-解释jsonp的原理" class="headerlink" title="12.解释jsonp的原理"></a>12.解释jsonp的原理</h4><p>JSONP（JSON with Padding）是一种跨域数据请求的方法，它利用了script标签不受同源策略限制的特性来实现跨域数据传输。</p>
<p>JSONP的原理如下：</p>
<ol>
<li>前端页面通过创建一个script标签，src属性指向目标服务器的API接口，并传递一个回调函数名作为查询参数。</li>
<li>目标服务器接收到请求后，将需要传递的数据包装成一个函数调用，并将数据作为参数传递给这个函数。</li>
<li>目标服务器返回的数据被包裹在回调函数中，返回给前端页面。</li>
<li>前端页面接收到数据后，由于script标签的特性，浏览器会立即执行返回的脚本，从而调用回调函数，并传入目标数据。</li>
</ol>
<p>通过这种方式，JSONP实现了跨域数据传输，解决了浏览器的同源策略限制。不过需要注意的是，JSONP只支持GET请求，且只能接收到目标服务器返回的数据，并不能像AJAX那样实现完整的请求和响应过程。</p>
<p>尽管JSONP能够实现跨域数据传输，但由于其存在一些安全隐患（容易被注入恶意代码），现在通常推荐使用CORS（跨域资源共享）来处理跨域请求。CORS是一种服务器端设置，通过在响应头中添加一些特定的字段，来允许前端页面从不同的源访问资源。</p>
<h4 id="13-HTTP与HTTPS的区别"><a href="#13-HTTP与HTTPS的区别" class="headerlink" title="13.HTTP与HTTPS的区别"></a>13.HTTP与HTTPS的区别</h4><p>HTTP（Hypertext Transfer Protocol）和HTTPS（Hypertext Transfer Protocol Secure）都是用于在客户端和服务器之间传输数据的协议，它们之间的主要区别在于安全性。</p>
<ol>
<li>安全性：<ul>
<li>HTTP是明文传输数据的协议，数据在传输过程中是不加密的，因此容易被窃听和篡改，存在安全风险。</li>
<li>HTTPS使用SSL&#x2F;TLS协议对数据进行加密传输，使得数据在传输过程中不易被窃听和篡改，提供了更高的安全性。</li>
</ul>
</li>
<li>端口号：<ul>
<li>HTTP默认使用端口80进行通信。</li>
<li>HTTPS默认使用端口443进行通信。</li>
</ul>
</li>
<li>证书：<ul>
<li>在使用HTTPS时，服务器需要获得一个SSL证书，该证书由可信的第三方机构（如CA机构）签发，用于验证服务器身份的真实性和合法性。</li>
<li>HTTP不需要证书，因为数据是明文传输，无法验证服务器的身份。</li>
</ul>
</li>
<li>性能：<ul>
<li>由于HTTPS需要进行加密解密操作，会导致比HTTP更多的计算和网络开销，因此HTTPS相对于HTTP来说在性能上稍微有些差异。但是随着硬件和网络的进步，这个差异已经越来越小。</li>
</ul>
</li>
</ol>
<p>总结：HTTP是明文传输数据的协议，安全性较差；而HTTPS通过SSL&#x2F;TLS协议对数据进行加密传输，提供更高的安全性。因此，对于涉及用户隐私或敏感数据的网站，建议使用HTTPS来保障数据的安全传输。</p>
<h4 id="14-简述web前端Cookie机制，并结合该机制说明会话保持原理"><a href="#14-简述web前端Cookie机制，并结合该机制说明会话保持原理" class="headerlink" title="14.简述web前端Cookie机制，并结合该机制说明会话保持原理"></a>14.简述web前端Cookie机制，并结合该机制说明会话保持原理</h4><p>Web前端的Cookie机制是一种在浏览器端存储少量数据的方法，它通过在客户端保存键值对，来实现会话状态的保持和数据的持久化。</p>
<p>当服务器响应浏览器的请求时，可以通过在响应头中设置Set-Cookie字段来向浏览器写入Cookie。浏览器接收到响应后，将Cookie保存在本地，下次请求同一域名的网页时，会将相应的Cookie信息自动包含在请求头中发送给服务器。</p>
<p>Cookie通常用于以下几个方面：</p>
<ol>
<li>会话保持：当用户登录后，服务器可以在响应中设置一个包含用户身份标识的Cookie，浏览器保存这个Cookie，之后的每次请求都会携带该Cookie，从而让服务器知道用户的身份。</li>
<li>跟踪用户行为：通过在Cookie中记录用户的一些操作或偏好设置，可以跟踪用户的行为，从而为用户提供个性化的服务或广告。</li>
<li>记住登录状态：在用户勾选“记住我”选项后，服务器可以设置一个长期有效的Cookie，使用户下次访问时自动登录。</li>
<li>存储临时数据：将一些临时数据保存在Cookie中，可以在不同页面间共享数据。</li>
</ol>
<p>需要注意的是，由于Cookie保存在客户端，所以存在一定的安全隐患，例如可能会被篡改或盗用。为了提高安全性，通常应将Cookie设置为HttpOnly，使其只能通过HTTP协议传递，无法通过JavaScript访问，从而防止XSS攻击。另外，为了避免敏感信息泄露，Cookie应该尽量设置为Secure，只在通过HTTPS协议传输时才发送。</p>
<p>总结：Cookie机制是通过在浏览器保存键值对来实现会话保持和数据持久化的方法。服务器通过在响应头中设置Set-Cookie字段，将Cookie写入浏览器，浏览器自动在每次请求中携带Cookie，从而实现会话状态的保持。</p>
<h4 id="15-你知道的HTTP请求方式有几种"><a href="#15-你知道的HTTP请求方式有几种" class="headerlink" title="15.你知道的HTTP请求方式有几种"></a>15.你知道的HTTP请求方式有几种</h4><p>HTTP协议定义了多种请求方法（也称为HTTP动词或HTTP谓词），用于指定对资源的操作类型。常见的HTTP请求方式有以下几种：</p>
<ol>
<li>GET：用于获取资源，向服务器请求数据。GET请求是幂等的，即对同一个URL的多次GET请求应该返回相同的结果。</li>
<li>POST：用于提交数据，向服务器提交数据以进行处理。POST请求不是幂等的，即对同一个URL的多次POST请求可能会产生不同的结果。</li>
<li>PUT：用于更新资源，向服务器上传新的数据取代指定的资源。</li>
<li>DELETE：用于删除资源，向服务器删除指定的资源。</li>
<li>HEAD：类似于GET请求，但只返回响应头部，不返回实际内容。</li>
<li>OPTIONS：用于获取支持的HTTP请求方法和服务器支持的功能。</li>
<li>PATCH：用于对资源进行部分更新。</li>
</ol>
<p>除了以上常见的请求方法，HTTP&#x2F;1.1还引入了一些扩展的方法，例如：CONNECT、TRACE、PROPFIND、PROPPATCH等。</p>
<p>不同的请求方法适用于不同的场景和操作类型。在实际应用中，根据业务需求选择合适的请求方法是很重要的。</p>
<h4 id="16-谈谈你理解的RESTFUL规范"><a href="#16-谈谈你理解的RESTFUL规范" class="headerlink" title="16.谈谈你理解的RESTFUL规范"></a>16.谈谈你理解的RESTFUL规范</h4><h4 id="17-解释一下三次握手是什么，具体流程。变为二次握手会发生什么问题"><a href="#17-解释一下三次握手是什么，具体流程。变为二次握手会发生什么问题" class="headerlink" title="17.解释一下三次握手是什么，具体流程。变为二次握手会发生什么问题?"></a>17.解释一下三次握手是什么，具体流程。变为二次握手会发生什么问题?</h4><p>三次握手是TCP&#x2F;IP协议中建立TCP连接的过程，用于确保客户端和服务器之间的连接是可靠的。具体流程如下：</p>
<ol>
<li>客户端向服务器发送连接请求（SYN包），客户端进入SYN_SEND状态。</li>
<li>服务器收到连接请求后，回复客户端一个确认信息（SYN+ACK包），服务器进入SYN_RECV状态。</li>
<li>客户端收到服务器的确认信息后，再向服务器发送一个确认信息（ACK包），客户端进入ESTABLISHED状态，表示连接建立成功。</li>
<li>服务器收到客户端的确认信息后，也进入ESTABLISHED状态，表示连接建立成功。</li>
</ol>
<p>这个过程中，第一次握手用于客户端请求连接，第二次握手用于服务器确认请求，并回复确认信息，第三次握手用于客户端确认服务器的确认信息。</p>
<p>如果变为二次握手，即只进行一次连接请求和服务器的确认，会产生以下问题：</p>
<ol>
<li>可能会导致服务器与客户端之间的连接不稳定，无法确认连接是否真正建立成功。</li>
<li>可能会出现半连接状态，即服务器在收到客户端的连接请求后，虽然向客户端回复了确认信息，但由于客户端未收到确认信息，所以客户端会一直等待确认，导致连接无法正常建立。</li>
</ol>
<p>因此，为了确保连接的可靠性和稳定性，TCP采用了三次握手的机制。三次握手可以保证客户端和服务器都确认对方的确认信息，从而建立一个稳定的连接。</p>
<h4 id="18-TCP和UDP分别是什么"><a href="#18-TCP和UDP分别是什么" class="headerlink" title="18.TCP和UDP分别是什么?"></a>18.TCP和UDP分别是什么?</h4><p>TCP（Transmission Control Protocol）和UDP（User Datagram Protocol）都是在网络通信中常见的传输层协议。</p>
<p>TCP是一种面向连接的协议，它确保数据传输的可靠性。在TCP连接中，通信双方会建立连接，然后进行数据传输，确保数据按顺序到达目的地，并且不会丢失或损坏。TCP通过序列号和确认机制来实现数据的可靠传输，同时还可以进行拥塞控制和流量控制。TCP适用于对数据可靠性要求较高的场景，如文件传输、电子邮件等。</p>
<p>UDP是一种无连接的协议，它不保证数据传输的可靠性。在UDP中，通信双方不需要建立连接，直接发送数据包，不进行确认和重传操作。UDP的优点是传输速度快，适用于实时性要求高的场景，如视频直播、实时游戏等。但UDP也容易丢包，数据传输不可靠。</p>
<p>总结：</p>
<ul>
<li>TCP是面向连接的，保证数据可靠性，适用于对数据可靠性要求高的场景。</li>
<li>UDP是无连接的，传输速度快，适用于实时性要求高的场景，但数据传输不可靠。</li>
</ul>
<h4 id="19-WebSocket的实现和应用。"><a href="#19-WebSocket的实现和应用。" class="headerlink" title="19.WebSocket的实现和应用。"></a>19.WebSocket的实现和应用。</h4><h4 id="20-一个图片url-访问后直接下载怎样实现"><a href="#20-一个图片url-访问后直接下载怎样实现" class="headerlink" title="20.一个图片url 访问后直接下载怎样实现?"></a>20.一个图片url 访问后直接下载怎样实现?</h4><p>要实现一个图片URL在访问后直接下载，可以通过设置HTTP响应头来实现。具体步骤如下：</p>
<ol>
<li>后端配置： 在后端服务器端，针对该图片URL，设置HTTP响应头，告诉浏览器该资源的Content-Disposition为”attachment”，这样浏览器会将该资源视为附件并提示用户下载。</li>
<li>后端代码示例（Node.js + Express）：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy codeconst express = require(&#x27;express&#x27;);</span><br><span class="line">const app = express();</span><br><span class="line"></span><br><span class="line">app.get(&#x27;/download-image&#x27;, (req, res) =&gt; &#123;</span><br><span class="line">  // 设置响应头，Content-Disposition为&quot;attachment&quot;</span><br><span class="line">  res.setHeader(&#x27;Content-Disposition&#x27;, &#x27;attachment; filename=image.jpg&#x27;);</span><br><span class="line"></span><br><span class="line">  // 读取图片文件，并将其作为响应发送给客户端</span><br><span class="line">  // 这里可以根据实际情况从文件系统或其他地方读取图片</span><br><span class="line">  // 然后使用res.sendFile()将图片发送给客户端</span><br><span class="line">  res.sendFile(&#x27;/path/to/image.jpg&#x27;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(3000, () =&gt; &#123;</span><br><span class="line">  console.log(&#x27;Server is running on port 3000&#x27;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ol>
<li>前端页面调用： 在前端页面中，使用一个链接或按钮来触发该图片URL的访问，这样当用户点击该链接或按钮时，浏览器会直接下载该图片。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">htmlCopy code&lt;!-- 假设图片下载链接为/download-image --&gt;</span><br><span class="line">&lt;a href=&quot;/download-image&quot;&gt;Download Image&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<p>当用户点击上述链接时，浏览器会下载图片，并以”image.jpg”为默认文件名保存到本地。注意，后端代码示例中的”&#x2F;path&#x2F;to&#x2F;image.jpg”需要替换成实际的图片路径，同时可以根据需要对文件名进行动态设置。</p>
<h4 id="21-说一下http2-0"><a href="#21-说一下http2-0" class="headerlink" title="21.说一下http2.0"></a>21.说一下http2.0</h4><h4 id="22-补充400和401、403-状态码"><a href="#22-补充400和401、403-状态码" class="headerlink" title="22.补充400和401、403 状态码"></a>22.补充400和401、403 状态码</h4><h4 id="23-fetch发送2次请求的原因"><a href="#23-fetch发送2次请求的原因" class="headerlink" title="23.fetch发送2次请求的原因"></a>23.fetch发送2次请求的原因</h4><p>当使用Fetch API发送请求时，可能会出现发送两次请求的情况。这通常是由于浏览器的预请求（Preflight Request）机制导致的。</p>
<p>预请求是一种由浏览器发送的特殊请求，用于在发送真正的请求之前检查服务器是否支持某些特定的请求头或方法。预请求通常发生在以下情况：</p>
<ol>
<li>跨域请求：当发送跨域请求时（例如从<a target="_blank" rel="noopener external nofollow noreferrer" href="http://example.com向http//api.example.com%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82%EF%BC%89%EF%BC%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BC%9A%E5%8F%91%E9%80%81%E9%A2%84%E8%AF%B7%E6%B1%82%E6%9D%A5%E7%A1%AE%E8%AE%A4%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%98%AF%E5%90%A6%E5%85%81%E8%AE%B8%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E3%80%82">http://example.com向http://api.example.com发送请求），浏览器会发送预请求来确认服务器是否允许跨域请求。</a></li>
<li>自定义请求头：当请求中包含一些自定义的请求头（例如Authorization头），而且该请求头在服务器端没有设置允许，浏览器会发送预请求来检查服务器是否支持该请求头。</li>
</ol>
<p>预请求的工作原理是，浏览器在发送真正的请求之前先发送一个OPTIONS请求（也称为预请求）到服务器，服务器返回预请求响应，浏览器根据预请求响应决定是否发送真正的请求。</p>
<p>为了避免Fetch API发送多次请求，可以采取以下措施：</p>
<ol>
<li>服务器端设置CORS（跨域资源共享）：在服务器端设置CORS规则，允许来自特定域名的跨域请求。这样可以避免预请求，直接发送真正的请求。</li>
<li>避免自定义请求头：尽量避免在请求中包含自定义的请求头，或者在服务器端设置允许这些自定义请求头，这样可以减少预请求的发送。</li>
<li>使用JSONP或者代理：如果跨域请求无法避免，可以考虑使用JSONP或者代理方式来发送请求，这样可以避免预请求的发送。</li>
</ol>
<p>总之，发送多次请求通常是由于浏览器的预请求机制导致的，可以通过设置CORS规则、避免自定义请求头等方式来避免预请求，从而解决发送多次请求的问题。</p>
<h4 id="24-对HTML语义化标签的理解"><a href="#24-对HTML语义化标签的理解" class="headerlink" title="24.对HTML语义化标签的理解"></a>24.对HTML语义化标签的理解</h4><p>HTML语义化是指在编写HTML代码时，合理地选择和使用标签，使得标签的结构和内容能够反映页面的结构和内容，使页面的结构和意义更加清晰明了，同时对搜索引擎和开发者友好。</p>
<p>使用语义化标签的好处有以下几点：</p>
<ol>
<li>代码可读性更好：通过语义化标签，代码的结构和含义更加明了，方便其他开发者阅读和理解代码。</li>
<li>对搜索引擎友好：搜索引擎能够更容易地理解页面的结构和内容，提高网页的搜索排名。</li>
<li>无障碍性：语义化标签能够提供更好的无障碍性支持，使得残障人士能够更容易地访问和理解页面内容。</li>
<li>便于维护和修改：使用语义化标签可以使得代码结构更加清晰，便于后期的维护和修改。</li>
</ol>
<p>常见的HTML语义化标签包括：</p>
<ol>
<li><code>&lt;header&gt;</code>：表示页面或者页面的一部分的页眉，通常包含网站的logo、导航菜单等。</li>
<li><code>&lt;nav&gt;</code>：表示导航栏，用于包含页面的导航链接。</li>
<li><code>&lt;main&gt;</code>：表示页面的主要内容，一个页面中通常只会包含一个main标签。</li>
<li><code>&lt;article&gt;</code>：表示一篇独立的文章或者内容块。</li>
<li><code>&lt;section&gt;</code>：表示页面的一个区域或者部分。</li>
<li><code>&lt;aside&gt;</code>：表示页面的侧边栏内容，通常用于包含与页面主要内容相关但又不是主要内容的部分。</li>
<li><code>&lt;footer&gt;</code>：表示页面或者页面的一部分的页脚，通常包含版权信息、联系方式等。</li>
<li><code>&lt;h1&gt;</code> - <code>&lt;h6&gt;</code>：表示标题，h1是最高级别的标题，h6是最低级别的标题。</li>
</ol>
<p>除了以上标签，还可以使用<code>&lt;p&gt;</code>、<code>&lt;ul&gt;</code>、<code>&lt;ol&gt;</code>、<code>&lt;li&gt;</code>等标签来表示段落、列表等内容，以及<code>&lt;figure&gt;</code>、<code>&lt;figcaption&gt;</code>等标签来表示图片和图题。</p>
<p>通过合理使用这些语义化标签，我们可以使得页面的结构更加清晰，对搜索引擎更友好，并提高页面的可访问性和可维护性。</p>
<h4 id="25-Cookie-和session的区别"><a href="#25-Cookie-和session的区别" class="headerlink" title="25.Cookie 和session的区别"></a>25.Cookie 和session的区别</h4><p>Cookie和Session都是用于在Web应用中存储用户状态和数据的方式，但它们有一些区别：</p>
<ol>
<li>存储位置：<ul>
<li>Cookie是存储在客户端（浏览器）的小型文本文件，通过响应头的Set-Cookie字段发送给浏览器，浏览器会保存在本地并在每次请求中携带在请求头中发送给服务器。</li>
<li>Session是存储在服务器上的会话数据，服务器会为每个用户创建一个唯一的Session，并将SessionID发送给客户端的Cookie中，客户端在每次请求中携带SessionID，服务器根据SessionID找到对应的Session数据。</li>
</ul>
</li>
<li>安全性：<ul>
<li>Cookie是存储在客户端，因此有一定的安全风险，例如Cookie可能被篡改、被盗用，因此不适合存储敏感信息。</li>
<li>Session数据存储在服务器上，相对来说更加安全，但仍然需要防止Session劫持等攻击。</li>
</ul>
</li>
<li>存储容量：<ul>
<li>Cookie的存储容量较小，通常只有几KB。</li>
<li>Session存储容量相对较大，取决于服务器的配置。</li>
</ul>
</li>
<li>生命周期：<ul>
<li>Cookie可以设置过期时间，可以长期保持，也可以设置为会话Cookie，在浏览器关闭后自动删除。</li>
<li>Session一般会设置一个较短的过期时间，一旦超过过期时间，Session数据将被销毁。</li>
</ul>
</li>
<li>使用场景：<ul>
<li>Cookie适合存储一些小型的非敏感数据，例如用户登录状态、用户偏好设置等。</li>
<li>Session适合存储一些较大或敏感的数据，例如用户购物车数据、用户登录信息等。</li>
</ul>
</li>
</ol>
<p>在实际应用中，Cookie和Session经常一起使用，比如服务器将用户的登录状态保存在Session中，然后将SessionID保存在Cookie中，这样在用户每次请求时，服务器可以根据SessionID找到对应的Session数据，从而实现用户状态的保持和管理。</p>
<h4 id="26-强缓存和协商缓存区别-什么时候用哪个-本质是"><a href="#26-强缓存和协商缓存区别-什么时候用哪个-本质是" class="headerlink" title="26.强缓存和协商缓存区别?什么时候用哪个?本质是?"></a>26.强缓存和协商缓存区别?什么时候用哪个?本质是?</h4><h4 id="27-cache-control-的值有哪些"><a href="#27-cache-control-的值有哪些" class="headerlink" title="27.cache-control 的值有哪些"></a>27.cache-control 的值有哪些</h4><h4 id="28-谈谈304状态码"><a href="#28-谈谈304状态码" class="headerlink" title="28.谈谈304状态码"></a>28.谈谈304状态码</h4><p>HTTP状态码中，状态码304表示”Not Modified”，它是一种缓存优化的状态码。当客户端发送一个条件请求（通常是GET请求）到服务器，并且该资源在服务器上没有发生过修改时，服务器会返回304状态码，表示客户端缓存的资源是最新的，无需重新传输相同的资源内容。</p>
<p>304状态码的工作流程如下：</p>
<ol>
<li>客户端发送一个条件请求，通常是带有If-Modified-Since或If-None-Match等请求头的GET请求。</li>
<li>服务器收到该请求后，会检查请求头中的条件参数（如Last-Modified或Etag等）与服务器上资源的实际情况进行对比。</li>
<li>如果服务器上的资源没有发生过修改，并且请求头中的条件参数与资源的实际情况匹配，服务器会返回304状态码，表示资源未被修改。</li>
<li>客户端收到304状态码后，会从本地缓存中读取该资源，并继续使用缓存的资源，无需重新下载。</li>
</ol>
<p>使用304状态码可以有效减少网络流量和服务器负载，提高网站的性能和响应速度。客户端和服务器之间的交互变为”请求-响应-缓存”的模式，减少了不必要的数据传输和服务器资源消耗。</p>
<p>要使用304状态码进行缓存优化，服务器通常会设置合适的缓存策略和响应头，包括设置Expires或Cache-Control等响应头，以及设置Last-Modified或Etag等条件参数，使得客户端和服务器可以进行缓存的判断和验证。同时，客户端也需要正确处理304状态码，从本地缓存中读取资源，并且在合适的时机重新发起条件请求，以确保缓存的资源始终是最新的</p>
<h4 id="29-什么是CDN-以及如何优化"><a href="#29-什么是CDN-以及如何优化" class="headerlink" title="29.什么是CDN,以及如何优化?"></a>29.什么是CDN,以及如何优化?</h4><p>CDN（Content Delivery Network）是内容分发网络的缩写。它是一种分布式的网络架构，通过将内容（如网页、图片、视频等静态资源）存储在离用户最近的服务器上，以提供更快速、可靠的内容传输和访问体验。</p>
<p>CDN优化的主要目标是减少网络延迟和提高页面加载速度，从而改善用户体验和网站性能。以下是一些CDN优化的方法：</p>
<ol>
<li><strong>内容缓存：</strong> CDN会将网站的静态资源缓存到多个节点服务器上，当用户请求访问这些资源时，可以直接从最近的节点服务器获取，避免了跨地区的数据传输，减少了网络延迟。</li>
<li><strong>负载均衡：</strong> CDN可以根据服务器的负载情况和用户的地理位置，将用户的请求分配给最合适的节点服务器，从而实现负载均衡，提高服务器的处理能力。</li>
<li><strong>数据压缩：</strong> CDN可以对网站的静态资源进行压缩，减小文件大小，从而减少数据传输量，提高页面加载速度。</li>
<li><strong>智能DNS解析：</strong> CDN会对DNS解析进行优化，根据用户的地理位置选择最近的节点服务器，从而加速DNS解析过程。</li>
<li><strong>预加载：</strong> CDN可以对网站的静态资源进行预加载，提前将资源缓存在节点服务器上，当用户请求访问时，可以直接从缓存中获取，减少等待时间。</li>
<li><strong>HTTP&#x2F;2支持：</strong> CDN支持HTTP&#x2F;2协议，可以提供多路复用和服务器推送等功能，从而减少连接数量和提高资源加载效率。</li>
<li><strong>缓存策略优化：</strong> 合理设置缓存策略，对不经常变化的静态资源进行长时间缓存，对动态资源进行短时间缓存，可以有效减少对源服务器的请求。</li>
</ol>
<p>通过使用CDN优化，可以有效提高网站的性能和用户体验，减少服务器负载，增加访问速度，并提高网站的可用性和稳定性。</p>
<h4 id="30-DNS是什么"><a href="#30-DNS是什么" class="headerlink" title="30.DNS是什么"></a>30.DNS是什么</h4><p>DNS是Domain Name System（域名系统）的缩写。它是一种用于将域名（如”<a target="_blank" rel="noopener external nofollow noreferrer" href="http://www.example.xn--com"">www.example.com"）转换为对应的IP地址（如192.0.2.1）的分布式命名系统。在互联网中，每台计算机都需要一个唯一的IP地址来进行通信，而IP地址通常是一串数字，不方便记忆。因此，人们使用域名来代替IP地址进行访问。</a>ip(192-oo1u065hlha146amqldom1mx505gwrtf.0.2.xn–1)-6d5cy0f8p907bvwbrw4gzfmkoe.xn–%2Cip%2Cip%2C-5t3kaf8l1nhb6ey2f93jkqa861disfnnldfe77af192xo9qh2j423buzb7ufbqltmbe70g4c0f3dtbeb2ahxfvzcwx9j3ckg2v5sag74lijcha435hxw7e.xn–%2Cip-zn9djh0by1es0y1rgdxalf19ei28g0fbi48a861bj98de8mbnswu2a.&#x2F;)</p>
<p>DNS的主要作用是将域名映射到对应的IP地址，使得用户可以通过输入域名来访问网站，而不需要记住复杂的IP地址。DNS使用一种分层、分布式的结构，由多个DNS服务器组成，它们相互协作来提供域名解析服务。</p>
<p>当用户在浏览器中输入一个域名时，浏览器会向本地DNS服务器发起查询，询问该域名对应的IP地址。如果本地DNS服务器没有缓存这个域名的解析结果，它就会向更上层的DNS服务器发起查询，逐级向上查询，直到找到一个能够提供域名解析的DNS服务器。</p>
<p>DNS的查询过程是逐级向上查询的过程，但在实际运行中，为了加快查询速度，DNS服务器会将查询结果缓存一段时间，以便下次查询时可以直接返回结果，而不需要再进行逐级查询。</p>
<p>总结来说，DNS是一种将域名映射到IP地址的系统，它在互联网中起到了非常重要的作用，是实现域名访问的基础。</p>
<h4 id="31-什么是四层、七层网络模型"><a href="#31-什么是四层、七层网络模型" class="headerlink" title="31.什么是四层、七层网络模型?"></a>31.什么是四层、七层网络模型?</h4><p>四层和七层网络模型是计算机网络中常用的两种网络模型，用于描述网络中不同层次的功能和协议。</p>
<ol>
<li><strong>四层网络模型（OSI模型）</strong>：</li>
</ol>
<p>四层网络模型，也称为OSI模型，是由国际标准化组织（ISO）制定的网络通信参考模型，将网络通信划分为四个层次，每个层次负责不同的功能。</p>
<ul>
<li><strong>物理层（Physical Layer）</strong>：负责物理传输介质上的数据传输，例如网线、光纤等。</li>
<li><strong>数据链路层（Data Link Layer）</strong>：处理相邻节点之间的数据传输，确保数据在物理介质上的可靠传输，如MAC地址。</li>
<li><strong>网络层（Network Layer）</strong>：负责网络之间的数据传输和路由选择，如IP地址。</li>
<li><strong>传输层（Transport Layer）</strong>：负责端到端的数据传输和错误检测，如TCP和UDP协议。</li>
</ul>
<ol>
<li><strong>七层网络模型（OSI&#x2F;RM模型）</strong>：</li>
</ol>
<p>七层网络模型是由国际标准化组织（ISO）和国际电信联盟（ITU）共同制定的网络通信参考模型，也称为OSI&#x2F;RM模型，将网络通信划分为七个层次，每个层次负责不同的功能。</p>
<ul>
<li><strong>物理层（Physical Layer）</strong>：同四层模型一样，负责物理传输介质上的数据传输。</li>
<li><strong>数据链路层（Data Link Layer）</strong>：同四层模型一样，处理相邻节点之间的数据传输。</li>
<li><strong>网络层（Network Layer）</strong>：同四层模型一样，负责网络之间的数据传输和路由选择。</li>
<li><strong>传输层（Transport Layer）</strong>：同四层模型一样，负责端到端的数据传输和错误检测。</li>
<li><strong>会话层（Session Layer）</strong>：负责建立、维护和终止应用程序之间的会话连接。</li>
<li><strong>表示层（Presentation Layer）</strong>：负责数据的格式转换、加密和压缩，确保数据在应用层之间的正确传递。</li>
<li><strong>应用层（Application Layer）</strong>：提供应用程序之间的通信服务，包括HTTP、FTP、SMTP等协议。</li>
</ul>
<p>七层网络模型在功能上更加细分，每个层次的职责更加明确，但在实际网络通信中，更常用的是四层网络模型，因为它更加简单，更符合实际应用场景。七层模型主要用于理论研究和教学。</p>
<h2 id="网络安全"><a href="#网络安全" class="headerlink" title="网络安全"></a>网络安全</h2><h4 id="1-什么是xss攻击及如何防范"><a href="#1-什么是xss攻击及如何防范" class="headerlink" title="1.什么是xss攻击及如何防范"></a>1.什么是xss攻击及如何防范</h4><p>XSS（Cross-Site Scripting）跨站脚本攻击是一种常见的网络安全漏洞，攻击者通过在网页中插入恶意脚本，使用户的浏览器执行这些恶意脚本，从而窃取用户信息、篡改网页内容或进行其他恶意行为。</p>
<p>XSS攻击分为三种类型：</p>
<ol>
<li><strong>存储型XSS</strong>：恶意脚本被存储在服务器上，并在用户访问被感染的页面时执行。攻击者通常通过提交带有恶意脚本的表单或评论等方式将恶意脚本存储到服务器中。</li>
<li><strong>反射型XSS</strong>：恶意脚本作为URL的一部分，用户点击恶意链接时，恶意脚本被传递给服务器并执行。攻击者通常会将恶意链接通过电子邮件、社交媒体等方式传播给用户。</li>
<li><strong>DOM型XSS</strong>：恶意脚本直接修改网页的DOM结构，从而触发执行。攻击者通常通过改变URL或其他用户可控的参数来触发DOM型XSS攻击。</li>
</ol>
<p>为了防范XSS攻击，可以采取以下措施：</p>
<ol>
<li><strong>输入验证和过滤</strong>：对于用户输入的数据，进行严格的验证和过滤，确保只接受合法的数据，防止恶意脚本被插入。</li>
<li><strong>输出转义</strong>：在将用户输入数据输出到网页时，将特殊字符转义为HTML实体，例如将”&lt;”转义为”&lt;”，这样可以防止脚本被执行。</li>
<li><strong>HttpOnly标记</strong>：在设置cookie时，使用HttpOnly标记，防止JavaScript脚本获取cookie，从而减少受到XSS攻击的风险。</li>
<li><strong>设置Content Security Policy（CSP）</strong>：CSP是一种HTTP头，可以指定哪些外部资源可以被加载和执行，从而限制恶意脚本的来源和执行。</li>
<li><strong>使用安全的编程实践</strong>：避免在网页中直接拼接动态内容，而是使用安全的编程实践，例如使用模板引擎来插入动态内容。</li>
<li><strong>限制用户的输入权限</strong>：对于一些用户权限较高的功能，要求用户进行身份验证或授权，避免未授权用户执行恶意操作。</li>
</ol>
<p>总的来说，防范XSS攻击需要综合考虑多种方法，包括前端和后端的安全措施，以确保用户的信息和网站的安全。同时，及时更新网站的漏洞和安全策略，以防止新型的XSS攻击。</p>
<h4 id="2-什么是ddos攻击及如何防范"><a href="#2-什么是ddos攻击及如何防范" class="headerlink" title="2.什么是ddos攻击及如何防范?"></a>2.什么是ddos攻击及如何防范?</h4><p>DDoS攻击是一种分布式的拒绝服务攻击，旨在通过大量虚假请求或恶意流量，使目标服务器或网络不可用，从而使合法用户无法访问服务。</p>
<p>DDoS攻击通常涉及多台被控制的计算机或设备（称为僵尸机），这些机器同时向目标服务器发送大量请求，导致服务器资源耗尽，无法处理合法用户的请求，从而导致服务停止响应。</p>
<p>防范DDoS攻击可以采取以下措施：</p>
<ol>
<li><strong>使用DDoS防火墙</strong>：DDoS防火墙可以识别和过滤掉恶意流量，阻止攻击流量达到目标服务器。</li>
<li><strong>负载均衡</strong>：通过使用负载均衡器，将请求分发到多台服务器，可以分散DDoS攻击对单个服务器的影响。</li>
<li><strong>增加带宽和服务器资源</strong>：增加网络带宽和服务器资源可以增加服务器的承载能力，从而更好地应对DDoS攻击。</li>
<li><strong>黑名单和白名单</strong>：对于IP地址进行黑名单和白名单管理，可以阻止或允许特定IP地址的访问，从而过滤掉恶意流量。</li>
<li><strong>合理设置请求频率限制</strong>：设置请求频率限制，限制单个IP地址或用户在特定时间内的请求次数，可以防止DDoS攻击中的某些恶意请求。</li>
<li><strong>网络流量监测和分析</strong>：实时监测网络流量，及时发现异常流量并采取措施进行阻断。</li>
<li><strong>云防护服务</strong>：使用云防护服务可以将攻击流量分散到云端进行处理，保护服务器免受DDoS攻击。</li>
</ol>
<p>总的来说，防范DDoS攻击需要采取多层次的安全措施，包括网络层面的防护和服务器层面的优化，以确保网络和服务的稳定性和可用性。同时，及时监测和响应异常流量，快速恢复服务也是重要的应对策略。</p>
<h4 id="3-什么是csrf攻击及如何防范"><a href="#3-什么是csrf攻击及如何防范" class="headerlink" title="3.什么是csrf攻击及如何防范?"></a>3.什么是csrf攻击及如何防范?</h4><p>CSRF（Cross-Site Request Forgery）跨站请求伪造，是一种常见的网络安全攻击方式。攻击者利用用户已登录的身份，在用户不知情的情况下，发送伪造的请求，以达到窃取用户信息、执行非法操作等恶意目的。</p>
<p>CSRF攻击的原理是利用网站对用户请求的信任，攻击者通过诱使用户访问恶意网站或点击恶意链接，触发网站对另一个站点的请求。由于浏览器会自动携带用户的登录信息，因此攻击者可以利用这个漏洞发送伪造请求，从而实施攻击。</p>
<p>为了防范CSRF攻击，可以采取以下措施：</p>
<ol>
<li><strong>验证来源站点</strong>：服务器可以检查请求的来源站点，如果请求不是来自合法的站点，可以拒绝该请求。</li>
<li><strong>使用验证码</strong>：要求用户在重要操作前输入验证码，可以防止CSRF攻击，因为攻击者无法获取验证码。</li>
<li><strong>添加随机令牌</strong>：在用户登录后，服务器生成一个随机令牌，并将其添加到用户的会话中和每个表单提交中。当用户提交表单时，服务器验证令牌的有效性，如果令牌无效，则拒绝请求。</li>
<li><strong>设置同源策略</strong>：使用同源策略限制跨站点的请求，可以有效防止CSRF攻击。</li>
<li><strong>设置HttpOnly标记</strong>：在设置用户的身份认证cookie时，使用HttpOnly标记，防止JavaScript脚本获取cookie，减少受到攻击的风险。</li>
<li><strong>定期更改密码</strong>：建议用户定期更改密码，减少受到CSRF攻击的风险。</li>
<li><strong>使用POST请求</strong>：在涉及敏感操作时，尽量使用POST请求，因为CSRF攻击通常利用GET请求来实施攻击。</li>
</ol>
<p>总的来说，防范CSRF攻击需要综合考虑多种方法，包括服务器端的验证和安全策略，以及前端的措施，确保用户请求的合法性，保护用户的安全和隐私。</p>
<h2 id="前端工程化"><a href="#前端工程化" class="headerlink" title="前端工程化"></a>前端工程化</h2><h4 id="1-如何理解前端模块化、前端组件化，二者有何区别"><a href="#1-如何理解前端模块化、前端组件化，二者有何区别" class="headerlink" title="1.如何理解前端模块化、前端组件化，二者有何区别?"></a>1.如何理解前端模块化、前端组件化，二者有何区别?</h4><p>前端模块化和前端组件化是两个重要的概念，它们都是为了更好地组织和管理前端代码，提高开发效率和代码复用性。</p>
<ol>
<li>前端模块化：</li>
</ol>
<p>前端模块化是将一个大的前端应用拆分成多个小的模块，每个模块都有自己的功能和职责，通过模块化的方式将代码进行分离和组织，使得代码更加清晰、可维护性更强。</p>
<p>常见的前端模块化方案有 CommonJS、AMD、ES6 Modules 等。这些方案允许开发者使用 <code>require</code> 或 <code>import</code> 等语法来导入其他模块，并将模块中的代码进行封装，避免了全局变量污染，提高了代码的可维护性和可复用性。</p>
<ol>
<li>前端组件化：</li>
</ol>
<p>前端组件化是将页面的各个部分拆分成独立的组件，每个组件都是一个相对独立的单元，具有自己的样式和行为，可以在多个页面中重复使用。</p>
<p>通过前端组件化，可以将页面拆分成多个小的组件，每个组件专注于处理一个特定的功能或展示效果，使得代码更加模块化、可复用性更高，同时也方便团队协作和维护。</p>
<p>区别：</p>
<p>前端模块化和前端组件化是两个不同的概念，但它们有一些相似之处。前端模块化强调的是代码的组织方式，将代码按功能进行拆分和组织，而前端组件化强调的是页面的组织方式，将页面拆分成独立的组件来构建。</p>
<p>前端模块化更注重代码的复用性，可以在不同的模块中导入和使用其他模块的代码；前端组件化更注重页面的复用性，可以在不同的页面中使用相同的组件。</p>
<p>综合来说，前端模块化和前端组件化是相辅相成的概念，它们都是为了实现代码的高度复用和可维护性，帮助开发者构建更加高效、健壮的前端应用。</p>
<h4 id="2-如何理解前后端分离"><a href="#2-如何理解前后端分离" class="headerlink" title="2.如何理解前后端分离?"></a>2.如何理解前后端分离?</h4><p>前后端分离是一种软件架构模式，它将前端和后端的开发分离开来，使得前端和后端可以独立开发，通过接口进行数据交互。在前后端分离的架构中，前端和后端是两个独立的项目，它们可以使用不同的技术栈和开发语言，从而提高开发效率和灵活性。</p>
<p>在传统的开发模式中，前端和后端的开发是耦合在一起的，前端负责展示页面和用户交互，后端负责处理业务逻辑和数据存储。这种模式下，前端和后端的开发必须紧密配合，前端需要等待后端接口的开发和联调，而后端需要等待前端页面的开发完成。</p>
<p>而在前后端分离的模式下，前端和后端是完全独立的，它们之间通过接口进行数据交互。前端负责页面的渲染和用户交互，后端负责处理业务逻辑和数据存储，前端和后端可以并行开发，互不影响。这样可以提高开发效率，减少开发时间，同时也方便不同团队协同开发。</p>
<p>前后端分离的架构模式还有以下优点：</p>
<ol>
<li>前后端独立部署：前端和后端可以独立部署，前端部署在Web服务器上，后端部署在应用服务器上，分别负责不同的任务，提高了系统的稳定性和可扩展性。</li>
<li>增加前端重用性：前后端分离后，前端可以根据需要在不同的项目中重用组件和页面，提高了前端代码的重用性。</li>
<li>前端技术栈灵活：前后端分离允许前端使用任意的技术栈，可以选择最适合项目需求的技术，不再受限于后端的技术栈。</li>
<li>接口规范化：前后端分离需要定义接口规范，使得前后端之间的数据交互更加明确和规范化，有利于团队协作和开发。</li>
</ol>
<p>总的来说，前后端分离是一种优秀的软件架构模式，它将前端和后端的开发解耦，提高了开发效率和代码重用性，使得前后端开发更加灵活和高效。</p>
<h3 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h3><h4 id="3-有自己配置过webpack吗-如果需求是多页面与单页面并行，需要如何配置"><a href="#3-有自己配置过webpack吗-如果需求是多页面与单页面并行，需要如何配置" class="headerlink" title="3.有自己配置过webpack吗?如果需求是多页面与单页面并行，需要如何配置?"></a>3.有自己配置过webpack吗?如果需求是多页面与单页面并行，需要如何配置?</h4><h5 id="配置Webpack支持多页面和单页面并行："><a href="#配置Webpack支持多页面和单页面并行：" class="headerlink" title="配置Webpack支持多页面和单页面并行："></a>配置Webpack支持多页面和单页面并行：</h5><ol>
<li><strong>目录结构准备</strong>：首先，需要在项目中建立不同的页面目录结构，每个页面目录下应包含一个入口文件（如index.js）和一个HTML模板文件（如index.html）。</li>
<li><strong>配置入口</strong>：在Webpack的配置文件中，使用entry配置多个入口点，每个入口点对应一个页面目录的入口文件。</li>
<li><strong>配置输出</strong>：使用output配置输出文件的规则，确保输出文件名与入口文件对应，并设置正确的输出路径。</li>
<li><strong>配置HtmlWebpackPlugin</strong>：使用HtmlWebpackPlugin插件为每个页面生成HTML文件，并指定对应的入口文件。</li>
<li><strong>配置多页面路由</strong>：如果有多个页面需要共享一些公共组件或资源，可以通过配置多页面路由来实现。</li>
</ol>
<p>示例Webpack配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    page1: &#x27;./src/page1/index.js&#x27;,</span><br><span class="line">    page2: &#x27;./src/page2/index.js&#x27;,</span><br><span class="line">    app: &#x27;./src/app/index.js&#x27; // 单页面应用的入口文件</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &#x27;[name].[contenthash].js&#x27;,</span><br><span class="line">    path: path.resolve(__dirname, &#x27;dist&#x27;)</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    new HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: &#x27;./src/page1/index.html&#x27;,</span><br><span class="line">      chunks: [&#x27;page1&#x27;],</span><br><span class="line">      filename: &#x27;page1.html&#x27;</span><br><span class="line">    &#125;),</span><br><span class="line">    new HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: &#x27;./src/page2/index.html&#x27;,</span><br><span class="line">      chunks: [&#x27;page2&#x27;],</span><br><span class="line">      filename: &#x27;page2.html&#x27;</span><br><span class="line">    &#125;),</span><br><span class="line">    // 其他插件和配置</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在以上示例中，Webpack配置了多个入口文件，并使用HtmlWebpackPlugin插件为每个页面生成对应的HTML文件。同时，也配置了单页面应用的入口文件，使多页面和单页面可以并行开发。</p>
<p>根据项目的实际需求，还可以进一步配置不同的Loader和Plugin，以满足不同页面的开发和优化需求。请根据您的具体项目结构和需求进行调整和扩展。</p>
<h4 id="4-Webpack的优点是什么"><a href="#4-Webpack的优点是什么" class="headerlink" title="4.Webpack的优点是什么?"></a>4.Webpack的优点是什么?</h4><p>Webpack具有许多优点，使其成为前端项目中最受欢迎的打包工具之一。以下是Webpack的一些优点：</p>
<ol>
<li><strong>模块化支持</strong>：Webpack支持将项目拆分成小模块，并通过导入和导出语法进行模块化开发，提高代码的可维护性和复用性。</li>
<li><strong>代码拆分</strong>：Webpack支持将代码拆分成多个bundle，实现按需加载，减少初次加载的时间和页面大小。</li>
<li><strong>丰富的Loader支持</strong>：Webpack允许通过Loader对不同类型的文件进行处理和转换，例如处理CSS、Less、Sass、图片等文件，使得开发过程更加灵活。</li>
<li><strong>插件扩展性</strong>：Webpack提供了丰富的插件系统，可以通过插件来扩展和优化Webpack的功能，满足不同项目的需求。</li>
<li><strong>开发工具</strong>：Webpack提供了强大的开发工具，例如热模块替换（HMR）、代码分析工具等，帮助开发者提高开发效率和调试能力。</li>
<li><strong>代码压缩和优化</strong>：Webpack可以对代码进行压缩和优化，减小文件体积，提高页面加载速度。</li>
<li><strong>多环境支持</strong>：Webpack支持多环境配置，可以根据开发、测试和生产环境的不同需求来进行配置。</li>
<li><strong>社区活跃</strong>：Webpack拥有庞大的开发者社区，有大量的文档、插件和开源项目可供使用，解决问题和学习都非常方便。</li>
<li><strong>资源加载优化</strong>：Webpack可以将小图片转换成base64格式，减少HTTP请求，提高页面加载速度。</li>
</ol>
<p>综上所述，Webpack具有丰富的功能和强大的生态系统，能够帮助开发者更高效地构建、打包和优化前端项目。</p>
<h4 id="5-Webpack的构建流程是什么-从读取配置到输出文件这个过程尽量说全"><a href="#5-Webpack的构建流程是什么-从读取配置到输出文件这个过程尽量说全" class="headerlink" title="5.Webpack的构建流程是什么?从读取配置到输出文件这个过程尽量说全"></a>5.Webpack的构建流程是什么?从读取配置到输出文件这个过程尽量说全</h4><p>Webpack的构建流程主要包括以下几个步骤：</p>
<ol>
<li><strong>读取配置文件</strong>：Webpack会首先读取项目根目录下的webpack配置文件（通常为webpack.config.js），获取其中的配置信息。</li>
<li><strong>解析入口文件</strong>：根据配置文件中的entry字段，Webpack会找到所有的入口文件，并从这些入口文件开始分析和构建依赖关系。</li>
<li><strong>依赖图分析</strong>：Webpack会递归地分析入口文件和它们的依赖文件，构建一个完整的依赖图，形成模块之间的依赖关系。</li>
<li><strong>模块解析和转换</strong>：Webpack会根据模块的类型（JavaScript、CSS、图片等）使用对应的Loader对模块进行解析和转换，将其转换成有效的JavaScript代码。</li>
<li><strong>插件处理</strong>：在模块转换的过程中，Webpack会根据配置文件中的plugins字段使用相应的插件对代码进行处理，例如代码压缩、文件拷贝等操作。</li>
<li><strong>输出文件</strong>：当所有的模块解析和转换完成后，Webpack会将最终的构建结果输出到指定的输出目录中。输出的文件名和路径通常由output字段配置决定。</li>
<li><strong>模块加载和代码执行</strong>：当浏览器加载输出的文件时，Webpack会将模块加载器（通常是webpack-runtime.js）插入到输出文件的头部，用于在浏览器中解析和加载模块。</li>
<li><strong>运行时逻辑处理</strong>：Webpack会根据配置文件中的mode字段确定运行时的逻辑，例如在开发环境下会添加热模块替换的逻辑，以实现代码的实时更新。</li>
</ol>
<p>总体来说，Webpack的构建流程包括了对入口文件和依赖文件的解析、模块转换和插件处理，最终将构建结果输出到指定的输出目录中，供浏览器加载和执行。在整个构建过程中，Webpack会根据配置文件中的设置来决定具体的构建行为和优化策略。</p>
<h4 id="6-说一下Webpack的热更新原理"><a href="#6-说一下Webpack的热更新原理" class="headerlink" title="6.说一下Webpack的热更新原理"></a>6.说一下Webpack的热更新原理</h4><p>Webpack的热更新（Hot Module Replacement，简称HMR）是一种提高开发效率的技术，它使得在开发过程中，当代码发生改变时，只更新发生改变的部分，而不需要整个页面刷新，从而减少了开发的重复工作和等待时间。</p>
<p>热更新的原理主要分为以下几个步骤：</p>
<ol>
<li>监听文件变化：Webpack通过监听文件系统的变化，当文件发生改变时，Webpack能够感知到。</li>
<li>构建新模块：当文件发生改变时，Webpack会重新构建该模块，并生成新的模块代码。</li>
<li>传递更新信号：在构建新模块后，Webpack会通过WebSocket或者XHR等方式向客户端发送更新信号。</li>
<li>客户端更新：客户端收到更新信号后，通过HMR Runtime（内置在Webpack生成的代码中），会根据更新信号进行更新，将新的模块代码插入到页面中，同时更新页面的状态。</li>
</ol>
<p>通过这种方式，热更新可以实现在不刷新整个页面的情况下，更新页面的部分内容，保持页面的状态和用户的交互，从而提高开发效率。</p>
<p>在使用Webpack时，开启热更新可以通过在配置文件中加入相应的配置来实现，例如使用<code>webpack-dev-server</code>插件或<code>webpack-hot-middleware</code>插件来实现热更新功能。</p>
<p>需要注意的是，热更新只在开发环境下使用，不应该在生产环境中使用，因为它会增加额外的代码和开销。在生产环境中应该使用Webpack的代码分割和缓存等技术来优化性能。</p>
<h4 id="7-有哪些常见的Loader-他们是解决什么问题的"><a href="#7-有哪些常见的Loader-他们是解决什么问题的" class="headerlink" title="7.有哪些常见的Loader?他们是解决什么问题的?"></a>7.有哪些常见的Loader?他们是解决什么问题的?</h4><p>常见的Loader是用于处理各种非JavaScript文件，将它们转换为Webpack可识别的模块。以下是一些常见的Loader及它们解决的问题：</p>
<ol>
<li>babel-loader：将ES6+的代码转换成向后兼容的JavaScript，解决不同浏览器对新语法的支持问题。</li>
<li>css-loader：解析CSS文件，并处理其中的import和url()等语法，使得Webpack可以识别CSS文件并将其打包。</li>
<li>style-loader：将解析后的CSS代码以<style>标签的形式插入到HTML文件中，使得样式可以生效。</li>
<li>sass-loader：解析Sass&#x2F;Scss文件，将其转换为CSS文件。</li>
<li>less-loader：解析Less文件，将其转换为CSS文件。</li>
<li>file-loader：处理图片、字体等文件，将它们复制到输出目录，并返回对应的路径。</li>
<li>url-loader：类似于file-loader，但可以根据文件大小将文件转换成DataURL，减少HTTP请求。</li>
<li>vue-loader：处理Vue单文件组件，将其转换为JavaScript模块。</li>
<li>json-loader：解析JSON文件，将其转换为JavaScript对象。</li>
<li>xml-loader：解析XML文件。</li>
</ol>
<p>这些Loader可以使得Webpack可以处理各种类型的资源文件，并将它们转换为可以被打包和使用的模块。通过使用不同的Loader，我们可以实现对不同类型文件的自动转换和处理，从而提高开发效率和优化前端资源。</p>
<h4 id="8-Loader-和Plugin的不同"><a href="#8-Loader-和Plugin的不同" class="headerlink" title="8.Loader 和Plugin的不同?"></a>8.Loader 和Plugin的不同?</h4><p>Loader和Plugin是Webpack两个重要的概念，它们的作用和用途有所不同：</p>
<ol>
<li>Loader：</li>
</ol>
<p>Loader是Webpack的核心功能之一，它用于处理非JavaScript文件（例如CSS、图片、字体等），将它们转换为Webpack可识别的模块。在Webpack的配置文件中，通过配置不同的Loader，可以将不同类型的文件转换成适合打包的模块。</p>
<p>Loader的作用是将源文件进行转换和处理，从而让Webpack可以识别和打包这些文件。例如，可以使用css-loader将CSS文件转换成JS模块，使用file-loader将图片转换成文件。</p>
<ol>
<li>Plugin：</li>
</ol>
<p>Plugin也是Webpack的核心功能，它用于扩展Webpack的功能，解决一些其他任务。Plugin在Webpack构建过程的不同阶段被调用，可以用于执行各种任务，例如压缩代码、代码分割、生成HTML文件、提取CSS等。</p>
<p>Plugin的作用是在Webpack构建过程中，对资源进行处理和优化。它可以修改输出文件、增加新的文件、在特定阶段执行自定义逻辑等。</p>
<p>总结：</p>
<p>Loader主要是用来处理文件，将文件转换成模块，让Webpack能够处理这些非JavaScript资源。而Plugin主要是用来扩展Webpack的功能，解决其他与文件转换无关的任务，如优化、代码注入、资源管理等。</p>
<p>在Webpack的配置中，Loader通过<code>module.rules</code>配置进行使用，而Plugin通过<code>plugins</code>配置进行使用。Loader和Plugin是Webpack中实现自动化构建和优化的两个重要组成部分，它们共同构成了Webpack的核心功能。</p>
<h4 id="9-如何利用Webpack来优化前端性能"><a href="#9-如何利用Webpack来优化前端性能" class="headerlink" title="9.如何利用Webpack来优化前端性能"></a>9.如何利用Webpack来优化前端性能</h4><p>Webpack可以通过以下方式来优化前端性能：</p>
<ol>
<li>代码分割：使用Webpack的代码分割功能，将代码分割成多个小块，按需加载，减少首次加载的时间和资源消耗。</li>
<li>文件压缩：使用Webpack的UglifyJsPlugin等插件来压缩JavaScript代码，使用OptimizeCSSAssetsPlugin来压缩CSS代码，减少文件的大小，加快加载速度。</li>
<li>Tree Shaking：使用Webpack的Tree Shaking功能，移除未使用的代码，减少打包后的文件大小。</li>
<li>图片优化：使用url-loader或者image-webpack-loader来优化图片，可以将小图片转换成DataURL或者压缩图片，减少图片的大小。</li>
<li>缓存优化：使用Webpack的hash或者chunkhash来为输出的文件添加hash值，实现文件的缓存优化。</li>
<li>异步加载：使用Webpack的动态import()或者使用import()函数来实现模块的异步加载，减少初始加载时间。</li>
<li>代码拆分：使用Webpack的SplitChunksPlugin来拆分代码块，将公共代码提取出来，减少重复加载和提高缓存利用率。</li>
<li>使用CDN：将一些公共库或者静态资源放在CDN上，加快加载速度。</li>
<li>缓存配置：对Webpack的构建结果进行缓存配置，加快重复构建的速度。</li>
<li>懒加载：使用Webpack的动态import()或者require.ensure()来实现模块的懒加载，提高页面的加载速度。</li>
</ol>
<p>以上是一些常见的Webpack优化方式，通过合理地配置Webpack，可以显著地提高前端性能，减少页面加载时间，提升用户体验。</p>
<h4 id="10-否过Loader和Plugin-描述一下编写-loader或plugin的思路"><a href="#10-否过Loader和Plugin-描述一下编写-loader或plugin的思路" class="headerlink" title="10.否过Loader和Plugin?描述一下编写 loader或plugin的思路?"></a>10.否过Loader和Plugin?描述一下编写 loader或plugin的思路?</h4><p>Loader和Plugin是Webpack中两个重要的概念，它们分别用于处理模块和扩展Webpack的功能。下面分别描述编写Loader和Plugin的思路：</p>
<h5 id="编写Loader的思路："><a href="#编写Loader的思路：" class="headerlink" title="编写Loader的思路："></a>编写Loader的思路：</h5><ol>
<li>确定输入和输出：首先确定Loader的输入和输出。Loader接收的是模块的源代码或资源文件，并输出经过处理后的代码或资源。</li>
<li>了解文件类型：根据需要处理的文件类型，了解其格式和结构，确定处理方式。</li>
<li>编写处理逻辑：根据文件类型和需求，编写处理逻辑。可以使用正则表达式、字符串替换、AST解析等方式对源代码进行转换和处理。</li>
<li>处理选项：考虑是否需要提供可配置的处理选项，以便用户在webpack配置中灵活地调整Loader的行为。</li>
<li>错误处理：在处理过程中，注意捕获和处理错误，确保Loader的健壮性和稳定性。</li>
<li>单元测试：编写单元测试来验证Loader的功能和正确性。</li>
<li>注册Loader：最后，将编写好的Loader注册到webpack配置中，让Webpack在构建过程中使用你的Loader。</li>
</ol>
<h5 id="编写Plugin的思路："><a href="#编写Plugin的思路：" class="headerlink" title="编写Plugin的思路："></a>编写Plugin的思路：</h5><ol>
<li>了解钩子：Plugin通过挂载在Webpack的钩子上来实现功能。首先了解Webpack提供了哪些钩子，选择合适的钩子来实现你的功能。</li>
<li>确定功能：明确Plugin的功能和目标，确保你的Plugin能够满足特定的需求。</li>
<li>编写插件代码：编写插件的代码逻辑，可以是一系列的处理步骤或是一个独立的功能。</li>
<li>处理参数：考虑是否需要接受参数，通过配置来灵活调整插件的功能。</li>
<li>错误处理：在插件的处理过程中，注意捕获和处理错误，确保插件的稳定性。</li>
<li>效率优化：尽量避免耗时的操作，考虑效率优化，减少构建时间。</li>
<li>测试插件：编写测试用例，验证插件的功能和正确性。</li>
<li>注册插件：将编写好的插件注册到webpack配置中，让Webpack在构建过程中使用你的插件。</li>
</ol>
<p>编写Loader和Plugin都需要深入了解Webpack的内部工作原理和提供的API，同时要考虑到用户的需求和使用场景，确保编写出高效、稳定且易用的Loader和Plugin。</p>
<h4 id="11-使用Webpack开发时，你用过哪些可以提高效率的插件"><a href="#11-使用Webpack开发时，你用过哪些可以提高效率的插件" class="headerlink" title="11.使用Webpack开发时，你用过哪些可以提高效率的插件?"></a>11.使用Webpack开发时，你用过哪些可以提高效率的插件?</h4><ol>
<li>HtmlWebpackPlugin：自动生成HTML文件，并自动引入打包后的资源文件。</li>
<li>MiniCssExtractPlugin：将CSS代码提取成单独的文件，避免将CSS嵌入到JS文件中。</li>
<li>CleanWebpackPlugin：在每次构建前清理输出目录，防止旧的文件残留。</li>
<li>HotModuleReplacementPlugin：启用热模块替换，实现无需刷新页面即可更新模块。</li>
<li>DefinePlugin：定义全局变量，例如在开发环境和生产环境中切换接口地址。</li>
<li>UglifyJsPlugin：压缩JS代码，减少文件体积。</li>
<li>OptimizeCSSAssetsPlugin：压缩CSS代码，减少文件体积。</li>
<li>BundleAnalyzerPlugin：可视化分析打包文件的大小和组成，帮助优化打包结果。</li>
<li>CopyWebpackPlugin：拷贝静态资源文件到输出目录。</li>
<li>HappyPack：多线程构建，加快打包速度。</li>
<li>CompressionWebpackPlugin：对输出的资源文件进行gzip压缩，加快网络传输速度。</li>
<li>SpeedMeasureWebpackPlugin：测量每个插件和loader的耗时，用于优化构建速度。</li>
<li>MiniProgramWebpackPlugin：用于开发小程序的插件，可以实现小程序的构建和优化。</li>
</ol>
<p>这些插件都可以根据项目的需要灵活配置和使用，帮助您提高开发效率和优化构建过程。</p>
<h4 id="12-什么是长缓存-在Webpack中如何做到长缓存优化"><a href="#12-什么是长缓存-在Webpack中如何做到长缓存优化" class="headerlink" title="12.什么是长缓存?在Webpack中如何做到长缓存优化?"></a>12.什么是长缓存?在Webpack中如何做到长缓存优化?</h4><h4 id="13-如何提高Webpack的构建速度"><a href="#13-如何提高Webpack的构建速度" class="headerlink" title="13.如何提高Webpack的构建速度?"></a>13.如何提高Webpack的构建速度?</h4><p>提高Webpack的构建速度是前端开发中非常重要的优化措施，可以从以下几个方面着手：</p>
<ol>
<li>使用最新版本的Webpack和相关插件：Webpack不断更新和优化，新版本通常会有性能改进。确保你使用的是最新版本的Webpack和相关插件，可以获得更好的构建性能。</li>
<li>减少入口文件大小：将入口文件的依赖项和逻辑控制保持最小。尽量避免在入口文件中引入大量不必要的模块，以减少构建时间。</li>
<li>使用多线程&#x2F;多进程构建：使用Webpack的多线程或多进程构建插件，如<code>thread-loader</code>或<code>parallel-webpack</code>，可以利用多核处理器的优势，加快构建速度。</li>
<li>合理使用Loader和Plugin：优化Loader和Plugin的配置，确保只对必要的文件进行处理。避免不必要的重复工作，如对已经处理过的文件再次进行处理。</li>
<li>使用缓存：使用缓存插件，如<code>cache-loader</code>或<code>hard-source-webpack-plugin</code>，可以缓存构建过程中的中间结果，避免重复计算和处理，提高构建速度。</li>
<li>拆分代码：通过代码拆分（Code Splitting）将大型的代码块拆分成较小的模块，可以实现按需加载，减少初始加载时间，提高页面响应速度。</li>
<li>压缩和优化代码：在生产环境下使用压缩和优化插件，如<code>UglifyJsPlugin</code>和<code>OptimizeCSSAssetsPlugin</code>，可以减小文件大小，提高加载速度。</li>
<li>使用动态导入：使用动态导入（Dynamic Import）来延迟加载不必要的模块，避免一次性加载过多的代码，优化页面加载速度。</li>
<li>配置resolve.alias：通过配置resolve.alias将一些常用的模块路径映射为简短的别名，可以减少Webpack的查找时间，加快构建速度。</li>
<li>删除不必要的插件和Loader：确保只使用必要的插件和Loader，删除不必要的配置，减少构建的复杂性。</li>
</ol>
<p>通过以上优化措施，可以显著提高Webpack的构建速度，加快项目的开发和部署过程。</p>
<h4 id="14-怎么实现Webpack的按需加载-什么是神奇注释"><a href="#14-怎么实现Webpack的按需加载-什么是神奇注释" class="headerlink" title="14.怎么实现Webpack的按需加载?什么是神奇注释?"></a>14.怎么实现Webpack的按需加载?什么是神奇注释?</h4><h4 id="15-Babel-的原理是什么"><a href="#15-Babel-的原理是什么" class="headerlink" title="15.Babel 的原理是什么?"></a>15.Babel 的原理是什么?</h4><p>Babel是一个用于将现代JavaScript代码转换成向后兼容版本的工具。它的主要原理是通过使用插件和预设来将新的JavaScript语法和功能转换为ES5或更早版本的代码，从而在旧版浏览器中也能够正确运行。</p>
<p>Babel的工作原理可以分为以下几个步骤：</p>
<ol>
<li>解析：Babel首先将输入的JavaScript代码解析成抽象语法树（AST），这样可以更方便地对代码进行分析和处理。</li>
<li>转换：Babel接下来会遍历AST，通过使用各种插件来进行代码转换。每个插件都负责处理特定的语法或功能，并将其转换成等效的ES5或更早版本的代码。</li>
<li>生成：最后，Babel会将经过转换的AST再次转换回字符串形式的代码，并输出为最终的转换结果。</li>
</ol>
<p>Babel的转换过程是高度可配置的，用户可以根据需要选择不同的插件和预设来实现不同的转换效果。例如，用户可以根据目标浏览器版本选择不同的预设，以便只转换那些需要兼容的语法和功能。</p>
<p>通过Babel的转换，开发者可以使用最新的JavaScript语法和功能，同时保证代码在各种浏览器中都能够正常运行。这使得开发者能够更加自由地选择和使用新的语言特性，而不必担心兼容性问题。</p>
<h4 id="16-如何写一个babel插件"><a href="#16-如何写一个babel插件" class="headerlink" title="16.如何写一个babel插件?"></a>16.如何写一个babel插件?</h4><h4 id="17-rebase-与merge的区别"><a href="#17-rebase-与merge的区别" class="headerlink" title="17.rebase 与merge的区别?"></a>17.rebase 与merge的区别?</h4><h4 id="18-git-reset、git-revert和git-checkout有什么区别"><a href="#18-git-reset、git-revert和git-checkout有什么区别" class="headerlink" title="18.git reset、git revert和git checkout有什么区别?"></a>18.git reset、git revert和git checkout有什么区别?</h4><p><code>git reset</code>、<code>git revert</code>和<code>git checkout</code>是Git中用于撤销和回退操作的三个命令，它们的区别如下：</p>
<ol>
<li><code>git reset</code>：</li>
</ol>
<ul>
<li><p>作用：<code>git reset</code>用于撤销提交，并且可以移动HEAD指针和分支引用。</p>
</li>
<li><p>操作：有三种模式可以使用，分别是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--soft</span><br></pre></td></tr></table></figure>

<p>、</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--mixed</span><br></pre></td></tr></table></figure>

<p>和</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--hard</span><br></pre></td></tr></table></figure>

<p>。</p>
<ul>
<li><code>--soft</code>：仅撤销提交，不会修改暂存区和工作区的内容，可以重新提交。</li>
<li><code>--mixed</code>（默认模式）：撤销提交，并且会取消暂存区的内容，但不会修改工作区的内容。</li>
<li><code>--hard</code>：彻底撤销提交，并且会取消暂存区和工作区的所有更改，慎用，数据会被永久删除。</li>
</ul>
</li>
</ul>
<ol>
<li><code>git revert</code>：</li>
</ol>
<ul>
<li>作用：<code>git revert</code>用于撤销一个或多个提交，但不会移动HEAD指针和分支引用，而是生成一个新的提交来记录撤销的更改。</li>
<li>操作：<code>git revert &lt;commit&gt;</code>可以撤销指定的提交，生成一个新的提交来撤销该提交的更改。</li>
</ul>
<ol>
<li><code>git checkout</code>：</li>
</ol>
<ul>
<li>作用：<code>git checkout</code>用于切换分支或恢复文件，也可以用于撤销工作区的更改。</li>
<li>操作：<code>git checkout &lt;branch&gt;</code>可以切换到指定的分支，<code>git checkout &lt;file&gt;</code>可以恢复指定文件到最新提交的状态，<code>git checkout &lt;commit&gt; &lt;file&gt;</code>可以恢复文件到指定提交的状态。</li>
</ul>
<p>总结：</p>
<ul>
<li><code>git reset</code>用于撤销提交，并且可以移动HEAD指针和分支引用，慎用。</li>
<li><code>git revert</code>用于撤销提交，但不会移动HEAD指针和分支引用，生成一个新的提交来记录撤销的更改。</li>
<li><code>git checkout</code>用于切换分支、恢复文件和撤销工作区的更改。</li>
</ul>
<h4 id="19-webpack-和vite区别-模块化与流的区别"><a href="#19-webpack-和vite区别-模块化与流的区别" class="headerlink" title="19.webpack 和vite区别(模块化与流的区别)"></a>19.webpack 和vite区别(模块化与流的区别)</h4><p>Webpack和Vite是两种前端构建工具，它们在模块化和构建方式上有一些区别：</p>
<ol>
<li>模块化：</li>
</ol>
<p>Webpack使用的是传统的模块化方案，即采用CommonJS或者ES6的模块化规范。在Webpack中，所有的模块都需要提前编译成通用的模块格式，然后再进行打包。</p>
<p>Vite则使用了现代的ES模块（ESM）模块化方案。在Vite中，开发时的模块是以原生ES模块的形式存在的，不需要提前编译成通用的模块格式。这样可以避免模块编译的过程，加快开发的速度。</p>
<ol>
<li>构建方式：</li>
</ol>
<p>Webpack是基于Node.js的构建工具，它在构建过程中需要先把所有的模块都加载进内存，再进行编译和打包。因此，Webpack的构建速度相对较慢。</p>
<p>Vite是基于浏览器的构建工具，它利用了浏览器原生支持ES模块的特性，可以直接在浏览器中进行模块加载和编译。这样可以避免了繁琐的编译过程，使得Vite的构建速度更快。</p>
<p>总结：</p>
<p>Webpack是一种通用的构建工具，适用于复杂的项目和多样化的需求。它的优势在于可以处理各种类型的资源，并提供了丰富的Loader和Plugin来满足不同的开发场景。</p>
<p>Vite是一种专注于开发体验的构建工具，适用于中小型项目和对开发效率要求较高的场景。它利用了浏览器原生支持ES模块的特性，加快了开发速度，但相对于Webpack功能相对较简单。</p>
<p>选择使用Webpack还是Vite，取决于项目的复杂程度和对开发效率的需求。对于大型项目或复杂的需求，Webpack可能更适合；而对于中小型项目或对开发效率要求较高的场景，Vite可能是更好的选择。</p>
<h4 id="20-webpack文件指纹策略-hash-chunkhash-contenthash"><a href="#20-webpack文件指纹策略-hash-chunkhash-contenthash" class="headerlink" title="20.webpack文件指纹策略: hash chunkhash contenthash"></a>20.webpack文件指纹策略: hash chunkhash contenthash</h4><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><h4 id="1-做过哪些前端性能优化相关的事情"><a href="#1-做过哪些前端性能优化相关的事情" class="headerlink" title="1.做过哪些前端性能优化相关的事情?"></a>1.做过哪些前端性能优化相关的事情?</h4><h4 id="2-要加载大量图片，你有哪些方法优化方案"><a href="#2-要加载大量图片，你有哪些方法优化方案" class="headerlink" title="2.要加载大量图片，你有哪些方法优化方案?"></a>2.要加载大量图片，你有哪些方法优化方案?</h4><p>加载大量图片可能会影响页面加载速度和用户体验。为了优化加载大量图片的方案，可以考虑以下几点：</p>
<ol>
<li><strong>懒加载</strong>：将页面上不可见区域的图片先不加载，等到用户滚动到可见区域时再进行加载。这样可以避免一次性加载大量图片导致页面加载缓慢。</li>
<li><strong>图片压缩</strong>：使用合适的图片压缩工具来减小图片文件的大小，提高加载速度。可以使用在线图片压缩工具或者通过构建工具进行图片压缩。</li>
<li><strong>延迟加载</strong>：如果页面上的图片不是首屏必须展示的内容，可以延迟加载这些图片，等到页面其他重要内容加载完毕后再加载图片。</li>
<li><strong>使用合适的图片格式</strong>：根据图片内容选择合适的图片格式，例如使用JPEG格式对照片进行压缩，使用PNG格式对于图标和透明图片。</li>
<li><strong>使用图片精灵</strong>：将多个小图片合并为一个大图片，然后通过CSS的background-position属性来显示需要的部分，减少HTTP请求次数。</li>
<li><strong>使用CDN</strong>：将图片资源放在CDN上，提高图片加载速度，减轻服务器负担。</li>
<li><strong>使用Base64编码</strong>：将小图片直接转换为Base64编码嵌入到HTML或CSS中，减少图片的HTTP请求。</li>
<li><strong>利用缓存</strong>：合理设置图片的缓存策略，让浏览器对图片进行缓存，提高二次加载速度。</li>
<li><strong>预加载</strong>：对于即将出现在页面上的图片，可以使用预加载技术，在首屏加载完成后，提前加载其他页面的图片资源，以提升用户体验。</li>
<li><strong>图片懒加载占位符</strong>：在图片加载前使用占位符，防止图片未加载时页面布局错乱。</li>
</ol>
<p>综合应用上述优化方案，可以有效地提高大量图片的加载性能，优化用户体验。在实际开发中，根据具体场景和需求来选择适合的优化方案。</p>
<h4 id="3-列表无限滚动，数据越来越多，页面卡顿，如何解决"><a href="#3-列表无限滚动，数据越来越多，页面卡顿，如何解决" class="headerlink" title="3.列表无限滚动，数据越来越多，页面卡顿，如何解决?"></a>3.列表无限滚动，数据越来越多，页面卡顿，如何解决?</h4><h4 id="4-for-let-i-x3D-0-i-lt-1000000-i-console-log-i-如何优化"><a href="#4-for-let-i-x3D-0-i-lt-1000000-i-console-log-i-如何优化" class="headerlink" title="4.for (let i&#x3D;0;i&lt;1000000; i++) {console.log(i)} 如何优化?"></a>4.for (let i&#x3D;0;i&lt;1000000; i++) {console.log(i)} 如何优化?</h4><p>在这个代码中，使用<code>console.log(i)</code>打印1000000个数字会导致浏览器控制台输出大量数据，从而影响性能。为了优化这段代码，可以考虑减少输出的数量或者采用其他方式进行输出。</p>
<p>一种优化方式是通过条件限制输出的数量，例如只输出前100个数字：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy codefor (let i = 0; i &lt; 1000000; i++) &#123;</span><br><span class="line">  if (i &lt; 100) &#123;</span><br><span class="line">    console.log(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一种方式是使用定时器来控制输出的频率，避免一次性输出大量数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy codelet i = 0;</span><br><span class="line">const interval = setInterval(() =&gt; &#123;</span><br><span class="line">  console.log(i);</span><br><span class="line">  i++;</span><br><span class="line">  if (i === 1000000) &#123;</span><br><span class="line">    clearInterval(interval);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, 10); // 每10毫秒输出一个数字</span><br></pre></td></tr></table></figure>

<p>这样可以控制输出的速度，避免一次性输出大量数据导致性能问题。</p>
<p>另外，如果只是为了测试性能或者查看数据，可以考虑使用性能分析工具来查看循环的执行时间，而不是直接输出到控制台。例如，在Chrome浏览器中可以使用Performance工具来分析代码的性能表现。</p>
<h4 id="5-谈谈你是如何判断网站的性能的"><a href="#5-谈谈你是如何判断网站的性能的" class="headerlink" title="5.谈谈你是如何判断网站的性能的?"></a>5.谈谈你是如何判断网站的性能的?</h4><p>判断网站性能可以从多个方面进行评估，以下是一些常见的指标和方法：</p>
<ol>
<li><strong>页面加载速度</strong>：测量网站的页面加载速度是评估性能的关键指标之一。可以使用工具如Lighthouse、PageSpeed Insights、WebPageTest等来测试页面的加载速度，并查看各项指标，如首次内容绘制（FCP）、可交互时间（TTI）、DOMContentLoaded事件等。</li>
<li><strong>网络请求优化</strong>：减少网页的网络请求可以加快页面加载速度。优化图片、CSS和JavaScript文件大小，使用CDN加速静态资源，合并和压缩文件，减少不必要的请求，都是优化网络请求的常见方法。</li>
<li><strong>缓存策略</strong>：合理使用缓存策略可以减少重复的网络请求，提高网站的性能。设置适当的缓存头，包括缓存过期时间、缓存的资源等，可以有效地减少服务器的负载和页面加载时间。</li>
<li><strong>响应式设计</strong>：确保网站能够在不同设备和屏幕尺寸上良好地展示，并且能够快速响应用户的操作，提供良好的用户体验。</li>
<li><strong>代码优化</strong>：优化前端代码，包括JavaScript、CSS和HTML，可以减少页面的加载时间和渲染时间。使用合理的数据结构和算法，避免使用过多的第三方库和插件，精简不必要的代码，都可以提高网站性能。</li>
<li><strong>服务器性能</strong>：优化服务器的配置和性能，包括使用高性能的服务器和数据库，优化数据库查询，使用缓存和负载均衡等技术，都可以提高网站的响应速度和并发能力。</li>
<li><strong>监测与分析</strong>：定期监测网站的性能指标，并进行分析，找出性能瓶颈和优化的空间。可以使用工具如Google Analytics、New Relic、GTMetrix等来进行性能监测和分析。</li>
</ol>
<p>总的来说，判断网站的性能需要综合考虑多个因素，从前端到后端，从服务器到网络，都需要进行优化和改进。定期进行性能测试和监测，以及持续的优化工作，可以帮助提高网站的性能和用户体验。</p>
<h4 id="6-解释一下，性能指标FP-FCP-FMP，如何查看。"><a href="#6-解释一下，性能指标FP-FCP-FMP，如何查看。" class="headerlink" title="6.解释一下，性能指标FP FCP FMP，如何查看。"></a>6.解释一下，性能指标FP FCP FMP，如何查看。</h4><h4 id="7-谈谈浏览器的渲染过程，DOM树和渲染树的区别。"><a href="#7-谈谈浏览器的渲染过程，DOM树和渲染树的区别。" class="headerlink" title="7.谈谈浏览器的渲染过程，DOM树和渲染树的区别。"></a>7.谈谈浏览器的渲染过程，DOM树和渲染树的区别。</h4><p>浏览器的渲染过程可以简单地描述为以下几个步骤：</p>
<ol>
<li><strong>构建DOM树</strong>：浏览器从顶部的HTML文档开始解析，构建DOM（文档对象模型）树，将HTML标签解析为DOM节点，构成一个树状结构，表示文档的层级结构。</li>
<li><strong>构建CSSOM树</strong>：同时，浏览器还会解析CSS样式文件，构建CSSOM（CSS对象模型）树，将CSS样式解析为CSS规则，并与DOM树关联，形成一个包含样式信息的树状结构。</li>
<li><strong>合并成渲染树</strong>：浏览器将DOM树和CSSOM树合并成一个渲染树（Render Tree），渲染树只包含需要显示的节点和样式信息，不包含不需要显示的节点（例如隐藏的元素）或者不影响样式的节点（例如script标签）。</li>
<li><strong>布局计算</strong>：渲染树中的每个节点都有自己的位置和大小信息，浏览器根据渲染树进行布局计算，确定每个节点在页面中的位置和大小。</li>
<li><strong>绘制页面</strong>：根据布局计算的结果，浏览器将页面中的每个节点绘制出来，形成最终的页面内容。</li>
</ol>
<p>值得注意的是，DOM树和渲染树是两个不同的概念：</p>
<ul>
<li><strong>DOM树</strong>：DOM树是由HTML文档解析生成的，它是表示文档内容和结构的树状结构，它包含了HTML标签及其嵌套关系，但不包含样式信息。</li>
<li><strong>渲染树</strong>：渲染树是由DOM树和CSSOM树合并生成的，它包含了需要显示的节点和样式信息，用于进行页面的布局和绘制。</li>
</ul>
<p>渲染树是浏览器最终用于渲染页面的数据结构，因为它只包含需要显示的内容和样式信息，所以渲染树的构建过程是非常高效的，这也是浏览器能够快速渲染页面的重要原因。而DOM树和CSSOM树的构建过程相对较慢，因为它们需要对HTML文档和CSS样式进行解析和处理。因此，在前端开发中，我们可以通过合理优化HTML和CSS的结构，来提高渲染性能。</p>
<h4 id="8-一个页面从输入URL到页面加载显示完成，这个过程中都发生了什么。"><a href="#8-一个页面从输入URL到页面加载显示完成，这个过程中都发生了什么。" class="headerlink" title="8.一个页面从输入URL到页面加载显示完成，这个过程中都发生了什么。"></a>8.一个页面从输入URL到页面加载显示完成，这个过程中都发生了什么。</h4><p>一个页面从输入URL到页面加载显示完成的过程可以分为以下几个阶段：</p>
<ol>
<li><strong>DNS解析</strong>：浏览器首先会对输入的URL进行DNS解析，将域名解析为服务器的IP地址，以便能够发送请求。</li>
<li><strong>建立TCP连接</strong>：浏览器通过TCP三次握手与服务器建立连接，确保双方能够正常通信。</li>
<li><strong>发送HTTP请求</strong>：浏览器向服务器发送HTTP请求，请求页面所需的HTML、CSS、JavaScript和其他资源。</li>
<li><strong>服务器处理请求</strong>：服务器接收到浏览器发送的请求，进行相应的处理，读取数据库或进行其他业务逻辑。</li>
<li><strong>返回HTTP响应</strong>：服务器将处理结果封装成HTTP响应，包括状态码、内容类型和实际内容等信息，发送回浏览器。</li>
<li><strong>接收响应数据</strong>：浏览器接收到服务器返回的HTTP响应数据，根据响应中的内容类型确定如何处理数据。</li>
<li><strong>解析HTML文档</strong>：浏览器解析HTML文档，构建DOM树，并开始加载其中引用的其他资源，如CSS和JavaScript。</li>
<li><strong>加载资源</strong>：浏览器并行加载HTML中引用的CSS和JavaScript文件，并执行JavaScript代码。</li>
<li><strong>渲染页面</strong>：浏览器根据DOM树和CSS样式对页面进行渲染，生成渲染树，并绘制页面内容。</li>
<li><strong>显示页面</strong>：最后，浏览器将渲染好的页面显示在用户的屏幕上，完成整个页面加载过程。</li>
</ol>
<p>在这个过程中，还可能会涉及到缓存、重定向、安全校验等其他步骤，不同的网站和网络环境可能会有一些差异。整个过程是一个复杂的协调和交互过程，其中每个步骤都对最终页面加载的速度和性能产生影响。因此，在开发和优化网页时，需要综合考虑各个方面，以提供更好的用户体验。</p>
<h4 id="9-什么是SPA单页面应用，首屏加载你是如何优化的"><a href="#9-什么是SPA单页面应用，首屏加载你是如何优化的" class="headerlink" title="9.什么是SPA单页面应用，首屏加载你是如何优化的"></a>9.什么是SPA单页面应用，首屏加载你是如何优化的</h4><p>SPA（Single Page Application）单页面应用是指在Web应用中只有一个HTML页面，通过动态加载内容实现页面的切换和更新，而不需要每次加载新的页面。在SPA中，所有的交互都在同一个页面中进行，通过前端路由实现页面切换，提升用户体验和页面加载速度。</p>
<p>优化首屏加载是SPA中的一个重要任务，因为用户访问网站时，首屏加载速度直接影响用户的第一印象和用户体验。以下是优化SPA首屏加载的一些常见方法：</p>
<ol>
<li><strong>代码分割</strong>：使用Webpack等构建工具进行代码分割，将不同页面的代码分割成多个bundle，实现按需加载，减小首屏加载体积。</li>
<li><strong>懒加载</strong>：将页面中的一些非必要组件或模块进行懒加载，即在需要使用时再进行加载，而不是一开始就全部加载，减少首屏加载时间。</li>
<li><strong>预加载</strong>：对于用户可能会访问的页面，可以使用预加载技术，在首屏加载完成后，提前加载其他页面的代码和资源，以提升后续页面的加载速度。</li>
<li><strong>首屏优化</strong>：将首屏需要展示的内容和功能尽量放在HTML的顶部部分，避免用户需要滚动页面才能看到有意义的内容。</li>
<li><strong>压缩和优化资源</strong>：对CSS、JavaScript、图片等资源进行压缩和优化，减小文件体积，提高加载速度。</li>
<li><strong>缓存策略</strong>：合理设置缓存策略，让浏览器对静态资源进行缓存，减少重复加载。</li>
<li><strong>使用CDN</strong>：将静态资源部署到CDN（内容分发网络），提高资源加载速度。</li>
<li><strong>服务端渲染（SSR）</strong>：对于一些对SEO和首屏加载速度要求较高的页面，可以考虑使用服务器端渲染技术，将首屏内容直接输出到HTML中，减少浏览器加载时间。</li>
</ol>
<p>以上方法是优化SPA单页面应用首屏加载的一些常见手段，结合项目实际情况，可以综合应用这些方法来提升用户的首屏加载体验。</p>
<h2 id="移动web开发"><a href="#移动web开发" class="headerlink" title="移动web开发"></a>移动web开发</h2><h4 id="1-知道PWA吗"><a href="#1-知道PWA吗" class="headerlink" title="1.知道PWA吗"></a>1.知道PWA吗</h4><p>渐进式网络应用程序（PWA）是一组网页技术和设计理念，旨在为用户在移动设备或桌面上访问网站时提供类似原生应用的体验。PWA结合了Web和移动应用程序的最佳功能，使其更快、更可靠、更吸引人。</p>
<p>渐进式网络应用程序的主要特点和特性包括：</p>
<ol>
<li>渐进增强：PWA被设计为在任何设备上工作，无论是什么平台或浏览器，采用了渐进增强的原则。它为所有用户提供基线体验，然后在支持高级功能的设备和浏览器上增强体验。</li>
<li>响应式设计：PWA采用响应式设计技术构建，确保用户界面在各种屏幕尺寸和方向上适应并运行良好。</li>
<li>离线支持：PWA可以在网络连接较差或没有网络连接的情况下工作。它利用服务工作者（Service Workers）缓存重要资源，使用户可以在先前访问过的页面或数据处于离线状态下访问。</li>
<li>类应用体验：PWA被设计成感觉像原生应用，提供平滑的动画、手势支持和沉浸式用户交互。</li>
<li>推送通知：PWA可以向用户发送推送通知，使得网站能够重新吸引用户并在浏览器关闭时提供及时更新。</li>
<li>可安装性：用户可以将PWA安装到主屏幕或应用程序抽屉中，就像原生应用一样，使他们无需经过应用商店安装即可快速访问。</li>
<li>安全：PWA必须通过HTTPS提供，以确保用户数据的安全性，并确保服务工作者能够正常工作。</li>
<li>可发现性：PWA可被搜索引擎发现，使得它们通过网络搜索轻松访问。</li>
</ol>
<p>通过整合这些特性，渐进式网络应用程序弥合了Web和原生应用体验之间的差距，提供了更无缝和愉悦的用户体验。它们在业务和开发者中变得越来越受欢迎，是一种高效的方式，让企业和开发者无需通过应用商店安装即可提供高质量的应用，并且能够大大提高用户的参与和留存率。</p>
<h4 id="2-移动布局方案"><a href="#2-移动布局方案" class="headerlink" title="2.移动布局方案"></a>2.移动布局方案</h4><p>移动布局方案主要是为了适应不同移动设备的屏幕尺寸和分辨率，确保网页在各种移动设备上都能呈现良好的用户体验。以下是几种常见的移动布局方案：</p>
<ol>
<li>响应式布局（Responsive Web Design，RWD）：响应式布局是一种灵活的布局方式，使用CSS媒体查询来根据不同设备的屏幕尺寸和分辨率应用不同的样式规则。通过调整元素的大小、位置和显示方式，以及使用弹性盒子（Flexbox）和网格布局（Grid Layout）等技术，网页可以自动适应不同设备的屏幕尺寸。</li>
<li>移动优先布局：移动优先布局是指首先针对移动设备设计网页，然后再逐步扩展到更大的屏幕。这种布局方式可以确保网页在移动设备上表现良好，并且可以优雅地适应更大的屏幕，提供更好的用户体验。</li>
<li>自适应布局：自适应布局是指根据设备的屏幕尺寸和分辨率，采用不同的固定布局或百分比布局。通过设置不同的样式规则，元素的大小和位置可以根据设备的屏幕尺寸进行适配。</li>
<li>视口布局（Viewport Layout）：视口布局是指通过meta标签设置视口的宽度，使得网页能够在移动设备上正确缩放和显示。可以使用以下meta标签来设置视口：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br></pre></td></tr></table></figure>

<ol>
<li>弹性图片：在移动布局中，图片大小和分辨率的适应也很重要。可以使用CSS的max-width属性或通过媒体查询来调整图片大小，确保图片在不同设备上显示合适。</li>
</ol>
<p>综合使用上述布局方案，可以实现适应不同移动设备的网页布局，并提供更好的用户体验。在实际开发中，根据具体需求和设计，可以选择其中一种或多种布局方案进行实现。</p>
<h4 id="3-Rem布局及其优缺点"><a href="#3-Rem布局及其优缺点" class="headerlink" title="3.Rem布局及其优缺点"></a>3.Rem布局及其优缺点</h4><p>Rem（Root Em）布局是一种相对于根元素的字体大小来确定尺寸的布局方式。在Rem布局中，网页中的所有尺寸都是相对于根元素（通常是html元素）的字体大小来计算的，而不是相对于浏览器默认字体大小。</p>
<p>优点：</p>
<ol>
<li>响应式布局：Rem布局能够根据根元素的字体大小自动适应不同屏幕尺寸，实现响应式布局，简化了在不同设备上的开发工作。</li>
<li>简单易用：只需要设置根元素的字体大小，其他元素的尺寸就可以按照相对大小来设置，减少了对具体尺寸的计算。</li>
<li>高度可控：由于所有尺寸都是相对于根元素的字体大小来计算的，开发者可以通过设置根元素的字体大小来统一调整整个页面的尺寸。</li>
<li>提高性能：使用Rem布局，可以减少在页面中使用固定尺寸的元素，从而减少页面重绘和回流的次数，提高性能。</li>
</ol>
<p>缺点：</p>
<ol>
<li>兼容性：Rem布局在一些老旧的浏览器中可能不兼容，需要做兼容性处理。</li>
<li>学习成本：对于一些初学者来说，可能需要一定的学习成本来理解和使用Rem布局。</li>
</ol>
<p>为了解决一些Rem布局的缺点，一些开发者可能会选择使用postcss-pxtorem等工具来自动将固定尺寸的像素值转换成Rem单位，从而简化开发过程。综合来看，Rem布局在现代web开发中是一种非常实用的布局方式，特别适合用于移动端开发和响应式设计。</p>
<h4 id="4-讲讲viewport和移动端布局"><a href="#4-讲讲viewport和移动端布局" class="headerlink" title="4.讲讲viewport和移动端布局"></a>4.讲讲viewport和移动端布局</h4><p>Viewport 是一个浏览器提供的窗口视口（viewport），它用于决定网页的初始显示尺寸和缩放比例，从而在移动设备上呈现合适的页面布局。在移动端，由于不同设备的屏幕尺寸和像素密度不同，使用Viewport 可以确保网页在不同移动设备上获得一致的展示效果。</p>
<p>移动端布局的目标是使网页在不同设备上显示良好，并提供优秀的用户体验。常见的移动端布局方案包括：</p>
<ol>
<li>响应式布局（Responsive Web Design，RWD）：使用 CSS 媒体查询来根据不同设备的屏幕尺寸和方向，应用不同的样式规则。响应式布局可以使网页自适应各种屏幕尺寸，提供良好的用户体验。</li>
<li>移动优先布局：移动优先布局是一种设计理念，首先将网页针对移动设备进行设计，然后再逐渐扩展到更大的屏幕。移动优先布局可以确保网页在移动设备上表现出色，并适应更大屏幕的设备。</li>
<li>视口布局（Viewport Layout）：通过 meta 标签设置视口（viewport）的宽度，使得网页能够在移动设备上正确缩放和显示。使用以下 meta 标签来设置视口：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">htmlCopy code</span><br><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br></pre></td></tr></table></figure>

<ol>
<li>弹性图片：在移动布局中，图片大小和分辨率的适应也很重要。可以使用 CSS 的 max-width 属性或通过媒体查询来调整图片大小，确保图片在不同设备上显示合适。</li>
<li>CSS3 媒体查询：通过 CSS3 的媒体查询，可以根据不同的屏幕尺寸、方向或像素密度应用不同的样式规则，从而实现更精确的移动端布局。</li>
</ol>
<p>综合使用上述布局方案，可以实现适应不同移动设备的网页布局，并提供更好的用户体验。在实际开发中，需要根据具体的需求和设计选择合适的移动端布局方案。</p>
<h4 id="5-移动端适配1px的问题"><a href="#5-移动端适配1px的问题" class="headerlink" title="5.移动端适配1px的问题"></a>5.移动端适配1px的问题</h4><p>在移动端适配中，处理1px问题是为了解决不同设备的像素密度（DPR，Device Pixel Ratio）差异，避免在高像素密度的设备上显示边框、线条等细节时出现虚化或粗细变化的问题。通常，移动设备的像素密度是1x、2x、3x等，而CSS中的像素单位是逻辑像素（CSS Pixel），与设备像素密度有关。</p>
<p>解决移动端1px问题的常用方法有：</p>
<ol>
<li>使用 border-image: 通过设置border-image属性来实现1px的边框效果，可以解决1px边框虚化的问题。</li>
<li>使用 transform: scale: 可以通过transform属性的scale缩放来实现1px边框，这样可以避免使用细线条，从而避免粗细变化。</li>
<li>使用伪元素 + transform: scale: 通过添加伪元素，并对伪元素进行scale缩放来实现1px边框的效果。</li>
<li>使用viewport单位：可以使用vw（视口宽度的百分比）单位来设置1px边框，这样可以根据设备宽度来适配1px效果。</li>
<li>使用flexible布局：可以使用lib-flexible等库来自动处理不同设备的像素密度差异，实现1px边框的适配。</li>
<li>使用@media媒体查询：可以通过媒体查询根据不同设备的像素密度设置不同的1px样式。</li>
</ol>
<p>需要注意的是，不同的解决方案适用于不同的场景，选择合适的方法取决于具体项目需求和开发环境。综合考虑兼容性、性能和开发复杂度等因素，可以选择最适合的解决方案来解决移动端1px问题。</p>
<h4 id="6-移动端性能优化相关经验"><a href="#6-移动端性能优化相关经验" class="headerlink" title="6.移动端性能优化相关经验"></a>6.移动端性能优化相关经验</h4><p>移动端性能优化对于提升用户体验、减少资源消耗和增加网页可用性都非常重要。以下是一些移动端性能优化的相关经验：</p>
<ol>
<li>图片优化：使用合适的图片格式（如WebP），对图片进行压缩和裁剪，以减少图片的大小和加载时间。</li>
<li>延迟加载：对于非首屏展示的内容，使用延迟加载技术，只在需要时加载资源，减少首次加载时间。</li>
<li>使用CDN：使用内容分发网络（CDN）来加速资源的传输，使资源可以从离用户更近的服务器获取，提高加载速度。</li>
<li>压缩资源：对CSS、JavaScript和HTML等静态资源进行压缩和合并，减少文件大小，提高加载速度。</li>
<li>避免重定向：尽量避免页面的重定向，减少请求次数和加载时间。</li>
<li>使用缓存：合理设置缓存策略，使页面内容可以在客户端缓存，减少重复请求，提高访问速度。</li>
<li>减少HTTP请求：合并CSS和JavaScript文件，减少HTTP请求次数，提高页面加载速度。</li>
<li>使用CSS动画：使用CSS动画替代JavaScript动画，以减少CPU和内存的消耗。</li>
<li>优化DOM操作：避免频繁的DOM操作，尽量减少重排和重绘，优化页面渲染性能。</li>
<li>使用Web Workers：对于耗时的计算和处理，可以使用Web Workers在后台进行，避免阻塞主线程，提高页面性能。</li>
<li>移除不必要的插件和库：只加载必要的插件和库，避免加载不必要的资源，减少页面加载时间。</li>
<li>优化字体：选择合适的字体格式和字体大小，减少字体文件的大小，提高页面加载速度。</li>
</ol>
<p>综合使用以上优化方法，可以显著提升移动端网页的性能，提供更好的用户体验。在实际项目中，需要根据具体情况进行性能分析和优化，不断优化和改进，以实现最佳的性能表现。</p>
<h4 id="7-移动端兼容性"><a href="#7-移动端兼容性" class="headerlink" title="7.移动端兼容性"></a>7.移动端兼容性</h4><p>移动端兼容性是指网页在不同移动设备和不同浏览器中的展示效果和功能兼容性。由于移动设备和浏览器的多样性，网页在不同设备上可能会出现样式错乱、功能不可用等问题。为了确保移动端网页能够在各种设备上正常运行，需要注意以下一些兼容性问题：</p>
<ol>
<li>浏览器兼容性：不同移动设备使用不同的浏览器，如iOS上使用Safari，安卓上使用Chrome、UC等。需要测试网页在不同浏览器中的兼容性，并及时修复兼容性问题。</li>
<li>分辨率和像素密度：移动设备的屏幕尺寸、分辨率和像素密度差异较大，需要使用响应式布局或移动优先布局来适应不同设备的屏幕尺寸。</li>
<li>触摸事件和手势：在移动设备上，用户主要使用触摸事件和手势操作，需要确保网页对触摸事件和手势操作的支持良好。</li>
<li>CSS3和HTML5支持：一些较旧的移动设备和浏览器可能不支持CSS3和HTML5的新特性，需要适当地使用polyfill和垫片来提供兼容性支持。</li>
<li>JavaScript兼容性：不同移动设备上的JavaScript引擎可能存在差异，需要测试网页在不同设备上的JavaScript兼容性，并做好兼容性处理。</li>
<li>性能优化：移动设备的性能相对较弱，需要注意优化网页的性能，减少HTTP请求、压缩资源、合并文件等，以提高网页的加载速度和响应性能。</li>
<li>移动设备特性：一些移动设备具有特殊的硬件和功能，如GPS、加速度计、摄像头等，可以利用这些特性来提供更丰富的功能和交互体验。</li>
</ol>
<p>总的来说，移动端兼容性是移动端开发中不可忽视的重要问题。在开发过程中，需要测试和优化网页在不同移动设备和浏览器中的兼容性，并根据具体需求选择合适的兼容性方案。</p>
<h4 id="8-小程序"><a href="#8-小程序" class="headerlink" title="8.小程序"></a>8.小程序</h4><p>小程序的移动端界面开发主要涉及到WXML（WeiXin Markup Language）和WXSS（WeiXin Style Sheet）的使用，同时需要考虑移动设备的特性和响应式布局。</p>
<p>以下是小程序移动端界面开发的一些关键点：</p>
<ol>
<li>使用WXML构建页面结构：WXML类似于HTML，用于构建页面的结构。在WXML中，可以使用小程序提供的组件来构建页面，也可以自定义组件。合理使用视图容器和布局组件可以实现页面的良好排版。</li>
<li>使用WXSS定义页面样式：WXSS类似于CSS，用于定义页面的样式。在移动端开发中，需要考虑不同设备的屏幕大小和像素密度，使用相对单位（如rpx）可以实现页面的响应式布局。</li>
<li>优化图片资源：移动设备的带宽和性能有限，需要优化图片资源的大小和加载速度。使用合适的图片格式和压缩工具可以提高页面加载速度。</li>
<li>响应式布局：针对不同屏幕大小和设备方向，可以使用弹性盒子布局（Flexbox）或栅格布局来实现响应式布局，以适应不同设备的显示效果。</li>
<li>触摸事件处理：在移动端界面开发中，需要处理用户的触摸事件，如点击、滑动、拖拽等。通过绑定合适的事件处理函数，可以实现页面的交互效果。</li>
<li>移动端特性考虑：在移动端开发中，需要考虑到用户操作习惯和设备特性，如触摸滑动、横竖屏切换、手势操作等。</li>
<li>良好的用户体验：移动端界面开发需要注重用户体验，如页面加载速度、交互效果、页面布局等，保证用户在移动设备上的良好体验。</li>
<li>调试和预览：在开发过程中，可以使用小程序开发者工具进行实时调试和预览，以便及时发现和解决问题。</li>
</ol>
<p>总的来说，小程序的移动端界面开发需要考虑到页面的结构、样式和交互，同时要注重移动设备的特性和用户体验，通过合理的布局和优化，打造出用户友好的移动端应用。</p>
<h4 id="9-2X图3X图适配"><a href="#9-2X图3X图适配" class="headerlink" title="9.2X图3X图适配"></a>9.2X图3X图适配</h4><p>在移动端开发中，2X图和3X图是为了适配不同像素密度的设备而准备的不同分辨率的图片。移动设备通常分为1X、2X、3X等不同像素密度的设备，其中2X设备的像素密度是1X的两倍，3X设备的像素密度是1X的三倍。</p>
<p>为了在不同像素密度的设备上展示高清晰度的图片，我们通常会提供2X和3X两种分辨率的图片，然后在CSS中根据设备的像素密度来选择合适的图片。假设我们有一张图片叫做image.png，那么在项目中，我们会准备以下三种图片：</p>
<ul>
<li>image.png：1X图，通常为图片的原始分辨率。</li>
<li><a href="mailto:image@2x.png" rel="external nofollow noreferrer">image@2x.png</a>：2X图，分辨率是1X图的两倍，用于2X像素密度的设备。</li>
<li><a href="mailto:image@3x.png" rel="external nofollow noreferrer">image@3x.png</a>：3X图，分辨率是1X图的三倍，用于3X像素密度的设备。</li>
</ul>
<p>在CSS中，我们可以使用媒体查询来选择合适的图片。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* 默认使用1X图 */</span><br><span class="line">.image &#123;</span><br><span class="line">  background-image: url(&#x27;image.png&#x27;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 2X像素密度的设备使用2X图 */</span><br><span class="line">@media only screen and (-webkit-min-device-pixel-ratio: 2),</span><br><span class="line">       only screen and (min-resolution: 192dpi) &#123;</span><br><span class="line">  .image &#123;</span><br><span class="line">    background-image: url(&#x27;image@2x.png&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 3X像素密度的设备使用3X图 */</span><br><span class="line">@media only screen and (-webkit-min-device-pixel-ratio: 3),</span><br><span class="line">       only screen and (min-resolution: 288dpi) &#123;</span><br><span class="line">  .image &#123;</span><br><span class="line">    background-image: url(&#x27;image@3x.png&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，在不同像素密度的设备上，会自动选择合适的图片，从而保证图片显示的清晰度和质量。通过使用2X图和3X图的适配方式，我们可以提供更好的用户体验，同时也避免了在高像素密度设备上出现模糊或失真的问题。</p>
<h4 id="10-图片在安卓上，有些设备模糊问题"><a href="#10-图片在安卓上，有些设备模糊问题" class="headerlink" title="10.图片在安卓上，有些设备模糊问题"></a>10.图片在安卓上，有些设备模糊问题</h4><p>在安卓设备上出现图片模糊问题通常与设备的像素密度（DPI）和图片的分辨率有关。安卓设备通常分为不同的像素密度，例如1X、1.5X、2X、3X等，不同的设备使用不同的像素密度，从而影响了图片在设备上的显示效果。</p>
<p>如果在某些安卓设备上出现了图片模糊问题，可以尝试以下几种解决方法：</p>
<ol>
<li>提供高分辨率图片：确保图片的分辨率足够高，特别是针对高像素密度的设备，提供更高分辨率的图片可以避免模糊问题。</li>
<li>使用矢量图：对于一些图标和矢量图形，可以考虑使用SVG格式的矢量图，这样可以无损缩放，适应不同像素密度的设备。</li>
<li>使用2X和3X图：根据设备的像素密度提供不同分辨率的图片，如之前提到的2X图和3X图适配方式，确保图片在不同设备上显示清晰。</li>
<li>使用CSS缩放：在某些情况下，可以使用CSS的transform属性来对图片进行缩放，以适应不同设备的像素密度，但需要注意缩放后可能出现细节损失。</li>
<li>使用viewport标签：确保在HTML的head标签中添加viewport标签，正确设置viewport的缩放和宽度，以保证页面在不同设备上正确显示。</li>
</ol>
<p>总的来说，图片模糊问题在安卓设备上可能由于像素密度差异造成，可以通过提供高分辨率图片、使用矢量图、适配不同像素密度等方法来解决。同时，建议在开发过程中多进行测试，确保网页在不同设备上显示效果良好。</p>
<h4 id="11-固定定位布局键盘挡住输入框内容"><a href="#11-固定定位布局键盘挡住输入框内容" class="headerlink" title="11.固定定位布局键盘挡住输入框内容"></a>11.固定定位布局键盘挡住输入框内容</h4><p>在移动端开发中，当使用固定定位（<code>position: fixed</code>）布局时，的确会遇到键盘挡住输入框内容的问题。这种情况通常发生在用户点击输入框进行输入时，键盘会弹出覆盖在页面上方，可能会遮挡住部分内容，特别是底部的输入框。</p>
<p>为了解决这个问题，可以采用以下几种方法：</p>
<ol>
<li>输入框聚焦时自动滚动：可以通过监听输入框的<code>focus</code>事件，在键盘弹出时自动滚动页面，使输入框不被键盘遮挡。可以使用<code>scrollIntoView</code>方法将输入框滚动到可视区域内。</li>
<li>键盘事件监听：监听键盘弹出和收起事件，根据键盘的高度调整页面布局。可以使用<code>window.onresize</code>事件监听键盘弹出和收起。</li>
<li>使用CSS样式：在键盘弹出时，可以通过CSS样式对输入框的位置进行调整，使其不被键盘遮挡。可以使用<code>@media</code>查询或<code>window.matchMedia</code>方法来检测键盘弹出和收起，然后通过CSS样式进行调整。</li>
<li>使用viewport单位：使用<code>vh</code>（视窗高度单位）来设置元素的高度，使其随着视窗高度的变化而变化，可以避免键盘遮挡问题。</li>
</ol>
<p>需要注意的是，不同设备和浏览器可能会有不同的行为和兼容性问题，因此在解决键盘遮挡问题时，需要进行充分的测试和调试，确保在各种情况下都能有良好的用户体验。同时，建议在设计和布局页面时尽量避免将重要的输入框放在页面底部，以减少键盘遮挡问题的发生。</p>
<h4 id="12-click-的300ms延迟问题和点击穿透问题"><a href="#12-click-的300ms延迟问题和点击穿透问题" class="headerlink" title="12.click 的300ms延迟问题和点击穿透问题"></a>12.click 的300ms延迟问题和点击穿透问题</h4><p>点击延迟问题（300ms延迟问题）和点击穿透问题都是在移动端开发中常见的问题，特别是在使用浏览器的默认click事件时可能会出现。以下是对这两个问题的解释和解决方案：</p>
<ol>
<li><p>点击延迟问题（300ms延迟问题）： 点击延迟问题是指在移动设备上，浏览器默认对于双击缩放（double tap to zoom）的处理机制。当用户点击页面上的一个可点击元素（例如链接、按钮等）时，浏览器会等待300毫秒的时间来判断用户是否在进行双击缩放操作。如果没有进行双击缩放操作，则触发点击事件。</p>
<p>解决方案：为了解决点击延迟问题，可以采用以下方法之一：</p>
<ul>
<li>使用<code>touchstart</code>或<code>touchend</code>事件来代替<code>click</code>事件，这样可以避免延迟问题，但可能会导致点击穿透问题。</li>
<li>使用<code>fastclick</code>库或<code>zepto.js</code>等移动端框架，这些框架都对点击延迟问题进行了处理。</li>
</ul>
</li>
<li><p>点击穿透问题： 点击穿透问题是指当一个元素在点击事件触发后，底层的元素也会被点击。这种情况通常发生在触发了一个点击事件后，上层元素消失（如弹窗关闭），而下层的元素被穿透点击。</p>
<p>解决方案：为了解决点击穿透问题，可以采用以下方法之一：</p>
<ul>
<li>使用<code>touchend</code>事件来代替<code>click</code>事件，因为<code>touchend</code>事件在元素消失之后不会继续传递，可以避免点击穿透问题。</li>
<li>使用<code>preventDefault</code>或<code>stopPropagation</code>方法来阻止事件冒泡，防止事件继续传递到底层元素。</li>
</ul>
</li>
</ol>
<p>需要注意的是，对于一些特殊场景，可能需要综合考虑点击延迟问题和点击穿透问题，采用合适的解决方案来确保良好的用户体验。同时，在移动端开发中，建议使用更适合移动设备的交互方式，如使用<code>touch</code>事件来代替<code>click</code>事件，避免延迟和穿透问题的出现。</p>
<h4 id="13-防止手机中页面放大和缩小"><a href="#13-防止手机中页面放大和缩小" class="headerlink" title="13.防止手机中页面放大和缩小"></a>13.防止手机中页面放大和缩小</h4><p>防止手机中页面放大和缩小，通常涉及到以下几个方面的考虑：</p>
<ol>
<li><p>禁用双击缩放：通过设置<code>meta</code>标签中的<code>user-scalable</code>属性来禁用双击缩放功能。将<code>user-scalable</code>属性设置为<code>no</code>可以防止用户在手机上通过双击页面来进行缩放操作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no&quot;&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>禁用手势缩放：通过CSS样式来禁用手势缩放功能。在某些浏览器中，用户可以使用手势缩放页面，通过以下CSS样式可以阻止手势缩放。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">  touch-action: pan-x pan-y;</span><br><span class="line">  /* 或者 */</span><br><span class="line">  touch-action: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>固定viewport尺寸：在<code>meta</code>标签中，将<code>viewport</code>的<code>width</code>设置为固定值，可以防止页面根据设备的宽度自动缩放。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">htmlCopy code</span><br><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=375, initial-scale=1.0&quot;&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>需要注意的是，禁用页面缩放可能会影响用户体验，特别是对于一些视力较差的用户。因此，在进行这些设置时，需要谨慎考虑，并进行充分的测试，确保在各种设备上都能有良好的用户体验。</p>
<h4 id="14-px、em、rem、-、vw、-vh、vm这些单位的区别"><a href="#14-px、em、rem、-、vw、-vh、vm这些单位的区别" class="headerlink" title="14.px、em、rem、 %、vw、 vh、vm这些单位的区别"></a>14.px、em、rem、 %、vw、 vh、vm这些单位的区别</h4><p>这些单位是用于前端开发中进行长度和尺寸的表示的，它们的区别如下：</p>
<ol>
<li>px（像素）：像素是屏幕上显示的最小单位，1px表示一个像素点。px是一个绝对单位，它在不同设备上具有相同的物理尺寸，但在高分辨率屏幕上可能会显得较小。</li>
<li>em：em是相对于父元素的字体大小的单位。如果父元素的字体大小是16px，1em就等于16px，2em就等于32px，以此类推。</li>
<li>rem：rem也是相对于根元素（html元素）的字体大小的单位。rem与em不同的是，rem的参考是根元素的字体大小，而em的参考是其父元素的字体大小。rem可以用于实现响应式布局，因为它的值不会受到父元素的影响。</li>
<li>%：百分比是相对于父元素的尺寸的百分比。例如，如果一个元素的宽度设置为50%，它将会是其父元素宽度的一半。</li>
<li>vw（视口宽度）：vw是相对于视口宽度的单位，1vw表示视口宽度的1%。例如，如果视口宽度为1000px，1vw将等于10px。</li>
<li>vh（视口高度）：vh是相对于视口高度的单位，1vh表示视口高度的1%。例如，如果视口高度为800px，1vh将等于8px。</li>
<li>vm：vm是相对于视口宽度和高度中较小的那个的单位。例如，如果视口宽度为1000px，视口高度为800px，1vm将等于8px（较小的值）。</li>
</ol>
<p>不同的单位在不同的场景下有不同的用途。px是绝对单位，常用于确定元素的固定大小；em和rem是相对单位，常用于实现相对于字体大小的缩放；%常用于相对于父元素的大小进行缩放；vw、vh、vm常用于实现响应式布局，相对于视口的大小进行缩放。在选择使用哪种单位时，需要根据具体的需求和设计进行选择。</p>
<h4 id="15-移动端适配-dpr浅析"><a href="#15-移动端适配-dpr浅析" class="headerlink" title="15.移动端适配-dpr浅析"></a>15.移动端适配-dpr浅析</h4><p>在移动端适配中，dpr（设备像素比）是一个非常重要的概念。设备像素比指的是设备的物理像素与逻辑像素的比例关系，它用来衡量设备屏幕的清晰度和显示效果。通常情况下，dpr的值为1、2或3，不同的设备有不同的dpr值。</p>
<p>一般来说，dpr越高，设备的屏幕显示越清晰，同时也意味着设备像素越多，页面元素需要更多的物理像素来渲染。因此，在移动端适配中，我们需要根据设备的dpr值来调整页面的布局和尺寸，以保证页面在不同dpr设备上的显示效果一致。</p>
<p>常见的dpr值及对应的设备类型：</p>
<ul>
<li>dpr为1：普通屏幕，如老款iPhone、普通Android手机。</li>
<li>dpr为2：高清屏幕，如iPhone Retina系列、高配Android手机。</li>
<li>dpr为3：超高清屏幕，如iPhone Plus系列、高配Android手机。</li>
</ul>
<p>为了实现移动端适配，我们通常会使用以下方法：</p>
<ol>
<li>使用viewport设置：通过设置<code>&lt;meta&gt;</code>标签中的<code>viewport</code>属性，根据设备的dpr值来调整页面缩放比例和显示效果。</li>
<li>使用rem单位：通过设置<code>&lt;html&gt;</code>元素的<code>font-size</code>为屏幕宽度的一定比例，然后使用rem单位来设置元素的尺寸，从而实现根据屏幕宽度自适应调整。</li>
<li>使用媒体查询：根据设备的dpr值和屏幕宽度，使用CSS媒体查询来适配不同的设备。</li>
</ol>
<p>综合使用以上方法，可以实现移动端适配，保证页面在不同设备上显示效果良好，避免出现错位、模糊等问题。</p>
<h4 id="16-移动端扩展点击区域"><a href="#16-移动端扩展点击区域" class="headerlink" title="16.移动端扩展点击区域"></a>16.移动端扩展点击区域</h4><p>在移动端开发中，有时候为了提高用户体验，可以通过扩展点击区域来增加点击目标的触发区域，使用户更容易点击到目标元素，特别是对于小尺寸的元素或者靠近屏幕边缘的元素。这样做可以减少用户误操作，提高页面的可用性。</p>
<p>有几种常见的方法可以实现移动端扩展点击区域：</p>
<ol>
<li>使用padding：为目标元素设置一定的padding值，这样可以增加元素的点击区域，但不改变元素的布局。</li>
<li>使用透明的伪元素：通过为目标元素添加一个透明的伪元素，将伪元素放置在目标元素周围，从而增加点击区域。</li>
<li>使用绝对定位和负边距：将目标元素设置为绝对定位，并为其设置负边距，使其超出父容器，从而增加点击区域。</li>
<li>使用透明图片：为目标元素设置一个透明的图片作为背景，将图片设置为合适的尺寸，从而增加点击区域。</li>
</ol>
<p>需要注意的是，在扩展点击区域时，要确保不会影响到其他元素的布局和交互。同时，要进行充分的测试，确保在不同设备上点击效果正常，不会产生误操作或影响用户体验。在实际开发中，根据具体的情况选择合适的方法来实现扩展点击区域，以提升用户体验。</p>
<h4 id="17-上下拉动滚动条时卡顿、慢"><a href="#17-上下拉动滚动条时卡顿、慢" class="headerlink" title="17.上下拉动滚动条时卡顿、慢"></a>17.上下拉动滚动条时卡顿、慢</h4><p>卡顿和慢的滚动体验通常是由于页面过多的元素或复杂的渲染引起的。在移动端开发中，特别是在滚动长页面时，可以采取以下措施来优化滚动性能：</p>
<ol>
<li>减少页面元素：尽量减少页面中不必要的元素，包括文字、图片和其他内容。页面中的元素越多，浏览器需要处理的内容也就越多，导致滚动体验变慢。</li>
<li>图片优化：确保图片尺寸适当，并使用合适的图片格式，例如JPEG和WebP格式，以减少图片的加载时间和文件大小。</li>
<li>使用CSS硬件加速：使用CSS属性<code>transform</code>和<code>will-change</code>来触发GPU硬件加速，从而优化页面的滚动和动画性能。</li>
<li>避免复杂的CSS选择器和样式：复杂的CSS选择器和样式会增加页面的渲染和布局计算时间，尽量使用简单的选择器和样式。</li>
<li>使用虚拟滚动：对于长列表或大量数据的滚动，可以考虑使用虚拟滚动技术，只渲染可见区域的内容，减少不必要的渲染。</li>
<li>使用防抖和节流：对于滚动事件和其他频繁触发的事件，可以使用防抖和节流技术来降低事件触发的频率，减少不必要的计算和操作。</li>
<li>使用合适的滚动库：对于复杂的滚动需求，可以考虑使用优化过的滚动库，例如iScroll、better-scroll等，以获得更流畅的滚动体验。</li>
</ol>
<p>通过以上优化措施，可以有效改善页面滚动时的卡顿和慢的问题，提升用户体验。同时，优化滚动性能也需要综合考虑页面的整体结构和内容，尽量避免过度复杂和冗余的内容，使页面保持简洁和高效。</p>
<h4 id="18-长时间按住页面出现闪退"><a href="#18-长时间按住页面出现闪退" class="headerlink" title="18.长时间按住页面出现闪退"></a>18.长时间按住页面出现闪退</h4><p>长时间按住页面可能导致页面出现闪退的问题是因为浏览器或设备对于长时间的触摸事件进行了处理，可能会触发浏览器或设备的某些保护机制，导致页面崩溃或闪退。</p>
<p>这种问题通常是由于页面处理长时间触摸事件的能力不足，或者页面代码中存在一些性能问题导致的。为了避免页面出现闪退问题，可以考虑以下几个方面的优化：</p>
<ol>
<li>避免过度复杂的事件处理：如果页面上有复杂的事件处理逻辑，尤其是长时间触摸事件的处理逻辑，可能会影响页面的性能。尽量简化事件处理逻辑，避免过多的计算和操作。</li>
<li>使用防抖和节流：对于长时间触摸事件，可以使用防抖和节流技术来控制事件的触发频率，从而避免过多的事件触发导致性能问题。</li>
<li>优化页面性能：检查页面代码，确保页面中没有冗余的代码和过度复杂的DOM结构。优化图片和资源加载，减少不必要的网络请求。尽量避免使用过多的动画效果和复杂的布局。</li>
<li>测试不同设备和浏览器：不同设备和浏览器对于长时间触摸事件的处理可能有所不同。在开发过程中，应该测试页面在不同设备和浏览器上的表现，及时发现和解决潜在的问题。</li>
</ol>
<p>如果页面在长时间触摸时仍然出现闪退问题，建议使用开发者工具查看浏览器的错误日志，以便更好地了解问题的具体原因，并进行针对性的优化。在优化页面性能时，需要综合考虑页面的整体结构和功能，寻找最优的解决方案，以提供更好的用户体验。</p>
<h4 id="19-webkit-mask兼容处理"><a href="#19-webkit-mask兼容处理" class="headerlink" title="19.webkit mask兼容处理"></a>19.webkit mask兼容处理</h4><p>WebKit是一种浏览器引擎，主要用于苹果的Safari浏览器和谷歌的Chrome浏览器。其中，<code>-webkit-mask</code>是WebKit引擎中用于实现元素遮罩的CSS属性。</p>
<p>由于不同浏览器对CSS属性的支持不同，为了确保在各种浏览器中正确显示元素遮罩，需要进行兼容处理。以下是一些常见的兼容处理方法：</p>
<ol>
<li>使用<code>-webkit-mask</code>和<code>mask</code>属性：为了在WebKit浏览器中正确显示元素遮罩，可以同时使用<code>-webkit-mask</code>和<code>mask</code>属性。例如：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.element &#123;</span><br><span class="line">  -webkit-mask: url(&#x27;mask.png&#x27;) no-repeat center;</span><br><span class="line">  mask: url(&#x27;mask.png&#x27;) no-repeat center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>使用浏览器引擎前缀：为了兼容不同浏览器，可以使用浏览器引擎前缀来设置元素遮罩。例如：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.element &#123;</span><br><span class="line">  -webkit-mask: url(&#x27;mask.png&#x27;) no-repeat center;</span><br><span class="line">  -moz-mask: url(&#x27;mask.png&#x27;) no-repeat center;</span><br><span class="line">  mask: url(&#x27;mask.png&#x27;) no-repeat center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>使用媒体查询：如果元素遮罩只在特定的浏览器或设备上需要兼容处理，可以使用媒体查询来针对不同的浏览器引擎设置元素遮罩。例如：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.element &#123;</span><br><span class="line">  mask: url(&#x27;mask.png&#x27;) no-repeat center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@media screen and (-webkit-min-device-pixel-ratio: 0) &#123;</span><br><span class="line">  .element &#123;</span><br><span class="line">    -webkit-mask: url(&#x27;mask.png&#x27;) no-repeat center;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>使用JavaScript检测：如果以上方法仍无法解决兼容性问题，可以使用JavaScript来检测浏览器引擎，并根据浏览器类型动态添加合适的样式。</li>
</ol>
<p>总之，兼容WebKit引擎的方法主要是使用<code>-webkit-mask</code>和<code>mask</code>属性，并结合浏览器引擎前缀和媒体查询来进行处理。根据具体的需求和兼容性要求，选择合适的方法来确保元素遮罩在不同浏览器中正常显示。</p>
<h4 id="20-transiton-闪屏"><a href="#20-transiton-闪屏" class="headerlink" title="20.transiton 闪屏"></a>20.transiton 闪屏</h4><p>在使用CSS的<code>transition</code>属性时，有时会出现闪屏的问题，特别是在使用<code>transform</code>属性进行动画过渡时。这是由于浏览器的优化机制造成的，浏览器会对<code>transform</code>属性进行硬件加速，导致元素在开始动画过渡时会先进行一次重绘，然后再执行动画，造成闪屏的效果。</p>
<p>为了避免<code>transition</code>闪屏问题，可以尝试以下几个方法：</p>
<ol>
<li>使用<code>transform</code>属性进行动画：<code>transform</code>属性是一种CSS硬件加速属性，因此动画会更加流畅。尽量避免使用其他需要重绘的属性，如<code>width</code>、<code>height</code>、<code>top</code>、<code>left</code>等，以减少重绘带来的闪屏问题。</li>
<li>使用<code>will-change</code>属性：<code>will-change</code>属性可以提示浏览器该元素将要进行动画效果，从而使浏览器提前做好优化准备。例如：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.element &#123;</span><br><span class="line">  will-change: transform;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>使用<code>translateZ(0)</code>进行强制3D加速：通过给元素添加<code>transform: translateZ(0)</code>，强制开启3D加速，可以减少闪屏问题。但是需要注意，不要在不需要硬件加速的情况下滥用3D加速，以免造成不必要的性能损耗。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.element &#123;</span><br><span class="line">  transform: translateZ(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>使用<code>requestAnimationFrame</code>代替<code>setTimeout</code>或<code>setInterval</code>：在实现动画时，使用<code>requestAnimationFrame</code>代替<code>setTimeout</code>或<code>setInterval</code>可以更好地与浏览器的重绘机制同步，避免闪屏问题。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function animate() &#123;</span><br><span class="line">  // 动画操作</span><br><span class="line">  requestAnimationFrame(animate);</span><br><span class="line">&#125;</span><br><span class="line">animate();</span><br></pre></td></tr></table></figure>

<p>总体而言，<code>transition</code>闪屏问题主要是由浏览器的优化机制造成的。通过合理使用CSS硬件加速属性、<code>will-change</code>属性和<code>requestAnimationFrame</code>方法，可以有效减少闪屏问题，提升页面动画的流畅性和用户体验。</p>
<h2 id="研发流程"><a href="#研发流程" class="headerlink" title="研发流程"></a>研发流程</h2><h2 id="Nodejs"><a href="#Nodejs" class="headerlink" title="Nodejs"></a>Nodejs</h2><h4 id="1-对Node-js有没有了解，它有什么特点，适合做什么业务"><a href="#1-对Node-js有没有了解，它有什么特点，适合做什么业务" class="headerlink" title="1.对Node.js有没有了解，它有什么特点，适合做什么业务"></a>1.对Node.js有没有了解，它有什么特点，适合做什么业务</h4><p>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行时环境，它使 JavaScript 可以在服务器端运行。Node.js 具有以下特点：</p>
<ol>
<li>非阻塞、异步 I&#x2F;O：Node.js 采用事件驱动、非阻塞 I&#x2F;O 模型，使得它能够高效处理大量并发请求，适用于高性能的网络应用。</li>
<li>单线程：Node.js 是单线程的，但通过事件循环机制和异步非阻塞 I&#x2F;O 实现了并发处理。这使得它能够处理高并发请求而不会导致线程阻塞。</li>
<li>轻量和高效：Node.js 是一个轻量级的运行时环境，具有高度的可伸缩性和低系统资源消耗，适用于构建高效的服务器应用。</li>
<li>统一的编程语言：Node.js 使用 JavaScript 作为编程语言，这使得前端开发人员能够在服务器端使用相同的语言和技术栈，简化了开发流程。</li>
<li>NPM：Node.js 附带了 NPM（Node Package Manager），是一个强大的包管理工具，提供了大量的开源库和模块，方便开发人员进行代码共享和复用。</li>
</ol>
<p>适合使用 Node.js 的业务包括：</p>
<ol>
<li>实时应用：Node.js 在处理高并发、实时通信的场景下表现优秀，适合构建实时聊天应用、多人在线游戏等。</li>
<li>Web 服务：Node.js 可以快速构建高性能的 Web 服务，适合构建 RESTful API、后端服务等。</li>
<li>微服务架构：Node.js 的轻量特性和高并发能力使其成为构建微服务架构的理想选择。</li>
<li>I&#x2F;O 密集型任务：Node.js 的异步非阻塞 I&#x2F;O 特性适合处理 I&#x2F;O 密集型任务，如文件读写、数据库操作等。</li>
<li>服务器端渲染：Node.js 可以用于服务器端渲染，将动态数据嵌入到网页模板中，提高网站的性能和搜索引擎优化。</li>
</ol>
<p>需要注意的是，Node.js 是单线程的，对于 CPU 密集型任务，其性能可能不如其他多线程的语言和平台。因此，在选择使用 Node.js 时，应该根据具体业务需求和特点进行合理的选择。</p>
<h4 id="2-Node和前端项目怎么解决跨域的"><a href="#2-Node和前端项目怎么解决跨域的" class="headerlink" title="2.Node和前端项目怎么解决跨域的"></a>2.Node和前端项目怎么解决跨域的</h4><p>在前端项目中，跨域问题通常是由浏览器的同源策略所导致的，而在 Node.js 环境中，由于没有浏览器的限制，不存在同源策略，因此不会出现跨域问题。在 Node.js 中可以轻松地访问不同域的资源。</p>
<p>然而，Node.js 通常用于构建后端服务器，而前端项目在浏览器中运行，所以跨域问题主要出现在前端项目中。在前端项目中解决跨域问题的常见方式包括：</p>
<ol>
<li>JSONP：使用 JSONP (JSON with Padding) 技术来进行跨域请求。JSONP 利用 <code>&lt;script&gt;</code> 标签的跨域特性，通过动态创建 <code>&lt;script&gt;</code> 元素并设置其 <code>src</code> 属性来请求跨域数据。</li>
<li>CORS（Cross-Origin Resource Sharing）：CORS 是一种现代的跨域解决方案，通过在服务器端设置响应头来授权特定的域名访问资源。在前端项目中，可以在发起跨域请求时设置 <code>withCredentials: true</code> 来携带认证信息。</li>
<li>代理：可以在前端项目的服务器端设置一个代理服务器，将跨域请求转发给目标服务器，并将响应返回给前端项目。这种方式需要在后端进行配置。</li>
<li>Nginx 反向代理：使用 Nginx 配置反向代理规则，将跨域请求转发给目标服务器，同时在服务器端设置 CORS 头部来允许跨域访问。</li>
<li>WebSocket：如果前端项目需要实现实时通信，可以使用 WebSocket 协议，它不受同源策略限制，可以在客户端与服务器之间建立长连接。</li>
</ol>
<p>需要根据具体的前端项目和后端服务器的部署情况来选择合适的解决方案。通常情况下，推荐使用 CORS 解决跨域问题，它是一种现代化的、更安全的跨域解决方案。对于不支持 CORS 的老旧浏览器，可以考虑使用 JSONP 或其他代理方式来实现跨域请求。</p>
<h4 id="3-Node的优点是什么-缺点是什么"><a href="#3-Node的优点是什么-缺点是什么" class="headerlink" title="3.Node的优点是什么?缺点是什么"></a>3.Node的优点是什么?缺点是什么</h4><ol>
<li>异步非阻塞：Node.js采用异步非阻塞I&#x2F;O模型，能够高效处理大量并发请求，使得应用具有出色的性能和响应能力。</li>
<li>单线程：Node.js是单线程的，通过事件循环机制实现并发处理，简化了多线程的复杂性，提高了开发效率。</li>
<li>快速构建：使用JavaScript作为开发语言，使得前端开发人员可以在服务器端使用相同的语言和技术栈，简化了开发流程，加快了开发速度。</li>
<li>轻量高效：Node.js是一个轻量级的运行时环境，具有高度的可伸缩性和低系统资源消耗，适用于构建高性能的服务器应用。</li>
<li>NPM支持：Node.js附带了NPM（Node Package Manager），是一个强大的包管理工具，提供了大量的开源库和模块，方便代码共享和复用。</li>
<li>广泛的社区支持：Node.js拥有庞大的开发者社区和丰富的第三方库，可以快速找到解决方案和组件，加速开发进度。</li>
</ol>
<p>Node.js的一些缺点包括：</p>
<ol>
<li>单线程：虽然单线程的设计使得Node.js在处理I&#x2F;O密集型任务方面表现优异，但在处理CPU密集型任务时性能可能不如多线程的语言和平台。</li>
<li>回调地狱：由于Node.js采用异步回调方式处理I&#x2F;O操作，可能导致嵌套过多的回调函数，造成代码难以阅读和维护，即所谓的”回调地狱”。</li>
<li>模块版本问题：由于NPM上的模块更新频繁，可能导致不同版本之间的兼容性问题，需要注意版本控制和模块依赖管理。</li>
<li>不适合CPU密集型任务：由于Node.js是单线程的，不适合处理CPU密集型任务，因为它会导致整个应用阻塞。</li>
<li>缺乏成熟的安全机制：Node.js在安全性方面相对较弱，需要开发者注意处理一些安全问题，如跨站脚本攻击（XSS）和SQL注入等。</li>
</ol>
<p>总体来说，Node.js在构建高性能、实时应用和I&#x2F;O密集型任务时表现优秀，但对于CPU密集型任务和一些特定场景，可能不太适合。因此，在选择使用Node.js时，应根据应用的需求和场景进行合理的选择。</p>
<h4 id="4-commonJS中的require-x2F-exports和ES6中import-x2F-export的区别是什么"><a href="#4-commonJS中的require-x2F-exports和ES6中import-x2F-export的区别是什么" class="headerlink" title="4.commonJS中的require&#x2F;exports和ES6中import&#x2F;export的区别是什么"></a>4.commonJS中的require&#x2F;exports和ES6中import&#x2F;export的区别是什么</h4><p>CommonJS 和 ES6 是 JavaScript 中两种不同的模块化规范，它们在模块导入和导出的语法和特性上有一些区别：</p>
<ol>
<li>导入语法：<ul>
<li>CommonJS 使用 <code>require()</code> 来导入模块，例如：<code>const moduleA = require(&#39;./moduleA&#39;)</code>。</li>
<li>ES6 使用 <code>import</code> 来导入模块，例如：<code>import moduleA from &#39;./moduleA&#39;</code>。</li>
</ul>
</li>
<li>导出语法：<ul>
<li>CommonJS 使用 <code>module.exports</code> 或 <code>exports</code> 来导出模块，例如：<code>module.exports = &#123;&#125;</code> 或 <code>exports.someFunction = function() &#123;&#125;</code>。</li>
<li>ES6 使用 <code>export</code> 来导出模块，例如：<code>export default &#123;&#125;</code> 或 <code>export function someFunction() &#123;&#125;</code>。</li>
</ul>
</li>
<li>动态导入：<ul>
<li>CommonJS 不支持动态导入，<code>require()</code> 只能在模块的顶层使用，不能在条件语句或函数中使用。</li>
<li>ES6 支持动态导入，可以使用 <code>import()</code> 函数动态加载模块，允许在运行时根据需要导入模块。</li>
</ul>
</li>
<li>导入和导出的细粒度控制：<ul>
<li>ES6 的导入和导出语法更灵活，可以使用 <code>import &#123; ... &#125; from &#39;module&#39;</code> 和 <code>export &#123; ... &#125;</code> 来导入和导出特定的变量或函数，而不是整个模块。</li>
</ul>
</li>
<li>静态解析：<ul>
<li>ES6 的模块导入和导出是静态解析的，意味着导入和导出的模块在编译时就确定了，这使得打包工具可以在编译时进行优化。</li>
<li>CommonJS 的导入和导出是动态的，无法在编译时静态确定模块的依赖关系。</li>
</ul>
</li>
</ol>
<p>总体而言，ES6 的模块化规范在语法上更加简洁和灵活，支持动态导入和细粒度导入导出，而 CommonJS 更适合在服务器端使用。在浏览器端和现代的前端项目中，通常使用 ES6 的模块化规范，而在 Node.js 环境下，可以继续使用 CommonJS 的模块化规范。在使用模块时，可以根据项目的需求和平台的支持情况来选择合适的模块化规范。</p>
<h4 id="5-简述同步和异步的区别，如何避免回调地狱，Node-的异步问题是如何解决的"><a href="#5-简述同步和异步的区别，如何避免回调地狱，Node-的异步问题是如何解决的" class="headerlink" title="5.简述同步和异步的区别，如何避免回调地狱，Node 的异步问题是如何解决的"></a>5.简述同步和异步的区别，如何避免回调地狱，Node 的异步问题是如何解决的</h4><p>同步和异步是关于任务执行顺序的概念：</p>
<ol>
<li>同步：同步任务是按照代码的顺序依次执行的，每个任务必须等待上一个任务执行完成后才能执行。</li>
<li>异步：异步任务是不按照代码顺序执行的，它会先放到任务队列中，等待同步任务执行完成后，再由事件循环机制来执行。</li>
</ol>
<p>避免回调地狱的方法有：</p>
<ol>
<li>使用 Promise：Promise 是一种用于处理异步操作的对象，它可以让异步代码更加清晰和可读。通过 Promise 的链式调用，可以避免回调地狱。</li>
<li>使用 async&#x2F;await：async&#x2F;await 是 ES2017 中引入的特性，它可以让异步代码看起来像同步代码一样，提高代码的可读性。</li>
</ol>
<p>Node.js 的异步问题解决方法主要有以下几种：</p>
<ol>
<li>回调函数：Node.js 采用回调函数来处理异步操作，通过回调函数可以在异步操作完成后执行相应的逻辑。</li>
<li>事件监听：Node.js 使用事件驱动的模型，通过事件监听和触发来处理异步操作。</li>
<li>Promise：Node.js 支持使用 Promise 来处理异步操作，通过链式调用可以避免回调地狱。</li>
<li>async&#x2F;await：Node.js 支持使用 async&#x2F;await 来处理异步操作，让异步代码看起来像同步代码一样，提高代码可读性。</li>
</ol>
<p>使用这些方法，可以更加优雅地处理 Node.js 中的异步问题，避免回调地狱，并提高代码的可维护性。</p>
<h4 id="6-dependencies-和devDependencies两者区别"><a href="#6-dependencies-和devDependencies两者区别" class="headerlink" title="6.dependencies 和devDependencies两者区别"></a>6.dependencies 和devDependencies两者区别</h4><p>在 Node.js 项目中，<code>dependencies</code> 和 <code>devDependencies</code> 是两个常见的属性，用于在 <code>package.json</code> 文件中声明不同类型的依赖。</p>
<ol>
<li><code>dependencies</code>：<ul>
<li><code>dependencies</code> 属性用于声明项目运行时所需的依赖项，即在项目运行时必须加载的模块。</li>
<li>这些依赖项会被安装在生产环境中，用于构建和运行项目的正式版本。</li>
<li>在生产环境中运行 <code>npm install</code> 或 <code>npm ci</code> 时，只会安装 <code>dependencies</code> 中声明的依赖项。</li>
</ul>
</li>
<li><code>devDependencies</code>：<ul>
<li><code>devDependencies</code> 属性用于声明开发过程中所需的依赖项，即仅在开发和构建过程中使用的模块。</li>
<li>这些依赖项不会被包含在最终生成的项目代码中，只会在开发过程中使用，例如测试框架、构建工具、代码检查等。</li>
<li>在生产环境中运行 <code>npm install</code> 或 <code>npm ci</code> 时，不会安装 <code>devDependencies</code> 中声明的依赖项。</li>
</ul>
</li>
</ol>
<p>示例 <code>package.json</code> 文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;my-project&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">  &quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;express&quot;: &quot;^4.17.1&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;devDependencies&quot;: &#123;</span><br><span class="line">    &quot;jest&quot;: &quot;^27.1.1&quot;,</span><br><span class="line">    &quot;babel&quot;: &quot;^7.15.0&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，<code>express</code> 是一个运行时依赖项，而 <code>jest</code> 和 <code>babel</code> 是开发依赖项。运行 <code>npm install</code> 时，只会安装 <code>express</code>，而 <code>jest</code> 和 <code>babel</code> 仅在运行 <code>npm install --only=dev</code> 或 <code>npm ci</code> 时才会被安装。这样可以使项目的依赖项更清晰，减少生产环境的冗余依赖。</p>
<h4 id="7-描述一下从接到url开始，到逻辑处理，到DB查询-到返回结果，整个过程是怎么处理的"><a href="#7-描述一下从接到url开始，到逻辑处理，到DB查询-到返回结果，整个过程是怎么处理的" class="headerlink" title="7.描述一下从接到url开始，到逻辑处理，到DB查询,到返回结果，整个过程是怎么处理的?"></a>7.描述一下从接到url开始，到逻辑处理，到DB查询,到返回结果，整个过程是怎么处理的?</h4><p>整个过程涉及到前端、后端和数据库的协作。下面是一般的流程描述：</p>
<ol>
<li>前端请求：<ul>
<li>客户端（浏览器或移动设备）向服务器发送 HTTP 请求，请求的 URL 包含了需要访问的资源或需要执行的操作。</li>
</ul>
</li>
<li>后端接收请求：<ul>
<li>服务器接收到请求后，通过路由系统将请求分发到对应的处理程序（后端控制器或中间件）。</li>
</ul>
</li>
<li>逻辑处理：<ul>
<li>后端控制器或中间件根据请求的 URL 和参数进行相应的逻辑处理，可能涉及到业务逻辑、验证等操作。</li>
</ul>
</li>
<li>数据库查询：<ul>
<li>如果逻辑处理需要从数据库中获取数据，后端将通过数据访问层（例如 ORM 或原生 SQL）向数据库发送查询请求。</li>
</ul>
</li>
<li>数据库操作：<ul>
<li>数据库接收到查询请求后，执行相应的查询操作，从数据库中获取所需的数据。</li>
</ul>
</li>
<li>处理结果：<ul>
<li>数据库将查询结果返回给后端。</li>
</ul>
</li>
<li>后端响应：<ul>
<li>后端控制器或中间件根据数据库查询结果进行适当的处理，构造响应数据。</li>
</ul>
</li>
<li>响应传输：<ul>
<li>后端将处理后的响应数据打包成 HTTP 响应，包括响应状态码、头部信息和响应体。</li>
</ul>
</li>
<li>前端接收：<ul>
<li>客户端接收到 HTTP 响应后，根据响应状态码和头部信息进行相应处理，如果响应体是 JSON 数据，则进行解析。</li>
</ul>
</li>
<li>前端渲染：<ul>
<li>前端根据接收到的数据进行相应的渲染，将数据显示在页面上。</li>
</ul>
</li>
</ol>
<p>整个过程可以根据具体的应用场景和技术栈进行细节调整。前端通过 HTTP 请求与后端进行交互，后端处理请求，并与数据库进行数据交互，最终将处理结果返回给前端，前端再将数据展示给用户。这样的交互过程构成了一次完整的前后端交互流程。</p>
<h4 id="8-谈谈你对Koa和Express的理解，二-者的区别是"><a href="#8-谈谈你对Koa和Express的理解，二-者的区别是" class="headerlink" title="8.谈谈你对Koa和Express的理解，二 者的区别是?"></a>8.谈谈你对Koa和Express的理解，二 者的区别是?</h4><p>Koa 和 Express 都是 Node.js 中常用的 Web 框架，用于快速构建 Web 应用程序和 RESTful API。它们都基于 Node.js 的 HTTP 模块，并提供了简洁的 API 和中间件来处理请求和响应。</p>
<p>Koa 的特点和理解：</p>
<ol>
<li>Koa 是一个更轻量级的框架，由 Express 的原作者设计。它采用了 ES6 的语法和 async&#x2F;await，使得代码更加简洁、可读性更强。</li>
<li>Koa 中间件机制非常灵活，使用了洋葱模型（Onion Model）来处理中间件的执行顺序，可以更方便地实现链式调用。</li>
<li>Koa 不包含任何默认中间件，需要开发者根据需求手动引入，并且可以根据项目的实际情况灵活地组织中间件。</li>
<li>Koa 的错误处理更加优雅，采用了 try…catch 来处理异常，并且提供了一个专门的错误处理中间件来集中处理错误。</li>
<li>Koa 使用了洋葱模型，因此在一些复杂的场景中，可能会更加清晰易懂。</li>
</ol>
<p>Express 的特点和理解：</p>
<ol>
<li>Express 是一个成熟的、功能丰富的框架，已经被广泛应用于许多项目。它有着强大的社区支持和丰富的插件。</li>
<li>Express 的中间件机制相对简单，采用了栈式调用的方式。中间件的执行顺序按照添加的顺序执行。</li>
<li>Express 包含了一些默认中间件，如处理静态文件、处理 JSON 数据等，因此在一些情况下会比 Koa 更加快速地搭建项目。</li>
<li>Express 的错误处理相对简单，通过在路由中直接抛出错误，然后通过专门的错误处理中间件来处理。</li>
</ol>
<p>两者的区别：</p>
<ol>
<li>语法：Koa 使用了 ES6 的 async&#x2F;await 语法，代码更加简洁；而 Express 使用了回调函数，代码相对冗长。</li>
<li>中间件：Koa 的中间件机制更加灵活，使用了洋葱模型，链式调用更直观；而 Express 使用栈式调用，添加和执行顺序一致。</li>
<li>默认中间件：Koa 不包含任何默认中间件，需要手动引入；而 Express 包含了一些默认中间件，如处理静态文件和 JSON 数据。</li>
<li>错误处理：Koa 使用了 try…catch 来处理异常，错误处理相对更加优雅；而 Express 通过在路由中抛出错误，然后通过错误处理中间件来处理。</li>
</ol>
<p>总体而言，Koa 更加轻量级、灵活，适合喜欢新的语法和更自由组织中间件的开发者；而 Express 更加成熟、功能丰富，适合需要快速搭建项目并且喜欢传统回调函数写法的开发者。选择使用哪个框架，可以根据项目的需求、个人偏好和团队经验来进行权衡。</p>
<h4 id="9-谈谈对egg和nest-js的理解，二者的区别是"><a href="#9-谈谈对egg和nest-js的理解，二者的区别是" class="headerlink" title="9.谈谈对egg和nest.js的理解，二者的区别是 ?"></a>9.谈谈对egg和nest.js的理解，二者的区别是 ?</h4><p>Egg 和 Nest.js 都是用于构建 Node.js 后端应用程序的框架，它们有不同的设计理念和特点。</p>
<p>Egg 的特点和理解：</p>
<ol>
<li>Egg 是一个企业级的 Node.js 框架，它基于 Koa 和 Express，并在此基础上提供了更多企业级的功能和插件。</li>
<li>Egg 遵循 “约定优于配置” 的设计原则，提供了一套约定和规范，可以快速开发出高质量的应用。</li>
<li>Egg 提供了插件系统，可以通过安装和配置插件来扩展功能，社区提供了丰富的插件。</li>
<li>Egg 的插件体系支持热插拔，可以动态开启和关闭插件，而无需重启应用。</li>
<li>Egg 提供了完善的开发调试工具，例如开发环境下的热更新、调试工具和单元测试支持等。</li>
</ol>
<p>Nest.js 的特点和理解：</p>
<ol>
<li>Nest.js 是一个用于构建高度可扩展的、模块化的 Node.js 后端应用程序的框架。</li>
<li>Nest.js 基于 TypeScript，它提供了强类型的开发体验，有助于代码的可维护性和可读性。</li>
<li>Nest.js 使用依赖注入（DI）和模块化的架构，使得应用的组织和管理更加清晰和灵活。</li>
<li>Nest.js 支持多种传输层协议，例如 HTTP、WebSocket 等，并且内置了 GraphQL 的支持。</li>
<li>Nest.js 提供了一套完善的工具和功能，如过滤器、中间件、拦截器等，使得开发者可以更方便地实现一些通用的功能。</li>
</ol>
<p>两者的区别：</p>
<ol>
<li>设计理念：Egg 更侧重于企业级应用，提供了约定和规范来保证应用的质量和稳定性，支持插件化开发；而 Nest.js 更侧重于模块化的架构和依赖注入，使得应用的组织和管理更加清晰和灵活。</li>
<li>语言和类型系统：Egg 使用 JavaScript 和部分 TypeScript，它对类型的支持较弱；而 Nest.js 使用 TypeScript，它对强类型的支持更加全面。</li>
<li>插件和功能支持：Egg 提供了丰富的插件，可以快速实现一些常用的功能；而 Nest.js 提供了一套完善的工具和功能，如过滤器、中间件、拦截器等，方便开发者实现通用的功能。</li>
</ol>
<p>选择使用 Egg 还是 Nest.js，可以根据项目的需求、团队技术栈和开发者个人偏好来决定。如果需要一个成熟、稳定的企业级框架并且对 TypeScript 有较高要求，可以选择 Egg；如果注重模块化架构和依赖注入，并且喜欢使用 TypeScript 进行开发，可以选择 Nest.js。</p>
<h2 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h2><h4 id="1-mysql-和mongoDB有什么区别"><a href="#1-mysql-和mongoDB有什么区别" class="headerlink" title="1.mysql 和mongoDB有什么区别"></a>1.mysql 和mongoDB有什么区别</h4><p>MySQL和MongoDB是两种不同类型的数据库管理系统，它们有一些显著的区别：</p>
<ol>
<li>数据模型：<ul>
<li>MySQL是一种关系型数据库管理系统（RDBMS），它使用表格来存储数据，每个表格包含固定的列和行，表格之间通过外键关联。</li>
<li>MongoDB是一种文档型数据库，它使用类似JSON的BSON格式来存储数据，数据以文档的形式存储，每个文档可以具有不同的结构。</li>
</ul>
</li>
<li>数据模式：<ul>
<li>MySQL要求事先定义表格的结构和数据类型，即采用固定的数据模式。</li>
<li>MongoDB是无模式的，允许在同一集合中存储不同结构的文档。</li>
</ul>
</li>
<li>查询语言：<ul>
<li>MySQL使用结构化查询语言（SQL）来进行数据查询和操作。</li>
<li>MongoDB使用基于对象的查询语言。</li>
</ul>
</li>
<li>主键：<ul>
<li>MySQL要求每个表格必须有主键来唯一标识每行数据。</li>
<li>MongoDB的文档默认具有一个 <code>_id</code> 字段作为主键。</li>
</ul>
</li>
<li>扩展性：<ul>
<li>MySQL通常在单个服务器上运行，并且垂直扩展性（增加硬件资源）有限。</li>
<li>MongoDB支持水平扩展性（增加服务器数量）以处理大规模数据和高并发请求。</li>
</ul>
</li>
<li>事务支持：<ul>
<li>MySQL支持事务，可以保证数据的一致性和完整性。</li>
<li>MongoDB在较早的版本中不支持事务，但从MongoDB 4.0开始提供了部分事务支持。</li>
</ul>
</li>
<li>存储引擎：<ul>
<li>MySQL支持多种存储引擎，如InnoDB、MyISAM等，每种引擎有不同的特点和用途。</li>
<li>MongoDB使用默认的WiredTiger存储引擎。</li>
</ul>
</li>
<li>使用场景：<ul>
<li>MySQL通常用于事务处理和需要严格数据模型的应用，如电子商务网站、金融系统等。</li>
<li>MongoDB适用于大规模的非结构化或半结构化数据，如日志、社交媒体数据、实时大数据等。</li>
</ul>
</li>
</ol>
<p>总体而言，MySQL适用于需要复杂查询和事务支持的应用，而MongoDB适用于需要灵活的数据模型和高度可扩展性的应用。选择使用哪种数据库取决于应用的需求和数据特性。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://awzz-coder.github.io">awzz-coder</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://awzz-coder.github.io/archives/5205ee75.html">https://awzz-coder.github.io/archives/5205ee75.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://awzz-coder.github.io" target="_blank">awzz博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/IT%E5%89%8D%E7%AB%AF/">IT前端</a><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a></div><div class="post_share"><div class="social-share" data-image="https://w.wallhaven.cc/full/2y/wallhaven-2yz3m9.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat-pay.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/wechat-pay.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/ali-pay.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/ali-pay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/archives/ef9ebb65.html" title="小程序开发实战"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://w.wallhaven.cc/full/2y/wallhaven-2yz3m9.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">小程序开发实战</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/archives/f99e1de4.html" title="HTML&#x2F;CSS 知识体系（部分）"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://w.wallhaven.cc/full/2y/wallhaven-2yz3m9.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-12</div><div class="title">HTML&#x2F;CSS 知识体系（部分）</div></div></a></div><div><a href="/archives/4b0178e0.html" title="JavaScript基础"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./img/default.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-23</div><div class="title">JavaScript基础</div></div></a></div><div><a href="/archives/f8e09374.html" title="Vue"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://w.wallhaven.cc/full/2y/wallhaven-2yz3m9.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-10</div><div class="title">Vue</div></div></a></div><div><a href="/archives/7db00131.html" title="前端工程化"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./img/default.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-01</div><div class="title">前端工程化</div></div></a></div><div><a href="/archives/0.html" title="数据结构与算法"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./img/default.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-10</div><div class="title">数据结构与算法</div></div></a></div><div><a href="/archives/ef9ebb65.html" title="小程序开发实战"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://w.wallhaven.cc/full/2y/wallhaven-2yz3m9.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-01</div><div class="title">小程序开发实战</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="lv-container" data-id="city" data-uid="MTAyMC81ODI5MC8zNDc1Mw=="></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./img/avatar.jpeg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">awzz-coder</div><div class="author-info__description">我的博客笔记-前端分享</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">19</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><a id="card-info-btn" href="https://awzz-coder.github.io"><i class="fab fa-github"></i><span>关注我</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/awzz-coder" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://www.baidu.com" rel="external nofollow noreferrer" target="_blank" title="Twitter"><i class="fab fa-twitter"></i></a><a class="social-icon" href="https://space.bilibili.com/476760963?spm_id_from=333.1007.0.0" rel="external nofollow noreferrer" target="_blank" title="B站"><i class="fas fa-b"></i></a><a class="social-icon" href="/546836216@qq.com" target="_blank" title="QQ邮箱"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到awzz的博客</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-text">前端面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#HTML-x2F-CSS"><span class="toc-text">HTML&#x2F;CSS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AFBFC-%E5%A6%82%E4%BD%95%E8%A7%A6%E5%8F%91-%E6%9C%89%E4%BD%95%E7%89%B9%E7%82%B9-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3margin%E2%80%9D%E5%A1%8C%E9%99%B7%E2%80%9D"><span class="toc-text">1.什么是BFC ?如何触发?有何特点?如何解决margin”塌陷”?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-CSS%E5%A6%82%E4%BD%95%E5%87%BA%E6%9D%A5%E6%BA%A2%E5%87%BA-%E8%AF%B4%E4%B8%80%E4%B8%8Boverflow%E4%B8%8D%E5%90%8C%E5%80%BC%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">2.CSS如何出来溢出?说一下overflow不同值的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80%E6%9C%89%E4%BB%80%E4%B9%88%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-text">3.三栏布局有什么实现方式？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-css-calc%E5%B1%9E%E6%80%A7%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88-%E4%B8%BB%E8%A6%81%E7%94%A8%E4%BA%8E%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="toc-text">4.css calc属性作用是什么?主要用于解决什么问题?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%9C%89%E4%B8%80%E4%B8%AA%E5%9B%BA%E5%AE%9A%E9%95%BF%E5%AE%BDdiv-%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E5%9C%A8%E5%B1%8F%E5%B9%95%E4%B8%8A%E5%9E%82%E7%9B%B4%E6%B0%B4%E5%B9%B3%E5%B1%85%E4%B8%AD"><span class="toc-text">5.有一个固定长宽div,怎么实现在屏幕上垂直水平居中</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%8B%E6%B8%90%E8%BF%9B%E5%A2%9E%E5%BC%BA-progressive-enhancement-%E5%92%8C%E4%BC%98%E9%9B%85%E9%99%8D%E7%BA%A7-gracefuldegradation"><span class="toc-text">6.描述一下渐进增强(progressive enhancement)和优雅降级(gracefuldegradation)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-iframe-%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%98%E7%82%B9-%E5%93%AA%E4%BA%9B%E7%BC%BA%E7%82%B9-%E8%83%9E%E6%9D%A5%E8%A7%A3%E5%86%B3%E8%BF%87%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="toc-text">7.iframe 有哪些优点?哪些缺点?胞来解决过什么问题?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-Google-Chrome%E5%A6%82%E4%BD%95%E6%94%AF%E6%8C%81%E5%A4%A7%E5%B0%8F%E5%B0%8F%E4%BA%8E12px-%E7%9A%84%E6%96%87%E5%AD%97"><span class="toc-text">8.Google Chrome如何支持大小小于12px 的文字?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%8Bcss%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B"><span class="toc-text">9.描述一下css盒子模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-HTML5%E7%9A%84%E7%89%B9%E6%80%A7%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-text">10.HTML5的特性有哪些?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-CSS3-%E7%9A%84%E7%89%B9%E6%80%A7%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-text">11.CSS3 的特性有哪些?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%B0%B4%E5%B9%B3%E5%B1%85%E4%B8%AD"><span class="toc-text">12.如何实现水平居中?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD"><span class="toc-text">13.如何实现垂直居中?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8F%8C%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80"><span class="toc-text">14.如何实现双圣杯布局?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15-CSS%E4%B8%AD%E9%80%89%E6%8B%A9%E5%99%A8%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-text">15.CSS中选择器的优先级?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-CSS-%E6%9D%83%E9%87%8D%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97"><span class="toc-text">16.CSS 权重如何计算?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#17-HTML5-input%E5%85%83%E7%B4%A0type%E5%B1%9E%E6%80%A7%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-text">17.HTML5 input元素type属性有哪些?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#18-CSS%E4%B8%AD%E5%93%AA%E4%BA%9B%E5%B1%9E%E6%80%A7%E5%8F%AF%E7%BB%A7%E6%89%BF%EF%BC%8C%E5%93%AA%E4%BA%9B%E4%B8%8D%E5%8F%AF%E4%BB%A5"><span class="toc-text">18.CSS中哪些属性可继承，哪些不可以</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#19-CSS%E5%8D%95%E4%BD%8D%E4%B8%ADpx%E3%80%81-em%E5%92%8Crem%E7%9A%84%E5%8C%BA%E5%88%AB-%E9%85%8D%E5%90%88font-size%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97-%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D%E6%96%B9%E6%A1%88"><span class="toc-text">19.CSS单位中px、 em和rem的区别?配合font-size如何计算? (移动端适配方案)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#20-%E5%A6%82%E4%BD%95%E7%94%BB%E4%B8%80%E6%9D%A10-5px%E7%9A%84%E7%BA%BF"><span class="toc-text">20.如何画一条0.5px的线</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#21-%E9%9A%90%E8%97%8F%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95-display-none%E4%B8%8Evisibility-hidden%E4%B8%8Eopacity-0%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">21.隐藏一个元素有哪些方法? display: none与visibility: hidden与opacity: 0之间的区别?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#22-position-%E7%9A%84%E5%80%BC%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%8C%E5%88%86%E5%88%AB%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9"><span class="toc-text">22.position 的值有哪些，分别有什么特点?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#23-%E4%BB%80%E4%B9%88%E6%98%AF%E6%B5%AE%E5%8A%A8%EF%BC%8C%E6%B5%AE%E5%8A%A8%E4%BC%9A%E5%BC%95%E8%B5%B7%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%8C%E6%9C%89%E4%BD%95%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-text">23.什么是浮动，浮动会引起什么问题，有何解决方案?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#24-line-height-%E5%92%8Cheight%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">24.line-height 和height的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#25-%E8%AE%BE%E7%BD%AE%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E7%9A%84%E8%83%8C%E6%99%AF%E9%A2%9C%E8%89%B2%EF%BC%8C%E8%83%8C%E6%99%AF%E9%A2%9C%E8%89%B2%E4%BC%9A%E5%A1%AB%E5%85%85%E5%93%AA%E4%BA%9B%E5%8C%BA%E5%9F%9F"><span class="toc-text">25.设置一个元素的背景颜色，背景颜色会填充哪些区域?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#26-inline-block-inline-%E5%92%8Cblock%E7%9A%84%E5%8C%BA%E5%88%AB-%E4%B8%BA%E4%BB%80%E4%B9%88img%E6%98%AFinline%E8%BF%98%E5%8F%AF%E4%BB%A5%E8%AE%BE%E7%BD%AE%E5%AE%BD%E9%AB%98"><span class="toc-text">26.inline-block. inline 和block的区别;为什么img是inline还可以设置宽高</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#27-%E4%BB%80%E4%B9%88%E6%98%AF%E9%87%8D%E7%BB%98-%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%9E%E6%B5%81-%E5%A6%82%E4%BD%95%E5%87%8F%E5%B0%91-%E5%A6%82%E4%BD%95%E8%AE%A9%E6%96%87%E6%A1%A3%E8%84%B1%E7%A6%BB%E6%96%87%E6%A1%A3%E6%B5%81"><span class="toc-text">27.什么是重绘?什么是回流?如何减少?如何让文档脱离文档流?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#28-box-sizing-%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8"><span class="toc-text">28.box-sizing 的作用，如何使用?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#29-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8"><span class="toc-text">29.如何实现清除浮动</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#30-CSS-%E5%8A%A8%E7%94%BB%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0"><span class="toc-text">30.CSS 动画如何实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#31-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%9C%A8%E6%9F%90%E4%B8%AA%E5%AE%B9%E5%99%A8%E4%B8%AD%E5%B1%85%E4%B8%AD%E7%9A%84"><span class="toc-text">31.如何实现在某个容器中居中的?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#32-%E5%A6%82%E4%BD%95%E6%94%B9%E5%8F%98%E4%B8%80%E4%B8%AADOM%E5%85%83%E7%B4%A0%E7%9A%84%E5%AD%97%E4%BD%93%E9%A2%9C%E8%89%B2"><span class="toc-text">32.如何改变一个DOM元素的字体颜色?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#33-%E7%9B%B8%E5%AF%B9%E5%B8%83%E5%B1%80%E5%92%8C%E7%BB%9D%E5%AF%B9%E5%B8%83%E5%B1%80%EF%BC%8Cposition-relative-%E5%92%8Cobsolute"><span class="toc-text">33.相对布局和绝对布局，position:relative 和obsolute</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#34-%E4%BB%80%E4%B9%88%E6%98%AF%E5%BC%B9%E6%80%A7%E7%9B%92%E5%AD%90flex%E5%B8%83%E5%B1%80"><span class="toc-text">34.什么是弹性盒子flex布局?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#35-%E4%BB%80%E4%B9%88%E6%98%AFrem%E5%B8%83%E5%B1%80"><span class="toc-text">35.什么是rem布局?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#36-less%E5%92%8Cscss%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">36.less和scss有什么区别?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#37-before-%E5%92%8C-after%E4%B8%AD%E5%8F%8C%E5%86%92%E5%8F%B7%E5%92%8C%E5%8D%95%E5%86%92%E5%8F%B7%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">37.::before 和::after中双冒号和单冒号的区别?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#38-CSS3%E6%96%B0%E5%A2%9E%E4%BC%AA%E7%B1%BB%EF%BC%8C%E4%BB%A5%E5%8F%8A%E4%BC%AA%E5%85%83%E7%B4%A0"><span class="toc-text">38.CSS3新增伪类，以及伪元素?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#39-%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88"><span class="toc-text">39.响应式布局实现方案?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#40-link-%E6%A0%87%E7%AD%BE%E5%92%8Cimport%E6%A0%87%E7%AD%BE%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">40.link 标签和import标签的区别?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#41-transition-%E5%92%8Canimation-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">41.transition 和animation 的区别?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#42-%E8%AF%B4%E4%B8%80%E4%B8%8B%E5%9D%97%E5%85%83%E7%B4%A0%E3%80%81%E8%A1%8C%E5%85%83%E7%B4%A0%E3%80%81%E7%BD%AE%E6%8D%A2%E5%85%83%E7%B4%A0"><span class="toc-text">42.说一下块元素、行元素、置换元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#43-%E5%A4%9A%E8%A1%8C%E5%85%83%E7%B4%A0%E7%9A%84%E6%96%87%E6%9C%AC%E7%9C%81%E7%95%A5%E5%8F%B7%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-text">43.多行元素的文本省略号如何实现？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#44-Doctype-%E4%BD%9C%E7%94%A8%EF%BC%9F%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F%E4%B8%8E%E6%B7%B7%E6%9D%82%E6%A8%A1%E5%BC%8F%E5%A6%82%E4%BD%95%E5%8C%BA%E5%88%86%EF%BC%9F%E5%AE%83%E4%BB%AC%E6%9C%89%E4%BD%95%E6%84%8F%E4%B9%89%EF%BC%9F"><span class="toc-text">44.Doctype 作用？严格模式与混杂模式如何区分？它们有何意义？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#45-css%E4%B8%AD%E5%88%B6%E4%BD%9C%E5%8A%A8%E7%94%BB%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BA%BA%E4%BB%AC%E7%94%A8translate%E6%9D%A5%E6%94%B9%E5%8F%98%E4%BD%8D%E7%BD%AE%E8%80%8C%E4%B8%8D%E6%98%AF%E5%AE%9A%E4%BD%8D%EF%BC%9F"><span class="toc-text">45.css中制作动画为什么人们用translate来改变位置而不是定位？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaScript"><span class="toc-text">JavaScript</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-javascript-%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-text">1.javascript 的数据类型有哪些?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-javascript-%E6%9C%89%E5%93%AA%E4%BA%9B%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="toc-text">2.javascript 有哪些引用类型?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%ADjavascript%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">3.如何判断javascript的数据类型?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%80%8E%E4%B9%88%E5%88%A4%E6%96%AD%E4%B8%A4%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9B%B8%E7%AD%89-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E7%A9%BA%E5%AF%B9%E8%B1%A1"><span class="toc-text">4.怎么判断两个对象相等?如何判断空对象?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-0-1-0-2%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%AD%89%E4%BA%8E0-3-%E8%A7%A3%E9%87%8A%E5%8E%9F%E7%90%86"><span class="toc-text">5.0.1 + 0.2为什么不等于0.3 ? (解释原理)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E3%80%81%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E5%88%97%E4%B8%BE%E5%9C%BA%E6%99%AF%E8%AF%B4%E6%98%8E%E3%80%82"><span class="toc-text">6.强制类型转换、隐式类型转换分别是什么，列举场景说明。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E5%88%9B%E5%BB%BA%E5%87%BD%E6%95%B0%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-text">7.创建函数的几种方式?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-javascript-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-text">8.javascript 创建对象的几种方式?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-%E5%88%97%E4%B8%BE%E5%AE%BF%E4%B8%BB%E5%AF%B9%E8%B1%A1%E3%80%81%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E3%80%81%E5%8E%9F%E7%94%9F%E5%AF%B9%E8%B1%A1%E5%B9%B6%E8%AF%B4%E6%98%8E%E5%85%B6%E5%AE%9A%E4%B9%89%E3%80%82"><span class="toc-text">9.列举宿主对象、内置对象、原生对象并说明其定义。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-x3D-x3D-x3D-%E5%92%8C-x3D-x3D-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">10.&#x3D;&#x3D;&#x3D;和&#x3D;&#x3D;的区别?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-null-undefined-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">11.null, undefined 的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E8%BF%94%E5%9B%9Eundefined%E5%80%BC"><span class="toc-text">12.什么情况下会返回undefined值?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-%E5%A6%82%E4%BD%95%E5%8C%BA%E5%88%86%E6%95%B0%E7%BB%84%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="toc-text">13.如何区分数组和对象?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84%E5%A6%82%E4%BD%95%E9%99%8D%E7%BB%B4"><span class="toc-text">14.多维数组如何降维?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15-%E6%80%8E%E4%B9%88%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E6%97%A5%E6%9C%9F-%E5%B9%B4-%E6%9C%88-%E6%97%A5-%E6%97%B6-%E5%88%86-%E7%A7%92"><span class="toc-text">15.怎么获取当前日期(年-月-日 时:分:秒) ?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-%E4%BB%80%E4%B9%88%E6%98%AF%E7%B1%BB%E6%95%B0%E7%BB%84-%E4%BC%AA%E6%95%B0%E7%BB%84-%EF%BC%8C-%E5%A6%82%E4%BD%95%E5%B0%86%E5%85%B6%E8%BD%AC%E5%8C%96%E4%B8%BA%E7%9C%9F%E5%AE%9E%E7%9A%84%E6%95%B0%E7%BB%84"><span class="toc-text">16.什么是类数组(伪数组)， 如何将其转化为真实的数组?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#17-%E5%A6%82%E4%BD%95%E9%81%8D%E5%8E%86%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-text">17.如何遍历对象的属性?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#18-%E5%A6%82%E4%BD%95%E7%BB%99%E4%B8%80%E4%B8%AA%E6%8C%89%E9%92%AE%E7%BB%91%E5%AE%9A%E4%B8%A4%E4%B8%AAonclick%E4%BA%8B%E4%BB%B6"><span class="toc-text">18.如何给一个按钮绑定两个onclick事件?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#19-%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%E6%98%AF%E4%BB%80%E4%B9%88-%E4%B8%8E%E5%87%BD%E6%95%B0%E6%8F%90%E5%8D%87%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">19.变量提升是什么?与函数提升的区别?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#20-%E4%BB%80%E4%B9%88%E6%98%AF%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE-%E5%A6%82%E4%BD%95%E5%BB%B6%E9%95%BF"><span class="toc-text">20.什么是作用域链?如何延长?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#21-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%95%B0%E7%BB%84%E7%9A%84%E9%9A%8F%E6%9C%BA%E6%8E%92%E5%BA%8F"><span class="toc-text">21.如何实现数组的随机排序?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#22-dom%E8%8A%82%E7%82%B9%E7%9A%84Attribute%E5%92%8CProperty-%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB"><span class="toc-text">22.dom节点的Attribute和Property 有何区别?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#23-dom%E7%BB%93%E6%9E%84%E6%93%8D%E4%BD%9C%E6%80%8E%E6%A0%B7%E6%B7%BB%E5%8A%A0%E3%80%81%E7%A7%BB%E9%99%A4%E3%80%81%E7%A7%BB%E5%8A%A8%E3%80%81%E5%A4%8D%E5%88%B6%E3%80%81%E5%88%9B%E5%BB%BA%E5%92%8C%E6%9F%A5%E6%89%BE%E8%8A%82%E7%82%B9"><span class="toc-text">23.dom结构操作怎样添加、移除、移动、复制、创建和查找节点?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#24-%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%EF%BC%8C%E5%AE%83%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84-%E5%A6%82%E4%BD%95%E9%98%BB%E6%AD%A2%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1"><span class="toc-text">24.什么是事件冒泡，它是如何工作的?如何阻止事件冒泡?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#25-%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E4%BB%B6%E6%8D%95%E8%8E%B7%EF%BC%8C%E5%AE%83%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84"><span class="toc-text">25.什么是事件捕获，它是如何工作的?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#26-%E5%A6%82%E4%BD%95%E8%AE%A9%E4%BA%8B%E4%BB%B6%E5%85%88%E5%86%92%E6%B3%A1%E5%90%8E%E6%8D%95%E8%8E%B7"><span class="toc-text">26.如何让事件先冒泡后捕获?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#27-JavaScript-%E5%8A%A8%E7%94%BB%E5%92%8CCSS3%E5%8A%A8%E7%94%BB%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">27.JavaScript 动画和CSS3动画有什么区别?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#28-dom%E7%9A%84%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B"><span class="toc-text">28.dom的事件模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#29-%E4%BA%8B%E4%BB%B6%E4%B8%89%E8%A6%81%E7%B4%A0%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">29.事件三要素是什么?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#30-%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%E4%BD%8D%E7%BD%AE"><span class="toc-text">30.获取元素位置?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#31-%E5%A6%82%E4%BD%95%E7%BB%91%E5%AE%9A%E4%BA%8B%E4%BB%B6%EF%BC%8C%E5%A6%82%E4%BD%95%E8%A7%A3%E9%99%A4%E4%BA%8B%E4%BB%B6"><span class="toc-text">31.如何绑定事件，如何解除事件?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#32-%E5%AF%B9%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">32.对事件委托的理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#33-setTimeout-%E5%92%8CsetInterval%E7%9A%84%E5%8C%BA%E5%88%AB%E5%8F%8A%E7%94%A8%E6%B3%95%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">33.setTimeout 和setInterval的区别及用法是什么?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#34-%E7%94%A8setTimeout%E6%9D%A5%E5%AE%9E%E7%8E%B0setInterval"><span class="toc-text">34.用setTimeout来实现setInterval</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#35-document-write-%E5%92%8CinnerHTML%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">35.document.write 和innerHTML的区别?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#36-%E5%85%83%E7%B4%A0%E6%8B%96%E5%8A%A8%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%8C%E5%8E%9F%E7%90%86%E6%98%AF%E6%80%8E%E6%A0%B7"><span class="toc-text">36.元素拖动如何实现，原理是怎样?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#37-%E4%BB%80%E4%B9%88%E6%98%AF%E9%87%8D%E7%BB%98-repaint-%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%9E%E6%B5%81-reflow-%E5%A6%82%E4%BD%95%E6%9C%80%E5%B0%8F%E5%8C%96%E9%87%8D%E7%BB%98%E5%92%8C%E5%9B%9E%E6%B5%81"><span class="toc-text">37.什么是重绘(repaint)?什么是回流(reflow)?如何最小化重绘和回流?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#38-%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-text">38.延迟加载的方式有哪些?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#39-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E6%9C%89%E5%93%AA%E4%BA%9B-%E5%85%B7%E4%BD%93%E6%80%8E%E4%B9%88%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C"><span class="toc-text">39.垃圾回收机制有哪些?具体怎么如何执行?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#40-%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-text">40.什么是内存泄漏?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#41-%E6%95%B0%E7%BB%84%E9%81%8D%E5%8E%86%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%8C%E5%88%86%E5%88%AB%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%8C%E6%80%A7%E8%83%BD%E5%A6%82%E4%BD%95"><span class="toc-text">41.数组遍历的方法有哪些，分别有什么特点，性能如何?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#42-ES5-%E5%92%8CES6%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8CES6%E6%96%B0%E5%A2%9E%E4%BA%86%E4%BB%80%E4%B9%88"><span class="toc-text">42.ES5 和ES6的区别，ES6新增了什么?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#43-ES6%E7%9A%84%E7%BB%A7%E6%89%BF%E5%92%8CES5%E7%9A%84%E7%BB%A7%E6%89%BF%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">43.ES6的继承和ES5的继承有什么区别?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#44-var%E3%80%81-let%E3%80%81-const-%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB-%E6%9A%82%E6%97%B6%E6%80%A7%E6%AD%BB%E5%8C%BA%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3"><span class="toc-text">44.var、 let、 const 之间的区别?暂时性死区如何理解?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#45-Class%E3%80%81-extends-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8"><span class="toc-text">45.Class、 extends 是什么，有什么作用?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#46-%E4%BB%80%E4%B9%88%E6%98%AFJS%E5%8C%85"><span class="toc-text">46.什么是JS包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#47-%E8%AF%B4%E4%B8%80%E4%B8%8B%E7%B1%BB%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E7%BB%A7%E6%89%BF%EF%BC%8C%E5%88%97%E4%B8%BE%E4%B8%80%E4%B8%8B%E4%BD%A0%E6%89%80%E7%9F%A5%E9%81%93%E7%9A%84%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F"><span class="toc-text">47.说一下类的创建和继承，列举一下你所知道的继承方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#48-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%BC%82%E6%AD%A5%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B1"><span class="toc-text">48.如何解决异步回调地狱</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#49-%E8%AF%B4%E4%B8%80%E4%B8%8B%E5%9B%BE%E7%89%87%E7%9A%84%E6%87%92%E5%8A%A0%E8%BD%BD%E5%92%8C%E9%A2%84%E5%8A%A0%E8%BD%BD"><span class="toc-text">49.说一下图片的懒加载和预加载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#50-mouseover%E5%92%8Cmouseenter%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">50.mouseover和mouseenter的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#51-new%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%81%9A%E4%BA%86%E5%93%AA%E4%BA%9B%E4%BA%8B%E6%83%85"><span class="toc-text">51.new操作符做了哪些事情</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#52-%E6%94%B9%E5%8F%98%E5%87%BD%E6%95%B0%E5%86%85%E9%83%A8this%E6%8C%87%E9%92%88%E7%9A%84%E6%8C%87%E5%90%91%E5%87%BD%E6%95%B0-bind-apply-call-%E7%9A%84%E5%8C%BA%E5%88%AB-%EF%BC%8C%E5%86%85%E5%9C%A8%E5%88%86%E5%88%AB%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="toc-text">52.改变函数内部this指针的指向函数(bind, apply, call 的区别)，内在分别是如何实现的?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#53-JS%E7%9A%84%E5%90%84%E7%A7%8D%E4%BD%8D%E7%BD%AE-%E6%AF%94%E5%A6%82clientHeight-scrollHeight-offsetHeight-%E4%BB%A5%E5%8F%8AscrollTop-offsetTop-clientTop%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">53.JS的各种位置,比如clientHeight, scrollHeight, offsetHeight ,以及scrollTop,offsetTop, clientTop的区别?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#54-%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BDJS%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">54.异步加载JS的方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#55-Ajax-%E8%A7%A3%E5%86%B3%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98"><span class="toc-text">55.Ajax 解决浏览器缓存问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#56-%E8%8A%82%E6%B5%81%E5%92%8C%E9%98%B2%E6%8A%96"><span class="toc-text">56.节流和防抖</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#57-eval-%E6%98%AF%E5%81%9A%E4%BB%80%E4%B9%88%E7%9A%84"><span class="toc-text">57.eval 是做什么的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#58-%E5%AF%B9%E8%B1%A1%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0"><span class="toc-text">58.对象深拷贝的简单实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#59-%E5%AE%9E%E7%8E%B0JS%E4%B8%AD%E6%89%80%E6%9C%89%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%B7%B1%E5%BA%A6%E5%85%8B%E9%9A%86-%E5%8C%85%E8%A3%85%E5%AF%B9%E8%B1%A1%EF%BC%8C-Date-%E5%AF%B9%E8%B1%A1%EF%BC%8C%E6%AD%A3%E5%88%99%E5%AF%B9%E8%B1%A1"><span class="toc-text">59.实现JS中所有对象的深度克隆(包装对象， Date 对象，正则对象)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#60-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAonce%E5%87%BD%E6%95%B0%EF%BC%8C%E4%BC%A0%E5%85%A5%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E5%8F%AA%E6%89%A7%E8%A1%8C%E4%B8%80%E6%AC%A1"><span class="toc-text">60.实现一个once函数，传入函数参数只执行一次</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#61-%E5%B0%86%E5%8E%9F%E7%94%9F%E7%9A%84ajax%E5%B0%81%E8%A3%85%E6%88%90promise"><span class="toc-text">61.将原生的ajax封装成promise</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#62-JS%E7%9B%91%E5%90%AC%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E7%9A%84%E6%94%B9%E5%8F%98"><span class="toc-text">62.JS监听对象属性的改变</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#63-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%A7%81%E6%9C%89%E5%8F%98%E9%87%8F%EF%BC%8C%E7%94%A8get%E5%8F%AF%E4%BB%A5%E8%AE%BF%E9%97%AE%EF%BC%8C%E4%B8%8D%E8%83%BD%E7%9B%B4%E6%8E%A5%E8%AE%BF%E9%97%AE"><span class="toc-text">63.如何实现一个私有变量，用get可以访问，不能直接访问</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#64-%E6%80%8E%E4%B9%88%E6%8E%A7%E5%88%B6%E4%B8%80%E6%AC%A1%E5%8A%A0%E8%BD%BD%E4%B8%80%E5%BC%A0%E5%9B%BE%E7%89%87%EF%BC%8C%E5%8A%A0%E8%BD%BD%E5%AE%8C%E5%90%8E%E5%86%8D%E5%8A%A0%E8%BD%BD%E4%B8%8B%E4%B8%80%E5%BC%A0"><span class="toc-text">64.怎么控制一次加载一张图片，加载完后再加载下一张</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#65-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0sleep%E7%9A%84%E6%95%88%E6%9E%9C-es5-%E6%88%96%E8%80%85es6"><span class="toc-text">65.如何实现sleep的效果(es5 或者es6)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#66-Function-proto-getPrototypeOf-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">66.Function._ proto_ (getPrototypeOf)是什么?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#67-%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E4%B8%ADthis-%E6%8C%87%E5%90%91"><span class="toc-text">67.箭头函数中this 指向</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#68-%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-text">68.数组常用方法有哪些</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#69-%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95"><span class="toc-text">69.数组去重有哪些方法?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#70-%E5%A6%82%E4%BD%95%E5%8E%BB%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%A6%96%E5%B0%BE%E7%A9%BA%E6%A0%BC"><span class="toc-text">70.如何去除字符串首尾空格</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#71-%E8%AF%B4%E8%AF%B4%E4%BD%A0%E6%89%80%E7%9F%A5%E9%81%93%E7%9A%84JS%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7"><span class="toc-text">71.说说你所知道的JS语言特性?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#72-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84"><span class="toc-text">72.如何判断一个数组?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#73-JS%E7%9A%84%E5%85%A8%E6%8E%92%E5%88%97"><span class="toc-text">73.JS的全排列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#74-%E8%B0%88%E8%B0%88%E4%BD%A0%E6%89%80%E7%90%86%E8%A7%A3%E7%9A%84%E8%B7%A8%E5%9F%9F%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89%E8%BF%99%E4%B8%AA%E9%97%AE%E9%A2%98-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3"><span class="toc-text">74.谈谈你所理解的跨域，为什么会有这个问题?如何解决?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#75-null-x3D-x3D-undefined%E8%BE%93%E5%87%BA%E4%BB%80%E4%B9%88-null-x3D-x3D-x3D-undefined%E5%91%A2"><span class="toc-text">75.null &#x3D;&#x3D; undefined输出什么? null &#x3D;&#x3D;&#x3D; undefined呢?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#76-%E4%BB%80%E4%B9%88%E6%98%AF%E6%8C%89%E9%9C%80%E5%8A%A0%E8%BD%BD"><span class="toc-text">76.什么是按需加载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#77-%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8Bsymbol"><span class="toc-text">77.简单介绍一下symbol</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#78-%E4%BB%8B%E7%BB%8D%E4%B8%8Bpromise-%E5%8F%8A%E5%85%B6%E5%BA%95%E5%B1%82%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0"><span class="toc-text">78.介绍下promise,及其底层如何实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#79-JS%E5%8E%9F%E5%9E%8B%E9%93%BE%EF%BC%8C%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%9A%84%E9%A1%B6%E7%AB%AF%E6%98%AF%E4%BB%80%E4%B9%88-Object-%E7%9A%84%E5%8E%9F%E5%9E%8B%E6%98%AF%E4%BB%80%E4%B9%88-Object%E7%9A%84%E5%8E%9F%E5%9E%8B%E7%9A%84%E5%8E%9F%E5%9E%8B%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">79.JS原型链，原型链的顶端是什么? Object 的原型是什么? Object的原型的原型是什么?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#80-promise-Generator-Async-%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">80.promise+Generator+Async 的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#81-JS%E4%B8%ADstring%E7%9A%84startwith%E5%92%8Cindexof%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">81.JS中string的startwith和indexof两种方法的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#82-JS%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%95%B0%E5%AD%97%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">82.JS字符串转数字的方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#83-%E5%B9%B3%E6%97%B6%E6%98%AF%E6%80%8E%E4%B9%88%E8%B0%83%E8%AF%95JS%E7%9A%84"><span class="toc-text">83.平时是怎么调试JS的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#84-%E6%80%8E%E4%B9%88%E8%8E%B7%E5%BE%97%E5%AF%B9%E8%B1%A1%E4%B8%8A%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-text">84.怎么获得对象上的属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#85-async%E5%92%8Cawait%E5%85%B7%E4%BD%93%E8%AF%A5%E6%80%8E%E4%B9%88%E7%94%A8"><span class="toc-text">85.async和await具体该怎么用?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#86-%E7%9F%A5%E9%81%93%E5%93%AA%E4%BA%9BES6%EF%BC%8CES7-%E7%9A%84%E8%AF%AD%E6%B3%95"><span class="toc-text">86.知道哪些ES6，ES7 的语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#87-promise-%E5%92%8Cawait-x2F-async%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-text">87.promise 和await&#x2F;async的关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#88-JS%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%E9%98%BB%E5%A1%9E%EF%BC%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%E3%80%82"><span class="toc-text">88.JS加载过程阻塞，解决方法。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#89-JS%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%EF%BC%8C%E5%9F%BA%E6%9C%AC%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%E4%BB%A5%E5%8F%8A%E5%BC%95%E7%94%A8%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">89.JS对象类型，基本对象类型以及引用对象类型的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#90-%E8%BD%AE%E6%92%AD%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-%E5%81%87%E5%A6%82%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2%E4%B8%8A%E6%9C%89%E4%B8%A4%E4%B8%AA%E8%BD%AE%E6%92%AD%EF%BC%8C%E4%BD%A0%E4%BC%9A%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0"><span class="toc-text">90.轮播的实现原理?假如一个页面上有两个轮播，你会怎么实现?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#91-%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8BJS%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF"><span class="toc-text">91.解释一下JS的事件循环</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#92-Localstorage%E3%80%81-sessionStorage%E3%80%81-cookie-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">92.Localstorage、 sessionStorage、 cookie 的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#93-%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8BHTML5DragAPI"><span class="toc-text">93.解释一下HTML5DragAPI</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#94-%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8Bwebworker"><span class="toc-text">94.解释一下webworker</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#95-%E5%92%8C-%E7%9A%84valueOf%E5%92%8CtoString-%E7%9A%84%E7%BB%93%E6%9E%9C%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">95.{} 和[]的valueOf和toString 的结果是什么?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#96-%E4%B8%89%E7%A7%8D%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">96.三种事件模型是什么?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#97-%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8BV8%E9%9A%90%E8%97%8F%E7%B1%BB"><span class="toc-text">97.介绍一下V8隐藏类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#98-AMD%E5%92%8CCMD%E8%A7%84%E8%8C%83%E7%9A%84%E5%8C%BA%E5%88%AB-%E8%AF%B4%E4%B8%80%E4%B8%8BCommonJS%E3%80%81AMD%E5%92%8CCMD"><span class="toc-text">98.AMD和CMD规范的区别?说一下CommonJS、AMD和CMD?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#99-%E8%B0%88%E8%B0%88JS%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6"><span class="toc-text">99.谈谈JS的运行机制</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue%E7%94%9F%E6%80%81"><span class="toc-text">Vue生态</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9Vue%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%8C%E6%9C%89%E4%BD%95%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">1.说说你对Vue的理解，有何优缺点?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Vue%E5%92%8CReact%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C"><span class="toc-text">2.Vue和React有什么不同?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BB%80%E4%B9%88%E6%98%AF%E8%99%9A%E6%8B%9FDOM"><span class="toc-text">3.什么是虚拟DOM?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%8F%8F%E8%BF%B0%E4%B8%8Bvue%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%9C%89%E5%93%AA%E4%BA%9B-%E5%88%86%E5%88%AB%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%E4%BA%8B%E6%83%85"><span class="toc-text">4.描述下vue的生命周期有哪些?分别做了什么事情?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-watch-%E6%80%8E%E4%B9%88%E6%B7%B1%E5%BA%A6%E7%9B%91%E5%90%AC%E5%AF%B9%E8%B1%A1%E5%8F%98%E5%8C%96"><span class="toc-text">5.watch 怎么深度监听对象变化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E5%88%A0%E9%99%A4%E6%95%B0%E7%BB%84%E7%94%A8delete%E5%92%8CVue-delete%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">6.删除数组用delete和Vue.delete有什么区别?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-watch-%E5%92%8Ccomputed%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">7.watch 和computed有什么区别?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-v-for%E6%B2%A1%E6%9C%89key%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="toc-text">8.v-for没有key会发生什么问题?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-%E8%B0%88%E8%B0%88Vue%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86"><span class="toc-text">9.谈谈Vue双向绑定原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-v-model-%E6%98%AF%E4%BB%80%E4%B9%88-%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%E5%91%A2"><span class="toc-text">10.v-model 是什么?有什么用呢?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-%E5%9C%A8vue%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%A6%82%E4%BD%95%E5%BC%95%E5%85%A5%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93-%E6%9C%89%E5%93%AA%E4%BA%9B%E5%85%B7%E4%BD%93%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95"><span class="toc-text">11.在vue项目中如何引入第三方库?有哪些具体操作方法?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-Vue3-0-%E9%87%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8Proxy-API%E6%9B%BF%E4%BB%A3defineProperty-API"><span class="toc-text">12.Vue3.0 里为什么要用Proxy API替代defineProperty API?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-Vue3-0-%E7%BC%96%E8%AF%91%E5%81%9A%E4%BA%86%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8C%96"><span class="toc-text">13.Vue3.0 编译做了哪些优化?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-Vue3-0-%E6%96%B0%E7%89%B9%E6%80%A7%E4%B8%80-Composition-API%E4%B8%8EReact-js%E4%B8%ADHooks%E7%9A%84%E5%BC%82%E5%90%8C%E7%82%B9"><span class="toc-text">14.Vue3.0 新特性一-Composition API与React.js中Hooks的异同点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15-Vue3-0-%E5%A6%82%E4%BD%95%E5%8F%98%E5%BE%97%E6%9B%B4%E5%BF%AB%E7%9A%84-dom-diff-%E7%AE%97%E6%B3%95%E6%9C%89%E4%BD%95%E4%BC%98%E5%8C%96"><span class="toc-text">15.Vue3.0 如何变得更快的? dom diff 算法有何优化?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-vue-%E8%A6%81%E5%81%9A%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E8%AF%A5%E6%80%8E%E4%B9%88%E5%81%9A-%E5%A6%82%E6%9E%9C%E6%8E%A7%E5%88%B6%E5%88%B0%E6%8C%89%E9%92%AE%E7%BA%A7%E5%88%AB%E7%9A%84%E6%9D%83%E9%99%90%E6%80%8E%E4%B9%88%E5%81%9A"><span class="toc-text">16.vue 要做权限管理该怎么做?如果控制到按钮级别的权限怎么做?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#17-vue-%E5%9C%A8created%E5%92%8Cmounted%E8%BF%99%E4%B8%A4%E4%B8%AA%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%AD%E8%AF%B7%E6%B1%82%E6%95%B0%E6%8D%AE%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E5%91%A2"><span class="toc-text">17.vue 在created和mounted这两个生命周期中请求数据有什么区别呢?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#18-%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9Proxy%E7%9A%84%E7%90%86%E8%A7%A3%E3%80%82"><span class="toc-text">18.说说你对Proxy的理解。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#19-Vue3-0%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87%E4%B8%BB%E8%A6%81%E6%98%AF%E4%BD%93%E7%8E%B0%E5%9C%A8%E5%93%AA%E4%BA%9B%E6%96%B9%E9%9D%A2"><span class="toc-text">19.Vue3.0性能提升主要是体现在哪些方面?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#20-vue3%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B0%E7%9A%84%E7%BB%84%E4%BB%B6"><span class="toc-text">20.vue3有哪些新的组件?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#21-Vue2-0-%E5%92%8CVue3-0%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">21.Vue2.0 和Vue3.0有什么区别?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#22-Composition-Api%E4%B8%8EOptions-Api%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C"><span class="toc-text">22.Composition Api与Options Api有什么不同?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#23-%E5%AF%B9Vue%E9%A1%B9%E7%9B%AE%E4%BD%A0%E5%81%9A%E8%BF%87%E5%93%AA%E4%BA%9B%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-text">23.对Vue项目你做过哪些性能优化?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#24-Vue%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-text">24.Vue组件通信的方式有哪些?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#25-Vue%E5%B8%B8%E7%94%A8%E7%9A%84%E4%BF%AE%E9%A5%B0%E7%AC%A6%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-text">25.Vue常用的修饰符有哪些?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#26-Vue%E4%B8%AD%E7%9A%84-nextTick%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8-%E5%BA%95%E5%B1%82%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0"><span class="toc-text">26.Vue中的$nextTick有什么作用?底层如何实现?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#27-v-show%E5%92%8Cv-if%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">27.v-show和v-if有什么区别?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#28-%E6%9C%89%E7%94%A8%E8%BF%87keep-alive%E5%90%97-%E5%AE%83%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8"><span class="toc-text">28.有用过keep-alive吗? 它有什么作用?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#29-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%99%9A%E6%8B%9FDOM%E5%90%97"><span class="toc-text">29.如何实现一个虚拟DOM吗?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#30-%E4%B8%BA%E4%BB%80%E4%B9%88data%E5%B1%9E%E6%80%A7%E6%98%AF%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E8%80%8C%E4%B8%8D%E6%98%AF%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%EF%BC%8C-%E5%85%B7%E4%BD%93%E5%8E%9F%E5%9B%A0%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">30.为什么data属性是一个函数而不是一个对象， 具体原因是什么?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#31-Vue2%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B%E4%BD%A0%E6%9C%89%E8%BF%87%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%8C%E5%81%9A%E4%BA%86%E5%93%AA%E4%BA%9B%E4%BA%8B%E6%83%85"><span class="toc-text">31.Vue2的初始化过程你有过了解吗，做了哪些事情?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#32-Vue3%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E4%B8%80%E4%B8%AA%E5%A4%A7%E6%A6%82%E6%B5%81%E7%A8%8B"><span class="toc-text">32.Vue3初始化的一个大概流程?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#33-vue3%E5%93%8D%E5%BA%94%E5%BC%8Fapi%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99"><span class="toc-text">33.vue3响应式api如何编写?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#34-%E5%9C%A8Vue%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%A0%E6%98%AF%E5%A6%82%E4%BD%95%E5%81%9A%E7%9A%84SSR%E6%B8%B2%E6%9F%93"><span class="toc-text">34.在Vue项目中你是如何做的SSR渲染?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#35-%E5%9C%A8vue%E4%B8%AD%E6%80%8E%E4%B9%88%E7%A1%AE%E5%AE%9A%E5%BC%95%E5%85%A5%E7%9A%84%E6%96%B9%E6%B3%95%E6%88%96%E5%BA%93%E9%9C%80%E8%A6%81%E5%8A%A0"><span class="toc-text">35.在vue中怎么确定引入的方法或库需要加{}</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6"><span class="toc-text">常用框架</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Echarts"><span class="toc-text">Echarts</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-echarts-%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-text">1.echarts 的基本用法?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%A6%82%E4%BD%95%E5%9C%A8vue%E4%B8%AD%E5%BC%95%E5%85%A5"><span class="toc-text">2.如何在vue中引入?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%A6%82%E4%BD%95%E7%BB%98%E5%88%B6%E6%9D%A1%E5%BD%A2%E5%9B%BE"><span class="toc-text">3.如何绘制条形图?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%88%87%E6%8D%A2%E6%97%B6%E5%8D%A1%E9%A1%BF%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3"><span class="toc-text">4.切换时卡顿如何解决?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-echarts%E5%9B%BE%E8%A1%A8%E8%87%AA%E9%80%82%E5%BA%94div-resize%E9%97%AE%E9%A2%98"><span class="toc-text">5.echarts图表自适应div resize问题?</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C"><span class="toc-text">计算机网络</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AFAjax-Ajax-%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%98%E7%82%B9%E5%92%8C%E7%BC%BA%E7%82%B9"><span class="toc-text">1.什么是Ajax, Ajax 都有哪些优点和缺点?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%AF%B7%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8BXMLHTTPrequest%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E5%92%8C%E5%B1%9E%E6%80%A7"><span class="toc-text">2.请介绍一下XMLHTTPrequest对象及常用方法和属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Ajax-%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%B5%81%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84"><span class="toc-text">3.Ajax 的实现流程是怎样的?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Ajax-%E6%8E%A5%E6%94%B6%E5%88%B0%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%8C%E6%95%B0%E6%8D%AE%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86"><span class="toc-text">4.Ajax 接收到的数据类型有哪些，数据如何处理?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%B0%81%E8%A3%85%E5%A5%BD%E7%9A%84Ajax%E9%87%8C%E7%9A%84%E5%B8%B8%E8%A7%81%E5%8F%82%E6%95%B0%E5%8F%8A%E5%85%B6%E4%BB%A3%E8%A1%A8%E7%9A%84%E5%90%AB%E4%B9%89"><span class="toc-text">5.封装好的Ajax里的常见参数及其代表的含义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-Ajax%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%8F%8A%E9%80%82%E7%94%A8%E5%92%8C%E4%B8%8D%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">6.Ajax注意事项及适用和不适用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-HTTP%E7%8A%B6%E6%80%81%E7%A0%81%E4%BB%A5%E5%8F%8A%E4%BB%A3%E8%A1%A8%E7%9A%84%E6%84%8F%E4%B9%89"><span class="toc-text">7.HTTP状态码以及代表的意义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-301-302-303%E7%8A%B6%E6%80%81%E7%A0%81%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">8.301 302 303状态码的区别?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-%E4%BB%80%E4%B9%88%E6%98%AF%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5"><span class="toc-text">9.什么是同源策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89%E8%B7%A8%E5%9F%9F%E7%9A%84%E9%97%AE%E9%A2%98%E5%87%BA%E7%8E%B0%EF%BC%8C%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98"><span class="toc-text">10.为什么会有跨域的问题出现，如何解决跨域问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-Get-%E5%92%8CPost%E7%9A%84%E5%8C%BA%E5%88%AB%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">11.Get 和Post的区别以及使用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-%E8%A7%A3%E9%87%8Ajsonp%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-text">12.解释jsonp的原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-HTTP%E4%B8%8EHTTPS%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">13.HTTP与HTTPS的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-%E7%AE%80%E8%BF%B0web%E5%89%8D%E7%AB%AFCookie%E6%9C%BA%E5%88%B6%EF%BC%8C%E5%B9%B6%E7%BB%93%E5%90%88%E8%AF%A5%E6%9C%BA%E5%88%B6%E8%AF%B4%E6%98%8E%E4%BC%9A%E8%AF%9D%E4%BF%9D%E6%8C%81%E5%8E%9F%E7%90%86"><span class="toc-text">14.简述web前端Cookie机制，并结合该机制说明会话保持原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15-%E4%BD%A0%E7%9F%A5%E9%81%93%E7%9A%84HTTP%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F%E6%9C%89%E5%87%A0%E7%A7%8D"><span class="toc-text">15.你知道的HTTP请求方式有几种</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-%E8%B0%88%E8%B0%88%E4%BD%A0%E7%90%86%E8%A7%A3%E7%9A%84RESTFUL%E8%A7%84%E8%8C%83"><span class="toc-text">16.谈谈你理解的RESTFUL规范</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#17-%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E5%85%B7%E4%BD%93%E6%B5%81%E7%A8%8B%E3%80%82%E5%8F%98%E4%B8%BA%E4%BA%8C%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="toc-text">17.解释一下三次握手是什么，具体流程。变为二次握手会发生什么问题?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#18-TCP%E5%92%8CUDP%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">18.TCP和UDP分别是什么?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#19-WebSocket%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%92%8C%E5%BA%94%E7%94%A8%E3%80%82"><span class="toc-text">19.WebSocket的实现和应用。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#20-%E4%B8%80%E4%B8%AA%E5%9B%BE%E7%89%87url-%E8%AE%BF%E9%97%AE%E5%90%8E%E7%9B%B4%E6%8E%A5%E4%B8%8B%E8%BD%BD%E6%80%8E%E6%A0%B7%E5%AE%9E%E7%8E%B0"><span class="toc-text">20.一个图片url 访问后直接下载怎样实现?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#21-%E8%AF%B4%E4%B8%80%E4%B8%8Bhttp2-0"><span class="toc-text">21.说一下http2.0</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#22-%E8%A1%A5%E5%85%85400%E5%92%8C401%E3%80%81403-%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-text">22.补充400和401、403 状态码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#23-fetch%E5%8F%91%E9%80%812%E6%AC%A1%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-text">23.fetch发送2次请求的原因</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#24-%E5%AF%B9HTML%E8%AF%AD%E4%B9%89%E5%8C%96%E6%A0%87%E7%AD%BE%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">24.对HTML语义化标签的理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#25-Cookie-%E5%92%8Csession%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">25.Cookie 和session的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#26-%E5%BC%BA%E7%BC%93%E5%AD%98%E5%92%8C%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98%E5%8C%BA%E5%88%AB-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%E5%93%AA%E4%B8%AA-%E6%9C%AC%E8%B4%A8%E6%98%AF"><span class="toc-text">26.强缓存和协商缓存区别?什么时候用哪个?本质是?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#27-cache-control-%E7%9A%84%E5%80%BC%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-text">27.cache-control 的值有哪些</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#28-%E8%B0%88%E8%B0%88304%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-text">28.谈谈304状态码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#29-%E4%BB%80%E4%B9%88%E6%98%AFCDN-%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96"><span class="toc-text">29.什么是CDN,以及如何优化?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#30-DNS%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">30.DNS是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#31-%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%9B%E5%B1%82%E3%80%81%E4%B8%83%E5%B1%82%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B"><span class="toc-text">31.什么是四层、七层网络模型?</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8"><span class="toc-text">网络安全</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AFxss%E6%94%BB%E5%87%BB%E5%8F%8A%E5%A6%82%E4%BD%95%E9%98%B2%E8%8C%83"><span class="toc-text">1.什么是xss攻击及如何防范</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BB%80%E4%B9%88%E6%98%AFddos%E6%94%BB%E5%87%BB%E5%8F%8A%E5%A6%82%E4%BD%95%E9%98%B2%E8%8C%83"><span class="toc-text">2.什么是ddos攻击及如何防范?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BB%80%E4%B9%88%E6%98%AFcsrf%E6%94%BB%E5%87%BB%E5%8F%8A%E5%A6%82%E4%BD%95%E9%98%B2%E8%8C%83"><span class="toc-text">3.什么是csrf攻击及如何防范?</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96"><span class="toc-text">前端工程化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96%E3%80%81%E5%89%8D%E7%AB%AF%E7%BB%84%E4%BB%B6%E5%8C%96%EF%BC%8C%E4%BA%8C%E8%80%85%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB"><span class="toc-text">1.如何理解前端模块化、前端组件化，二者有何区别?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB"><span class="toc-text">2.如何理解前后端分离?</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#webpack"><span class="toc-text">webpack</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%9C%89%E8%87%AA%E5%B7%B1%E9%85%8D%E7%BD%AE%E8%BF%87webpack%E5%90%97-%E5%A6%82%E6%9E%9C%E9%9C%80%E6%B1%82%E6%98%AF%E5%A4%9A%E9%A1%B5%E9%9D%A2%E4%B8%8E%E5%8D%95%E9%A1%B5%E9%9D%A2%E5%B9%B6%E8%A1%8C%EF%BC%8C%E9%9C%80%E8%A6%81%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE"><span class="toc-text">3.有自己配置过webpack吗?如果需求是多页面与单页面并行，需要如何配置?</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%85%8D%E7%BD%AEWebpack%E6%94%AF%E6%8C%81%E5%A4%9A%E9%A1%B5%E9%9D%A2%E5%92%8C%E5%8D%95%E9%A1%B5%E9%9D%A2%E5%B9%B6%E8%A1%8C%EF%BC%9A"><span class="toc-text">配置Webpack支持多页面和单页面并行：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Webpack%E7%9A%84%E4%BC%98%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">4.Webpack的优点是什么?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-Webpack%E7%9A%84%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88-%E4%BB%8E%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE%E5%88%B0%E8%BE%93%E5%87%BA%E6%96%87%E4%BB%B6%E8%BF%99%E4%B8%AA%E8%BF%87%E7%A8%8B%E5%B0%BD%E9%87%8F%E8%AF%B4%E5%85%A8"><span class="toc-text">5.Webpack的构建流程是什么?从读取配置到输出文件这个过程尽量说全</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E8%AF%B4%E4%B8%80%E4%B8%8BWebpack%E7%9A%84%E7%83%AD%E6%9B%B4%E6%96%B0%E5%8E%9F%E7%90%86"><span class="toc-text">6.说一下Webpack的热更新原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9A%84Loader-%E4%BB%96%E4%BB%AC%E6%98%AF%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%E7%9A%84"><span class="toc-text">7.有哪些常见的Loader?他们是解决什么问题的?</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/archives/5205ee75.html" title="面试题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://w.wallhaven.cc/full/2y/wallhaven-2yz3m9.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="面试题"/></a><div class="content"><a class="title" href="/archives/5205ee75.html" title="面试题">面试题</a><time datetime="2023-05-09T16:00:00.000Z" title="发表于 2023-05-10 00:00:00">2023-05-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/archives/ef9ebb65.html" title="小程序开发实战"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://w.wallhaven.cc/full/2y/wallhaven-2yz3m9.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="小程序开发实战"/></a><div class="content"><a class="title" href="/archives/ef9ebb65.html" title="小程序开发实战">小程序开发实战</a><time datetime="2023-01-31T16:00:00.000Z" title="发表于 2023-02-01 00:00:00">2023-02-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/archives/f8e09374.html" title="Vue"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://w.wallhaven.cc/full/2y/wallhaven-2yz3m9.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Vue"/></a><div class="content"><a class="title" href="/archives/f8e09374.html" title="Vue">Vue</a><time datetime="2022-12-09T16:00:00.000Z" title="发表于 2022-12-10 00:00:00">2022-12-10</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://w.wallhaven.cc/full/2y/wallhaven-2yz3m9.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By awzz-coder</div><div class="footer_custom_text">Hi, welcome to my <a target="_blank" rel="noopener external nofollow noreferrer" href="https://butterfly.js.org/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>function loadLivere () {
  if (typeof LivereTower === 'object') {
    window.LivereTower.init()
  }
  else {
    (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
    })(document, 'script');
  }
}

if ('Livere' === 'Livere' || !false) {
  if (false) btf.loadComment(document.getElementById('lv-container'), loadLivere)
  else loadLivere()
}
else {
  function loadOtherComment () {
    loadLivere()
  }
}</script></div><div class="aplayer no-destroy" data-id="7487493788" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="true"> </div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></body></html>
<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>JavaScript基础 | awzz博客</title><meta name="author" content="awzz-coder"><meta name="copyright" content="awzz-coder"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="JavaScript基础语法-数据结构-DOM操作-BOM操作">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaScript基础">
<meta property="og:url" content="https://awzz-coder.github.io/archives/4b0178e0.html">
<meta property="og:site_name" content="awzz博客">
<meta property="og:description" content="JavaScript基础语法-数据结构-DOM操作-BOM操作">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://awzz-coder.github.io/img/default.jpg">
<meta property="article:published_time" content="2022-06-22T16:00:00.000Z">
<meta property="article:modified_time" content="2023-04-08T15:28:04.390Z">
<meta property="article:author" content="awzz-coder">
<meta property="article:tag" content="IT前端">
<meta property="article:tag" content="JavaScript">
<meta property="article:tag" content="DOM">
<meta property="article:tag" content="BOM">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://awzz-coder.github.io/img/default.jpg"><link rel="shortcut icon" href="/img/site_logo.ico"><link rel="canonical" href="https://awzz-coder.github.io/archives/4b0178e0.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><meta name="baidu-site-verification" content="codeva-1kLiQ63o8L"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":3000,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":100},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JavaScript基础',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-04-08 23:28:04'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./img/avatar.jpeg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-graduation-cap"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-people-robbery"></i><span> 教程</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/teach/"><i class="fa-fw fas fa-comments-o"></i><span> 简介</span></a></li><li><a class="site-page child" href="/teach/"><i class="fa-fw fas fa-voicemail"></i><span> 基础</span></a></li><li><a class="site-page child" href="/teach/"><i class="fa-fw fas fa-scale-unbalanced"></i><span> 进阶</span></a></li><li><a class="site-page child" href="/teach/"><i class="fa-fw fas fa-stethoscope"></i><span> 总结</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-heart"></i><span> 娱乐</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/games/"><i class="fa-fw fas fa-heart"></i><span> 游戏</span></a></li><li><a class="site-page child" href="/cartoon/"><i class="fa-fw fas fa-heart"></i><span> 漫画</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa-heart"></i><span> 书籍</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/photo/"><i class="fa-fw fas fa-image"></i><span> 壁纸</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-toolbox"></i><span> 工具</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/seek/"><i class="fa-fw fas fa-circle-nodes"></i><span> 查询类</span></a></li><li><a class="site-page child" href="/online/"><i class="fa-fw fas fa-heart"></i><span> 在线版</span></a></li><li><a class="site-page child" href="/tools/"><i class="fa-fw fas fa-heart"></i><span> 工具类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-comments"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-list"></i><span> 其他</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-circle-info"></i><span> 关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/./img/default.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="awzz博客"><span class="site-name">awzz博客</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-graduation-cap"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-people-robbery"></i><span> 教程</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/teach/"><i class="fa-fw fas fa-comments-o"></i><span> 简介</span></a></li><li><a class="site-page child" href="/teach/"><i class="fa-fw fas fa-voicemail"></i><span> 基础</span></a></li><li><a class="site-page child" href="/teach/"><i class="fa-fw fas fa-scale-unbalanced"></i><span> 进阶</span></a></li><li><a class="site-page child" href="/teach/"><i class="fa-fw fas fa-stethoscope"></i><span> 总结</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-heart"></i><span> 娱乐</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/games/"><i class="fa-fw fas fa-heart"></i><span> 游戏</span></a></li><li><a class="site-page child" href="/cartoon/"><i class="fa-fw fas fa-heart"></i><span> 漫画</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa-heart"></i><span> 书籍</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/photo/"><i class="fa-fw fas fa-image"></i><span> 壁纸</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-toolbox"></i><span> 工具</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/seek/"><i class="fa-fw fas fa-circle-nodes"></i><span> 查询类</span></a></li><li><a class="site-page child" href="/online/"><i class="fa-fw fas fa-heart"></i><span> 在线版</span></a></li><li><a class="site-page child" href="/tools/"><i class="fa-fw fas fa-heart"></i><span> 工具类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-comments"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-list"></i><span> 其他</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-circle-info"></i><span> 关于</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">JavaScript基础</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-06-22T16:00:00.000Z" title="发表于 2022-06-23 00:00:00">2022-06-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-04-08T15:28:04.390Z" title="更新于 2023-04-08 23:28:04">2023-04-08</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/">前端知识</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">21.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>71分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><h2 id="1-邂逅JavaScript"><a href="#1-邂逅JavaScript" class="headerlink" title="1.邂逅JavaScript"></a>1.邂逅JavaScript</h2><h3 id="1、认识编程语言"><a href="#1、认识编程语言" class="headerlink" title="1、认识编程语言"></a>1、认识编程语言</h3><p>计算机语言就是我们人和计算机进行交流要学习的语言</p>
<p>HTML：标记语言；CSS：样式语言；都属于计算机语言</p>
<p>JavaScript也是计算机语言，更精确来说是一门编程语言</p>
<p><strong>计算机语言：</strong>人与计算机之间通讯的语言，是人与计算机之间传递信息的介质，其概念比通用的编程语言要更广泛；</p>
<p><strong>编程语言</strong>：用来定义计算机程序的形式语言。它是一种被标准化的交流技巧，用来向计算机发出指令，一种能让程序员准确定义计算机所需使用数据的计算机语言，并准确的定义在不同情况下所应采取的行动。</p>
<p><strong>编程语言特点</strong>：</p>
<ul>
<li>数据和数据结构</li>
<li>指令及流程控制</li>
<li>引用机制和重用机制</li>
<li>设计哲学</li>
</ul>
<h3 id="2、编程语言发展史"><a href="#2、编程语言发展史" class="headerlink" title="2、编程语言发展史"></a>2、编程语言发展史</h3><p><strong>阶段一：</strong>机器语言，只由0和1组成 </p>
<p><strong>阶段二：</strong>汇编语言，用符号来代替冗长的、难以记忆的0和1代码，经过汇编器转化为0和1</p>
<p><strong>阶段三：</strong>高级语言，接近自然语言，更符合人类的思维方式</p>
<h3 id="3、JavaScript的历史"><a href="#3、JavaScript的历史" class="headerlink" title="3、JavaScript的历史"></a>3、JavaScript的历史</h3><p>javascript是一门高级的、解释型的编程语言</p>
<p>是一门基于原型的、头等函数的语言，是一门多范式的语言，支持面向对象程序设计、指令式编程、以及函数式编程</p>
<p>94年网景公司发布navigator浏览器0.9版，但是只能用于浏览，不具备与用户的交互能力。</p>
<p>95年招募Brendan Eich，希望将scheme语言作为网页脚本语言的可能性</p>
<p>同时，sun公司将oak语言更名为Java，管理层倾向于java，希望能简化java来适应脚本的需求</p>
<p>brendan eich不感兴趣并且用了十天设计了js，最初叫做mocha，在navigator2.0 beta更名为livescript，在navigator3.0beta 3 改名为javascript，为了搭上java热度</p>
<p>95年微软首推IE，并对navigator进行逆向发明了jscript</p>
<p>96.11月，网景正式向ECMA提交了语言规范</p>
<ul>
<li>97.6月，ECMA为javascript制定了ECMAScript标准规范</li>
</ul>
<p>所以，ecmascript是一种规范，而javascript是这种规范的一种实现</p>
<h3 id="4、JavaScript的组成"><a href="#4、JavaScript的组成" class="headerlink" title="4、JavaScript的组成"></a>4、JavaScript的组成</h3><p>定义语言规范：ECMAScript</p>
<p>DOM：用于操作文档的API</p>
<p>BOM：用于操作浏览器的API</p>
<h3 id="5、JavaScript运行引擎"><a href="#5、JavaScript运行引擎" class="headerlink" title="5、JavaScript运行引擎"></a>5、JavaScript运行引擎</h3><p>常见的js引擎：</p>
<ul>
<li>javascriptCore：webkit中的js引擎，apple公司开发</li>
<li>v8：Goole开发的强大的js引擎</li>
</ul>
<p>浏览器内核与js引擎的关系</p>
<p>webkit为例：</p>
<ul>
<li>webcore：负责html的解析、布局、渲染等相关工作（渲染层）</li>
<li>javascriptcore：解析、执行js代码（逻辑层）</li>
</ul>
<h3 id="6、JavaScript应用场景"><a href="#6、JavaScript应用场景" class="headerlink" title="6、JavaScript应用场景"></a>6、JavaScript应用场景</h3><p>web开发、移动端开发、小程序端开发、桌面应用开发、后端开发</p>
<h2 id="2-JavaScript的基本语法"><a href="#2-JavaScript的基本语法" class="headerlink" title="2.JavaScript的基本语法"></a>2.JavaScript的基本语法</h2><h3 id="1、javascript编写方式"><a href="#1、javascript编写方式" class="headerlink" title="1、javascript编写方式"></a>1、javascript编写方式</h3><ul>
<li>HTML代码内</li>
<li>script标签内</li>
<li>外部的js文件</li>
</ul>
<h3 id="2、noscript元素的使用"><a href="#2、noscript元素的使用" class="headerlink" title="2、noscript元素的使用"></a>2、noscript元素的使用</h3><p>如果运行的浏览器不支持js，需要一直优雅的处理方式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;noscript&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>您的浏览器不支持js<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">&lt;/noscript&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">alert</span>(<span class="string">&#x27;您的浏览器正在运行js代码&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>



<h3 id="3、javascript注意事项"><a href="#3、javascript注意事项" class="headerlink" title="3、javascript注意事项"></a>3、javascript注意事项</h3><ul>
<li>script元素不能写成单标签，在外联引用js文件时，script标签内不能编写js代码</li>
<li>省略type属性，以前的script标签中：type&#x3D;”text&#x2F;javascrpit”</li>
<li>加载顺序：自上而下，推荐放在body子元素的最后一行</li>
<li>js代码严格区分大小写</li>
</ul>
<h3 id="4、javascript交互方式"><a href="#4、javascript交互方式" class="headerlink" title="4、javascript交互方式"></a>4、javascript交互方式</h3><p>alert：接受一个参数，弹窗查看</p>
<p>console.log：接收多个参数，在浏览器控制台查看</p>
<p>document.write：接受多个字符串，在浏览器页面查看</p>
<p>prompt：接受一个参数，在浏览器接受用户输入</p>
<ul>
<li>代码出错可以再控制台console查看</li>
<li>控制台 &gt; 可以直接编写js代码，回车执行代码，shift+enter可以写多行代码</li>
<li>debug进行调试，查看代码的执行流程</li>
</ul>
<h3 id="5、javascript语句和分号"><a href="#5、javascript语句和分号" class="headerlink" title="5、javascript语句和分号"></a>5、javascript语句和分号</h3><p>语句是向浏览器发出的指令，通常表达为一个操作或行为</p>
<p>通常情况下每条语句的后面会添一个分号，表示语句的结束：</p>
<ul>
<li>当存在换行符时，在大多数情况下可以省略分号</li>
<li>js将换行理解为”隐式”分号</li>
<li>也称之为自动插入分号</li>
</ul>
<p>注释方式：&#x2F;*  … *&#x2F;：多行注释      &#x2F;&#x2F;：单行注释</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">文档注释  <span class="comment">// js文件中</span></span><br><span class="line"><span class="comment">/**.....*/</span></span><br></pre></td></tr></table></figure>

<p>Js中不支持注释的嵌套</p>
<p>插件：</p>
<p>log快速：react：clg</p>
<p>括号范围：bracket pair colorizer，里面配置设置.json</p>
<h2 id="3-JavaScript的变量和数据结构"><a href="#3-JavaScript的变量和数据结构" class="headerlink" title="3.JavaScript的变量和数据结构"></a>3.JavaScript的变量和数据结构</h2><h3 id="1、认识JavaScript变量"><a href="#1、认识JavaScript变量" class="headerlink" title="1、认识JavaScript变量"></a>1、认识JavaScript变量</h3><p>程序中变量的数据：</p>
<ul>
<li>购物车商品的数量、价格</li>
<li>游戏技能时间的冷却、血量</li>
</ul>
<h4 id="1-变化数据的记录—变量"><a href="#1-变化数据的记录—变量" class="headerlink" title="1.变化数据的记录—变量"></a>1.变化数据的记录—变量</h4><ul>
<li>一个变量就是用于存放数值的容器</li>
<li>这个数字可能是一个用于计算的数字，或字符串，或其他的任意数据</li>
<li>变量的独特之处在于它存放的数量是可以改变的</li>
</ul>
<p>可以把变量看做一个盒子，盒子里面装着我们的数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var message = &#x27;hello&#x27;</span><br><span class="line">message = &#x27;why&#x27;</span><br></pre></td></tr></table></figure>



<h4 id="2-变量的命名格式"><a href="#2-变量的命名格式" class="headerlink" title="2.变量的命名格式"></a>2.变量的命名格式</h4><p>定义一个变量包含两部分</p>
<ul>
<li>变量的声明：告诉js引擎接下来我要定一个变量</li>
<li>变量的赋值：使用  &#x3D;  给变量进行赋值</li>
</ul>
<p>可以同时声明多个变量</p>
<h3 id="2、变量的定义、规范"><a href="#2、变量的定义、规范" class="headerlink" title="2、变量的定义、规范"></a>2、变量的定义、规范</h3><p><strong>变量命名规则：</strong>必须遵守</p>
<ul>
<li>第一个字符必须是一个英文字母、下划线（_）、$符号</li>
<li>其他字符可以是字母、下划线、美元符号或数字</li>
<li>不能使用关键字和保留字命名</li>
<li>变量严格区分大小写</li>
</ul>
<p><strong>规范：</strong></p>
<ul>
<li>多个单词，驼峰命名法</li>
<li>推荐等号两边添加一个空格，结构清晰</li>
<li>语句结束加上分号</li>
<li>变量名字尽量见名知意</li>
</ul>
<p>如果变量未声明就使用，会直接报错  not defined</p>
<p>如果一个变量有声明但是没有赋值，会打印undefined</p>
<p>在js中也可以不使用var在全局声明一个变量（不推荐），如果不使用var来声明一个变量，也是可以声明成功的，而且这个变量会被加入到window对象中</p>
<h3 id="3、数据类型和typeof"><a href="#3、数据类型和typeof" class="headerlink" title="3、数据类型和typeof"></a>3、数据类型和typeof</h3><p>js中的值都有特定的类型，将值赋值给一个变量，那这么变量就具备了特定的类型</p>
<p>一个变量可以在前一刻是个字符串，下一刻就存储一个数字</p>
<p>允许这种操作的编程语言，比如js，称之为动态类型的编程语言</p>
<p>在js中有八种基本的数据类型（7中原始类型和一种复杂类型）</p>
<ul>
<li>Number（包括小数）</li>
<li>String</li>
<li>Boolean</li>
<li>Undefined</li>
<li>Null</li>
<li>Object</li>
<li>Bigint</li>
<li>Symbol</li>
</ul>
<p>因为ECMAScript的类型系统是松散的，所以需要一种手段来确定任意变量的数据类型</p>
<p>typeof应运而生，返回值：</p>
<p>“undefined”表示值未定义；</p>
<p>“boolean”表示值为布尔值；</p>
<p>“string”表示值为字符串；</p>
<p>“number”表示值为数值；</p>
<p>“object”表示值为对象（而不是函数）或null；</p>
<p>“function”表示值为函数；</p>
<p>“symbol”表示值为符号；</p>
<p>typeof(x)  它与typeof x 相同</p>
<p>typeof是一个操作符，它并非是一个函数，()只是将后续的内容当作一个整体而已</p>
<h3 id="4、常见的数据类型"><a href="#4、常见的数据类型" class="headerlink" title="4、常见的数据类型"></a>4、常见的数据类型</h3><h4 id="number类型"><a href="#number类型" class="headerlink" title="number类型"></a>number类型</h4><p>代表整数和浮点数，可以进行加减乘除，除了常规的数字，还包括特殊数值也属于number类型</p>
<ul>
<li>Infinity：代表无穷大，负无穷大：1&#x2F;0</li>
<li>NaN：代表一个计算错误，比如数字乘字符串</li>
</ul>
<p>最大的数字：Number.MAX_VALUE</p>
<p>最小的数字：Number.MIN_VALUE，小于这个数字会被转化为0</p>
<p>isNaN()来判断一个数字是不是数字，不是数字返回true</p>
<h4 id="string类型：字符串类型"><a href="#string类型：字符串类型" class="headerlink" title="string类型：字符串类型"></a>string类型：字符串类型</h4><p>在开发中我们经常会有一些文本需要表示，这个时候我们会使用字符串String：</p>
<ul>
<li>比如人的姓名：coderwhy。地址：广州市。简介：认真是一种可怕的力量</li>
</ul>
<p>JavaScript 中的字符串必须被括在引号里，有三种包含字符串的方式</p>
<ul>
<li><p>双引号：”Hello”</p>
</li>
<li><p>单引号：’Hello’</p>
</li>
<li><p>反引号：<code>Hello</code></p>
</li>
</ul>
<p>前后的引号类型必须一致：</p>
<ul>
<li><p>如果在字符串里面本身包括单引号，可以使用双引号</p>
</li>
<li><p>如果在字符串里面本身包括双引号，可以使用单引号</p>
</li>
</ul>
<p>引号：单引号、双引号、反引号（支持${表达式&#x2F;变量}）</p>
<p>前后的引号必须一致</p>
<p>转义字符：除了普通可打印的字符，一些特殊的字符可以通过转义字符的形式放在字符串中</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230227141333739.png" alt="image-20230227141333739"></p>
<p>字符串的操作：</p>
<ul>
<li>字符串拼接（+）</li>
<li>获取字符串长度（.length）</li>
</ul>
<h4 id="Boolean类型：用于表示真假"><a href="#Boolean类型：用于表示真假" class="headerlink" title="Boolean类型：用于表示真假"></a>Boolean类型：用于表示真假</h4><p>包含两个值：true；false</p>
<h4 id="Undefined类型"><a href="#Undefined类型" class="headerlink" title="Undefined类型"></a>Undefined类型</h4><p>只有一个值，undefined：声明了变量未赋值（未进行初始化）</p>
<ul>
<li>定义变量时候最好进行赋值，而不是只是声明</li>
<li>不要显示的将一个变量赋值为undefined<ul>
<li>可以初始化为0\null\空字符串等值</li>
</ul>
</li>
</ul>
<h4 id="Object类型"><a href="#Object类型" class="headerlink" title="Object类型"></a>Object类型</h4><p>是一个特殊的类型，通常称之为引用类型或者复杂类型</p>
<p>其他的数据类型我们称之为原始类型，因为它们的值只包含一个单独的内容</p>
<p>Object往往可以表示一组数据，是其他数据的一个集合，用{}表示一个对象</p>
<h4 id="Null类型"><a href="#Null类型" class="headerlink" title="Null类型"></a>Null类型</h4><p>只有一个值：null</p>
<p>通常用来表示一个对象为空，所以我们通常再给一个对象进行初始化时，会赋值为null</p>
<p>typeof识别为object</p>
<p>null与undefined的关系：</p>
<ul>
<li>undefined通常只有在一个变量声明但是未初始化时，默认为undefined才使用</li>
<li>并且我们不推荐给一个变量直接赋值为undefined，所以很少使用</li>
<li>null值非常常用，当一个变量准备保存一个对象，但是这个对象不确定时，可以先赋值为null</li>
</ul>
<h4 id="数据类型总结"><a href="#数据类型总结" class="headerlink" title="数据类型总结"></a>数据类型总结</h4><p>JavaScript 中有八种基本的数据类型（前七种为基本数据类型，也称为原始类型，而 object 为复杂数据类型，也称为引用类型）</p>
<ul>
<li>number 用于任何类型的数字：整数或浮点数</li>
<li>string 用于字符串：一个字符串可以包含 0 个或多个字符，所以没有单独的单字符类型</li>
<li>boolean 用于 true 和 false</li>
<li>undefined 用于未定义的值 —— 只有一个 undefined 值的独立类型</li>
<li>object 用于更复杂的数据结构</li>
<li>null 用于未知的值 —— 只有一个 null 值的独立类型</li>
<li>symbol 用于唯一的标识符</li>
<li>bigint 用于任意长度的整数。</li>
</ul>
<h3 id="5、数据类型的转换"><a href="#5、数据类型的转换" class="headerlink" title="5、数据类型的转换"></a>5、数据类型的转换</h3><p>在大多数情况下，运算符和函数会自动将赋予它们的值转换为正确的类型，这是一种隐式转换</p>
<p>我们也可通过显式的方式来对数据进行类型转换</p>
<h4 id="1-字符串String的转换"><a href="#1-字符串String的转换" class="headerlink" title="1.字符串String的转换"></a>1.字符串String的转换</h4><p>方式1：隐式转换</p>
<ul>
<li>一个字符串和其他类型进行+操作<ul>
<li>+运算符左右两边有一个是字符串，那么另一边会自动转换为字符串再进行拼接操作</li>
</ul>
</li>
<li>某些函数的执行也会自动将参数转为字符串类型<ul>
<li>比如log函数</li>
</ul>
</li>
</ul>
<p>方式2：显式转换</p>
<ul>
<li>调用String()函数</li>
<li>调用toString方法</li>
</ul>
<h4 id="2-数字类型Number的转换"><a href="#2-数字类型Number的转换" class="headerlink" title="2.数字类型Number的转换"></a>2.数字类型Number的转换</h4><p>方式1：隐式转换</p>
<ul>
<li>在算数运算中，通常会将其他类型转换为数字类型来进行计算<ul>
<li>比如：“6”&#x2F;“2”</li>
<li>但是如果是+运算，并且其中一边有字符串，那么还是按照字符串来连接的</li>
</ul>
</li>
</ul>
<p>方式2：显示转换</p>
<ul>
<li>Numbe() 函数</li>
</ul>
<h5 id="其他类型转换数字的规则"><a href="#其他类型转换数字的规则" class="headerlink" title="其他类型转换数字的规则"></a>其他类型转换数字的规则</h5><p>undefined—&gt;NaN</p>
<p>null—&gt;0</p>
<p>true和false—&gt;1and0</p>
<p>string—&gt;去掉首尾空格后的纯数字字符串中含有的数字；如果剩余字符串为空，则转换为0；否则，将会从剩余字符串中“读取”数字；当类型转换出现error时返回NaN</p>
<h4 id="3-布尔类型Boolean的转换"><a href="#3-布尔类型Boolean的转换" class="headerlink" title="3.布尔类型Boolean的转换"></a>3.布尔类型Boolean的转换</h4><p> 隐式转换的规则：</p>
<p>1.直观上为空的值转换成boolean类型都是false</p>
<ul>
<li><p>直观上空的值：0&#x2F;“”&#x2F;undefined&#x2F;null&#x2F;NaN -&gt; false</p>
</li>
<li><p>其他值：true</p>
</li>
</ul>
<p>2.显示转换</p>
<ul>
<li>Boolean()</li>
</ul>
<p>包含0的字符串转化是true</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Boolean</span>(<span class="string">&quot;&quot;</span>));  <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Boolean</span>(<span class="string">&quot;0&quot;</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>



<h2 id="4-JavaScript基础运算符"><a href="#4-JavaScript基础运算符" class="headerlink" title="4.JavaScript基础运算符"></a>4.JavaScript基础运算符</h2><h3 id="1、运算符和运算元"><a href="#1、运算符和运算元" class="headerlink" title="1、运算符和运算元"></a>1、运算符和运算元</h3><p>认识运算符（operators）：加（+）、减（-）、乘（*）、除（&#x2F;）</p>
<p>运算元：运算符应用的对象</p>
<ul>
<li>5*2: 5 和 2 就是运算元</li>
</ul>
<p>如果一个运算符对应的只有一个运算元，那么它是一元运算符</p>
<ul>
<li>-10</li>
</ul>
<p>如果一个运算符拥有两个运算元，那么就是二元运算符</p>
<h3 id="2、算术运算符"><a href="#2、算术运算符" class="headerlink" title="2、算术运算符"></a>2、算术运算符</h3><p>用在数学表达式中，与数学方法一致</p>
<p>算术运算符是对数据进行计算的符号</p>
<p>Math.pow(2,3)  表示 2 的3次幂（es6）；   **  也是幂（es7）</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230405151813539.png" alt="image-20230405151813539"></p>
<h3 id="3、赋值运算符"><a href="#3、赋值运算符" class="headerlink" title="3、赋值运算符"></a>3、赋值运算符</h3><p>使用的 &#x3D; 就是赋值运算符</p>
<p>语句 x &#x3D; value 将value写入 x 然后返回 x</p>
<p>链式赋值（不推荐）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 = num2 = num3 = <span class="number">321</span></span><br></pre></td></tr></table></figure>

<ul>
<li>链式赋值从右往左计算</li>
<li>所有的变量共享一个值</li>
</ul>
<h5 id="原地修改"><a href="#原地修改" class="headerlink" title="原地修改"></a>原地修改</h5><p>我们经常需要对变量做运算，并将新的结果存放在同一变量中</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">100</span></span><br><span class="line">num = num + <span class="number">10</span></span><br></pre></td></tr></table></figure>

<ul>
<li>可以使用 +&#x3D;  *&#x3D; 来缩写</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230227165921852.png" alt="image-20230227165921852"></p>
<p>所有的算术运算符都有简短的“修改并赋值”运算符：&#x2F;&#x3D; 和 -&#x3D; 等</p>
<h3 id="4、自增和自减"><a href="#4、自增和自减" class="headerlink" title="4、自增和自减"></a>4、自增和自减</h3><p>对一个数进行加一、减一是最常见的数学运算符之一</p>
<p>自增 ++ 将变量加一</p>
<p>自减 – 将变量减一</p>
<p>自增&#x2F;自减只能用于变量</p>
<ul>
<li>用在数值（5–）则会报错</li>
</ul>
<h5 id="和–的位置"><a href="#和–的位置" class="headerlink" title="++和–的位置"></a>++和–的位置</h5><p>独立使用的话++、–放在前后无所谓，放在后面称之为后置形式，放在前面称之为前置形式</p>
<p>都是+1，单独使用是看不到区别</p>
<p>如果我们要对变量进行自增操作时，并且需要立即使用自增后的值，那么需要使用前置形式</p>
<p>前置形式返回一个新的值，但后置返回原来的值</p>
<h3 id="5、运算符优先级"><a href="#5、运算符优先级" class="headerlink" title="5、运算符优先级"></a>5、运算符优先级</h3><p>运算符放在一起使用时会有一定的优先级</p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence</a></p>
<h3 id="6、比较运算符"><a href="#6、比较运算符" class="headerlink" title="6、比较运算符"></a>6、比较运算符</h3><p>比大小的运算符</p>
<p>大于&#x2F;小于： &gt;   &lt;</p>
<p>大于等于：&gt;&#x3D;</p>
<p>相等：&#x3D;&#x3D;</p>
<p>不相等：！&#x3D;</p>
<p>比较运算符的结果都是boolean类型</p>
<h3 id="额外知识补充"><a href="#额外知识补充" class="headerlink" title="额外知识补充"></a>额外知识补充</h3><h4 id="x3D-x3D-和-x3D-x3D-x3D-的区别"><a href="#x3D-x3D-和-x3D-x3D-x3D-的区别" class="headerlink" title="&#x3D;&#x3D;和&#x3D;&#x3D;&#x3D;的区别"></a>&#x3D;&#x3D;和&#x3D;&#x3D;&#x3D;的区别</h4><p>&#x3D;&#x3D; 普通相等运算符，在类型不相同的情况下，会将运算元先转成Number类型的值，再进行比较</p>
<p>空字符串和false也是如此，会进行隐式转换</p>
<p>null比较特殊，内存地址：0X0，应该会被当成一个对象与原生类型进行比较</p>
<p>&#x3D;&#x3D;&#x3D; 严格相等运算符，在类型不相同的情况下，直接返回false</p>
<p>不相等：!&#x3D;；  严格不相等：!&#x3D;&#x3D;</p>
<p>严格代码稍长，但是能体现代码的意图</p>
<h2 id="5-JavaScript分支语句"><a href="#5-JavaScript分支语句" class="headerlink" title="5.JavaScript分支语句"></a>5.JavaScript分支语句</h2><h3 id="1、if分支语句"><a href="#1、if分支语句" class="headerlink" title="1、if分支语句"></a>1、if分支语句</h3><p>程序的三种执行方式</p>
<ul>
<li>顺序：从上到下，顺序执行</li>
<li>分支：根据条件判断，决定执行代码的分支</li>
<li>循环：让特定代码重复执行</li>
</ul>
<p>代码块：是多行执行代码的集合，通过一个{}放在一起</p>
<ul>
<li>在开发中，一行代码很难完成某一个特定的功能，我们将这些代码放在一个代码块中</li>
</ul>
<p>在js中，我们通过流程控制语句来决定如何执行一段代码块</p>
<ul>
<li>关键字</li>
<li>分支语句、循环语句</li>
</ul>
<p>分支结构</p>
<ul>
<li>根据条件来决定代码的执行</li>
<li>也称为判断结构或选择结构</li>
<li>几乎所有的编程语言都有分支结构</li>
</ul>
<p>js常见的分支结构</p>
<ul>
<li>if分支结构<ul>
<li>单分支结构<ul>
<li>if…</li>
</ul>
</li>
<li>多分支结构<ul>
<li>if…else…</li>
<li>if…esle if…else…</li>
</ul>
</li>
</ul>
</li>
<li>switch分支结构</li>
</ul>
<p>if 单分支结构</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件判断) &#123; 执行代码块 &#125; <span class="comment">// 条件判断为true就执行代码块</span></span><br></pre></td></tr></table></figure>

<p>如果代码块中只有一行代码，那么可以省略花括号，写在一排</p>
<p>if(…)语句会计算圆括号中的表达式，并将计算结果转换为布尔值，规则同Boolean函数</p>
<h3 id="2、if…else…语句"><a href="#2、if…else…语句" class="headerlink" title="2、if…else…语句"></a>2、if…else…语句</h3><p>多分支语句，if 语句有时会包含可选的else模块</p>
<p>如果判断条件不成立，就会执行它内部的代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件成立) &#123;成立的代码块&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;不成立的代码块&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3、if…else-if…else语句"><a href="#3、if…else-if…else语句" class="headerlink" title="3、if…else if…else语句"></a>3、if…else if…else语句</h3><p>判断多个条件，可以使用 else if 实现</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件<span class="number">1</span>) &#123;代码块&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(条件<span class="number">2</span>) &#123;代码块&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;前面所有条件不成立&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4、三元运算符"><a href="#4、三元运算符" class="headerlink" title="4、三元运算符"></a>4、三元运算符</h3><p>只是用if else语句可能会导致代码臃肿</p>
<p>三元运算符通过<code>？</code>表示</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> result = condition ? value1 : value2</span><br><span class="line"><span class="keyword">var</span> result = num1 &gt; num2 ? num1 : num2  <span class="comment">// 比较大小</span></span><br></pre></td></tr></table></figure>



<h3 id="5、逻辑运算符"><a href="#5、逻辑运算符" class="headerlink" title="5、逻辑运算符"></a>5、逻辑运算符</h3><p>主要有三个：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">||(或)：一个为真   &amp;&amp;(与)：同时为真    ！(非)：取反</span><br></pre></td></tr></table></figure>

<p>可以将多个表达式或值放在一起来获取到一个最终的结果</p>
<h5 id="逻辑-的本质"><a href="#逻辑-的本质" class="headerlink" title="逻辑||的本质"></a>逻辑||的本质</h5><ul>
<li>也称之为短路或</li>
<li>从左到右依次计算操作数</li>
<li>处理每一个操作数时，都会将其转化为布尔值</li>
<li>如果结果是true，就停止计算，返回这个<strong>操作数的初始值</strong></li>
<li>如果所有操作数都被计算过(也就是，转换结果都是false)，则返回最后一个<strong>操作数</strong></li>
</ul>
<p>返回的值是操作数的初始形式，不会转换为boolean类型</p>
<p>换句话说，一个或运算的链，将返回第一个真值，如果不存在真值，就返回该链的最后一个值</p>
<h5 id="逻辑-amp-amp-的本质"><a href="#逻辑-amp-amp-的本质" class="headerlink" title="逻辑&amp;&amp;的本质"></a>逻辑&amp;&amp;的本质</h5><ul>
<li>也称之为短路与</li>
<li>从左到右依次计算操作数</li>
<li>处理每一个操作数时，都会将其转化为布尔值</li>
<li>如果结果是false，就停止计算，返回这个<strong>操作数的原始值</strong></li>
<li>如果所有操作数都被计算过(都是真值)，则返回最后一个<strong>操作数</strong></li>
</ul>
<p>换句话说，与运算返回第一个假值，如果没有假值就返回最后一个值</p>
<h5 id="逻辑非的补充"><a href="#逻辑非的补充" class="headerlink" title="逻辑非的补充"></a>逻辑非的补充</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> message = <span class="string">&#x27;hello world&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Boolean</span>(message))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(!!message)</span><br></pre></td></tr></table></figure>

<p>逻辑非运算符接受一个参数，并按如下运算：</p>
<ul>
<li><p>步骤一：将操作数转化为布尔类型：true&#x2F;false</p>
</li>
<li><p>步骤二：返回相反的值；</p>
</li>
</ul>
<p>两个非运算 !! 有时候用来将某个值转化为布尔类型</p>
<ul>
<li><p>也就是，第一个非运算将该值转化为布尔类型并取反，第二个非运算再次取反</p>
</li>
<li><p>最后我们就得到了一个任意值到布尔值的转化。</p>
</li>
</ul>
<h3 id="6、switch语句"><a href="#6、switch语句" class="headerlink" title="6、switch语句"></a>6、switch语句</h3><p>switch 是分支结构的一种语句</p>
<ul>
<li>通过判断表达式的结果（或者变量）是否等于case语句的常量，来执行相应的分支体的</li>
</ul>
<p>与if不同的是，switch语句只能做值的严格相等判断（&#x3D;&#x3D;&#x3D;），而 if 语句可以做值的范围判断</p>
<ul>
<li><p>switch语句至少一个 case 代码块和一个可选的 default 代码块</p>
</li>
<li><p>默认情况下会有 case 穿透，case语句结束后会执行下一条case语句，添加break会跳出 switch，不执行后续代码</p>
</li>
</ul>
<h2 id="6-JavaScript循环语句"><a href="#6-JavaScript循环语句" class="headerlink" title="6.JavaScript循环语句"></a>6.JavaScript循环语句</h2><h3 id="1、认识循环语句"><a href="#1、认识循环语句" class="headerlink" title="1、认识循环语句"></a>1、认识循环语句</h3><p>生活中：对一个列表进行累加、将1到10数字逐个输出等等</p>
<p>循环是一种重复运行同一代码的方法</p>
<ul>
<li>如果是对某一列表进行循环操作，我们通常称之为遍历或者迭代</li>
</ul>
<p>三种循环方式：</p>
<ul>
<li>while循环</li>
<li>do…while循环</li>
<li>for循环</li>
</ul>
<h3 id="2、while-循环"><a href="#2、while-循环" class="headerlink" title="2、while 循环"></a>2、while 循环</h3><p>当条件成立时，执行代码块</p>
<p>当条件不成立时，跳出代码块</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(循环条件) &#123;</span><br><span class="line">    <span class="comment">// 循环代码块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果条件一直成立，那么会产生死循环</p>
<ul>
<li><p>这时候必须通过关闭网页来停止死循环</p>
</li>
<li><p>开发中一定要避免死循环的产生</p>
</li>
</ul>
<h3 id="3、do…while-循环"><a href="#3、do…while-循环" class="headerlink" title="3、do…while 循环"></a>3、do…while 循环</h3><p>do…while 循环与while循环非常像，二者经常可以相互替代</p>
<p>但是do…while的特点是不管条件成不成立，do循环都会先执行一次</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    <span class="comment">//循环代码块</span></span><br><span class="line">&#125; <span class="keyword">while</span>(循环条件)</span><br></pre></td></tr></table></figure>



<h3 id="4、for-循环"><a href="#4、for-循环" class="headerlink" title="4、for 循环"></a>4、for 循环</h3><p>for循环更加复杂，但它是最常用的循环形式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(begin;condition;step)&#123;</span><br><span class="line">    <span class="comment">//循环代码块body</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>begin：进入循环时执行一次</li>
<li>condition：在每次循环迭代之前检查：如果为false，停止循环</li>
<li>循环体：条件为真时，重复运行</li>
<li>step：在每次循环迭代后执行</li>
</ul>
<p>begin执行一次，然后进行迭代：每次检查condition后，执行body和step</p>
<p><strong>for循环的嵌套</strong></p>
<ul>
<li>在开发中，某下情况下一次循环是无法达到目的的，需要使用循环的嵌套</li>
</ul>
<p>for循环的嵌套：循环中执行体又嵌套了循环</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">九九乘法表</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&#x27;&lt;table&gt;&#x27;</span>)</span><br><span class="line"><span class="comment">// 九九乘法表</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&quot;&lt;tr&gt;&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>;j &lt; i + <span class="number">1</span>; j++)&#123;</span><br><span class="line">        <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">`&lt;td&gt;<span class="subst">$&#123;j+<span class="number">1</span>&#125;</span>×<span class="subst">$&#123;i+<span class="number">1</span>&#125;</span>=<span class="subst">$&#123;(j+<span class="number">1</span>)*(i+<span class="number">1</span>)&#125;</span>&lt;/td&gt;`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&quot;&lt;/tr&gt;&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&#x27;&lt;/table&gt;&#x27;</span>)</span><br></pre></td></tr></table></figure>



<h3 id="5、循环控制—break、continue"><a href="#5、循环控制—break、continue" class="headerlink" title="5、循环控制—break、continue"></a>5、循环控制—break、continue</h3><p>在执行循环过程中，遇到某一个条件时</p>
<ul>
<li>循环体不再执行(即使没有执行完)，跳出循环</li>
<li>本次循环体不再执行，执行下一次的循环体</li>
</ul>
<p>break：直接跳出循环，循环结束</p>
<ul>
<li>break在某一条件满足时，退出循环，不再执行后续重复的代码</li>
</ul>
<p>continue：跳过本次循环次，执行下一次循环体</p>
<ul>
<li>continue是break的”轻量版”</li>
<li>continue 在满足某一条件时，不执行后续重复的代码</li>
</ul>
<h3 id="6、案例练习"><a href="#6、案例练习" class="headerlink" title="6、案例练习"></a>6、案例练习</h3><p>随机数的生成</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">100</span>)    <span class="comment">// [0,1)</span></span><br></pre></td></tr></table></figure>



<h2 id="7-JavaScript函数"><a href="#7-JavaScript函数" class="headerlink" title="7.JavaScript函数"></a>7.JavaScript函数</h2><h3 id="1、认识-JavaScript-函数"><a href="#1、认识-JavaScript-函数" class="headerlink" title="1、认识 JavaScript 函数"></a>1、认识 JavaScript 函数</h3><p>foo、bar、baz：通常被用做函数、变量、文件的名词，计算机编程术语的一部分，本身没有别的用途和意义，被称为“伪变量”</p>
<p>什么是函数呢？</p>
<p>alert函数、prompt函数、log函数、String&#x2F;Number&#x2F;Boolean函数</p>
<p>函数是某种特定功能的代码的封装，帮助我们完成特定的功能</p>
<p>函数的使用</p>
<ul>
<li>声明函数—封装独立的功能</li>
<li>调用函数—享受封装的成果</li>
</ul>
<p>函数的作用：在开发程序时，使用函数可以提高编写的效率以及代码的重用</p>
<h3 id="2、函数的声明和调用"><a href="#2、函数的声明和调用" class="headerlink" title="2、函数的声明和调用"></a>2、函数的声明和调用</h3><p>声明函数使用function关键字：这种写法称之为函数的定义</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> 函数名() &#123; 函数封装的代码块 &#125;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>函数名的命名规则和前面变量名的命名规则是相同的</li>
<li>函数要尽量做到见名知意（一般是动词）</li>
<li>函数定义完后里面的代码是不会执行的，函数必须调用才会执行</li>
</ul>
<p>函数的参数：增加函数的通用性，针对相同的数据处理逻辑，能够适应更多的数据</p>
<ul>
<li>在函数内部，把参数当做变量使用，进行需要的数据处理</li>
<li>在函数调用时，按照函数定义的参数顺序，把希望在函数内部处理的数据，通过参数传递</li>
</ul>
<p>形参和实参</p>
<ul>
<li>形参（parameters）：定义函数时，小括号中的参数，是用来接收参数用的，在函数内部作为变量使用</li>
<li>实参（arguments）：调用函数时，小括号里的参数，是用来把数据传递到函数内部用的</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// name 称之为函数的参数（形参，形式参数）</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printInfo</span>(<span class="params">name</span>) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`my name is <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &#x27;wbh&#x27; 称之为函数的参数（实参，实际参数）</span></span><br><span class="line"><span class="title function_">printInfo</span>(<span class="string">&#x27;wbh&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>函数的返回值</p>
<p>函数不仅可以有参数，还可以有返回值</p>
<ul>
<li>使用return关键字来返回结果</li>
<li>一旦函数中执行returan操作，那么当前函数会终止</li>
<li>如果函数中没有使用return语句，那么函数会有默认的返回值：undefined</li>
<li>如果函数使用return语句，但是return后面没有任何值，那么函数的返回值也是undefined</li>
</ul>
<p>事实上在函数中有一个特别的对象：arguments对象</p>
<ul>
<li>默认情况下，arguments对象是所有(非箭头)函数中都可用的局部变量</li>
<li>该对象中存放着所有调用者传入的参数，从0位置开始，依次存放</li>
<li>arguments变量的类型是一个object类型(array-like)，不是一个数组，但是和数组的用法看起来很像</li>
<li>如果调用者传入的参数多于函数接收的参数，可以通过arguments去获取所有的参数</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(name)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>)</span><br><span class="line">    <span class="comment">// arguments是一个对象</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="variable language_">arguments</span>) </span><br><span class="line">    <span class="comment">// 对arguments进行遍历</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;<span class="variable language_">arguments</span>.<span class="property">length</span>;i++) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>[i])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>(<span class="string">&#x27;why&#x27;</span>,<span class="number">23</span>,<span class="number">445</span>,<span class="string">&quot;大连市&quot;</span>)</span><br></pre></td></tr></table></figure>



<h3 id="3、函数的递归调用"><a href="#3、函数的递归调用" class="headerlink" title="3、函数的递归调用"></a>3、函数的递归调用</h3><p>在开发中，函数内部是可以调用另外一个函数的</p>
<p>那么可以调用自己吗？</p>
<ul>
<li>可以的</li>
<li>但是必须有结束条件，否则会产生无限调用，造成报错</li>
</ul>
<p>函数调用自己—递归（recursion）</p>
<p>编程的递归调用</p>
<ul>
<li>将一个复杂的任务，转化成可以重复执行的相同任务</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">pow</span>(<span class="params">x,n</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(n=<span class="number">1</span>) <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">return</span> x*<span class="title function_">pow</span>(x,n-<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4、局部和全局变量"><a href="#4、局部和全局变量" class="headerlink" title="4、局部和全局变量"></a>4、局部和全局变量</h3><p>在 javascript（es5之前）中没有块级作用域的概念，var 定义的变量是没有块级作用域</p>
<p>但是函数可以定义自己的作用域（scope）</p>
<p>作用域：表示一些标识符的作用有效范围</p>
<p>函数的作用域表示在函数内部定义的变量，只有在函数内部可以被访问到</p>
<ul>
<li><p>es5 之前函数代码块是会形成自己的作用域的</p>
</li>
<li><p>在函数内部定义的变量在外面是拿不到的</p>
</li>
</ul>
<p>全局变量：在全局（script元素中）定义一个变量，那么这个变量是可以在定义之后的任何范围内被访问到，那么称这个变量为全局变量，在任何函数中可见，通过var定义的变量会被添加到window中</p>
<p>内部变量：局部变量，在函数内部定义的变量，只有在函数的内部才能访问，称之为局部变量</p>
<p>外部变量：在函数内部去访问函数之外的变量，被访问的变量称之为外部变量，（定义在函数外部的变量）</p>
<p>在函数中，访问变量的顺序</p>
<ul>
<li>优先访问自己函数中的变量，没有找到时，在外部中访问</li>
</ul>
<h3 id="5、函数表达式的写法"><a href="#5、函数表达式的写法" class="headerlink" title="5、函数表达式的写法"></a>5、函数表达式的写法</h3><p>在js中，函数并不是一种神奇的语法结构，而是一种特殊的值</p>
<ul>
<li>前面定义函数的方式，我们称之为函数的声明</li>
</ul>
<p>函数表达式写法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> bar = <span class="keyword">function</span>(<span class="params"></span>) &#123; &#125;</span><br></pre></td></tr></table></figure>

<p>function关键字后面没有函数名</p>
<ul>
<li>函数表达式允许省略函数名</li>
</ul>
<p>无论函数是如何创建的，函数都是一个值</p>
<p>在js开发中，我们可以将函数作为头等公民</p>
<h5 id="声明-vs-表达式"><a href="#声明-vs-表达式" class="headerlink" title="声明 vs 表达式"></a>声明 vs 表达式</h5><ul>
<li>语法不同<ul>
<li>函数声明：在主代码流中声明为单独的语句的函数</li>
<li>函数表达式：在一个表达式中或另一个语法结构中创建的函数</li>
</ul>
</li>
<li>创建函数的时机不同<ul>
<li>函数表达式是在代码执行到达时被创建，并且仅在那一刻起可用</li>
<li>在函数声明被定义之前，它就可以被调用<ul>
<li>这是内部算法的缘故</li>
<li>当javascript准备运行脚本时，首先会在脚本中寻找全局函数声明，并创建这些函数</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="开发中如何选择"><a href="#开发中如何选择" class="headerlink" title="开发中如何选择"></a>开发中如何选择</h5><p>首选考虑函数声明语法</p>
<p>它能够为组织代码提供更多的灵活性，因为我们可以在声明这些函数之前调用这些函数</p>
<h3 id="6、函数的头等公民"><a href="#6、函数的头等公民" class="headerlink" title="6、函数的头等公民"></a>6、函数的头等公民</h3><p>头等函数（第一等函数）：是指在程序设计语言中，函数被当做头等公民</p>
<ul>
<li>这意味着，函数可以作为别的函数的参数、函数的返回值，赋值给变量或存储在数据结构中</li>
<li>有人主张也应包括支持匿名函数</li>
</ul>
<p>通常对作为头等公民的编程方式，称之为函数式编程</p>
<ul>
<li>JavaScript 就是符合函数式编程的语言，这也是 js 的一大特点</li>
</ul>
<h5 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h5><p>既然一个函数可以在变量中来回传递，那么也可以传递给另外一个函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">fn</span>)&#123;</span><br><span class="line">    <span class="title function_">fn</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;执行了bar函数&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>(bar)</span><br></pre></td></tr></table></figure>

<p>foo这种函数我们也可以称之为高阶函数</p>
<h5 id="高阶函数必须满足两个条件之一"><a href="#高阶函数必须满足两个条件之一" class="headerlink" title="高阶函数必须满足两个条件之一"></a>高阶函数必须满足两个条件之一</h5><ul>
<li>接受一个或者多个函数作为输入</li>
<li>输出一个函数</li>
</ul>
<h5 id="匿名函数的理解"><a href="#匿名函数的理解" class="headerlink" title="匿名函数的理解"></a>匿名函数的理解</h5><p>如果在传入一个函数时，我们没有指定这个函数的名称或者通过函数表达式指定函数对应的变量，那么这个函数称之为匿名函数</p>
<h3 id="7、立即执行函数"><a href="#7、立即执行函数" class="headerlink" title="7、立即执行函数"></a>7、立即执行函数</h3><p>一个函数定义完后被立即执行</p>
<ul>
<li>第一部分是定义了一个匿名函数，这个函数有自己独立的作用域</li>
<li>第二部分是后面的()，表示这个函数被执行了</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>)&#123;  <span class="comment">// 函数名可以删除</span></span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;bar函数被立刻执行&#x27;</span>)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<p>会创建一个独立的执行上下文环境，可以避免外界访问或修改内部的变量，也避免了对内部变量的修改</p>
<h5 id="立即执行函数的其他写法"><a href="#立即执行函数的其他写法" class="headerlink" title="立即执行函数的其他写法"></a>立即执行函数的其他写法</h5><p>立即执行函数必须是一个表达式，不能是函数声明</p>
<p>当圆括号出现在匿名函数的末尾想要调用函数时，会默认将函数当成是函数声明</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="title function_">clg</span>(<span class="string">&quot;立即执行函数&quot;</span>) </span><br><span class="line">&#125;()  <span class="comment">// 错误写法</span></span><br></pre></td></tr></table></figure>

<p>当圆括号包裹函数时，会默认将函数作为表达式去解析，而不是函数声明</p>
<p>下面方法也可</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 3.其他写法</span></span><br><span class="line"><span class="comment">// 匿名函数</span></span><br><span class="line"><span class="comment">// (function(fn) &#123;</span></span><br><span class="line"><span class="comment">//   console.log(&#x27;立即执行函数被调用&#x27;)</span></span><br><span class="line"><span class="comment">// &#125;())</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// + - !</span></span><br><span class="line">+<span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;立即执行函数&#x27;</span>)</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>



<h3 id="8、代码规范"><a href="#8、代码规范" class="headerlink" title="8、代码规范"></a>8、代码规范</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230302102120792.png" alt="image-20230302102120792"></p>
<h2 id="8-JavaScript的面向对象"><a href="#8-JavaScript的面向对象" class="headerlink" title="8.JavaScript的面向对象"></a>8.JavaScript的面向对象</h2><h3 id="1、对象类型的使用"><a href="#1、对象类型的使用" class="headerlink" title="1、对象类型的使用"></a>1、对象类型的使用</h3><p>对象类型是一种存储键值对（key-value）的更复杂的数据类型</p>
<ul>
<li>键值对可以是属性和方法</li>
<li>其中key是字符串<ul>
<li>key是字符串类型，但是在定义对象的属性名时，大部分情况下引号都是可以省略的</li>
</ul>
</li>
<li>value可以是任意类型，包括基本数据类型、函数类型、对象类型等</li>
</ul>
<p>两个术语：函数&#x2F;方法</p>
<p>​    函数（function）：如果在js中通过function默认定义一个结构，称之为函数</p>
<p>​    方法(method)：如果将一个函数放到对象中，并作为对象的一个属性，那么这个函数称之为方法</p>
<h5 id="创建对象和使用对象"><a href="#创建对象和使用对象" class="headerlink" title="创建对象和使用对象"></a>创建对象和使用对象</h5><p>创建对象的方式很多，包括三种：</p>
<ul>
<li>对象字面量：通过{}</li>
<li>new Object + 动态添加属性</li>
<li>new 其他类</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.字面量创建</span></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;why&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2.new object</span></span><br><span class="line"><span class="comment">// Object 构造函数</span></span><br><span class="line"><span class="keyword">var</span> obj2 = <span class="keyword">new</span> <span class="title class_">Object</span>()</span><br><span class="line">obj2.<span class="property">name</span> = <span class="string">&#x27;kobe&#x27;</span></span><br><span class="line"><span class="comment">// 3.new 其他类()</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> obj3 = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj3)</span><br></pre></td></tr></table></figure>



<p>属性之间是以逗号分割的</p>
<p>对象的使用：</p>
<ul>
<li>访问对象的属性</li>
<li>修改对象的属性</li>
<li>添加对象的属性</li>
<li>删除对象的属性：delete 关键字</li>
</ul>
<h5 id="方括号和引用的使用"><a href="#方括号和引用的使用" class="headerlink" title="方括号和引用的使用"></a>方括号和引用的使用</h5><p>对于多词属性来说，js是无法理解的</p>
<p>而点符号要求key是有效的变量标识符</p>
<ul>
<li>不包含空格、不以数字开头、也不包含特殊字符(允许使用$和_)</li>
</ul>
<p>这时候可以使用方括号来获取对象的属性 </p>
<h5 id="对象的遍历"><a href="#对象的遍历" class="headerlink" title="对象的遍历"></a>对象的遍历</h5><p>表示获取对象中所有的属性和方法</p>
<p>Object.keys() 方法会返回一个由一个给定对象的自身可枚举属性组成的数组</p>
<ul>
<li>普通的for循环</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> userKeys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(user)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; userKeys.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> key = userKeys[i]</span><br><span class="line">  <span class="keyword">var</span> value = user[key]</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`key: <span class="subst">$&#123;key&#125;</span>, value: <span class="subst">$&#123;value&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>for…in…遍历，key 即是属性，user[key] 这是对应的值</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> user) &#123;</span><br><span class="line">  <span class="keyword">var</span> value = user[key]</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`key: <span class="subst">$&#123;key&#125;</span>, value: <span class="subst">$&#123;value&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>for…of..不能遍历，因为对象默认是不可迭代的，for of 对数组有效</li>
</ul>
<h5 id="栈内存和堆内存"><a href="#栈内存和堆内存" class="headerlink" title="栈内存和堆内存"></a>栈内存和堆内存</h5><p>程序是需要加载到内存中执行的，我们可以将内存划分为两个区域，栈内存和堆内存</p>
<p>原始类型占据的空间是在栈内存中分配的</p>
<p>对象类型占据的空间是在堆内存中分配的</p>
<h3 id="2、值类型和引用类型"><a href="#2、值类型和引用类型" class="headerlink" title="2、值类型和引用类型"></a>2、值类型和引用类型</h3><p>原始类型的保存方式：在变量中保存的是值本身</p>
<ul>
<li>所以原始类型也被称之为值类型</li>
</ul>
<p>对象类型的保存方式：在变量中保存的是对象的“引用”</p>
<ul>
<li>所以对象类型也被称之为引用类型</li>
</ul>
<h3 id="3、函数的-this-指向"><a href="#3、函数的-this-指向" class="headerlink" title="3、函数的 this 指向"></a>3、函数的 this 指向</h3><p>函数中是有一个this的变量，this变量在大多数情况下会指向一个对象</p>
<p>使用 this 方便在一个方法中，拿到当前对象的一些属性</p>
<p>情况一：如果普通的函数被默认调用，即全局环境下默认调用一个函数，那么this指向的是window</p>
<p>情况二：如果函数它是被某一个对象来引用并且调用它，即通过对象调用，那么this对指向这个对象(调用的那个对象)</p>
<p>this代表的是当前调用对象</p>
<h3 id="4、工厂方法创建类"><a href="#4、工厂方法创建类" class="headerlink" title="4、工厂方法创建类"></a>4、工厂方法创建类</h3><h5 id="1-类和对象的思维方式"><a href="#1-类和对象的思维方式" class="headerlink" title="1.类和对象的思维方式"></a>1.类和对象的思维方式</h5><p>创建一些列类似的对象，比如学生、游戏英雄，都具有姓名学号，但是具体的值不同</p>
<p>方法1：手动创建，但是重复代码很多</p>
<p>方法2：for循环，但是不能修改具体的值</p>
<p>方法3：工厂函数，一种常见的设计模式，但在js中大可不必这样做</p>
<p>工厂方法创建对象有一个比较大的问题：我们在打印对象时，对象的类型都是Object类型</p>
<ul>
<li>但是从某些角度来说，这些对象应该有一个他们共同的类型</li>
</ul>
<h5 id="2-构造函数的方式：使用new关键词（操作符）"><a href="#2-构造函数的方式：使用new关键词（操作符）" class="headerlink" title="2.构造函数的方式：使用new关键词（操作符）"></a>2.构造函数的方式：使用new关键词（操作符）</h5><ul>
<li>构造函数也被称之为构造器，通常我们在创建对象时会调用的函数</li>
<li>在其他编程语言，构造函数存在于类中的一个方法，称为构造方法</li>
<li>但在js中，构造函数扮演了其他语言中类的角色</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">coder</span>(<span class="params">name, age, height</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">height</span> = height</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">running</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;running&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在函数调用的前面加上 new 关键字(操作符)</span></span><br><span class="line"><span class="keyword">var</span> stu1 = <span class="keyword">new</span> <span class="title function_">coder</span>(<span class="string">&quot;why&quot;</span>, <span class="number">21</span>, <span class="number">157</span>)</span><br></pre></td></tr></table></figure>



<p>也就是在 JavaScript 中，构造函数其实就是类的扮演者：</p>
<p>比如系统默认给我们提供的 Date 就是一个构造函数，也可以看成是一个类</p>
<p>在ES5之前，我们都是通过 function 来声明一个构造函数（类）的，之后通过 new 关键字来对其进行调用</p>
<p>在ES6之后，JavaScript 可以像别的语言一样，通过 class 来声明一个类</p>
<h3 id="5、构造函数和类"><a href="#5、构造函数和类" class="headerlink" title="5、构造函数和类"></a>5、构造函数和类</h3><h5 id="1-什么是类（构造函数）"><a href="#1-什么是类（构造函数）" class="headerlink" title="1.什么是类（构造函数）"></a>1.什么是类（构造函数）</h5><ul>
<li><p>现实生活中往往是根据一份描述&#x2F;一个模板来创建一个实体对象的</p>
</li>
<li><p>编程语言也是一样, 也必须先有一份描述, 在这份描述中说明将来创建出来的对象有哪些属性(成员变量)和行为(成员方法)</p>
</li>
</ul>
<p>比如现实生活中，我们会如此来描述一些事物：</p>
<ul>
<li><p>比如水果fruits是一类事物的统称，苹果、橘子、葡萄等是具体的对象；</p>
</li>
<li><p>比如人person是一类事物的统称，而Jim、Lucy、Lily、李雷、韩梅梅是具体的对象；</p>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230303155836052.png" alt="image-20230303155836052"></p>
<p>对象是由类创建出来的，类相当于设计图纸，用于描述对象的内容(属性)</p>
<p>类在没有调用的情况下是没有在内存中创建的，使用需要new操作符</p>
<p>JavaScript中类的表示形式就是构造函数。</p>
<h5 id="2-JavaScript中的构造函数是怎么样的？"><a href="#2-JavaScript中的构造函数是怎么样的？" class="headerlink" title="2.JavaScript中的构造函数是怎么样的？"></a>2.JavaScript中的构造函数是怎么样的？</h5><p>构造函数也是一个普通的函数，从表现形式来说，和千千万万个普通的函数没有任何区别；</p>
<p>那么如果这么一个普通的函数被使用new操作符来调用了，那么这个函数就称之为是一个构造函数；</p>
<p>如果一个函数被使用new操作符调用了，那么它会执行如下操作：</p>
<ol>
<li><p>在内存中创建一个新的对象（空对象）；</p>
</li>
<li><p>这个对象内部的[[prototype]]属性会被赋值为该构造函数的prototype属性；</p>
</li>
<li><p>构造函数内部的this，会指向创建出来的新对象；</p>
</li>
<li><p>执行函数的内部代码（函数体代码）；</p>
</li>
<li><p>如果构造函数没有返回非空对象，则返回创建出来的新对象；</p>
</li>
</ol>
<p>构造函数可以确保我们的对象是有我们定义的类型的（例如：student）</p>
<h5 id="3-全局对象window了解"><a href="#3-全局对象window了解" class="headerlink" title="3.全局对象window了解"></a>3.全局对象window了解</h5><p>浏览器中存在一个全局对象 Object —&gt; window</p>
<p>作用1：查找变量时，最终会查到 window 头上</p>
<p>作用2：将我们一些浏览器全局提供给我们的变量&#x2F;函数&#x2F;对象，放在 window 对象上</p>
<p>作用3：使用 var 定义的变量会被默认添加到 window 上面(设计缺陷)</p>
<p>浏览器看到后面添加了<strong>var</strong> message 信息，会对前方 clg.window 进行刷新，所以前方打印的window对象中可以查看到 message定义的信息</p>
<p>函数也是对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义对象类型的变量</span></span><br><span class="line"><span class="comment">// 地址 -&gt; 指针 -&gt; 引用</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125; <span class="comment">// 堆内存</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125; <span class="comment">// 堆内存</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;&#125;  <span class="comment">// 堆内存</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// console.log(typeof obj)  //Object</span></span><br><span class="line"><span class="comment">// console.log(typeof foo)  // function -&gt; object</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Dog</span>(<span class="params"></span>) &#123; &#125;</span><br><span class="line"><span class="comment">// 构造函数上(类上面) 添加的函数，称之为类方法</span></span><br><span class="line"><span class="title class_">Dog</span>.<span class="property">running</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="title class_">Dog</span>.<span class="title function_">running</span>()</span><br></pre></td></tr></table></figure>



<h2 id="9-JavaScript常见的内置类"><a href="#9-JavaScript常见的内置类" class="headerlink" title="9.JavaScript常见的内置类"></a>9.JavaScript常见的内置类</h2><h3 id="1、认识包装类型"><a href="#1、认识包装类型" class="headerlink" title="1、认识包装类型"></a>1、认识包装类型</h3><p>原始类型的包装类</p>
<p>js的原始类型并非对象类型，所以理论上，他们是没法获取属性或调用方法的</p>
<p>那么出现这样的现象，是因为js为了使其可以获取属性和调用方法，对其封装了对应的包装类型</p>
<p>常见的包装类型：String、Number、Boolean、Symbol、Bigint类型</p>
<p>包装类型的使用过程，当我们使用原始类型的属性或者方法时</p>
<ul>
<li><p>根据原始值，创建一个原始类型对应的包装类型对象</p>
</li>
<li><p>调用对应的属性或者方法，返回一个新的值</p>
</li>
<li><p>创建的包装类对象被销毁</p>
</li>
<li><p>通常JavaScript引擎会进行很多的优化，它可以跳过创建包装类的过程在内部直接完成属性的获取或者方法的调用</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;why&quot;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> num1)  <span class="comment">// object</span></span><br></pre></td></tr></table></figure>

<p>注意事项：null、undefined 没有任何的方法，也没有对应的 “ 对象包装型 ”</p>
<h3 id="2、数字类型Number"><a href="#2、数字类型Number" class="headerlink" title="2、数字类型Number"></a>2、数字类型Number</h3><h4 id="1-属性补充："><a href="#1-属性补充：" class="headerlink" title="1.属性补充："></a>1.属性补充：</h4><ul>
<li>Number.MAX_SAFE_INTEGER：JavaScript 中最大的安全整数 (2^53 - 1) </li>
<li>Number.MIN_SAFE_INTEGER：JavaScript 中最小的安全整数 -(2^53 - 1)</li>
</ul>
<h4 id="2-实例方法补充"><a href="#2-实例方法补充" class="headerlink" title="2.实例方法补充"></a>2.实例方法补充</h4><p> 方法一：toString(base)，将数字转成字符串，并且按照base进制进行转化</p>
<ul>
<li><p>base 的范围可以从 2 到 36，默认情况下是 10； </p>
</li>
<li><p>注意：如果是直接对一个数字操作，需要使用..运算符；</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num1.<span class="title function_">toString</span>(<span class="number">2</span>))  <span class="comment">// 转成2进制</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1000.</span>.<span class="title function_">toString</span>(<span class="number">2</span>))</span><br></pre></td></tr></table></figure>

<p>方法二：toFixed(digits)，格式化一个数字，保留digits位的小数，返回值是string类型； </p>
<ul>
<li><p>digits的范围是0到20（包含）之间；</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类方法：</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">parseInt</span>()  通过类名调用</span><br><span class="line"><span class="comment">// 实例方法：</span></span><br><span class="line"><span class="number">123.</span>.<span class="title function_">toFixed</span>(<span class="number">2</span>) 通过具体的对象调用</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-类方法补充"><a href="#3-类方法补充" class="headerlink" title="3.类方法补充"></a>3.类方法补充</h4><p>方法一：Number.parseInt(string[, radix])，将字符串解析成整数，也有对应的全局方法parseInt，不会四舍五入</p>
<p>方法二：Number. parseFloat(string)，将字符串解析成浮点数，也有对应的全局方法parseFloat</p>
<h3 id="3、数字对象Math"><a href="#3、数字对象Math" class="headerlink" title="3、数字对象Math"></a>3、数字对象Math</h3><p>Math 是一个内置对象（不是一个构造函数），它拥有一些数学常数属性和数学函数方法</p>
<p>常见的属性</p>
<ul>
<li>Math.PI：圆周率</li>
<li>Math.ceil：向上舍入取整 </li>
<li>Math.round：四舍五入取整 </li>
<li>Math.random：生成0~1的随机数（包含0，不包含1）</li>
<li>Math.pow(x, y)：返回x的y次幂</li>
</ul>
<h3 id="4、字符串类型String"><a href="#4、字符串类型String" class="headerlink" title="4、字符串类型String"></a>4、字符串类型String</h3><p>String 类提供了我们对于字符串各种操作的属性和方法</p>
<h4 id="1-常见的属性"><a href="#1-常见的属性" class="headerlink" title="1.常见的属性"></a>1.常见的属性</h4><ul>
<li>length：获取字符串的长度</li>
</ul>
<p>操作一：访问字符串的字符 </p>
<p>使用方法一：通过字符串的索引 str[0] </p>
<p>使用方法二：通过str.charAt(pos)方法 </p>
<p>它们的区别是索引的方式没有找到会返回undefined，而charAt没有找到会返回空字符串； </p>
<p>练习：字符串的遍历 </p>
<p>方式一：普通for循环</p>
<p>方式二：for..of..遍历</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// for...of...的遍历 -&gt; 迭代器</span></span><br><span class="line"><span class="comment">// 目前的可迭代对象：字符串/数组</span></span><br><span class="line"><span class="comment">// 对象不支持 for  of</span></span><br><span class="line"><span class="comment">// string 对象内部是将字符串变成了一个可迭代对象</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> char <span class="keyword">of</span> message) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(char)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-修改字符串"><a href="#2-修改字符串" class="headerlink" title="2.修改字符串"></a>2.修改字符串</h4><p>字符串的不可变性</p>
<ul>
<li>字符串在定义后是不可修改的</li>
</ul>
<p>在我们改变很多字符串的操作中，都是生成了一个新的字符串</p>
<p>比如改变字符串大小的两个方法 </p>
<ul>
<li><p>toLowerCase()：将所有的字符转成小写； </p>
</li>
<li><p>toUpperCase()：将所有的字符转成大写；</p>
</li>
</ul>
<h4 id="3-查找字符串"><a href="#3-查找字符串" class="headerlink" title="3.查找字符串"></a>3.查找字符串</h4><p>方法1：str.indexOf(searchValue[, fromIndex])</p>
<ul>
<li>从fromIndex开始，查找searchValue的索引</li>
<li>没有找到则返回-1</li>
<li>类似的方法 lastIndexOf，从最后开始查找（用的较少）</li>
</ul>
<p>方法2：是否包含字符串 str.includes(searchString[, position])</p>
<ul>
<li>position位置开始查找searchString， 根据情况返回 true 或 false</li>
<li>这是ES6新增的方法</li>
</ul>
<p>方法3：以xxx开头 str.startWith(searchString[, position])</p>
<ul>
<li>从position位置开始，判断字符串是否以searchString开头</li>
<li>这是ES6新增的方法，下面的方法也一样</li>
</ul>
<p>方法4：以xxx结尾 str.endWith(searchString[, length])</p>
<ul>
<li>length长度内，判断字符串是否以searchString结尾</li>
</ul>
<p>方法5：替换字符串 str.replace(regexp|substr,newSubStr|function)</p>
<ul>
<li>查找到对应的字符串，并且使用新的字符串进行替代</li>
<li>也可以传入一个正则表达式来查找，也可以传入一个函数来替换</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> message = <span class="string">&quot;my name is why.&quot;</span></span><br><span class="line">   <span class="keyword">var</span> name = <span class="string">&#x27;why&#x27;</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 判断一个字符串中是否有另外一个字符串</span></span><br><span class="line">   <span class="comment">// 1.indexOf(searchString, fromIndex)</span></span><br><span class="line">   <span class="comment">// 返回的结果是一个索引值</span></span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">     index:</span></span><br><span class="line"><span class="comment">       情况1：搜索到：搜索字符串所在的索引位置</span></span><br><span class="line"><span class="comment">       情况2：没有搜索到，返回-1</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"> <span class="comment">//  var index = message.indexOf(name)</span></span><br><span class="line"> <span class="comment">//  if (message.indexOf(name) !== -1) &#123;</span></span><br><span class="line"> <span class="comment">//   console.log(&quot;message中包含name&quot;)</span></span><br><span class="line"> <span class="comment">//  &#125; else &#123;</span></span><br><span class="line"> <span class="comment">//   console.log(&quot;message中不包含name&quot;)</span></span><br><span class="line"> <span class="comment">//  &#125;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 方法2：es6中新增一个方法，来判断包含关系</span></span><br><span class="line"> <span class="comment">// if (message.includes(name)) &#123;</span></span><br><span class="line"> <span class="comment">//   console.log(&quot;message中包含name&quot;)</span></span><br><span class="line"> <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 3.startWith:是否以xxx开头</span></span><br><span class="line"> <span class="comment">// if (message.startsWith(&quot;my&quot;)) &#123;</span></span><br><span class="line"> <span class="comment">//   console.log(&quot;message以my开头&quot;)</span></span><br><span class="line"> <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 4.endWith:是否以xxx结尾</span></span><br><span class="line"> <span class="comment">// if (message.endsWith(&#x27;why&#x27;)) &#123;</span></span><br><span class="line"> <span class="comment">//   console.log(&quot;message以why结尾&quot;)</span></span><br><span class="line"> <span class="comment">// &#125; else &#123;</span></span><br><span class="line"> <span class="comment">//   console.log(&quot;no&quot;)</span></span><br><span class="line"> <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 5.替换字符串 replace</span></span><br><span class="line"> <span class="comment">// var newMessage = message.replace(&quot;why&quot;, &quot;kobe&quot;)</span></span><br><span class="line"> <span class="comment">// console.log(newMessage)</span></span><br><span class="line"> <span class="keyword">var</span> newName = <span class="string">&quot;kobe&quot;</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">var</span> newMessage = message.<span class="title function_">replace</span>(<span class="string">&quot;why&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> newName.<span class="title function_">toUpperCase</span>()</span><br><span class="line"> &#125;)</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(newMessage)</span><br></pre></td></tr></table></figure>



<p>获取子字符串</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>选择方式</th>
<th>负值参数</th>
</tr>
</thead>
<tbody><tr>
<td>slice(start,end)</td>
<td>从start到end（不含end）</td>
<td>允许</td>
</tr>
<tr>
<td>substring(start,end)</td>
<td>从start到end（不含end）</td>
<td>负值代表0</td>
</tr>
<tr>
<td>substr(start,length)</td>
<td>从start开始获取长为 length 的字符串</td>
<td>允许start为负数</td>
</tr>
</tbody></table>
<p>substr 方法可能有的浏览器不支持，推荐slcie，负值：-1表示为最后一位</p>
<h4 id="4-字符串的拼接"><a href="#4-字符串的拼接" class="headerlink" title="4.字符串的拼接"></a>4.字符串的拼接</h4><p>方法：</p>
<ul>
<li><p>运用 + 运算符</p>
</li>
<li><p>str1.concat(str2)   括号中的是可变参数，支持链式编程</p>
</li>
</ul>
<p>删除首尾空格：str.trim()</p>
<h4 id="6-字符串切割与改变连接方式"><a href="#6-字符串切割与改变连接方式" class="headerlink" title="6.字符串切割与改变连接方式"></a>6.字符串切割与改变连接方式</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> message = <span class="string">&quot;223-423-422-122-352&quot;</span></span><br><span class="line">   <span class="keyword">var</span> items = message.<span class="title function_">split</span>(<span class="string">&quot;-&quot;</span>)  <span class="comment">// 返回值是一个string类型的数组</span></span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(items)</span><br><span class="line">   <span class="comment">// 将此数组改为以 * 连接的字符串</span></span><br><span class="line">   <span class="keyword">var</span> newMessage = items.<span class="title function_">join</span>(<span class="string">&quot;*&quot;</span>)</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(newMessage)</span><br></pre></td></tr></table></figure>



<p>补充 string 方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;124&quot;</span></span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">padStart</span>(<span class="number">4</span>, <span class="string">&quot;0&quot;</span>))   <span class="comment">// 0124</span></span><br></pre></td></tr></table></figure>



<h3 id="5、数组Array使用详解"><a href="#5、数组Array使用详解" class="headerlink" title="5、数组Array使用详解"></a>5、数组Array使用详解</h3><h4 id="1-什么是数组"><a href="#1-什么是数组" class="headerlink" title="1.什么是数组"></a>1.什么是数组</h4><p>是一种有序的组合，里面的元素是按照一定顺序来排列的，可以通过索引查找</p>
<p>数组和对象都是一种保存多个数据的数据结构</p>
<p>通过 [ ] 创建</p>
<ul>
<li>数组是一种特殊的对象类型</li>
</ul>
<p>通过构造函数 Array 创建</p>
<ul>
<li>new Array()  &#x2F;&#x2F; () 里面可以传入数据  “ ”  ，但是如果传入一个数字类型，会默认当成我们要创建一个对应长度的数组</li>
</ul>
<p>数组元素从0开始索引</p>
<ul>
<li>一些编程语言可以通过 arr[-1] 来访问最后一个元素</li>
<li>js并不支持这种写法，访问最后一个元素：arr[arr.length-1]</li>
</ul>
<h4 id="2-数组的基本操作"><a href="#2-数组的基本操作" class="headerlink" title="2.数组的基本操作"></a>2.数组的基本操作</h4><h5 id="1、访问数组中的元素"><a href="#1、访问数组中的元素" class="headerlink" title="1、访问数组中的元素"></a>1、访问数组中的元素</h5><ul>
<li>arr[index]</li>
<li>arr.at(index)<ul>
<li>如果index &gt;&#x3D; 0，则与arr[index] 的情况相同</li>
<li>对于index为负数的情况，它则从数组的尾部向前数</li>
</ul>
</li>
</ul>
<h5 id="2、修改数组中的元素"><a href="#2、修改数组中的元素" class="headerlink" title="2、修改数组中的元素"></a>2、修改数组中的元素</h5><p>arr[index] &#x3D; “coderwhy”</p>
<h5 id="3、删除"><a href="#3、删除" class="headerlink" title="3、删除"></a>3、删除</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">delete</span> names[<span class="number">2</span>] </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(names)  <span class="comment">// 索引为2的位置为empty</span></span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(names[<span class="number">2</span>])  <span class="comment">// 查询结果为undefined</span></span><br></pre></td></tr></table></figure>

<p>删除和添加元素虽然也可以通过索引来直接操作，但是开发中很少这样操作。</p>
<p>具体的操作方法</p>
<ul>
<li>添加&#x2F;删除尾部<ul>
<li>push()：在尾部添加元素，为可变参数</li>
<li>pop()：在尾部删除元素，一次只能删除一个元素</li>
</ul>
</li>
<li>添加&#x2F;删除首部<ul>
<li>unshift()：在首部添加元素，为可变参数， 在首端添加元素，整个其他数组元素向后移动</li>
<li>shift()：在首部删除元素，一次只能删除一个元素， 取出队列首端的一个元素，整个数组元素向前前移动</li>
</ul>
</li>
</ul>
<p>相对来说，push和pop的运行比较快</p>
<p>删除方法2：</p>
<ul>
<li>arr.splice</li>
</ul>
<p>语法结构：arr.splice(start, deleteCount, [, item1[, item2[,item3]…]])</p>
<p>从start位置开始，删除deleteCount（0代表不删除)个元素，后面的则为添加items</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除元素</span></span><br><span class="line">	names.<span class="title function_">splice</span>(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(names)</span><br><span class="line"><span class="comment">// 新增元素</span></span><br><span class="line">	names.<span class="title function_">splice</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="string">&quot;ssx&quot;</span>, <span class="string">&quot;ccg&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(names)</span><br><span class="line"><span class="comment">// 替换元素</span></span><br><span class="line">	names.<span class="title function_">splice</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;vc&quot;</span>, <span class="string">&quot;ccc&quot;</span>, <span class="string">&quot;kobe&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(names)</span><br></pre></td></tr></table></figure>

<p>这个方法会修改原数组</p>
<p>length 属性：用于获取数组的长</p>
<ul>
<li>当我们修改出租的时候，length 属性会自动更新</li>
</ul>
<p>length属性是可写的</p>
<ul>
<li>如果我们手动增加一个默认大于length的数值，那么会增加数组的长度</li>
<li>但是如果我们减少它，数组会被截断</li>
</ul>
<p>清空数组的最简单的方法就是：arr.length &#x3D; 0</p>
<h5 id="4、数组的遍历"><a href="#4、数组的遍历" class="headerlink" title="4、数组的遍历"></a>4、数组的遍历</h5><ul>
<li>普通的 for 循环</li>
<li>for..in 遍历：获取到的 index 为索引值，arr[index] 为 value 值</li>
<li>for..of 遍历：获取不到索引值，能获取到每一个元素</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2.1 普通的for 循环</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; names.<span class="property">length</span>; i++) &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(names[i])</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 2.2 for...in</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">var</span> index <span class="keyword">in</span> names) &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(index, names[index])  <span class="comment">// 索引</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 2.3 for...of</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">var</span> items <span class="keyword">of</span> names) &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(items)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h5 id="5、数组方法"><a href="#5、数组方法" class="headerlink" title="5、数组方法"></a>5、数组方法</h5><ul>
<li>arr.slice 方法：用于对数组进行截取，不会修改原数组，类似于字符串的slice方法<ul>
<li>arr.slice(start, end) 截取到的元素包含strat，但不包含end 元素</li>
</ul>
</li>
<li>arr.concat 方法：创建一个新的数组，其中包含来自于其他数组和其他项的值<ul>
<li>var newArr &#x3D; arr.concat(“ssd”, “ssx”, “ccc”)</li>
</ul>
</li>
<li>arr.join 方法：将一个数组的所有元素连接成一个字符串并返回这个字符串<ul>
<li>console.log(arr.join(“-“))</li>
</ul>
</li>
</ul>
<h5 id="6、查找元素"><a href="#6、查找元素" class="headerlink" title="6、查找元素"></a>6、查找元素</h5><ul>
<li>arr.indexOf(searchElement[, fromIndex]) 方法，查找某个元素的索引<ul>
<li>从 fromIndex 开始查找，如果找到则返回索引，没找到返回-1</li>
<li>也有对应的从最后位置开始查找的 lastIndexOf 方法</li>
<li>对于复杂数据类型的不便于查找，使用 for 循环也可以实现</li>
</ul>
</li>
<li>arr.includes 方法：判断数组是否包含某个元素<ul>
<li>arr.includes(valueToFind[, fromIndex])</li>
<li>从索引from开始查找item，找到则返回true，找不到返回false</li>
</ul>
</li>
<li>find 和 findIndex 直接查找元素或者元素的索引（es6之后）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> findStu = students.<span class="title function_">find</span>(<span class="keyword">function</span>(<span class="params">item</span>)&#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(item)</span><br><span class="line">     <span class="keyword">return</span> item.<span class="property">id</span> = <span class="number">101</span></span><br><span class="line">   &#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(findStu)</span><br></pre></td></tr></table></figure>



<h5 id="7、排序和反转"><a href="#7、排序和反转" class="headerlink" title="7、排序和反转"></a>7、排序和反转</h5><p>方法1：算法实现排序</p>
<p>方法2：使用 sort 高级函数，排序之后生成一个新的数组，可用于复杂类型的数组</p>
<ul>
<li><p>如果 compareFunction(a, b) 小于 0 ，那么 a 会被排列到 b 前面； </p>
</li>
<li><p>如果 compareFunction(a, b) 等于 0 ， a 和 b 的相对位置不变； </p>
</li>
<li><p>如果 compareFunction(a, b) 大于 0 ， b 会被排列到 a 前面； </p>
</li>
<li><p>也就是说，谁小谁排在前面；</p>
</li>
</ul>
<p> reverse() 方法将数组中元素的位置颠倒，并返回该数组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">num.<span class="title function_">sort</span>(<span class="keyword">function</span>(<span class="params">item1, item2</span>) &#123;</span><br><span class="line">     <span class="comment">// item1 和 item2 进行比较</span></span><br><span class="line">     <span class="comment">// 返回的是 正数</span></span><br><span class="line">     <span class="comment">// 谁小谁在前</span></span><br><span class="line">     <span class="keyword">return</span> item1 - item2  <span class="comment">//升序</span></span><br><span class="line">     <span class="comment">// return item2 - item1  //降序</span></span><br><span class="line">   &#125;)</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(num)</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(num.<span class="title function_">reverse</span>())  <span class="comment">// 反转</span></span><br></pre></td></tr></table></figure>



<h5 id="8、数组的其他高阶函数"><a href="#8、数组的其他高阶函数" class="headerlink" title="8、数组的其他高阶函数"></a>8、数组的其他高阶函数</h5><p>arr.forEach  参数（item,index,arr）</p>
<ul>
<li>遍历数组，并且让数组中每一个元素都执行一次对应的方法</li>
</ul>
<p>arr.map   参数（item,index,arr）</p>
<ul>
<li>map() 方法创建一个新数组</li>
<li>这个新数组由原数组中的每个元素都调用一次提供的函数后的返回值组成</li>
</ul>
<p>arr.filter   参数（item,index,arr）</p>
<ul>
<li>filter() 方法创建一个新数组</li>
<li>新数组中只包含每个元素调用函数返回为true的元素</li>
</ul>
<p>arr.reduce  参数（preValue, item） preValue 可以传入一个0  作为第一次执行的preValue</p>
<ul>
<li>用于计算数组中所有元素的总和</li>
<li>对数组中的每个元素按序执行一个由您提供的 reducer 函数</li>
<li>每一次运行 reducer 会将先前元素的计算结果作为参数传入，最后将其结果汇总为单个返回值</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">综合练习：过滤所有的偶数 计算偶数的平方 再求和</span><br><span class="line">    <span class="keyword">var</span> total = num.<span class="title function_">filter</span>(<span class="keyword">function</span>(<span class="params">item</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> item % <span class="number">2</span> === <span class="number">0</span></span><br><span class="line">    &#125;).<span class="title function_">map</span>(<span class="keyword">function</span>(<span class="params">item</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> item * item</span><br><span class="line">    &#125;).<span class="title function_">reduce</span>(<span class="keyword">function</span>(<span class="params">preValue, item</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> preValue + item</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(total)</span><br></pre></td></tr></table></figure>



<h3 id="6、Date类型的使用"><a href="#6、Date类型的使用" class="headerlink" title="6、Date类型的使用"></a>6、Date类型的使用</h3><h4 id="1-创建Date对象"><a href="#1-创建Date对象" class="headerlink" title="1.创建Date对象"></a>1.创建Date对象</h4><p>在 js 中使用 Date 来表示和处理时间</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Date 构造函数的以下用法</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>()  <span class="comment">// 当前时间</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&quot;2022-08-08&quot;</span>)   <span class="comment">// 传入参数，时间字符串</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">2022</span>, <span class="number">02</span>, <span class="number">03</span>, <span class="number">06</span>, <span class="number">15</span>, <span class="number">06</span>, <span class="number">33</span>) <span class="comment">// 传入具体的年月日时分秒毫秒</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">1000267496623</span>) <span class="comment">// 传入一个Unix时间戳  1s -&gt; 1000ms</span></span><br></pre></td></tr></table></figure>



<h4 id="2-dateString-时间的表示方式"><a href="#2-dateString-时间的表示方式" class="headerlink" title="2. dateString 时间的表示方式"></a>2. dateString 时间的表示方式</h4><p>日期的表示方式有两种：RFC 2822 标准 或者 ISO 8601 标准</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date)  <span class="comment">//  Wed Mar 08 2023 09:52:44 GMT+0800 (中国标准时间) </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date.<span class="title function_">toDateString</span>())  <span class="comment">// Wed Mar 08 2023</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date.<span class="title function_">toISOString</span>())  <span class="comment">// 2023-03-08T01:52:44.254Z 标准时间 不是北京时间</span></span><br></pre></td></tr></table></figure>

<p>可以将其转化成ISO 8601标准的：  </p>
<p>YYYY：年份，0000 ~ 9999</p>
<p>MM：月份，01 ~ 12</p>
<p>DD：日，01 ~ 31</p>
<p>T：分隔日期和时间，没有特殊含义，可以省略</p>
<p>HH：小时，00 ~ 24 </p>
<p>mm：分钟，00 ~ 59 </p>
<p>ss：秒，00 ~ 59</p>
<p>.sss：毫秒  Z：时区</p>
<h4 id="3-Date-对象的方法"><a href="#3-Date-对象的方法" class="headerlink" title="3.Date 对象的方法"></a>3.Date 对象的方法</h4><p>我们可以从Date对象中获取各种详细的信息： </p>
<ul>
<li><p>getFullYear()：获取年份（4 位数）</p>
</li>
<li><p>getMonth()：获取月份，从 0 到 11</p>
</li>
<li><p>getDate()：获取当月的具体日期，从 1 到 31（方法名字有点迷）</p>
</li>
<li><p>getHours()：获取小时</p>
</li>
<li><p>getMinutes()：获取分钟</p>
</li>
<li><p>getSeconds()：获取秒钟</p>
</li>
<li><p>getMilliseconds()：获取毫秒</p>
</li>
<li><p>getDay()：获取一周中的第几天，从 0（星期日）到 6（星期六）</p>
</li>
</ul>
<p>设置信息的方法</p>
<ul>
<li>setFullYear(year, [month], [date]) </li>
<li>setMonth(month, [date]) </li>
<li>setDate(date) </li>
<li>setHours(hour, [min], [sec], [ms]) </li>
<li>setMinutes(min, [sec], [ms]) </li>
<li>setSeconds(sec, [ms]) </li>
<li>setMilliseconds(ms) </li>
<li>setTime(milliseconds)</li>
</ul>
<p>设置超范围的数值，它会自动校准</p>
<h4 id="4-Date-获取-Unix-时间戳"><a href="#4-Date-获取-Unix-时间戳" class="headerlink" title="4.Date 获取 Unix 时间戳"></a>4.Date 获取 Unix 时间戳</h4><p>Unix 时间戳：它是一个整数值，表示自1970年1月1日00:00:00 UTC以来的毫秒数</p>
<p>前面可知，我们可以通过传入一个时间戳来获取其表示的时间</p>
<p>获取当前的时间戳：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">方法<span class="number">1</span>：<span class="keyword">var</span> timestamp1 = <span class="title class_">Date</span>.<span class="title function_">now</span>()</span><br><span class="line">方法<span class="number">2</span>：<span class="keyword">var</span> date = <span class="keyword">new</span> <span class="title class_">Date</span>()</span><br><span class="line">	  <span class="keyword">var</span> timestamp2 = date.<span class="title function_">getTime</span>()</span><br><span class="line">方法<span class="number">3</span>：<span class="variable language_">console</span>.<span class="title function_">log</span>(+date)  <span class="comment">// +运算符</span></span><br><span class="line">可写为：<span class="keyword">var</span> timestamp5 = +<span class="keyword">new</span> <span class="title class_">Date</span>()</span><br></pre></td></tr></table></figure>

<p>将一个对象转成时间戳：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> date2 = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&quot;2033-03-03&quot;</span>)</span><br><span class="line">方法<span class="number">1</span>：<span class="keyword">var</span> timestamp3 = date2.<span class="title function_">getTime</span>()</span><br><span class="line">方法<span class="number">2</span>：<span class="keyword">var</span> timestamp4 = date2.<span class="title function_">valueOf</span>()</span><br><span class="line">方法<span class="number">3</span>：<span class="variable language_">console</span>.<span class="title function_">log</span>(+date2)</span><br><span class="line">可写为：<span class="keyword">var</span> timestamp6 = +<span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&quot;2033-03-03&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>时间戳的作用：例如：计算一个操作花费的时间</p>
<h4 id="5-Date-parse-方法"><a href="#5-Date-parse-方法" class="headerlink" title="5.Date.parse 方法"></a>5.Date.parse 方法</h4><p> Date.parse(str) 方法可以从一个字符串中读取日期，并且输出对应的Unix时间戳</p>
<ul>
<li><p>作用等同于 new Date(dateString).getTime() 操作</p>
</li>
<li><p>需要符合 RFC2822 或 ISO 8601 日期格式的字符串</p>
</li>
<li><p>其他格式也许也支持，但结果不能保证一定正常</p>
</li>
<li><p>如果输入的格式不能被解析，那么会返回NaN</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> timeString = <span class="string">&quot;2033-2-3&quot;</span></span><br><span class="line"><span class="keyword">var</span> timestamp = <span class="title class_">Date</span>.<span class="title function_">parse</span>(timeString)</span><br></pre></td></tr></table></figure>



<h2 id="10-JavaScript-的-DOM-操作"><a href="#10-JavaScript-的-DOM-操作" class="headerlink" title="10.JavaScript 的 DOM 操作"></a>10.JavaScript 的 DOM 操作</h2><h3 id="1、什么是DOM"><a href="#1、什么是DOM" class="headerlink" title="1、什么是DOM"></a>1、什么是DOM</h3><p>学完以上ECMAScript 语法，我们还需要学习浏览器提供开发者的DOM、BOM相关的API才能对网页、浏览器进行操作</p>
<p>window 全局对象不仅提供了js语法部分的Object\Arry\Date等，也提供了DOM\BOM部分</p>
<p>DOM：浏览器考虑到开发者与用户可能需要对网页元素做某些操作，会将网页元素抽象成JS对象</p>
<ul>
<li>即将网页所有的元素表示为可以修改的对象</li>
<li>所以这些对象都可以通过 JS 来对其进行访问，所以可以通过 JS 来操作页面</li>
<li>这个抽象过程称之为文档对象模型，称之为 Document Object Model</li>
<li>作为了JS语法与网页元素的桥梁</li>
</ul>
<p>BOM：浏览器对象模型</p>
<ul>
<li>由浏览器提供的用于处理文档之外的所有的其他对象</li>
<li>比如 navigator、location、history 等对象</li>
</ul>
<h3 id="2、认识DOM-Tree"><a href="#2、认识DOM-Tree" class="headerlink" title="2、认识DOM Tree"></a>2、认识DOM Tree</h3><p>在 html 结构中，所有元素都会形成一个树结构（节点是元素）</p>
<p>抽象为 DOM 之后也会形成 DOM Tree （节点是抽象的对象）</p>
<h3 id="3、DOM-的整体结构"><a href="#3、DOM-的整体结构" class="headerlink" title="3、DOM 的整体结构"></a>3、DOM 的整体结构</h3><p>DOM相当于是JavaScript和HTML、CSS之间的桥梁</p>
<ul>
<li>通过浏览器提供给我们的DOM API，我们可以对元素以及其中的内容做任何事情；</li>
</ul>
<p>DOM的继承关系</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230309102756157.png" alt="image-20230309102756157"></p>
<p>document 对象</p>
<p>Document节点表示的整个载入的网页，它的实例是全局的document对象：</p>
<ul>
<li><p>对DOM的所有操作都是从 document 对象开始的</p>
</li>
<li><p>它是DOM的入口点，可以从document开始去访问任何节点元素</p>
</li>
</ul>
<p>对于最顶层的html、head、body元素，我们可以直接在document对象中获取到：</p>
<ul>
<li><p>html元素： &#x3D; document.documentElement</p>
</li>
<li><p>body元素： &#x3D; document.body</p>
</li>
<li><p>head元素： &#x3D; document.head</p>
</li>
<li><p>文档声明： &#x3D; document.doctype</p>
</li>
</ul>
<h3 id="4、节点、元素导航"><a href="#4、节点、元素导航" class="headerlink" title="4、节点、元素导航"></a>4、节点、元素导航</h3><h4 id="1-节点之间导航"><a href="#1-节点之间导航" class="headerlink" title="1.节点之间导航"></a>1.节点之间导航</h4><p>如果我们获取到一个节点（Node）后，可以根据这个节点去获取其他的节点，我们称之为节点之间的导航</p>
<p>节点之间存在如下的关系：</p>
<ul>
<li><p>父节点：parentNode</p>
</li>
<li><p>前兄弟节点：previousSibling</p>
</li>
<li><p>后兄弟节点：nextSibling</p>
</li>
<li><p>子节点：childNodes</p>
</li>
<li><p>第一个子节点：firstChild</p>
</li>
<li><p>第二个子节点：lastChild</p>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230311132712739.png" alt="image-20230311132712739"></p>
<h4 id="2-元素之间导航"><a href="#2-元素之间导航" class="headerlink" title="2.元素之间导航"></a>2.元素之间导航</h4><p>如果我们获取到一个元素（Element）后，可以根据这个元素去获取其他的元素，我们称之为元素之间的导航。</p>
<p>节点之间存在如下的关系：</p>
<ul>
<li><p>父元素：parentElement</p>
</li>
<li><p>前兄弟节点：previousElementSibling</p>
</li>
<li><p>后兄弟节点：nextElementSibling</p>
</li>
<li><p>子节点：children</p>
</li>
<li><p>第一个子节点：firstElementChild</p>
</li>
<li><p>第二个子节点：lastElementChild</p>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230311132841099.png" alt="image-20230311132841099"></p>
<h4 id="3-table元素之间的导航"><a href="#3-table元素之间的导航" class="headerlink" title="3.table元素之间的导航"></a>3.table元素之间的导航</h4><p>table 还元素支持以下这些属性：</p>
<ul>
<li><p>table.rows —  tr元素的集合</p>
</li>
<li><p>table.caption&#x2F;tHead&#x2F;tFoot — 引用元素caption、thead、tfoot </p>
</li>
<li><p>table.tBodies — tbody 元素的集合</p>
</li>
</ul>
<p>thead、tfoot、tbody 元素提供了 rows 属性</p>
<ul>
<li>tbody.rows — 表格内部 tr 元素的集合</li>
</ul>
<p>tr：</p>
<ul>
<li><p>tr.cells — 在给定 tr 中的 td 和 th 单元格的集合</p>
</li>
<li><p>tr.sectionRowIndex — 给定的 tr 在封闭的 thead&#x2F;tbody&#x2F;tfoot 中的位置（索引）</p>
</li>
<li><p>tr.rowIndex — 在整个表格中 tr 的编号（包括表格的所有行）</p>
</li>
</ul>
<p>td 和 th</p>
<ul>
<li>td.cellIndex — 在封闭的 tr 中单元格的编号</li>
</ul>
<h4 id="4-form元素之间的导航"><a href="#4-form元素之间的导航" class="headerlink" title="4.form元素之间的导航"></a>4.form元素之间的导航</h4><p>获取 form 元素可以通过节点和元素的方法获取，也可以通过forms获取；</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> formEl = <span class="variable language_">document</span>.<span class="property">forms</span>[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<p>form 元素中的内容可以通过 elements 来获取：form.elements</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> elements = formEl.<span class="property">elements</span></span><br></pre></td></tr></table></figure>

<p>获取 form 中的子元素还可以通过 name 其属性获取</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> inputEl = formEl.<span class="property">elements</span>.<span class="property">account</span></span><br></pre></td></tr></table></figure>

<p>作用是有时能够以此来获取 input 表单的 value</p>
<h3 id="5、获取元素的方法"><a href="#5、获取元素的方法" class="headerlink" title="5、获取元素的方法"></a>5、获取元素的方法</h3><p>DOM 提供的获取元素的方法：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>搜索方式</th>
<th>可以在元素上调用？</th>
<th>实时？</th>
</tr>
</thead>
<tbody><tr>
<td>querySelector</td>
<td>css-selector</td>
<td>√</td>
<td>-</td>
</tr>
<tr>
<td>querySelectorAll</td>
<td>css-selector</td>
<td>√</td>
<td>-</td>
</tr>
<tr>
<td>getElementById</td>
<td>id</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>getElementByName</td>
<td>name</td>
<td>-</td>
<td>√</td>
</tr>
<tr>
<td>getElementByTagName</td>
<td>tar or ‘*’</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>getElementByClassName</td>
<td>class</td>
<td>√</td>
<td>√</td>
</tr>
</tbody></table>
<p>目前最常用的是querySelector和querySelectAll </p>
<p>getElementById偶尔也会使用或者在适配一些低版本浏览器时；</p>
<h3 id="6、Node-节点的属性"><a href="#6、Node-节点的属性" class="headerlink" title="6、Node 节点的属性"></a>6、Node 节点的属性</h3><h4 id="1-nodeType属性："><a href="#1-nodeType属性：" class="headerlink" title="1.nodeType属性："></a>1.nodeType属性：</h4><ul>
<li><p>nodeType 属性提供了一中获取节点类型的方法</p>
</li>
<li><p>它有一个数值型值</p>
</li>
</ul>
<p>常见的节点类型：</p>
<table>
<thead>
<tr>
<th>常量</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Node.ELEMENT_NODE</td>
<td>1</td>
<td>一个元素节点，例如p元素和div元素</td>
</tr>
<tr>
<td>Node.TEXT_NODE</td>
<td>3</td>
<td>Element 或者 Attr 中实际的 文字</td>
</tr>
<tr>
<td>Node.COMMENT_NODE</td>
<td>8</td>
<td>一个 Comment 节点。</td>
</tr>
<tr>
<td>Node.DOCUMENT_NODE</td>
<td>9</td>
<td>一个 Document 节点。</td>
</tr>
<tr>
<td>Node.DOCUMENT_TYPE_NODE</td>
<td>10</td>
<td>描述文档类型的DocumentType 节点。例如<!DCOTYPE html></td>
</tr>
</tbody></table>
<p>nodeName：获取节点的名字</p>
<p>tagName：获取元素的名称</p>
<ul>
<li><p>tagName 属性仅适用于 Element 节点；</p>
</li>
<li><p>nodeName 是为任意 Node 定义的：</p>
<ul>
<li>对于元素，它的意义与 tagName 相同，所以使用哪一个都是可以的；</li>
<li>对于其他节点类型（text，comment 等），它拥有一个对应节点类型的字符串</li>
</ul>
</li>
</ul>
<p>nodeValue&#x2F;data： 用于获取非元素节点的文本内容</p>
<p>innerHTML 属性</p>
<ul>
<li>将元素中的 HTML 获取为字符串形式； </li>
<li>设置元素中的内容；</li>
</ul>
<p>outerHTML 属性</p>
<ul>
<li>包含了元素的完整 HTML</li>
<li>innerHTML 加上元素本身一样；</li>
</ul>
<p>textContent 属性</p>
<ul>
<li>仅仅获取元素中的文本内容；</li>
</ul>
<p>innerHTML和textContent的区别：</p>
<ul>
<li>仅仅设置文本的话作用相同</li>
</ul>
<p>内容带标签的话</p>
<ul>
<li><p>使用 innerHTML，我们将其“作为 HTML”插入，带有所有 HTML 标签</p>
</li>
<li><p>使用 textContent，我们将其“作为文本”插入，所有符号（symbol）均按字面意义处理</p>
</li>
</ul>
<p>全局属性 hidden：可以用于设置元素隐藏</p>
<p>一个元素除了有开始标签、结束标签、内容之外，还有很多的属性（attribute）</p>
<p>浏览器在解析HTML元素时，会将对应的attribute也创建出来放到对应的元素对象上。</p>
<ul>
<li><p>比如id、class就是全局的attribute，会有对应的id、class属性；</p>
</li>
<li><p>比如href属性是针对a元素的，type、value属性是针对input元素的；</p>
</li>
</ul>
<p>Attribute 的分类：</p>
<p>1.如果是HTML标准制定的Attribute，称之为标准的Attribute</p>
<p>2.而自定义的Attribute，称之为非标准的Attribute</p>
<h4 id="2-Attribute-属性的操作："><a href="#2-Attribute-属性的操作：" class="headerlink" title="2.Attribute 属性的操作："></a>2.Attribute 属性的操作：</h4><p>对于所有的（标准的和自定义的）attribute访问都支持如下的方法：</p>
<ul>
<li><p>elem.hasAttribute(name) — 检查特性是否存在。</p>
</li>
<li><p>elem.getAttribute(name) — 获取这个特性值。（字符串类型）（不存在则返回 null）</p>
</li>
<li><p>elem.setAttribute(name, value) — 设置这个特性值。</p>
</li>
<li><p>elem.removeAttribute(name) — 移除这个特性。</p>
</li>
<li><p>attributes：attr对象的集合，具有name、value属性</p>
</li>
</ul>
<p>attribute具备以下特征：</p>
<ul>
<li><p>它们的名字是大小写不敏感的（id 与 ID 相同）。</p>
</li>
<li><p>它们的值总是字符串类型的。</p>
</li>
</ul>
<h4 id="3-元素的属性-property"><a href="#3-元素的属性-property" class="headerlink" title="3.元素的属性 property"></a>3.元素的属性 property</h4><p>对于 HTML 元素，在元素中称其属性为 attribute，通过js获取元素对象之后（通过property获取attribute的值），称之为元素的对象模型。</p>
<p>对于标准的attribute，会在DOM对象上创建与其对应的property属性：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里的id称之为property</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(boxEl.<span class="property">id</span>, boxEl.<span class="property">age</span>, boxEl.<span class="property">height</span>,boxEl.<span class="property">title</span>)</span><br></pre></td></tr></table></figure>

<p>不是标准的属性的话（自定义）返回值为 undefined</p>
<p>在大多数情况下，它们是相互作用的</p>
<ul>
<li><p>改变property，通过attribute获取的值，会随着改变；</p>
</li>
<li><p>通过attribute操作修改，property的值会随着改变；</p>
<ul>
<li>但是input的value修改只能通过attribute的方法；</li>
</ul>
</li>
</ul>
<p>大多数情况下，设置、获取attribute，推荐使用property的方式：这是因为它默认情况下是有类型的；</p>
<p>*<em>HTML5的data-<em>自定义属性，那么它们也是可以在dataset属性中获取到的</em></em></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230405193102932.png" alt="image-20230405193102932"></p>
<h4 id="4-JavaScript中动态修改样式"><a href="#4-JavaScript中动态修改样式" class="headerlink" title="4.JavaScript中动态修改样式"></a>4.JavaScript中动态修改样式</h4><p>有时候我们会通过JavaScript来动态修改样式，这个时候我们有两个选择：</p>
<ul>
<li><p>选择一：在CSS中编写好对应的样式，动态的添加class；</p>
</li>
<li><p>选择二：动态的修改style属性；</p>
</li>
</ul>
<p>开发中如何选择呢？</p>
<ul>
<li><p>在大多数情况下，如果可以动态修改class完成某个功能，更推荐使用动态class；</p>
</li>
<li><p>如果对于某些情况，无法通过动态修改class（比如精准修改某个css属性的值），那么就可以修改style属性</p>
</li>
</ul>
<p>元素的 className 和 classList</p>
<p>元素的class attribute，对应的property并非叫class，而是className：</p>
<p>这是因为JavaScript早期是不允许使用class这种关键字来作为对象的属性，所以DOM规范使用了className；</p>
<p>虽然现在JavaScript已经没有这样的限制，但是并不推荐，并且依然在使用className这个名称</p>
<p>对className进行赋值，<strong>它会替换整个类中的字符串</strong></p>
<p>如果我们需要添加或者移除单个的class，那么可以使用classList属性。</p>
<p>elem.classList 是一个特殊的对象：</p>
<ul>
<li><p>elem.classList.add (class) ：添加一个类</p>
</li>
<li><p>elem.classList.remove(class)：添加&#x2F;移除类。</p>
</li>
<li><p>elem.classList.toggle(class) ：如果类不存在就添加类，存在就移除它。</p>
</li>
<li><p>elem.classList.contains(class)：检查给定类，返回 true&#x2F;false。</p>
</li>
</ul>
<p>classList是可迭代对象，可以通过for of进行遍历。</p>
<p>元素的 style 属性</p>
<p>如果需要单独修改某一个CSS属性，那么可以通过style来操作：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">boxEl.<span class="property">style</span>.<span class="property">fontSize</span> = <span class="string">&quot;30px&quot;</span></span><br></pre></td></tr></table></figure>

<p>对于多词（multi-word）属性，使用驼峰式（小驼峰） camelCase</p>
<p>如果我们将值设置为空字符串，那么会使用CSS的默认样式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">boxEl.<span class="property">style</span>.<span class="property">fontSize</span> = <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>多个样式的写法，我们需要使用cssText属性：</p>
<p>不推荐这种用法，<strong>因为它会替换整个字符串</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">boxEl.<span class="property">style</span>.<span class="property">cssText</span> = <span class="string">&#x27;font-size: 30px; color: red;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>元素 style 的读取</p>
<p> 对于内联样式，是可以通过style.*的方式读取到的；</p>
<p>对于style、css文件中的样式，是读取不到的</p>
<p>这个时候，我们可以通过getComputedStyle的全局函数来实现</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getComputedStyle</span>(boxEl).<span class="property">fontSize</span>)</span><br></pre></td></tr></table></figure>



<h4 id="5-创建元素"><a href="#5-创建元素" class="headerlink" title="5.创建元素"></a>5.创建元素</h4><p>document.write：非常便捷，但是对于复杂的内容、元素关系拼接并不方便</p>
<h5 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h5><ul>
<li>步骤一：创建元素：document.createElement(tag)</li>
<li>步骤二：插入元素到 DOM 的某一个位置</li>
</ul>
<p>插入方式：</p>
<ul>
<li><p>node.append(…nodes or strings) —— 在 node 末尾插入节点或字符串</p>
</li>
<li><p>node.prepend(…nodes or strings) —— 在 node 开头插入节点或字符串</p>
</li>
<li><p>node.before(…nodes or strings) —— 在 node 前面插入节点或字符串</p>
</li>
<li><p>node.after(…nodes or strings) —— 在 node 后面插入节点或字符串</p>
</li>
<li><p>node.replaceWith(…nodes or strings) —— 将 node 替换为给定的节点或字符串</p>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230312090927700.png" alt="image-20230312090927700"></p>
<h5 id="移除和克隆元素"><a href="#移除和克隆元素" class="headerlink" title="移除和克隆元素"></a>移除和克隆元素</h5><p>移除元素我们可以调用元素本身的remove方法：</p>
<p>想要复制一个现有的元素，可以通过cloneNode方法：</p>
<ul>
<li><p>可以传入一个Boolean类型的值，来决定是否是深度克隆；</p>
</li>
<li><p>深度克隆会克隆对应元素的子元素，否则不会；</p>
</li>
</ul>
<h5 id="旧方法操作元素（了解）"><a href="#旧方法操作元素（了解）" class="headerlink" title="旧方法操作元素（了解）"></a>旧方法操作元素（了解）</h5><p>parentElem.appendChild(node)： </p>
<ul>
<li>在parentElem的父元素最后位置添加一个子元素</li>
</ul>
<p>parentElem.insertBefore(node, nextSibling)：</p>
<ul>
<li>在parentElem的nextSibling前面插入一个子元素；</li>
</ul>
<p>parentElem.replaceChild(node, oldChild)：</p>
<ul>
<li>在parentElem中，新元素替换之前的oldChild元素；</li>
</ul>
<p>parentElem.removeChild(node)：</p>
<ul>
<li>在parentElem中，移除某一个元素；</li>
</ul>
<h4 id="6-元素的大小、滚动"><a href="#6-元素的大小、滚动" class="headerlink" title="6.元素的大小、滚动"></a>6.元素的大小、滚动</h4><p>clientWidth：contentWith+padding（不包含滚动条）</p>
<p>clientHeight：contentHeight+padding</p>
<p>clientTop：border-top的宽度</p>
<p>clientLeft：border-left的宽度</p>
<p>offsetWidth：元素完整的宽度</p>
<p>offsetHeight：元素完整的高度</p>
<p>offsetLeft：距离父元素的x</p>
<p>offsetHeight：距离父元素的y</p>
<p>scrollHeight：整个可滚动的区域高度</p>
<p>scrollTop：滚动部分的高度</p>
<h4 id="7-window的大小、滚动"><a href="#7-window的大小、滚动" class="headerlink" title="7.window的大小、滚动"></a>7.window的大小、滚动</h4><p>window的width和height</p>
<ul>
<li><p>innerWidth、innerHeight：获取window窗口的宽度和高度（包含滚动条）</p>
</li>
<li><p>outerWidth、outerHeight：获取window窗口的整个宽度和高度（包括调试工具、工具栏）</p>
</li>
<li><p>documentElement.clientHeight、documentElement.clientWidth：获取html的宽度和高度（不包含滚动条）</p>
</li>
</ul>
<p>indow的滚动位置：</p>
<ul>
<li><p>scrollX：X轴滚动的位置（别名pageXOffset）</p>
</li>
<li><p>scrollY：Y轴滚动的位置（别名pageYOffset）</p>
</li>
</ul>
<p>也有提供对应的滚动方法：</p>
<ul>
<li><p>方法 scrollBy(x,y) ：将页面滚动至相对于当前位置的 (x, y) 位置；</p>
</li>
<li><p>方法 scrollTo(pageX,pageY) 将页面滚动至绝对坐标；</p>
</li>
</ul>
<h2 id="11-JavaScript-中的事件"><a href="#11-JavaScript-中的事件" class="headerlink" title="11.JavaScript 中的事件"></a>11.JavaScript 中的事件</h2><h3 id="1、认识事件"><a href="#1、认识事件" class="headerlink" title="1、认识事件"></a>1、认识事件</h3><p>Web页面需要经常和用户之间进行交互，而交互的过程中我们可能想要捕捉这个交互的过程：</p>
<p>比如用户点击了某个按钮、用户在输入框里面输入了某个文本、用户鼠标经过了某个位置；</p>
<p>浏览器需要搭建一条JavaScript代码和事件之间的桥梁；</p>
<p>当某个事件发生时，让JavaScript可以响应（执行某个函数），所以我们需要针对事件编写处理程序（handler）</p>
<ul>
<li><p>事件监听方式一：在script中直接监听（很少使用）；</p>
</li>
<li><p>事件监听方式二：DOM属性，通过元素的on来监听事件；</p>
</li>
<li><p>事件监听方式三：通过EventTarget中的addEventListener来监听；</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;button onclick=<span class="string">&quot;console.log(&#x27;按钮1发生了点击~&#x27;)&quot;</span>&gt;按钮<span class="number">1</span>&lt;/button&gt;</span><br><span class="line">btn2El.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;按钮2发生了点击&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">btn3El.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;btn3的事件监听1&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h4 id="常见的事件列表"><a href="#常见的事件列表" class="headerlink" title="常见的事件列表"></a>常见的事件列表</h4><p>鼠标事件</p>
<ul>
<li>click —— 当鼠标点击一个元素时（触摸屏设备会在点击时生成）</li>
<li>mouseover &#x2F; mouseout —— 当鼠标指针移入&#x2F;离开一个元素时</li>
<li>mousedown &#x2F; mouseup —— 当在元素上按下&#x2F;释放鼠标按钮时</li>
<li>mousemove —— 当鼠标移动时</li>
</ul>
<p>键盘事件</p>
<ul>
<li>keydown 和 keyup —— 当按下和松开一个按键时</li>
</ul>
<p>表单（form）元素事件</p>
<ul>
<li>submit —— 当访问者提交了一个 form 时</li>
<li>focus —— 当访问者聚焦于一个元素时，例如聚焦于一个 input</li>
</ul>
<p>Document 事件</p>
<ul>
<li>DOMContentLoaded —— 当 HTML 的加载和处理均完成，DOM 被完全构建完成时</li>
</ul>
<p>CSS 事件</p>
<ul>
<li>transitionend —— 当一个 CSS 动画完成时。</li>
</ul>
<h3 id="2、认识事件流"><a href="#2、认识事件流" class="headerlink" title="2、认识事件流"></a>2、认识事件流</h3><h4 id="1-产生"><a href="#1-产生" class="headerlink" title="1.产生"></a>1.产生</h4><p>当我们在浏览器上对着一个元素点击时，你点击的不仅仅是这个元素本身；</p>
<p>这是因为我们的HTML元素是存在父子元素叠加层级的；</p>
<p>比如一个span元素是放在div元素上的，div元素是放在body元素上的，body元素是放在html元素上的</p>
<h4 id="2-事件冒泡和事件捕获"><a href="#2-事件冒泡和事件捕获" class="headerlink" title="2.事件冒泡和事件捕获"></a>2.事件冒泡和事件捕获</h4><p>默认情况下事件是从最内层的span向外依次传递的顺序，这个顺序我们称之为事件冒泡（Event Bubble）;</p>
<p>事实上，还有另外一种监听事件流的方式就是从外层到内层，这种称之为事件捕获（Event Capture）；</p>
<p>为什么会产生两种不同的处理流呢？</p>
<ul>
<li><p>这是因为早期浏览器开发时，不管是IE还是Netscape公司都发现了这个问题;</p>
</li>
<li><p>但是他们采用了完全相反的事件流来对事件进行了传递；</p>
</li>
<li><p>IE采用了事件冒泡的方式，Netscape采用了事件捕获的方式；</p>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230403204855424.png"></p>
<p>过程：</p>
<p>如果我们都对其进行监听，则执行顺序：</p>
<ul>
<li><p>捕获阶段：事件（从 Window）向下走近元素</p>
</li>
<li><p>目标阶段：目标阶段（Target phase）</p>
</li>
<li><p>冒泡阶段：冒泡阶段（Bubbling phase）</p>
</li>
</ul>
<p>事实上，我们可以通过event对象来获取当前的阶段：eventPhase</p>
<p>开发中通常会使用事件冒泡，所以事件捕获了解即可</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230403205036219.png" alt="image-20230403205036219"></p>
<h3 id="3、事件对象"><a href="#3、事件对象" class="headerlink" title="3、事件对象"></a>3、事件对象</h3><p>当一个事件发生时，就会有和这个事件相关的很多信息：</p>
<ul>
<li><p>比如事件的类型是什么，你点击的是哪一个元素，点击的位置是哪里等等相关的信息；</p>
</li>
<li><p>这些信息会被封装到一个Event对象中，这个对象由浏览器创建，称之为event对象；</p>
</li>
<li><p>该对象给我们提供了想要的一些属性，以及可以通过该对象进行某些操作；</p>
</li>
</ul>
<p>如何获取这个event对象呢？</p>
<ul>
<li><p>event对象会在传入的事件处理（event handler）函数回调时，被系统传入；</p>
</li>
<li><p>我们可以在回调函数中拿到这个event对象；</p>
</li>
</ul>
<h4 id="event-常见的属性"><a href="#event-常见的属性" class="headerlink" title="event 常见的属性"></a>event 常见的属性</h4><p>type：事件的类型；</p>
<p><strong>target：当前事件发生的元素；</strong></p>
<p><strong>currentTarget：当前处理事件的元素；</strong></p>
<p>eventPhase：事件所处的阶段；</p>
<p>offsetX、offsetY：事件发生在元素内的位置；</p>
<p>clientX、clientY：事件发生在客户端内的位置；</p>
<p>pageX、pageY：事件发生在客户端相对于document的位置；</p>
<p>screenX、screenY：事件发生相对于屏幕的位置；</p>
<p>常见的方法：</p>
<ul>
<li><p>preventDefault：取消事件的默认行为；</p>
</li>
<li><p>stopPropagation：阻止事件的进一步传递（冒泡或者捕获都可以阻止）；</p>
</li>
</ul>
<p>事件处理中的 this</p>
<p>在函数中，我们也可以通过 this 来获取当前的发生元素</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btnEl = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;button&quot;</span>)</span><br><span class="line"><span class="keyword">var</span> divEl = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;div&quot;</span>)</span><br><span class="line"></span><br><span class="line">divEl.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">currentTarget</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(divEl)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span> === divEl)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是因为在浏览器内部，调用 event handler是绑定到当前的 currentTarget 上的</p>
<h3 id="4、EventTarget-类"><a href="#4、EventTarget-类" class="headerlink" title="4、EventTarget 类"></a>4、EventTarget 类</h3><p>所有的节点、元素都继承自EventTarget，事实上Window也继承自EventTarget</p>
<p><strong>EventTarget是一个DOM接口，主要用于添加、删除、派发Event事件；</strong></p>
<p>EventTarget常见的方法：</p>
<ul>
<li><p>addEventListener：注册某个事件类型以及事件处理函数；</p>
</li>
<li><p>removeEventListener：移除某个事件类型以及事件处理函数；</p>
</li>
<li><p>dispatchEvent：派发某个事件类型到 EventTarget 上；</p>
</li>
</ul>
<h3 id="5、事件委托"><a href="#5、事件委托" class="headerlink" title="5、事件委托"></a>5、事件委托</h3><p>事件冒泡在某种情况下可以帮助我们实现强大的事件处理模式 – 事件委托模式（也是一种设计模式）</p>
<ul>
<li><p>当子元素被点击时，父元素可以通过冒泡可以监听到子元素的点击；</p>
</li>
<li><p>并且可以通过event.target获取到当前监听的元素；</p>
</li>
</ul>
<p>案例：一个ul中存放多个li，点击某一个li会变成红色</p>
<ul>
<li><p>方案一：监听每一个li的点击，并且做出相应</p>
</li>
<li><p>方案二：在ul中监听点击，并且通过event.target拿到对应的li进行处理</p>
<ul>
<li>因为这种方案并不需要遍历后给每一个li上添加事件监听，所以它更加高效</li>
</ul>
</li>
</ul>
<h4 id="事件委托的标记"><a href="#事件委托的标记" class="headerlink" title="事件委托的标记"></a>事件委托的标记</h4><p>某些事件委托可能需要对具体的子组件进行区分，这个时候我们可以使用data-*对其进行标记：</p>
<p>比如多个按钮的点击，区分点击了哪一个按钮</p>
<h3 id="6、常见的事件"><a href="#6、常见的事件" class="headerlink" title="6、常见的事件"></a>6、常见的事件</h3><h4 id="1-常见的鼠标事件"><a href="#1-常见的鼠标事件" class="headerlink" title="1.常见的鼠标事件"></a>1.常见的鼠标事件</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230404201639786.png" alt="image-20230404201639786"></p>
<h4 id="2-mouseover和mouseenter的区别"><a href="#2-mouseover和mouseenter的区别" class="headerlink" title="2.mouseover和mouseenter的区别"></a>2.mouseover和mouseenter的区别</h4><p>mouseenter和mouseleave</p>
<ul>
<li>不支持冒泡</li>
<li>进入子元素依然属于在该元素内，没有任何反应</li>
</ul>
<p>mouseover和mouseout</p>
<ul>
<li>支持冒泡</li>
<li>进入元素的子元素时<ul>
<li>先调用父元素的mouseout</li>
<li>再调用子元素的mouseover</li>
<li>因为支持冒泡，所以会将mouseover传递到父元素中</li>
</ul>
</li>
</ul>
<h4 id="3-常见的键盘事件"><a href="#3-常见的键盘事件" class="headerlink" title="3.常见的键盘事件"></a>3.常见的键盘事件</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230404201729813.png" alt="image-20230404201729813"></p>
<p>事件的执行顺序是 onkeydown、onkeypress、onkeyup</p>
<ul>
<li><p>down事件先发生</p>
</li>
<li><p>press发生在文本被输入</p>
</li>
<li><p>up发生在文本输入完成</p>
</li>
</ul>
<p>通过key和code来区分按下的键：</p>
<ul>
<li>code：“按键代码”（”KeyA”，”ArrowLeft” 等），特定于键盘上按键的物理位置</li>
<li>key：字符（”A”，”a” 等），对于非字符（non-character）的按键，通常具有与 code 相同的值</li>
</ul>
<h4 id="4-常见的表单事件"><a href="#4-常见的表单事件" class="headerlink" title="4.常见的表单事件"></a>4.常见的表单事件</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230403205650505.png" alt="image-20230403205650505"></p>
<h4 id="5-文档加载事件"><a href="#5-文档加载事件" class="headerlink" title="5.文档加载事件"></a>5.文档加载事件</h4><ul>
<li><p>DOMContentLoaded：浏览器已完全加载 HTML，并构建了 DOM 树，但像和样式表之类的外部资源可能尚未加载 完成</p>
</li>
<li><p>load：浏览器不仅加载完成了 HTML，还加载完成了所有外部资源：图片，样式等</p>
</li>
</ul>
<p>事件类型：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://developer.mozilla.org/zh-CN/docs/Web/Events">https://developer.mozilla.org/zh-CN/docs/Web/Events</a></p>
<h2 id="12-DOM阶段案例"><a href="#12-DOM阶段案例" class="headerlink" title="12.DOM阶段案例"></a>12.DOM阶段案例</h2><p>定时器</p>
<p>消息滚动</p>
<p>关闭弹窗</p>
<p>侧边栏触控展示</p>
<p>登录展示</p>
<p>tab栏切换</p>
<p>轮播图的实现</p>
<p>购物车操作</p>
<h2 id="13-JavaScript中的BOM操作"><a href="#13-JavaScript中的BOM操作" class="headerlink" title="13.JavaScript中的BOM操作"></a>13.JavaScript中的BOM操作</h2><h3 id="1、认识BOM操作"><a href="#1、认识BOM操作" class="headerlink" title="1、认识BOM操作"></a>1、认识BOM操作</h3><p>BOM：浏览器对象模型（Brower Object Model）</p>
<ul>
<li><p>简称 BOM，由浏览器提供的用于处理文档（document）之外的所有内容的其他对象</p>
</li>
<li><p>比如navigator、location、history等对象</p>
</li>
</ul>
<p>JavaScript有一个非常重要的运行环境就是浏览器</p>
<ul>
<li>而且浏览器本身又作为一个应用程序需要对其本身进行操作</li>
<li>所以通常浏览器会有对应的对象模型（BOM，Browser Object Model）</li>
<li>我们可以将BOM看成是连接 JavaScript 脚本与浏览器窗口的桥梁</li>
</ul>
<p>BOM主要包括一下的对象模型：</p>
<ul>
<li>window：包括全局属性、方法，控制浏览器窗口相关的属性、方法</li>
<li>location：浏览器连接到的对象的位置（URL）</li>
<li>history：操作浏览器的历史</li>
<li>navigator：用户代理（浏览器）的状态和标识（很少用到）</li>
<li>screen：屏幕窗口信息（很少用到）</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230403201933683.png" alt="image-20230403201933683"></p>
<h3 id="2、全局对象window"><a href="#2、全局对象window" class="headerlink" title="2、全局对象window"></a>2、全局对象window</h3><p>window对象在浏览器中可以从两个视角来看待：</p>
<ul>
<li><p>视角一：全局对象</p>
<ul>
<li>我们知道ECMAScript其实是有一个全局对象的，这个全局对象在Node中是global</li>
<li>在浏览器中就是window对象</li>
</ul>
</li>
<li><p>视角二：浏览器窗口对象</p>
<ul>
<li>作为浏览器窗口时，提供了对浏览器操作的相关的API</li>
</ul>
</li>
</ul>
<p>这两个视角存在大量重叠的地方，不需要刻意去区分它们：</p>
<ul>
<li><p>事实上对于浏览器和Node中全局对象名称不一样的情况，目前已经指定了对应的标准，称之为globalThis，并且大多数现代 浏览器都支持它</p>
</li>
<li><p>放在window对象上的所有属性都可以被访问</p>
</li>
<li><p>使用var定义的变量会被添加到window对象中</p>
</li>
<li><p>window默认给我们提供了全局的函数和类：setTimeout、Math、Date、Object等</p>
</li>
</ul>
<p>事实上window对象上肩负的重担是非常大的：</p>
<ul>
<li><p>第一：包含大量的属性，localStorage、console、location、history、screenX、scrollX等</p>
</li>
<li><p>第二：包含大量的方法，alert、close、scrollTo、open等等（大概40+个方法）</p>
</li>
<li><p>第三：包含大量的事件，focus、blur、load、hashchange等等（大概30+个事件）</p>
</li>
<li><p>第四：包含从EventTarget继承过来的方法，addEventListener、removeEventListener、dispatchEvent方法；</p>
</li>
</ul>
<p>属性、方法、事件在MDN文档查看：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window">https://developer.mozilla.org/zh-CN/docs/Web/API/Window</a></p>
<p>查看MDN文档时不同的符号的意思：</p>
<ul>
<li><p>删除符号：表示这个API已经废弃，不推荐继续使用了</p>
</li>
<li><p>点踩符号：表示这个API不属于W3C规范，某些浏览器有实现（所以兼容性的问题）</p>
</li>
<li><p>实验符号：该API是实验性特性，以后可能会修改，并且存在兼容性问题</p>
</li>
</ul>
<p>window 常见的属性</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">outerHeight</span>)</span><br></pre></td></tr></table></figure>

<p>window 常见的方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> openBtn = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;.open&quot;</span>)</span><br><span class="line"></span><br><span class="line">    openBtn.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">window</span>.<span class="title function_">open</span>(<span class="string">&quot;./page/new.html&quot;</span>, <span class="string">&quot;_blank&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> closeBtn = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;.close&quot;</span>)</span><br><span class="line"></span><br><span class="line">    closeBtn.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">window</span>.<span class="title function_">close</span>()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>window 常见的事件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// window.onfocus = function() &#123;</span></span><br><span class="line">    <span class="comment">//   console.log(&quot;窗口获得了焦点&quot;)</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// window.onblur = function() &#123;</span></span><br><span class="line">    <span class="comment">//   console.log(&quot;窗口失去了焦点&quot;)</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="variable language_">window</span>.<span class="property">onhashchange</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hash值发生了改变&quot;</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="3、location对象"><a href="#3、location对象" class="headerlink" title="3、location对象"></a>3、location对象</h3><p>location对象用于表示window上当前链接到的URL信息</p>
<p>常见的属性：</p>
<ul>
<li>href: 当前window对应的超链接URL, 整个URL</li>
<li>protocol: 当前的协议；  host: 主机地址</li>
<li>hostname: 主机地址(不带端口)</li>
<li>port: 端口；  pathname: 路径</li>
<li>search: 查询字符串</li>
<li>hash: 哈希值</li>
<li>username：URL中的username（很多浏览器已经禁用）</li>
<li>password：URL中的password（很多浏览器已经禁用）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.完整的url</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(location.<span class="property">href</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2。获取url的信息</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(location.<span class="property">hostname</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(location.<span class="property">host</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(location.<span class="property">protocol</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(location.<span class="property">port</span>)</span><br></pre></td></tr></table></figure>

<p>location其实是URL的一个抽象实现：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230403202307394.png" alt="image-20230403202307394"></p>
<p>location有如下常用的方法：</p>
<ul>
<li>assign：赋值一个新的URL，并且跳转到该URL中</li>
<li>replace：打开一个新的URL，并且跳转到该URL中（不同的是不会在浏览记录中留下之前的记录）</li>
<li>reload：重新加载页面，可以传入一个Boolean类型</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">btns[<span class="number">0</span>].<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      location.<span class="title function_">assign</span>(<span class="string">&quot;https://www.baidu.com&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    btns[<span class="number">1</span>].<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      location.<span class="title function_">replace</span>(<span class="string">&quot;https://www.baidu.com&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    btns[<span class="number">2</span>].<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      location.<span class="title function_">reload</span>()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="4、URLSearchParams"><a href="#4、URLSearchParams" class="headerlink" title="4、URLSearchParams"></a>4、URLSearchParams</h3><p>URLSearchParams 定义了一些实用的方法来处理 URL 的查询字符串</p>
<ul>
<li><p>可以将一个字符串转化成URLSearchParams类型</p>
</li>
<li><p>也可以将一个URLSearchParams类型转成字符串</p>
</li>
</ul>
<p>URLSearchParams常见的方法有如下：</p>
<ul>
<li><p>get：获取搜索参数的值</p>
</li>
<li><p>set：设置一个搜索参数和值</p>
</li>
<li><p>append：追加一个搜索参数和值</p>
</li>
<li><p>has：判断是否有某个搜索参数</p>
</li>
<li><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://developer.mozilla.org/zh-CN/docs/Web/API/URLSearchParams">https://developer.mozilla.org/zh-CN/docs/Web/API/URLSearchParams</a></p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> urlSearchString = <span class="string">&quot;?name=wbh&amp;age=21&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(urlSearchString.<span class="title function_">split</span>(<span class="string">&quot;&amp;&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> searchParams = <span class="keyword">new</span> <span class="title class_">URLSearchParams</span>(urlSearchString)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(searchParams.<span class="title function_">get</span>(<span class="string">&quot;name&quot;</span>))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(searchParams.<span class="title function_">get</span>(<span class="string">&quot;age&quot;</span>))</span><br><span class="line"></span><br><span class="line">searchParams.<span class="title function_">append</span>(<span class="string">&quot;address&quot;</span>, <span class="string">&quot;广州市&quot;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(searchParams.<span class="title function_">get</span>(<span class="string">&quot;address&quot;</span>))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(searchParams.<span class="title function_">toString</span>())</span><br></pre></td></tr></table></figure>

<p>中文会使用encodeURIComponent和decodeURIComponent进行编码和解码</p>
<h3 id="5、history对象"><a href="#5、history对象" class="headerlink" title="5、history对象"></a>5、history对象</h3><p>history对象允许我们访问浏览器曾经的会话历史记录</p>
<p>有两个属性</p>
<ul>
<li><p>length：会话中的记录条数</p>
</li>
<li><p>state：当前保留的状态值</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(history.<span class="property">length</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(history.<span class="property">state</span>)</span><br></pre></td></tr></table></figure>

<p>有五个方法</p>
<ul>
<li>back()：返回上一页，等价于history.go(-1)</li>
<li>forward()：前进下一页，等价于history.go(1)</li>
<li>go()：加载历史中的某一页</li>
<li>pushState()：打开一个指定的地址</li>
<li>replaceState()：打开一个新的地址，并且使用replace；</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">btnEl.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// history.pushState(&#123;name:&quot;wd&quot;, age:&quot;23&quot;&#125;, &quot;&quot;, &quot;/why&quot;)</span></span><br><span class="line">      history.<span class="title function_">replaceState</span>(&#123;<span class="attr">name</span>:<span class="string">&quot;wd&quot;</span>, <span class="attr">age</span>:<span class="string">&quot;23&quot;</span>&#125;, <span class="string">&quot;&quot;</span>, <span class="string">&quot;/why&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> backEl = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;.back&quot;</span>)</span><br><span class="line">    backEl.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      history.<span class="title function_">back</span>()</span><br><span class="line">      history.<span class="title function_">forward</span>()</span><br><span class="line">      <span class="comment">// 类似于上面的两个方法，只是可以传入层级</span></span><br><span class="line">      history.<span class="title function_">go</span>(-<span class="number">2</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>history和hash目前是vue、react等框架实现路由的底层原理</p>
<h3 id="6、navigator、screen（很少用）"><a href="#6、navigator、screen（很少用）" class="headerlink" title="6、navigator、screen（很少用）"></a>6、navigator、screen（很少用）</h3><p>navigator 对象表示用户代理的状态和标识等信息</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230403202821277.png" alt="image-20230403202821277"></p>
<p>screen主要记录的是浏览器窗口外面的客户端显示器的信息</p>
<ul>
<li>比如屏幕的逻辑像素 screen.width、screen.height</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230403202842991.png" alt="image-20230403202842991"></p>
<h3 id="7、JSON、Storage"><a href="#7、JSON、Storage" class="headerlink" title="7、JSON、Storage"></a>7、JSON、Storage</h3><h4 id="1-JSON的简单理解"><a href="#1-JSON的简单理解" class="headerlink" title="1.JSON的简单理解"></a>1.JSON的简单理解</h4><p>在目前的开发中，JSON是一种非常重要的数据格式，它并不是编程语言，而是一种可以在服务器和客户端之间传输的数据格式</p>
<p>JSON的全称是JavaScript Object Notation（JavaScript对象符号）</p>
<ul>
<li>JSON是由Douglas Crockford构想和设计的一种轻量级资料交换格式，算是JavaScript的一个子集</li>
<li>但是虽然JSON被提出来的时候是主要应用JavaScript中，但是目前已经独立于编程语言，可以在各个编程语言中使用</li>
<li>很多编程语言都实现了将JSON转成对应模型的方式</li>
</ul>
<p>其他的传输格式：</p>
<ul>
<li>XML：在早期的网络传输中主要是使用XML来进行数据交换的，但是这种格式在解析、传输等各方面都弱于JSON，所以目前已经很 少在被使用了</li>
<li>Protobuf：另外一个在网络传输中目前已经越来越多使用的传输格式是protobuf，但是直到2021年的3.x版本才支持JavaScript，所 以目前在前端使用的较少</li>
</ul>
<p>目前JSON被使用的场景也越来越多：</p>
<ul>
<li>网络数据的传输JSON数据</li>
<li>项目的某些配置文件</li>
<li>非关系型数据库（NoSQL）将json作为存储格式</li>
</ul>
<h4 id="2-JSON的基本语法"><a href="#2-JSON的基本语法" class="headerlink" title="2.JSON的基本语法"></a>2.JSON的基本语法</h4><p>JSON的顶层支持三种类型的值：</p>
<ul>
<li><p>简单值：数字（Number）、字符串（String，不支持单引号）、布尔类型（Boolean）、null类型</p>
</li>
<li><p>对象值：由key、value组成，key是字符串类型，并且必须添加双引号，值可以是简单值、对象值、数组值</p>
</li>
<li><p>数组值：数组的值可以是简单值、对象值、数组值</p>
</li>
</ul>
<h4 id="3-JSON序列化"><a href="#3-JSON序列化" class="headerlink" title="3.JSON序列化"></a>3.JSON序列化</h4><p>某些情况下我们希望将JavaScript中的复杂类型转化成JSON格式的字符串，这样方便对其进行处理</p>
<ul>
<li><p>比如我们希望将一个对象保存到localStorage中</p>
</li>
<li><p>但是如果我们直接存放一个对象，这个对象会被转化成 [object Object] 格式的字符串，并不是我们想要的结果；</p>
</li>
</ul>
<p>在ES5中引用了JSON全局对象，该对象有两个常用的方法：</p>
<ul>
<li>stringify方法：将JavaScript类型转成对应的JSON字符串</li>
<li>parse方法：解析JSON字符串，转回对应的JavaScript类型</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;sdw&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">23</span>,</span><br><span class="line">    <span class="attr">friend</span>: &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;dsds&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1.将obj对象进行序列化</span></span><br><span class="line"><span class="keyword">var</span> objJSONString = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(objJSONString)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.存储到浏览器本地 localstorage</span></span><br><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&quot;info&quot;</span>, objJSONString)</span><br><span class="line"><span class="keyword">var</span> item = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&quot;info&quot;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(item, <span class="keyword">typeof</span> item)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.将自付出转回到对象（反序列化）</span></span><br><span class="line"><span class="keyword">var</span> newObj = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(item)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newObj)</span><br></pre></td></tr></table></figure>



<h4 id="4-Stringfy的补充"><a href="#4-Stringfy的补充" class="headerlink" title="4.Stringfy的补充"></a>4.Stringfy的补充</h4><h5 id="Stringfy-的参数-replacer"><a href="#Stringfy-的参数-replacer" class="headerlink" title="Stringfy 的参数 replacer"></a>Stringfy 的参数 replacer</h5><p>JSON.stringify() 方法将一个 JavaScript 对象或值转换为 JSON 字符串：</p>
<ul>
<li><p>如果指定了一个 replacer 函数，则可以选择性地替换值</p>
</li>
<li><p>如果指定的 replacer 是数组，则可选择性地仅包含数组指定的属性</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// replacer参数</span></span><br><span class="line"><span class="keyword">var</span> objJSONString = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj, <span class="keyword">function</span>(<span class="params">key, value</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (key === <span class="string">&quot;name&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;coderwhy&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> value</span><br><span class="line">&#125;, <span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure>

<h5 id="Stringify的参数space"><a href="#Stringify的参数space" class="headerlink" title="Stringify的参数space"></a>Stringify的参数space</h5><p>如果对象本身包含toJSON方法，那么会直接使用toJSON方法的结果：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2.space参数</span></span><br><span class="line"><span class="comment">// var objJSONString = JSON.stringify(obj, null, 4)</span></span><br><span class="line"><span class="comment">// console.log(objJSONString)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.如果对象本身有显示toJSON方法，那么直接调用toJSON方法</span></span><br><span class="line"><span class="keyword">var</span> objJSONString = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(objJSONString)</span><br></pre></td></tr></table></figure>

<h4 id="5-parse方法"><a href="#5-parse方法" class="headerlink" title="5.parse方法"></a>5.parse方法</h4><p>JSON.parse() 方法用来解析JSON字符串，构造由字符串描述的JavaScript值或对象</p>
<ul>
<li>提供可选的 reviver 函数用以在返回之前对所得到的对象执行变换(操作)</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> newObj = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(objJSONString, <span class="keyword">function</span>(<span class="params">key, value</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (key === <span class="string">&quot;age&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> value + <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>JSON的方法可以帮我们实现对象的深拷贝</p>
<h3 id="8、认识Storage"><a href="#8、认识Storage" class="headerlink" title="8、认识Storage"></a>8、认识Storage</h3><h4 id="1-浏览器本地存储"><a href="#1-浏览器本地存储" class="headerlink" title="1.浏览器本地存储"></a>1.浏览器本地存储</h4><p>WebStorage主要提供了一种机制，可以让浏览器提供一种比cookie更直观的key、value存储方式：</p>
<ul>
<li>localStorage：本地存储，提供的是一种永久性的存储方法，在关闭掉网页重新打开时，存储的内容依然保留</li>
<li>sessionStorage：会话存储，提供的是本次会话的存储，在关闭掉会话时，存储的内容会被清除</li>
</ul>
<h4 id="2-localStorage和sessionStorage的区别"><a href="#2-localStorage和sessionStorage的区别" class="headerlink" title="2.localStorage和sessionStorage的区别"></a>2.localStorage和sessionStorage的区别</h4><ul>
<li>验证一：关闭网页后重新打开，localStorage会保留，而sessionStorage会被删除</li>
<li>验证二：在页面内实现跳转，localStorage会保留，sessionStorage也会保留</li>
<li>验证三：在页面外实现跳转（打开新的网页），localStorage会保留，sessionStorage不会被保留</li>
</ul>
<h4 id="3-Storage有如下的属性和方法："><a href="#3-Storage有如下的属性和方法：" class="headerlink" title="3.Storage有如下的属性和方法："></a>3.Storage有如下的属性和方法：</h4><p>属性：</p>
<ul>
<li>Storage.length：只读属性<ul>
<li>返回一个整数，表示存储在Storage对象中的数据项数量</li>
</ul>
</li>
</ul>
<p>方法：</p>
<ul>
<li>Storage.key()：该方法接受一个数值n作为参数，返回存储中的第n个key名称</li>
<li>Storage.getItem()：该方法接受一个key作为参数，并且返回key对应的value</li>
<li>Storage.setItem()：该方法接受一个key和value，并且将会把key和value添加到存储中<ul>
<li>如果key存储，则更新其对应的值</li>
</ul>
</li>
<li>Storage.removeItem()：该方法接受一个key作为参数，并把该key从存储中删除</li>
<li>Storage.clear()：该方法的作用是清空存储中的所有key</li>
</ul>
<h2 id="14-阶段案例"><a href="#14-阶段案例" class="headerlink" title="14.阶段案例"></a>14.阶段案例</h2><blockquote>
<p> 华为商城的搭建</p>
</blockquote>
<ol>
<li>页面搭建</li>
<li>数据插入，现阶段两种方法：创建每一个元素并插入；&#96;&#96;字符模板插入</li>
<li>实现列表的动态展示<ul>
<li>获取需要进行筛选的条件</li>
<li>动态获取 filters 内容（点击按钮获取textContent，取消按钮移除textContent）</li>
</ul>
</li>
<li>过滤数据</li>
<li>展示数据</li>
</ol>
<blockquote>
<p> 华为轮播图实现与无限轮播</p>
</blockquote>
<p>原理：为图片添加 active，并设置 opacity</p>
<ol>
<li>获取数据插入页面</li>
<li>使用定位，将图片定位在 banner 中</li>
<li>监听事件（上下页）点击，将图片进行展示（opacity &#x3D; 1，添加动画）</li>
<li>定时器进行自动轮播</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://awzz-coder.github.io">awzz-coder</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://awzz-coder.github.io/archives/4b0178e0.html">https://awzz-coder.github.io/archives/4b0178e0.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://awzz-coder.github.io" target="_blank">awzz博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/IT%E5%89%8D%E7%AB%AF/">IT前端</a><a class="post-meta__tags" href="/tags/JavaScript/">JavaScript</a><a class="post-meta__tags" href="/tags/DOM/">DOM</a><a class="post-meta__tags" href="/tags/BOM/">BOM</a></div><div class="post_share"><div class="social-share" data-image="/./img/default.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat-pay.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/wechat-pay.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/ali-pay.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/ali-pay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/archives/974a452e.html" title="网络规划与设计"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://w.wallhaven.cc/full/6d/wallhaven-6dm5xx.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">网络规划与设计</div></div></a></div><div class="next-post pull-right"><a href="/archives/58e66b84.html" title="计算机网络知识整理"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://w.wallhaven.cc/full/kx/wallhaven-kxz71q.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">计算机网络知识整理</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/archives/0.html" title="数据结构与算法"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./img/default.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-10</div><div class="title">数据结构与算法</div></div></a></div><div><a href="/archives/f99e1de4.html" title="HTML&#x2F;CSS 知识体系（部分）"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://w.wallhaven.cc/full/2y/wallhaven-2yz3m9.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-12</div><div class="title">HTML&#x2F;CSS 知识体系（部分）</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="lv-container" data-id="city" data-uid="MTAyMC81ODI5MC8zNDc1Mw=="></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./img/avatar.jpeg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">awzz-coder</div><div class="author-info__description">我的博客笔记-前端分享</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" href="https://awzz-coder.github.io"><i class="fab fa-github"></i><span>关注我</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/awzz-coder" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://www.baidu.com" rel="external nofollow noreferrer" target="_blank" title="Twitter"><i class="fab fa-twitter"></i></a><a class="social-icon" href="https://space.bilibili.com/476760963?spm_id_from=333.1007.0.0" rel="external nofollow noreferrer" target="_blank" title="B站"><i class="fas fa-b"></i></a><a class="social-icon" href="/546836216@qq.com" target="_blank" title="QQ邮箱"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到awzz的博客</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#JavaScript"><span class="toc-text">JavaScript</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E9%82%82%E9%80%85JavaScript"><span class="toc-text">1.邂逅JavaScript</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E8%AE%A4%E8%AF%86%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80"><span class="toc-text">1、认识编程语言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%8F%91%E5%B1%95%E5%8F%B2"><span class="toc-text">2、编程语言发展史</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81JavaScript%E7%9A%84%E5%8E%86%E5%8F%B2"><span class="toc-text">3、JavaScript的历史</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81JavaScript%E7%9A%84%E7%BB%84%E6%88%90"><span class="toc-text">4、JavaScript的组成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81JavaScript%E8%BF%90%E8%A1%8C%E5%BC%95%E6%93%8E"><span class="toc-text">5、JavaScript运行引擎</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81JavaScript%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">6、JavaScript应用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-JavaScript%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-text">2.JavaScript的基本语法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81javascript%E7%BC%96%E5%86%99%E6%96%B9%E5%BC%8F"><span class="toc-text">1、javascript编写方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81noscript%E5%85%83%E7%B4%A0%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">2、noscript元素的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81javascript%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">3、javascript注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81javascript%E4%BA%A4%E4%BA%92%E6%96%B9%E5%BC%8F"><span class="toc-text">4、javascript交互方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81javascript%E8%AF%AD%E5%8F%A5%E5%92%8C%E5%88%86%E5%8F%B7"><span class="toc-text">5、javascript语句和分号</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-JavaScript%E7%9A%84%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">3.JavaScript的变量和数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E8%AE%A4%E8%AF%86JavaScript%E5%8F%98%E9%87%8F"><span class="toc-text">1、认识JavaScript变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%8F%98%E5%8C%96%E6%95%B0%E6%8D%AE%E7%9A%84%E8%AE%B0%E5%BD%95%E2%80%94%E5%8F%98%E9%87%8F"><span class="toc-text">1.变化数据的记录—变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%8F%98%E9%87%8F%E7%9A%84%E5%91%BD%E5%90%8D%E6%A0%BC%E5%BC%8F"><span class="toc-text">2.变量的命名格式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%8F%98%E9%87%8F%E7%9A%84%E5%AE%9A%E4%B9%89%E3%80%81%E8%A7%84%E8%8C%83"><span class="toc-text">2、变量的定义、规范</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8Ctypeof"><span class="toc-text">3、数据类型和typeof</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E5%B8%B8%E8%A7%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">4、常见的数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#number%E7%B1%BB%E5%9E%8B"><span class="toc-text">number类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#string%E7%B1%BB%E5%9E%8B%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B"><span class="toc-text">string类型：字符串类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Boolean%E7%B1%BB%E5%9E%8B%EF%BC%9A%E7%94%A8%E4%BA%8E%E8%A1%A8%E7%A4%BA%E7%9C%9F%E5%81%87"><span class="toc-text">Boolean类型：用于表示真假</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Undefined%E7%B1%BB%E5%9E%8B"><span class="toc-text">Undefined类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Object%E7%B1%BB%E5%9E%8B"><span class="toc-text">Object类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Null%E7%B1%BB%E5%9E%8B"><span class="toc-text">Null类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%80%BB%E7%BB%93"><span class="toc-text">数据类型总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-text">5、数据类型的转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%AD%97%E7%AC%A6%E4%B8%B2String%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-text">1.字符串String的转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%95%B0%E5%AD%97%E7%B1%BB%E5%9E%8BNumber%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-text">2.数字类型Number的转换</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%95%B0%E5%AD%97%E7%9A%84%E8%A7%84%E5%88%99"><span class="toc-text">其他类型转换数字的规则</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8BBoolean%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-text">3.布尔类型Boolean的转换</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-JavaScript%E5%9F%BA%E7%A1%80%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">4.JavaScript基础运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E8%BF%90%E7%AE%97%E5%85%83"><span class="toc-text">1、运算符和运算元</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">2、算术运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">3、赋值运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E5%9C%B0%E4%BF%AE%E6%94%B9"><span class="toc-text">原地修改</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E8%87%AA%E5%A2%9E%E5%92%8C%E8%87%AA%E5%87%8F"><span class="toc-text">4、自增和自减</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%92%8C%E2%80%93%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="toc-text">++和–的位置</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-text">5、运算符优先级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">6、比较运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%9D%E5%A4%96%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85"><span class="toc-text">额外知识补充</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#x3D-x3D-%E5%92%8C-x3D-x3D-x3D-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">&#x3D;&#x3D;和&#x3D;&#x3D;&#x3D;的区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-JavaScript%E5%88%86%E6%94%AF%E8%AF%AD%E5%8F%A5"><span class="toc-text">5.JavaScript分支语句</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81if%E5%88%86%E6%94%AF%E8%AF%AD%E5%8F%A5"><span class="toc-text">1、if分支语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81if%E2%80%A6else%E2%80%A6%E8%AF%AD%E5%8F%A5"><span class="toc-text">2、if…else…语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81if%E2%80%A6else-if%E2%80%A6else%E8%AF%AD%E5%8F%A5"><span class="toc-text">3、if…else if…else语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">4、三元运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">5、逻辑运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%BB%E8%BE%91-%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-text">逻辑||的本质</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%BB%E8%BE%91-amp-amp-%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-text">逻辑&amp;&amp;的本质</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E9%9D%9E%E7%9A%84%E8%A1%A5%E5%85%85"><span class="toc-text">逻辑非的补充</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81switch%E8%AF%AD%E5%8F%A5"><span class="toc-text">6、switch语句</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-JavaScript%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5"><span class="toc-text">6.JavaScript循环语句</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E8%AE%A4%E8%AF%86%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5"><span class="toc-text">1、认识循环语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81while-%E5%BE%AA%E7%8E%AF"><span class="toc-text">2、while 循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81do%E2%80%A6while-%E5%BE%AA%E7%8E%AF"><span class="toc-text">3、do…while 循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81for-%E5%BE%AA%E7%8E%AF"><span class="toc-text">4、for 循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E5%BE%AA%E7%8E%AF%E6%8E%A7%E5%88%B6%E2%80%94break%E3%80%81continue"><span class="toc-text">5、循环控制—break、continue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81%E6%A1%88%E4%BE%8B%E7%BB%83%E4%B9%A0"><span class="toc-text">6、案例练习</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-JavaScript%E5%87%BD%E6%95%B0"><span class="toc-text">7.JavaScript函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E8%AE%A4%E8%AF%86-JavaScript-%E5%87%BD%E6%95%B0"><span class="toc-text">1、认识 JavaScript 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%87%BD%E6%95%B0%E7%9A%84%E5%A3%B0%E6%98%8E%E5%92%8C%E8%B0%83%E7%94%A8"><span class="toc-text">2、函数的声明和调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E5%87%BD%E6%95%B0%E7%9A%84%E9%80%92%E5%BD%92%E8%B0%83%E7%94%A8"><span class="toc-text">3、函数的递归调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E5%B1%80%E9%83%A8%E5%92%8C%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="toc-text">4、局部和全局变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%86%99%E6%B3%95"><span class="toc-text">5、函数表达式的写法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E-vs-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">声明 vs 表达式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%80%E5%8F%91%E4%B8%AD%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9"><span class="toc-text">开发中如何选择</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81%E5%87%BD%E6%95%B0%E7%9A%84%E5%A4%B4%E7%AD%89%E5%85%AC%E6%B0%91"><span class="toc-text">6、函数的头等公民</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="toc-text">回调函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E5%BF%85%E9%A1%BB%E6%BB%A1%E8%B6%B3%E4%B8%A4%E4%B8%AA%E6%9D%A1%E4%BB%B6%E4%B9%8B%E4%B8%80"><span class="toc-text">高阶函数必须满足两个条件之一</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">匿名函数的理解</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0"><span class="toc-text">7、立即执行函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0%E7%9A%84%E5%85%B6%E4%BB%96%E5%86%99%E6%B3%95"><span class="toc-text">立即执行函数的其他写法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E3%80%81%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83"><span class="toc-text">8、代码规范</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-JavaScript%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-text">8.JavaScript的面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">1、对象类型的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E5%92%8C%E4%BD%BF%E7%94%A8%E5%AF%B9%E8%B1%A1"><span class="toc-text">创建对象和使用对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%8B%AC%E5%8F%B7%E5%92%8C%E5%BC%95%E7%94%A8%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">方括号和引用的使用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-text">对象的遍历</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%88%E5%86%85%E5%AD%98%E5%92%8C%E5%A0%86%E5%86%85%E5%AD%98"><span class="toc-text">栈内存和堆内存</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="toc-text">2、值类型和引用类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E5%87%BD%E6%95%B0%E7%9A%84-this-%E6%8C%87%E5%90%91"><span class="toc-text">3、函数的 this 指向</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E5%88%9B%E5%BB%BA%E7%B1%BB"><span class="toc-text">4、工厂方法创建类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%80%9D%E7%BB%B4%E6%96%B9%E5%BC%8F"><span class="toc-text">1.类和对象的思维方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%9A%E4%BD%BF%E7%94%A8new%E5%85%B3%E9%94%AE%E8%AF%8D%EF%BC%88%E6%93%8D%E4%BD%9C%E7%AC%A6%EF%BC%89"><span class="toc-text">2.构造函数的方式：使用new关键词（操作符）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E7%B1%BB"><span class="toc-text">5、构造函数和类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E7%B1%BB%EF%BC%88%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%89"><span class="toc-text">1.什么是类（构造函数）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-JavaScript%E4%B8%AD%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%98%AF%E6%80%8E%E4%B9%88%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="toc-text">2.JavaScript中的构造函数是怎么样的？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%85%A8%E5%B1%80%E5%AF%B9%E8%B1%A1window%E4%BA%86%E8%A7%A3"><span class="toc-text">3.全局对象window了解</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-JavaScript%E5%B8%B8%E8%A7%81%E7%9A%84%E5%86%85%E7%BD%AE%E7%B1%BB"><span class="toc-text">9.JavaScript常见的内置类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E8%AE%A4%E8%AF%86%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B"><span class="toc-text">1、认识包装类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E6%95%B0%E5%AD%97%E7%B1%BB%E5%9E%8BNumber"><span class="toc-text">2、数字类型Number</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%B1%9E%E6%80%A7%E8%A1%A5%E5%85%85%EF%BC%9A"><span class="toc-text">1.属性补充：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E8%A1%A5%E5%85%85"><span class="toc-text">2.实例方法补充</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%B1%BB%E6%96%B9%E6%B3%95%E8%A1%A5%E5%85%85"><span class="toc-text">3.类方法补充</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E6%95%B0%E5%AD%97%E5%AF%B9%E8%B1%A1Math"><span class="toc-text">3、数字对象Math</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8BString"><span class="toc-text">4、字符串类型String</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%B8%B8%E8%A7%81%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-text">1.常见的属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BF%AE%E6%94%B9%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">2.修改字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%9F%A5%E6%89%BE%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">3.查找字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8B%BC%E6%8E%A5"><span class="toc-text">4.字符串的拼接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%87%E5%89%B2%E4%B8%8E%E6%94%B9%E5%8F%98%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F"><span class="toc-text">6.字符串切割与改变连接方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E6%95%B0%E7%BB%84Array%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3"><span class="toc-text">5、数组Array使用详解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E7%BB%84"><span class="toc-text">1.什么是数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%95%B0%E7%BB%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-text">2.数组的基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E8%AE%BF%E9%97%AE%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0"><span class="toc-text">1、访问数组中的元素</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E4%BF%AE%E6%94%B9%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0"><span class="toc-text">2、修改数组中的元素</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E5%88%A0%E9%99%A4"><span class="toc-text">3、删除</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%E3%80%81%E6%95%B0%E7%BB%84%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-text">4、数组的遍历</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5%E3%80%81%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95"><span class="toc-text">5、数组方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6%E3%80%81%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0"><span class="toc-text">6、查找元素</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7%E3%80%81%E6%8E%92%E5%BA%8F%E5%92%8C%E5%8F%8D%E8%BD%AC"><span class="toc-text">7、排序和反转</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8%E3%80%81%E6%95%B0%E7%BB%84%E7%9A%84%E5%85%B6%E4%BB%96%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0"><span class="toc-text">8、数组的其他高阶函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81Date%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">6、Date类型的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%88%9B%E5%BB%BADate%E5%AF%B9%E8%B1%A1"><span class="toc-text">1.创建Date对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-dateString-%E6%97%B6%E9%97%B4%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E5%BC%8F"><span class="toc-text">2. dateString 时间的表示方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Date-%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">3.Date 对象的方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Date-%E8%8E%B7%E5%8F%96-Unix-%E6%97%B6%E9%97%B4%E6%88%B3"><span class="toc-text">4.Date 获取 Unix 时间戳</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-Date-parse-%E6%96%B9%E6%B3%95"><span class="toc-text">5.Date.parse 方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-JavaScript-%E7%9A%84-DOM-%E6%93%8D%E4%BD%9C"><span class="toc-text">10.JavaScript 的 DOM 操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFDOM"><span class="toc-text">1、什么是DOM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%AE%A4%E8%AF%86DOM-Tree"><span class="toc-text">2、认识DOM Tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81DOM-%E7%9A%84%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84"><span class="toc-text">3、DOM 的整体结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E8%8A%82%E7%82%B9%E3%80%81%E5%85%83%E7%B4%A0%E5%AF%BC%E8%88%AA"><span class="toc-text">4、节点、元素导航</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%8A%82%E7%82%B9%E4%B9%8B%E9%97%B4%E5%AF%BC%E8%88%AA"><span class="toc-text">1.节点之间导航</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%85%83%E7%B4%A0%E4%B9%8B%E9%97%B4%E5%AF%BC%E8%88%AA"><span class="toc-text">2.元素之间导航</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-table%E5%85%83%E7%B4%A0%E4%B9%8B%E9%97%B4%E7%9A%84%E5%AF%BC%E8%88%AA"><span class="toc-text">3.table元素之间的导航</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-form%E5%85%83%E7%B4%A0%E4%B9%8B%E9%97%B4%E7%9A%84%E5%AF%BC%E8%88%AA"><span class="toc-text">4.form元素之间的导航</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">5、获取元素的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81Node-%E8%8A%82%E7%82%B9%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-text">6、Node 节点的属性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-nodeType%E5%B1%9E%E6%80%A7%EF%BC%9A"><span class="toc-text">1.nodeType属性：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Attribute-%E5%B1%9E%E6%80%A7%E7%9A%84%E6%93%8D%E4%BD%9C%EF%BC%9A"><span class="toc-text">2.Attribute 属性的操作：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%85%83%E7%B4%A0%E7%9A%84%E5%B1%9E%E6%80%A7-property"><span class="toc-text">3.元素的属性 property</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-JavaScript%E4%B8%AD%E5%8A%A8%E6%80%81%E4%BF%AE%E6%94%B9%E6%A0%B7%E5%BC%8F"><span class="toc-text">4.JavaScript中动态修改样式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%88%9B%E5%BB%BA%E5%85%83%E7%B4%A0"><span class="toc-text">5.创建元素</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E5%85%83%E7%B4%A0"><span class="toc-text">插入元素</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A7%BB%E9%99%A4%E5%92%8C%E5%85%8B%E9%9A%86%E5%85%83%E7%B4%A0"><span class="toc-text">移除和克隆元素</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%97%A7%E6%96%B9%E6%B3%95%E6%93%8D%E4%BD%9C%E5%85%83%E7%B4%A0%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="toc-text">旧方法操作元素（了解）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E5%85%83%E7%B4%A0%E7%9A%84%E5%A4%A7%E5%B0%8F%E3%80%81%E6%BB%9A%E5%8A%A8"><span class="toc-text">6.元素的大小、滚动</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-window%E7%9A%84%E5%A4%A7%E5%B0%8F%E3%80%81%E6%BB%9A%E5%8A%A8"><span class="toc-text">7.window的大小、滚动</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-JavaScript-%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6"><span class="toc-text">11.JavaScript 中的事件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E8%AE%A4%E8%AF%86%E4%BA%8B%E4%BB%B6"><span class="toc-text">1、认识事件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%88%97%E8%A1%A8"><span class="toc-text">常见的事件列表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%AE%A4%E8%AF%86%E4%BA%8B%E4%BB%B6%E6%B5%81"><span class="toc-text">2、认识事件流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BA%A7%E7%94%9F"><span class="toc-text">1.产生</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%E5%92%8C%E4%BA%8B%E4%BB%B6%E6%8D%95%E8%8E%B7"><span class="toc-text">2.事件冒泡和事件捕获</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1"><span class="toc-text">3、事件对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#event-%E5%B8%B8%E8%A7%81%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-text">event 常见的属性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81EventTarget-%E7%B1%BB"><span class="toc-text">4、EventTarget 类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98"><span class="toc-text">5、事件委托</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%E7%9A%84%E6%A0%87%E8%AE%B0"><span class="toc-text">事件委托的标记</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81%E5%B8%B8%E8%A7%81%E7%9A%84%E4%BA%8B%E4%BB%B6"><span class="toc-text">6、常见的事件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%B8%B8%E8%A7%81%E7%9A%84%E9%BC%A0%E6%A0%87%E4%BA%8B%E4%BB%B6"><span class="toc-text">1.常见的鼠标事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-mouseover%E5%92%8Cmouseenter%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">2.mouseover和mouseenter的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%B8%B8%E8%A7%81%E7%9A%84%E9%94%AE%E7%9B%98%E4%BA%8B%E4%BB%B6"><span class="toc-text">3.常见的键盘事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%B8%B8%E8%A7%81%E7%9A%84%E8%A1%A8%E5%8D%95%E4%BA%8B%E4%BB%B6"><span class="toc-text">4.常见的表单事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%96%87%E6%A1%A3%E5%8A%A0%E8%BD%BD%E4%BA%8B%E4%BB%B6"><span class="toc-text">5.文档加载事件</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-DOM%E9%98%B6%E6%AE%B5%E6%A1%88%E4%BE%8B"><span class="toc-text">12.DOM阶段案例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-JavaScript%E4%B8%AD%E7%9A%84BOM%E6%93%8D%E4%BD%9C"><span class="toc-text">13.JavaScript中的BOM操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E8%AE%A4%E8%AF%86BOM%E6%93%8D%E4%BD%9C"><span class="toc-text">1、认识BOM操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%85%A8%E5%B1%80%E5%AF%B9%E8%B1%A1window"><span class="toc-text">2、全局对象window</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81location%E5%AF%B9%E8%B1%A1"><span class="toc-text">3、location对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81URLSearchParams"><span class="toc-text">4、URLSearchParams</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81history%E5%AF%B9%E8%B1%A1"><span class="toc-text">5、history对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81navigator%E3%80%81screen%EF%BC%88%E5%BE%88%E5%B0%91%E7%94%A8%EF%BC%89"><span class="toc-text">6、navigator、screen（很少用）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81JSON%E3%80%81Storage"><span class="toc-text">7、JSON、Storage</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-JSON%E7%9A%84%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3"><span class="toc-text">1.JSON的简单理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-JSON%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-text">2.JSON的基本语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-JSON%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-text">3.JSON序列化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Stringfy%E7%9A%84%E8%A1%A5%E5%85%85"><span class="toc-text">4.Stringfy的补充</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Stringfy-%E7%9A%84%E5%8F%82%E6%95%B0-replacer"><span class="toc-text">Stringfy 的参数 replacer</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Stringify%E7%9A%84%E5%8F%82%E6%95%B0space"><span class="toc-text">Stringify的参数space</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-parse%E6%96%B9%E6%B3%95"><span class="toc-text">5.parse方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E3%80%81%E8%AE%A4%E8%AF%86Storage"><span class="toc-text">8、认识Storage</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8"><span class="toc-text">1.浏览器本地存储</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-localStorage%E5%92%8CsessionStorage%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">2.localStorage和sessionStorage的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Storage%E6%9C%89%E5%A6%82%E4%B8%8B%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-text">3.Storage有如下的属性和方法：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-%E9%98%B6%E6%AE%B5%E6%A1%88%E4%BE%8B"><span class="toc-text">14.阶段案例</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/archives/0.html" title="数据结构与算法"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据结构与算法"/></a><div class="content"><a class="title" href="/archives/0.html" title="数据结构与算法">数据结构与算法</a><time datetime="2022-07-09T16:00:00.000Z" title="发表于 2022-07-10 00:00:00">2022-07-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/archives/163a8691.html" title="Git的基本使用"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://w.wallhaven.cc/full/2y/wallhaven-2yz22m.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Git的基本使用"/></a><div class="content"><a class="title" href="/archives/163a8691.html" title="Git的基本使用">Git的基本使用</a><time datetime="2022-06-30T16:00:00.000Z" title="发表于 2022-07-01 00:00:00">2022-07-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/archives/974a452e.html" title="网络规划与设计"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://w.wallhaven.cc/full/6d/wallhaven-6dm5xx.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="网络规划与设计"/></a><div class="content"><a class="title" href="/archives/974a452e.html" title="网络规划与设计">网络规划与设计</a><time datetime="2022-06-24T16:00:00.000Z" title="发表于 2022-06-25 00:00:00">2022-06-25</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/./img/default.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By awzz-coder</div><div class="footer_custom_text">Hi, welcome to my <a target="_blank" rel="noopener external nofollow noreferrer" href="https://butterfly.js.org/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>function loadLivere () {
  if (typeof LivereTower === 'object') {
    window.LivereTower.init()
  }
  else {
    (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
    })(document, 'script');
  }
}

if ('Livere' === 'Livere' || !false) {
  if (false) btf.loadComment(document.getElementById('lv-container'), loadLivere)
  else loadLivere()
}
else {
  function loadOtherComment () {
    loadLivere()
  }
}</script></div><div class="aplayer no-destroy" data-id="7487493788" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="true"> </div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></body></html>
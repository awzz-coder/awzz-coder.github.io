<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Vue</title>
      <link href="/archives/f8e09374.html"/>
      <url>/archives/f8e09374.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><h2 id="1-邂逅Vue"><a href="#1-邂逅Vue" class="headerlink" title="1.邂逅Vue"></a>1.邂逅Vue</h2><h3 id="1、Vue在前端的重要性"><a href="#1、Vue在前端的重要性" class="headerlink" title="1、Vue在前端的重要性"></a>1、Vue在前端的重要性</h3><p>Vue 是一套用于构建用户界面的渐进式 JavaScript 框架</p><p>它基于标准 HTML、CSS和JavaScript构建，并提供了一套声明式的、组件化的编程模型</p><p>帮助你高效地开发用户界面，无论任务是简单还是复杂</p><p>什么是渐进式框架？</p><p>表示我们可以在项目中一点点来引入和使用Vue，而不一定需要全部使用Vue来开发整个项目</p><p>目前前端最流行的是三大框架：Vue、React、Angular</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230409072236471.png" alt="image-20230409072236471"></p><p>国外，优先推荐React、其次是Vue和Angular</p><p>国内，优先推荐且必须学习Vue，其次是React，其次是Angular</p><h3 id="2、Vue2还是Vue3"><a href="#2、Vue2还是Vue3" class="headerlink" title="2、Vue2还是Vue3"></a>2、Vue2还是Vue3</h3><p>Vue3：更好的性能；更小的打包体积；更好的TypeScript集成；更优秀的 API 设计</p><p>Vue3 目前已经是稳定的版本，并且 Vue3 在2022年2月7日已经成为默认安装版本</p><p>目前社区也经过一定时间的沉淀，更加的完善了，包括 AntDesignVue、Element-Plus 都提供了对 Vue3 的支持，所以很多公司目前新的项目都已经在使用 Vue3 来进行开发了</p><p>并且在面试的时候，几乎都会问到各种各样 Vue3 相关的问题</p><p>Vue 的本质，就是一个 JavaScript 的库</p><p>使用 Vue 的方式</p><ul><li>在页面通过CDN的方式来引入<ul><li><a href="https://unpkg.com/vue@next">https://unpkg.com/vue@next</a></li></ul></li><li>下载 Vue 的 JS 文件，并且自己手动引入</li><li>通过 npm 包管理工具安装使用它</li><li>直接通过 Vue CIL 创建项目，并且使用它</li></ul><h3 id="3、Vue-初体验"><a href="#3、Vue-初体验" class="headerlink" title="3、Vue 初体验"></a>3、Vue 初体验</h3><p>Vue 页面</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./lib/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 1.创建app </span></span><br><span class="line">  <span class="keyword">const</span> app = <span class="title class_">Vue</span>.<span class="title function_">createApp</span>(&#123;</span><br><span class="line">    <span class="attr">template</span>: <span class="string">`&lt;h1&gt;Hello Vue&lt;/h2&gt;`</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.挂载app</span></span><br><span class="line">  app.<span class="title function_">mount</span>(<span class="string">&quot;#app&quot;</span>)</span><br></pre></td></tr></table></figure><p>案例1.动态message</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">template</span>: <span class="string">`&lt;h2&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt;`</span></span><br></pre></td></tr></table></figure><p>案例2. 列表数据</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">       &lt;h2&gt;电影列表&lt;/h2&gt;</span></span><br><span class="line"><span class="string">       &lt;ul&gt;</span></span><br><span class="line"><span class="string">         &lt;li v-for=&quot;item in movies&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt; </span></span><br><span class="line"><span class="string">       &lt;/ul&gt;</span></span><br><span class="line"><span class="string">     `</span>,</span><br><span class="line">     <span class="attr">data</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> &#123;</span><br><span class="line">         <span class="attr">message</span>: <span class="string">&quot;你好啊，ikun&quot;</span>,</span><br><span class="line">         <span class="attr">movies</span>: [ <span class="string">&quot;大话西游&quot;</span>, <span class="string">&quot;恶灵&quot;</span>, <span class="string">&quot;少年派&quot;</span>, <span class="string">&quot;盗梦空间&quot;</span>, <span class="string">&quot;五十度灰&quot;</span> ]</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>案例3.计数器</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>当前计数: &#123;&#123;counter&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;increment&quot;</span>&gt;</span>+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;decrement&quot;</span>&gt;</span>-1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> app = <span class="title class_">Vue</span>.<span class="title function_">createApp</span>(&#123;</span><br><span class="line">    <span class="attr">data</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">counter</span>: <span class="number">0</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">methods</span>: &#123;</span><br><span class="line">      <span class="attr">increment</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 暂时了解：this通过bild绑定某个对象 可以改变data的return&#123;&#125; 中的对象</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">counter</span>++</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">decrement</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">counter</span>--</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  app.<span class="title function_">mount</span>(<span class="string">&quot;#app&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="4、命令式与声明式编程"><a href="#4、命令式与声明式编程" class="headerlink" title="4、命令式与声明式编程"></a>4、命令式与声明式编程</h3><p>原生开发和Vue开发的模式和特点是完全不同的，涉及到两种不同的编程范式</p><ul><li><p>命令式编程和声明式编程</p></li><li><p>命令式编程关注的是 “how to do”自己完成整个how的过程</p></li><li><p>声明式编程关注的是 “what to do”，由框架(机器)完成 “how”的过程</p></li></ul><p>在原生的实现过程中</p><ul><li><p>每完成一个操作，都需要通过JavaScript编写一条代码，来给浏览器一个指令</p></li><li><p>这样的编写代码的过程，我们称之为命令式编程</p></li><li><p>在早期的原生JavaScript和jQuery开发的过程中，都是通过这种命令式的方式编写代码</p></li></ul><p>在Vue的实现过程中的操作</p><ul><li><p>在createApp传入的对象中声明需要的内容，模板template、数据data、方法methods</p></li><li><p>这样的编写代码的过程，我们称之为是声明式编程</p></li><li><p>目前Vue、React、Angular、小程序的编程模式，我们称之为声明式编程</p></li></ul><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/%E5%91%BD%E4%BB%A4%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%92%8C%E5%A3%B0%E6%98%8E%E5%BC%8F%E7%BC%96%E7%A8%8B%E7%9A%84%E6%80%9D%E6%83%B3%E5%8C%BA%E5%88%AB.png" alt="命令式编程和声明式编程的思想区别"></p><h3 id="5、MVC和MVVM的模型区别"><a href="#5、MVC和MVVM的模型区别" class="headerlink" title="5、MVC和MVVM的模型区别"></a>5、MVC和MVVM的模型区别</h3><p>MVC和MVVM都是一种软件的体系结构</p><ul><li><p>MVC是Model – View –Controller的简称，是在前期被使用非常框架的架构模式，比如iOS、前端；</p></li><li><p>MVVM是Model-View-ViewModel的简称，是目前非常流行的架构模式</p></li></ul><p>通常情况下，我们也经常称Vue是一个MVVM的框架</p><ul><li>Vue官方其实有说明，Vue虽然并没有完全遵守MVVM的模型，但整个设计受到它的启发</li></ul><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230409203218899.png" alt="image-20230409203218899"></p><h3 id="6、常用-options-api"><a href="#6、常用-options-api" class="headerlink" title="6、常用 options api"></a>6、常用 options api</h3><h4 id="1-data"><a href="#1-data" class="headerlink" title="1.data"></a>1.data</h4><p>data属性是传入一个函数，并且该函数需要返回一个对象</p><ul><li><p>在 Vue2.x 的时候，也可以传入一个对象（虽然官方推荐是一个函数）</p></li><li><p>在 Vue3.x 的时候，必须传入一个函数，否则就会直接在浏览器中报错</p></li></ul><p>data中返回的对象会被Vue的响应式系统劫持，之后对该对象的修改或者访问都会在劫持中被处理</p><ul><li><p>在 template 或者 app 中通过 <code>&#123;&#123;counter&#125;&#125;</code> 访问 ounter，可以从对象中获取到数据</p></li><li><p>修改counter的值时，app中的 <code>&#123;&#123;counter&#125;&#125;</code>也会发生改变</p></li></ul><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/data%E6%95%B0%E6%8D%AE%E5%A6%82%E4%BD%95%E8%A2%AB%E5%B1%95%E7%A4%BA%E7%9A%84.png" alt="data数据如何被展示的"></p><h4 id="2-methods"><a href="#2-methods" class="headerlink" title="2.methods"></a>2.methods</h4><p>methods 属性是一个对象，通常我们会在这个对象中定义很多的方法：</p><ul><li><p>这些方法可以被绑定到模板中</p></li><li><p>在该方法中，我们可以使用 this 关键字来直接访问到data中返回的对象的属性</p></li></ul><p>问题一：为什么不能使用箭头函数（官方文档有给出解释）</p><ul><li>我们在 methods 中要使用 data 返回对象中的数据，那么这个 this 是必须有值的，并且应该可以通过 this 获取到data返回对象中的数据，不可以是 window，因为 window 中我们无法获取到 data 返回对象中的数据，但是如果我们使用箭头函数，那么这个 this 就会是window了</li></ul><p>问题二：不使用箭头函数的情况下，this 到底指向的是什么？（可以作为一道面试题）</p><p>proxy，事实上Vue的源码当中就是对 methods 中的所有函数进行了遍历，并且通过bind绑定了 this</p><h3 id="7、vscode-代码片段"><a href="#7、vscode-代码片段" class="headerlink" title="7、vscode 代码片段"></a>7、vscode 代码片段</h3><p>便于快速生成Vue的基本代码结构</p><p>具体的步骤如下：</p><ul><li><p>第一步，复制自己需要生成代码片段的代码</p></li><li><p>第二步，<a href="https://snippet-generator.app/%E5%9C%A8%E8%AF%A5%E7%BD%91%E7%AB%99%E4%B8%AD%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5">https://snippet-generator.app/在该网站中生成代码片段</a></p></li><li><p>第三步，在VSCode中配置代码片段</p></li></ul><h2 id="2-模板语法"><a href="#2-模板语法" class="headerlink" title="2.模板语法"></a>2.模板语法</h2><h3 id="1、Mustache-语法"><a href="#1、Mustache-语法" class="headerlink" title="1、Mustache 语法"></a>1、Mustache 语法</h3><p>React的开发模式：</p><ul><li><p>React使用的jsx，所以对应的代码都是编写的类似于js的一种语法</p></li><li><p>之后通过Babel将jsx编译成 React.createElement 函数调用</p></li></ul><p>Vue也支持jsx的开发模式</p><ul><li><p>但大多数情况下，使用基于HTML的模板语法</p></li><li><p>在模板中，允许开发者以声明式的方式将DOM和底层组件实例的数据绑定在一起</p></li><li><p>在底层的实现中，Vue将模板编译成虚拟DOM渲染函数</p></li></ul><p>把数据显示到模板（template）中，使用最多的语法是“Mustache”语法 (双大括号)的文本插值</p><ul><li><p>并且data返回的对象是有添加到Vue的响应式系统中</p></li><li><p>当data中的数据发生改变时，对应的内容也会发生更新</p></li><li><p>Mustache中不仅仅可以是data中的属性，也可以是一个JavaScript的表达式</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">  &lt;!-- <span class="number">1.</span>基本使用 --&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>当前计数: &#123;&#123;counter&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">  &lt;!-- <span class="number">2.</span>表达式 --&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>双倍计数: &#123;&#123; counter * 2 &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>展示信息: &#123;&#123; infos.split(&quot; &quot;).join(&quot;-&quot;) &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">  &lt;!-- <span class="number">3.</span>三元表达式 --&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123; age &gt;= 18 ? &quot;成年人&quot; : &quot;未成年人&quot; &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">  &lt;!-- <span class="number">4.</span>调用methods中函数 --&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123; formateDate(123) &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">  &lt;!-- <span class="number">5.</span>注意：这里不能定义语句 --&gt;</span><br><span class="line">  &lt;!-- <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123; const name = &quot;why&quot;; name&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span> --&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>若是在createApp对象中使用template并写入东西，则会覆盖挂载的app中的原来的html结构，所以可以不写template，而挂载app中的div的html结构会当做template模板，便于书写html结构</p><h3 id="2、常见基本指令"><a href="#2、常见基本指令" class="headerlink" title="2、常见基本指令"></a>2、常见基本指令</h3><h4 id="1-v-once"><a href="#1-v-once" class="headerlink" title="1.v-once"></a>1.v-once</h4><p>用于指定元素或者组件只渲染一次：</p><ul><li><p>当数据发生变化时，元素或者组件以及其所有的子元素将视为静态内容并且跳过</p></li><li><p>该指令可以用于性能优化</p></li><li><p>如果是子节点，也是只会渲染一次</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- 指令：v-once 自身以及子元素只渲染一次 --&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-once</span>&gt;</span> </span></span><br><span class="line"><span class="language-xml">      &#123;&#123;message&#125;&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">span</span>&gt;</span>数字: &#123;&#123;counter&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">模板中使用&#123;&#123;&#125;&#125;进行渲染一次之后，不能修改所渲染的数据（数据能被修改但是渲染的数据仍是第一次渲染的数据）</span><br></pre></td></tr></table></figure><h4 id="2-v-text"><a href="#2-v-text" class="headerlink" title="2.v-text"></a>2.v-text</h4><p>用于更新元素的 textContent</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;h2&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt;</span><br><span class="line">如果&#123;&#123;message不含别的解释内容，则两者等价，不然v-text会替换标签中原有的内容&#125;&#125;</span><br><span class="line">   &lt;!-- 将data对应的文本设置到元素中  message会替换aaa--&gt;</span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-text</span>=<span class="string">&quot;message&quot;</span>&gt;</span>aaa<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h4 id="3-v-html"><a href="#3-v-html" class="headerlink" title="3.v-html"></a>3.v-html</h4><p>默认情况下，如果我们展示的内容本身是html的，那么vue并不会对其进行特殊的解析</p><ul><li>如果我们希望这个内容被Vue可以解析出来，那么可以使用 v-html 来展示</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;h2&gt;&#123;&#123; content &#125;&#125;&lt;/h2&gt;</span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-html</span>=<span class="string">&quot;content&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="attr">data</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> &#123;</span><br><span class="line">         <span class="attr">content</span>: <span class="string">`&lt;span style=&quot;color: red; font-size: 30px;&quot;&gt;哈哈哈&lt;/span&gt;`</span></span><br><span class="line">       &#125;</span><br><span class="line">     &#125;,</span><br></pre></td></tr></table></figure><h4 id="4-v-pre"><a href="#4-v-pre" class="headerlink" title="4.v-pre"></a>4.v-pre</h4><p>v-pre用于跳过元素和它的子元素的编译过程，显示原始的Mustache标签：</p><ul><li>跳过不需要编译的节点，加快编译的速度</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div v-pre&gt;</span><br><span class="line">     <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">     <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>当前计数: &#123;&#123; counter &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">     <span class="language-xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-pre</span>&gt;</span>&#123;&#123;&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">   &lt;/div&gt;</span><br><span class="line"><span class="comment">// div中设置了 v-pre则子元素也不会进行编译</span></span><br></pre></td></tr></table></figure><h4 id="5-v-cloak"><a href="#5-v-cloak" class="headerlink" title="5.v-cloak"></a>5.v-cloak</h4><p>这个指令保持在元素上直到关联组件实例结束编译</p><ul><li>和 CSS 规则与 [v-cloak] { display: none } 一起用时，这个指令可以隐藏未编译的 Mustache 标签直到组件实例准备完毕</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">  [v-cloak] &#123;</span><br><span class="line">    <span class="attr">display</span>: none;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-cloak</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> app = <span class="title class_">Vue</span>.<span class="title function_">createApp</span>(&#123;</span><br><span class="line">      <span class="attr">data</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">          <span class="attr">message</span>: <span class="string">&quot;Hello Vue&quot;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">    app.<span class="title function_">mount</span>(<span class="string">&quot;#app&quot;</span>)</span><br><span class="line">  &#125;, <span class="number">3000</span>)</span><br></pre></td></tr></table></figure><h4 id="6-v-memo"><a href="#6-v-memo" class="headerlink" title="6.v-memo"></a>6.v-memo</h4><p>缓存一个模板的子树，在元素和组件上都可以使用，为了实现缓存，该指令需要传入一个固定长度的依赖值数组进行比较。如果数组里的每个值都与最后一次的渲染相同，那么整个子树的更新将被跳过</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> &lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">   &lt;!-- name 和 age 都保持不变才跳过对数据的修改操作 --&gt;</span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-memo</span>=<span class="string">&quot;[name, age]&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;<span class="name">h2</span>&gt;</span>name: &#123;&#123; name &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;<span class="name">h2</span>&gt;</span>age: &#123;&#123; age &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;<span class="name">h2</span>&gt;</span>height: &#123;&#123; height &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeMessage&quot;</span>&gt;</span>改变信息<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"> &lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title class_">Vue</span>.<span class="title function_">createApp</span>(&#123;</span><br><span class="line">     <span class="attr">data</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> &#123;</span><br><span class="line">         <span class="attr">name</span>: <span class="string">&quot;sws&quot;</span>,</span><br><span class="line">         <span class="attr">age</span>: <span class="number">23</span>,</span><br><span class="line">         <span class="attr">height</span>: <span class="number">1.84</span></span><br><span class="line">       &#125;</span><br><span class="line">     &#125;,</span><br><span class="line">     <span class="attr">methods</span>: &#123;</span><br><span class="line">       <span class="title function_">changeMessage</span>(<span class="params"></span>) &#123;</span><br><span class="line">         <span class="comment">// this.name = &quot;swd&quot;,</span></span><br><span class="line">         <span class="variable language_">this</span>.<span class="property">age</span> = <span class="number">21</span>,</span><br><span class="line">         <span class="variable language_">this</span>.<span class="property">height</span> = <span class="number">1.82</span></span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;)</span><br></pre></td></tr></table></figure><h3 id="3、v-bind-绑定属性"><a href="#3、v-bind-绑定属性" class="headerlink" title="3、v-bind 绑定属性"></a>3、v-bind 绑定属性</h3><p>动态的绑定一个或多个 attribute，也可以是组件的 prop（向另一个组件传递props值）</p><p>当用于绑定 class 或 style attribute， 支持额外的值类型如数组或对象</p><h4 id="1-绑定基本属性"><a href="#1-绑定基本属性" class="headerlink" title="1.绑定基本属性"></a>1.绑定基本属性</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- <span class="number">1.</span>绑定img的src --&gt;</span><br><span class="line">   &lt;!-- 语法糖: v-bind -&gt; : --&gt;</span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">v-bind:src</span>=<span class="string">&quot;showImgUrl&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="comment">&lt;!-- 2.绑定a的超链接 --&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;<span class="name">a</span> <span class="attr">:href</span>=<span class="string">&quot;href&quot;</span>&gt;</span>百度一下<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>案例：点击切换图片</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;button @click=<span class="string">&quot;changeImg&quot;</span>&gt;切换图片&lt;/button&gt;</span><br><span class="line">   <span class="attr">data</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> &#123;</span><br><span class="line">           <span class="attr">imgUrl1</span>: <span class="string">&quot;xxx1&quot;</span>,</span><br><span class="line">           <span class="attr">imgUrl2</span>: <span class="string">&quot;xxx2&quot;</span>,</span><br><span class="line">           <span class="attr">showImgUrl</span>: <span class="string">&quot;xxx1&quot;</span>,</span><br><span class="line">           <span class="attr">href</span>: <span class="string">&quot;https://www.baidu.com&quot;</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="attr">methods</span>: &#123;</span><br><span class="line">       <span class="title function_">changeImg</span>(<span class="params"></span>) &#123;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">showImgUrl</span> = <span class="variable language_">this</span>.<span class="property">showImgUrl</span> === <span class="variable language_">this</span>.<span class="property">imgUrl1</span> ? <span class="variable language_">this</span>.<span class="property">imgUrl2</span> : <span class="variable language_">this</span>.<span class="property">imgUrl1</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="2-绑定class"><a href="#2-绑定class" class="headerlink" title="2.绑定class"></a>2.绑定class</h4><p>开发中，有时候我们的元素class也是动态的，比如：</p><ul><li><p>当数据为某个状态时，字体显示红色</p></li><li><p>当数据另一个状态时，字体显示黑色</p></li></ul><p>绑定class有两种方式：</p><ul><li><p>对象语法：可以传给 :class (v-bind:class 的简写) 一个对象，以动态地切换 class</p></li><li><p>数组语法：可以把一个数组传给 :class，以应用一个 class 列表</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">  &lt;style&gt;</span><br><span class="line">    .<span class="property">active</span> &#123;</span><br><span class="line">      <span class="attr">color</span>: red;</span><br><span class="line">   &#125;</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="comment">&lt;!-- 1.基本绑定class --&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h2</span> <span class="attr">:class</span>=<span class="string">&quot;classes&quot;</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    <span class="comment">&lt;!-- 2.动态class可以写对象语法 --&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">:class</span>=<span class="string">&quot; isActive ? &#x27;active&#x27; : &#x27;&#x27; &quot;</span> @<span class="attr">click</span>=<span class="string">&quot;btnClick&quot;</span>&gt;</span>我是按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span> </span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    <span class="comment">&lt;!-- 2.1对象语法的基本使用 --&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">:class</span>=<span class="string">&quot;&#123;active: isActive&#125;&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;btnClick&quot;</span>&gt;</span>我是&#123;&#123; message &#125;&#125;按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    <span class="comment">&lt;!-- 2.2对象语法的多个键值对 --&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">:class</span>=<span class="string">&quot;&#123;active: isActive, why: true, kobe: false&#125;&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;btnClick&quot;</span>&gt;</span>我是&#123;&#123; message &#125;&#125;按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    <span class="comment">&lt;!-- 2.3动态绑定的class可以个普通的class并列使用 --&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;abc bcd&quot;</span> <span class="attr">:class</span>=<span class="string">&quot;&#123;active: isActive, why: true, kobe: false&#125;&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;btnClick&quot;</span>&gt;</span>我是&#123;&#123; message &#125;&#125;按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    <span class="comment">&lt;!-- 2.4动态绑定的class可以个普通的class并列使用 --&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;abc bcd&quot;</span> <span class="attr">:class</span>=<span class="string">&quot;getDynamicClasses()&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;btnClick&quot;</span>&gt;</span>我是&#123;&#123; message &#125;&#125;按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    <span class="comment">&lt;!-- 3.动态class可以写数组语法 --&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h2</span> <span class="attr">:class</span>=<span class="string">&#x27;[&quot;abc&quot;, &quot;sss&quot;]&#x27;</span>&gt;</span>Hello Array<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h2</span> <span class="attr">:class</span>=<span class="string">&#x27;[&quot;abc&quot;, className]&#x27;</span>&gt;</span>Hello Array<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h2</span> <span class="attr">:class</span>=<span class="string">&#x27;[&quot;abc&quot;, className, isActive? &quot;active&quot; : &quot;&quot;]&#x27;</span>&gt;</span>Hello Array<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h2</span> <span class="attr">:class</span>=<span class="string">&#x27;[&quot;abc&quot;, className, &#123; active: isActive &#125;]&#x27;</span>&gt;</span>Hello Array<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./lib/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">const</span> app = <span class="title class_">Vue</span>.<span class="title function_">createApp</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">data</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="attr">message</span>: <span class="string">&quot;原色&quot;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="attr">classes</span>: <span class="string">&quot;ads scw fvs&quot;</span>, </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="attr">isActive</span>: <span class="literal">false</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="attr">className</span>: <span class="string">&quot;sdw&quot;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">methods</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="title function_">btnClick</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="variable language_">this</span>.<span class="property">isActive</span> = !<span class="variable language_">this</span>.<span class="property">isActive</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="variable language_">this</span>.<span class="property">message</span> = <span class="variable language_">this</span>.<span class="property">message</span> === <span class="string">&quot;原色&quot;</span> ? <span class="string">&quot;红色&quot;</span> : <span class="string">&quot;原色&quot;</span> </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">getDynamicClasses</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="keyword">return</span> &#123; <span class="attr">active</span>: <span class="variable language_">this</span>.<span class="property">isActive</span>, <span class="attr">why</span>: <span class="literal">true</span>, <span class="attr">kobe</span>: <span class="literal">false</span>&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    app.<span class="title function_">mount</span>(<span class="string">&quot;#app&quot;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h4 id="3-绑定style"><a href="#3-绑定style" class="headerlink" title="3.绑定style"></a>3.绑定style</h4><p>可以利用v-bind:style来绑定一些CSS内联样式：</p><ul><li><p>这是因为某些样式我们需要根据数据动态来决定</p></li><li><p>比如某段文字的颜色，大小等等</p></li></ul><p>CSS property 名可以用驼峰式或短横线（使用括号）分隔 ，记得用引号括起来来命名</p><p>绑定class有两种方式：</p><ul><li><p>对象语法</p></li><li><p>数组语法：:style 的数组语法可以将多个样式对象应用到同一个元素上</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">   &lt;!-- <span class="number">1.</span>普通的style写法 --&gt;</span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">style</span>=<span class="string">&quot;color: red; font-size: 30px;&quot;</span>&gt;</span>哈哈哈<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">   &lt;!-- <span class="number">2.</span>style中的某些值，来自data中 --&gt;</span><br><span class="line">   &lt;!-- <span class="number">2.1</span>动态绑定style 在后面跟上 对象类型 --&gt;</span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">:style</span>=<span class="string">&quot;&#123; color: fontColor, fontSize: fontSize + &#x27;px&#x27; &#125;&quot;</span>&gt;</span>嘻嘻嘻<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">   &lt;!-- <span class="number">2.2</span> 动态的绑定属性，这个属性是一个对象 --&gt;</span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">:style</span>=<span class="string">&quot;objStyle&quot;</span>&gt;</span>哈哈哈<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">   &lt;!-- <span class="number">3.</span>style的数组语法 --&gt;</span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">:style</span>=<span class="string">&quot;[objStyle, &#123;backgroundColor: &#x27;purple&#x27;&#125;]&quot;</span>&gt;</span>嘿嘿嘿<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="attr">data</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> &#123;</span><br><span class="line">         <span class="attr">fontColor</span>: <span class="string">&#x27;blue&#x27;</span>,</span><br><span class="line">         <span class="attr">fontSize</span>: <span class="number">30</span>,</span><br><span class="line">         <span class="attr">objStyle</span>: &#123;</span><br><span class="line">           <span class="attr">fontSize</span>: <span class="string">&#x27;50px&#x27;</span>,</span><br><span class="line">           <span class="attr">color</span>: <span class="string">&#x27;green&#x27;</span></span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><h4 id="4-动态绑定属性"><a href="#4-动态绑定属性" class="headerlink" title="4.动态绑定属性"></a>4.动态绑定属性</h4><p>某些情况下，我们属性的名称可能也不是固定的：</p><ul><li><p>如果属性名称不是固定的，我们可以使用 :[属性名]&#x3D;“值” 的格式来定义</p></li><li><p>这种绑定的方式，我们称之为动态绑定属性</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">:</span>[<span class="attr">name</span>]=<span class="string">&quot;&#x27;aaa&#x27;&quot;</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">  <span class="attr">data</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">          <span class="attr">message</span>: <span class="string">&quot;Hello Vue&quot;</span>,</span><br><span class="line">          <span class="attr">name</span>: <span class="string">&quot;class&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="5-绑定对象"><a href="#5-绑定对象" class="headerlink" title="5.绑定对象"></a>5.绑定对象</h4><p>如果希望将一个对象的所有属性绑定到元素上的所有属性：</p><ul><li>可以直接使用 v-bind 绑定一个 对象</li></ul><p>案例：infos对象会被拆解成div的各个属性</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>&lt;h2 :name=<span class="string">&quot;name&quot;</span> :age=<span class="string">&quot;age&quot;</span> :height=<span class="string">&quot;height&quot;</span>&gt;<span class="title class_">Hello</span> <span class="title class_">World</span>&lt;/h2&gt;</span><br><span class="line">    &lt;!-- v-bind绑定对象  给组件传递参数 --&gt;</span><br><span class="line"><span class="number">2</span>   &lt;h2 v-bind=<span class="string">&quot;props&quot;</span>&gt;<span class="title class_">Hello</span> <span class="title class_">Bind</span>&lt;/h2&gt;</span><br><span class="line"><span class="attr">data</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">props</span>: &#123;</span><br><span class="line">                <span class="attr">name</span>: <span class="string">&quot;why&quot;</span>,</span><br><span class="line">                <span class="attr">age</span>: <span class="number">23</span>,</span><br><span class="line">                <span class="attr">height</span>: <span class="number">1.44</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&quot;why&quot;</span>,</span><br><span class="line">            <span class="attr">age</span>: <span class="number">23</span>,</span><br><span class="line">            <span class="attr">height</span>: <span class="number">1.44</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    <span class="comment">// 1 2效果相同</span></span><br></pre></td></tr></table></figure><h3 id="4-、Vue-的事件绑定"><a href="#4-、Vue-的事件绑定" class="headerlink" title="4 、Vue 的事件绑定"></a>4 、Vue 的事件绑定</h3><p>为了与用户进行交互，必须监听用户发生的事件</p><p>v-on的使用：</p><ul><li><p>缩写（语法糖）：@</p></li><li><p>预期：Function | Inline Statement | Object</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- <span class="number">1.</span>基本的写法 --&gt;</span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span> <span class="attr">v-on:click</span>=<span class="string">&quot;divClick&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">   &lt;!-- <span class="number">2.</span>语法糖写法 --&gt;</span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;divClick&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">   &lt;!-- <span class="number">3.</span>绑定的方法位置，也可以写成一个表达式（不常用,不推荐） --&gt;</span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123; counter &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;increment&quot;</span>&gt;</span>+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;counter--&quot;</span>&gt;</span>-1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">   &lt;!-- <span class="number">4.</span>绑定其他方法 --&gt;</span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span> @<span class="attr">mousemove</span>=<span class="string">&quot;divMousemove&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">   &lt;!-- <span class="number">5.</span>绑定多个事件 分开传入或者传入对象 --&gt;</span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;divClick&quot;</span> @<span class="attr">mousemove</span>=<span class="string">&quot;divMousemove&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="comment">// v-on: == v-on 下方这儿:可以省略</span></span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span> <span class="attr">v-on:</span>=<span class="string">&quot;&#123; click: divClick, mousemove: divMousemove &#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span> @=<span class="string">&quot;&#123; click: divClick, mousemove: divMousemove &#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="title function_">divClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">         <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;divClick&quot;</span>)</span><br><span class="line">       &#125;,</span><br><span class="line">       <span class="title function_">increment</span>(<span class="params"></span>) &#123;</span><br><span class="line">         <span class="variable language_">this</span>.<span class="property">counter</span>++</span><br><span class="line">       &#125;,</span><br><span class="line">       <span class="title function_">divMousemove</span>(<span class="params"></span>) &#123;</span><br><span class="line">         <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;mousemove&quot;</span>)</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><ul><li>参数：event</li><li>自定义参数</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- <span class="number">1.</span>默认传递event对象 --&gt;</span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;btn1Click&quot;</span>&gt;</span>按钮1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">   &lt;!-- <span class="number">2.</span>只有自己的参数 --&gt;</span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;btn2Click(&#x27;why&#x27;, age)&quot;</span>&gt;</span>按钮2<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">   &lt;!-- <span class="number">3.</span>明确的参数和event对象 --&gt;</span><br><span class="line">   &lt;!-- 在模板中想要明确的获取event对象：$event --&gt;</span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;btn3Click(&#x27;swd&#x27;, age, $event)&quot;</span>&gt;</span>按钮3<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.默认参数：event对象</span></span><br><span class="line">       <span class="comment">// 总结：如果在绑定事件的时候，没有传递任何的参数，那么event对象会被默认传递进来</span></span><br><span class="line">       <span class="title function_">btn1Click</span>(<span class="params"></span>) &#123;</span><br><span class="line">         <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;btnClick:&quot;</span>, event)</span><br><span class="line">       &#125;,</span><br><span class="line">       <span class="title function_">btn2Click</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">         <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;btn2Click&quot;</span>, name, age)</span><br><span class="line">       &#125;,</span><br><span class="line">       <span class="title function_">btn3Click</span>(<span class="params">name, age, event</span>) &#123;</span><br><span class="line">         <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;btn3Click&quot;</span>, name, age, event)</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><ul><li><p>修饰符：</p><ul><li>.stop - 调用 event.stopPropagation()</li><li>.prevent - 调用 event.preventDefault()</li><li>.capture - 添加事件侦听器时使用 capture 模式</li><li>.self - 只当事件是从侦听器绑定的元素本身触发时才触发回调</li><li>.{keyAlias} - 仅当事件是从特定键触发时才触发回调</li><li>.once - 只触发一次回调</li><li>.left - 只当点击鼠标左键时触发</li><li>.right - 只当点击鼠标右键时触发</li><li>.middle - 只当点击鼠标中键时触发</li><li>.passive - { passive: true } 模式添加侦听器</li></ul></li><li><p>用法：绑定事件监听</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div <span class="keyword">class</span>=<span class="string">&quot;box&quot;</span> @click=<span class="string">&quot;divClick&quot;</span>&gt;</span><br><span class="line">     <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.stop</span>=<span class="string">&quot;btnClick&quot;</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">   &lt;/div&gt;</span><br></pre></td></tr></table></figure><h3 id="5、Vue-的条件渲染"><a href="#5、Vue-的条件渲染" class="headerlink" title="5、Vue 的条件渲染"></a>5、Vue 的条件渲染</h3><p>某些情况下需要根据当前的条件决定某些元素或组件是否渲染，这时就需要进行条件判断</p><p>v-if、v-else、v-else-if用于根据条件来渲染某一块的内容：</p><ul><li><p>这些内容只有在条件为true时，才会被渲染出来</p></li><li><p>这三个指令与JavaScript的条件语句if、else、else if类似</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-if</span>=<span class="string">&quot;score &gt; 90&quot;</span>&gt;</span>优秀<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-else-if</span>=<span class="string">&quot;score &gt; 80&quot;</span>&gt;</span>良好<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-else-if</span>=<span class="string">&quot;score &gt;= 60&quot;</span>&gt;</span>及格<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-else</span>&gt;</span>不及格<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><h4 id="1-v-if的渲染原理"><a href="#1-v-if的渲染原理" class="headerlink" title="1.v-if的渲染原理"></a>1.v-if的渲染原理</h4><ul><li><p>v-if是惰性的</p></li><li><p>当条件为false时，其判断的内容完全不会被渲染或者会被销毁掉</p></li><li><p>当条件为true时，才会真正渲染条件块中的内容</p></li></ul><p>即当v-if所判断的条件为false时，页面查看代码中没有其创建的元素</p><h4 id="2-template-元素"><a href="#2-template-元素" class="headerlink" title="2.template 元素"></a>2.template 元素</h4><p>因为v-if是一个指令，所以必须将其添加到一个元素上：</p><ul><li><p>但是如果我们希望切换的是多个元素</p></li><li><p>此时我们渲染div，但是我们并不希望div这种元素被渲染</p></li><li><p>这个时候，我们可以选择使用template</p></li></ul><p>template元素可以当做不可见的包裹元素，并且在v-if上使用，但是最终template不会被渲染出来：</p><ul><li>有点类似于小程序中的block</li></ul><h4 id="3-v-show和v-if的区别"><a href="#3-v-show和v-if的区别" class="headerlink" title="3.v-show和v-if的区别"></a>3.v-show和v-if的区别</h4><p>在用法上的区别：</p><ul><li><p>v-show是不支持template</p></li><li><p>v-show不可以和v-else一起使用</p></li></ul><p>本质的区别：</p><ul><li><p>v-show元素无论是否需要显示到浏览器上，它的DOM实际都是有存在的，只是通过CSS的display属性来进行切换</p></li><li><p>v-if当条件为false时，其对应的元素压根不会被渲染到DOM中</p></li></ul><p>开发中选择</p><ul><li><p>如果我们的元素需要在显示和隐藏之间频繁的切换，那么使用v-show</p></li><li><p>如果不会频繁的发生切换，那么使用v-if</p></li></ul><h3 id="6、Vue-的列表渲染"><a href="#6、Vue-的列表渲染" class="headerlink" title="6、Vue 的列表渲染"></a>6、Vue 的列表渲染</h3><h4 id="1-渲染（遍历）方式"><a href="#1-渲染（遍历）方式" class="headerlink" title="1.渲染（遍历）方式"></a>1.渲染（遍历）方式</h4><p>开发中，我们往往会从服务器拿到一组数据，并且需要对其进行渲染</p><ul><li><p>这时可以使用v-for来完成</p></li><li><p>v-for类似于JavaScript的for循环，可以用于遍历一组数据</p></li></ul><p>v-for的基本格式是 “item in 数组”：</p><ul><li><p>数组通常是来自data或者prop，也可以是其他方式</p></li><li><p>item是我们给每项元素起的一个别名，这个别名可以自定来定义</p></li></ul><p>我们知道，在遍历一个数组的时候会经常需要拿到数组的索引：</p><ul><li><p>如果我们需要索引，可以使用格式： “(item, index) in 数组”</p></li><li><p>注意上面的顺序：数组元素项item是在前面的，索引项index是在后面的</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- <span class="number">1.</span>电影列表进行渲染 --&gt;</span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>电影列表<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;movie in movies&quot;</span>&gt;</span>&#123;&#123;movie&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">   &lt;!-- <span class="number">2.</span>电影列表同时索引(数组) --&gt;</span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">     // 支持 of  </span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(movie, index) in movies&quot;</span>&gt;</span>&#123;&#123;index + 1&#125;&#125; - &#123;&#123;movie&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">   &lt;!-- <span class="number">3.</span>遍历数组复杂数据 --&gt;</span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>商品列表<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span> <span class="attr">v-for</span>=<span class="string">&quot;item in products&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;<span class="name">h3</span> <span class="attr">class</span>=<span class="string">&quot;title&quot;</span>&gt;</span>商品:&#123;&#123;item.name&#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;<span class="name">span</span>&gt;</span>价格:&#123;&#123;item.price&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;<span class="name">p</span>&gt;</span>秒杀:&#123;&#123;item.desc&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>v-for也支持遍历对象，并且支持有一二三个参数：</p><ul><li><p>一个参数： “value in object”</p></li><li><p>二个参数： “(value, key) in object”</p></li><li><p>三个参数： “(value, key, index) in object”</p></li></ul><p>v-for同时也支持数字的遍历：</p><ul><li>每一个item都是一个数字</li></ul><p>v-for也可以遍历其他可迭代对象(Iterable)</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- <span class="number">1.</span>遍历对象 --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(value, key, index) in info&quot;</span>&gt;</span>&#123;&#123;value&#125;&#125;-&#123;&#123;key&#125;&#125;-&#123;&#123;index&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;!--<span class="number">2.</span>遍历字符串 --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in message&quot;</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;!-- <span class="number">3.</span>遍历数字 --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in 10&quot;</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h4 id="2-template元素"><a href="#2-template元素" class="headerlink" title="2.template元素"></a>2.template元素</h4><p>类似于v-if，你可以使用 template 元素来循环渲染一段包含多个元素的内容：</p><ul><li>使用template来对多个元素进行包裹，而不是使用div来完成；</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- 如果div没有实际的意义，可以使用template替换 --&gt;</span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">&quot;(value, key, index) in infos&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;value&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;<span class="name">strong</span>&gt;</span>&#123;&#123;key&#125;&#125;<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;<span class="name">i</span>&gt;</span>&#123;&#123;index&#125;&#125;<span class="tag">&lt;/<span class="name">i</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h4 id="3-数组更新检测"><a href="#3-数组更新检测" class="headerlink" title="3.数组更新检测"></a>3.数组更新检测</h4><p>Vue 将被侦听的数组的变更方法进行了包裹，所以它们也将会触发视图更新</p><p>这些被包裹过的方法包括：</p><ul><li><p>push()</p></li><li><p>pop()</p></li><li><p>shift()</p></li><li><p>unshift()</p></li><li><p>splice()</p></li><li><p>sort()</p></li><li><p>reverse()</p></li></ul><p>替换数组的方法</p><ul><li>上面的方法会直接修改原来的数组</li></ul><p>但是某些方法不会替换原来的数组，而是会生成新的数组，比如 filter()、concat() 和 slice()</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> &lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in names&quot;</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;btnClick&quot;</span>&gt;</span>修改数组<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"> &lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> &#123;</span><br><span class="line">         <span class="attr">names</span>: [<span class="string">&quot;sdw&quot;</span>, <span class="string">&quot;dwdx&quot;</span>, <span class="string">&quot;wwa&quot;</span>]</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;,</span><br><span class="line">     <span class="attr">methods</span>: &#123;</span><br><span class="line">       <span class="title function_">btnClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">         <span class="comment">// 1.将数组修改为新的数组</span></span><br><span class="line">         <span class="comment">// this.names = [&#x27;scs&#x27;,&#x27;dwa&#x27;]</span></span><br><span class="line"></span><br><span class="line">         <span class="comment">// 2.通过一些数组的方法法，修改数组中的元素</span></span><br><span class="line">         <span class="comment">// this.names.push(&quot;ig&quot;)</span></span><br><span class="line"></span><br><span class="line">         <span class="comment">// this.names.splice(2,1,&quot;why&quot;)</span></span><br><span class="line">         <span class="comment">// this.names.sort()</span></span><br><span class="line">         <span class="comment">// this.names.reverse()</span></span><br><span class="line"></span><br><span class="line">         <span class="comment">// 3.不修改原数组的方法是不能侦听（watch）</span></span><br><span class="line">         <span class="keyword">const</span> newNames = <span class="variable language_">this</span>.<span class="property">names</span>.<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> item + <span class="string">&quot;why&quot;</span>)</span><br><span class="line">         <span class="variable language_">this</span>.<span class="property">names</span> = newNames</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><h4 id="4-v-for中的key"><a href="#4-v-for中的key" class="headerlink" title="4.v-for中的key"></a>4.v-for中的key</h4><h5 id="1、了解key属性"><a href="#1、了解key属性" class="headerlink" title="1、了解key属性"></a>1、了解key属性</h5><p>在使用v-for进行列表渲染时，我们通常会给元素或者组件绑定一个key属性</p><ul><li><p>key属性主要用在Vue的虚拟DOM算法，在新旧nodes对比时辨识VNodes</p></li><li><p>如果不使用key，Vue会使用一种最大限度减少动态元素并且尽可能的尝试就地修改&#x2F;复用相同类型元素的算法</p></li><li><p>而使用key时，它会基于key的变化重新排列元素顺序，并且会移除&#x2F;销毁key不存在的元素</p></li></ul><h5 id="2、虚拟DOM"><a href="#2、虚拟DOM" class="headerlink" title="2、虚拟DOM"></a>2、虚拟DOM</h5><p>VNode：先理解HTML元素创建出来的VNode</p><ul><li><p>VNode的全称是Virtual Node，也就是虚拟节点</p></li><li><p>无论是组件还是元素，它们最终在Vue中表示出来的都是一个个VNode</p></li><li><p>VNode的本质是一个JavaScript的对象</p></li></ul><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230410203039359.png" alt="image-20230410203039359"></p><p>如果不只是一个简单的div，而是有一堆元素，那么应该会形成一个VNode Tree</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230410203141402.png" alt="image-20230410203141402"></p><p>作用：</p><ul><li>跨平台：将对象进行多端的解析，以展示于不同的平台</li></ul><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230410203257959.png" alt="image-20230410203257959"></p><ul><li>diff 算法</li></ul><p>案例：点击按钮在 li 插入 f 元素</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;button @click=<span class="string">&quot;insetF&quot;</span>&gt;插入F&lt;/button&gt;</span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="comment">&lt;!-- key要求唯一：id --&gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in letters&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;item&quot;</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="attr">methods</span>: &#123;</span><br><span class="line">       <span class="title function_">insetF</span>(<span class="params"></span>) &#123;</span><br><span class="line">         <span class="variable language_">this</span>.<span class="property">letters</span>.<span class="title function_">splice</span>(<span class="number">2</span>, <span class="number">0</span>, <span class="string">&quot;f&quot;</span>)</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>这次更新对于ul和button是不需要进行更新，需要更新的是我们li的列表</p><ul><li><p>在Vue中，对于相同父元素的子元素节点并不会重新渲染整个列表</p></li><li><p>因为对于列表中 a、b、c、d它们都是没有变化的</p></li><li><p>在操作真实DOM的时候，我们只需要在中间插入一个f的li即可</p></li></ul><p>Vue中对于列表的更新究竟是如何操作的呢？</p><p>Vue事实上会对于有key和没有key会调用两个不同的方法</p><ul><li><p>有key，那么就使用 patchKeyedChildren方法</p></li><li><p>没有key，那么久使用 patchUnkeyedChildren方法</p></li></ul><p>在没有key时diff算法效率并不高</p><ul><li><p>c和d来说它们事实上并不需要有任何的改动</p></li><li><p>但是c被f所使用了，所有后续所有的内容都要一次进行改动，并且最后进行新增</p></li></ul><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230410203723802.png" alt="image-20230410203723802"></p><h5 id="3、key的作用"><a href="#3、key的作用" class="headerlink" title="3、key的作用"></a>3、key的作用</h5><p>有key的diff算法</p><p>第一步的操作是从头开始进行遍历、比较</p><ul><li><p>a和b是一致的会继续进行比较</p></li><li><p>c和f因为key不一致，所以就会break跳出循环</p></li></ul><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230410204040153.png" alt="image-20230410204040153"></p><p>第二步的操作是从尾部开始进行遍历、比较</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230410204053987.png" alt="image-20230410204053987"></p><p>第三步是如果旧节点遍历完毕，但是依然有新的节点，那么就新增节点</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230410204020323.png" alt="image-20230410204020323"></p><p>第四步是如果新的节点遍历完毕，但是依然有旧的节点，那么就移除旧节点</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230410204005807.png" alt="image-20230410204005807"></p><p>第五步是最特色的情况，中间还有很多未知的或者乱序的节点</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230410203948482.png" alt="image-20230410203948482"></p><p>所以可以发现，Vue在进行diff算法的时候，会尽量利用我们的key来进行优化操作</p><ul><li><p>在没有key的时候我们的效率是非常低效的</p></li><li><p>在进行插入或者重置顺序的时候，保持相同的key可以让diff算法更加的高效</p></li></ul><h2 id="3-Options-API"><a href="#3-Options-API" class="headerlink" title="3.Options API"></a>3.Options API</h2><h3 id="1、计算属性computed"><a href="#1、计算属性computed" class="headerlink" title="1、计算属性computed"></a>1、计算属性computed</h3><h4 id="1-基本使用"><a href="#1-基本使用" class="headerlink" title="1.基本使用"></a>1.基本使用</h4><p>在模板中可以直接通过插值语法显示一些data中的数据</p><p>但是某些情况可能需要对数据进行一些转化后再显示，或者需要将多个数据结合起来进行显示</p><ul><li><p>比如需要对多个data数据进行运算、三元运算符来决定结果、数据进行某种转化后显示</p></li><li><p>在模板中使用表达式，可以非常方便的实现，但是设计它们的初衷是用于简单的运算</p></li><li><p>在模板中放入太多的逻辑会让模板过重和难以维护</p></li><li><p>并且如果多个地方都使用到，那么会有大量重复的代码</p></li></ul><p>有没有什么方法可以将逻辑抽离出去</p><ul><li><p>可以，其中一种方式就是将逻辑抽取到一个method中，放到methods的options中</p></li><li><p>但是这种做法有一个直观的弊端，就是所有的data使用过程都会变成了一个方法的调用</p></li></ul><p>另外一种方式就是使用计算属性computed</p><p>计算属性</p><ul><li><p>官方并没有给出直接的概念解释</p></li><li><p>而是说：对于任何包含响应式数据的复杂逻辑，你都应该使用计算属性</p></li><li><p>计算属性将被混入到组件实例中</p><ul><li>所有 getter 和 setter 的 this 上下文自动地绑定为组件实例；</li></ul></li></ul><p>计算属性的用法：</p><ul><li><p>选项：computed</p></li><li><p>类型：{ [key: string]: Function | { get: Function, set: Function } }</p></li></ul><h5 id="案例对比实现"><a href="#案例对比实现" class="headerlink" title="案例对比实现"></a>案例对比实现</h5><h6 id="1-模板语法："><a href="#1-模板语法：" class="headerlink" title="1.模板语法："></a>1.模板语法：</h6><ul><li><p>缺点一：模板中存在大量的复杂逻辑，不便于维护（模板中表达式的初衷是用于简单的计算）</p></li><li><p>缺点二：当有多次一样的逻辑时，存在重复的代码</p></li><li><p>缺点三：多次使用的时候，很多运算也需要多次执行，没有缓存</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- 插值语法表达式直接拼接 --&gt;</span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123; firstName + &quot; &quot; + lastName&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123; firstName&#125;&#125; &#123;&#123;lastName&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">   &lt;!-- <span class="number">2.</span>显示等级 --&gt;</span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123; score &gt;= 60 ? &#x27;及格&#x27; : &#x27;不及格&#x27; &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">   &lt;!-- <span class="number">3.</span>反转单词 --&gt;</span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123; message.split(&quot; &quot;).reverse().join(&quot; &quot;) &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"> &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">     <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> &#123;</span><br><span class="line">         <span class="comment">// 1.姓名</span></span><br><span class="line">         <span class="attr">firstName</span>: <span class="string">&quot;kobe&quot;</span>,</span><br><span class="line">         <span class="attr">lastName</span>: <span class="string">&quot;bryant&quot;</span>,</span><br><span class="line">         <span class="comment">// 2.分数  及格/不及格</span></span><br><span class="line">         <span class="attr">score</span>: <span class="number">80</span>,</span><br><span class="line">         <span class="comment">// 3.一串文本，对文本中的单词进行反转显示</span></span><br><span class="line">         <span class="attr">message</span>: <span class="string">&#x27;my name is wbh&#x27;</span></span><br><span class="line">       &#125;</span><br><span class="line">     &#125;,</span><br></pre></td></tr></table></figure><h6 id="2-methods-实现"><a href="#2-methods-实现" class="headerlink" title="2.methods 实现"></a>2.methods 实现</h6><ul><li><p>缺点一：我们事实上需要显示的是一个结果，但是都变成了一种方法的调用</p></li><li><p>缺点二：多次使用方法的时候，没有缓存，也需要多次计算</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">methods</span>: &#123;</span><br><span class="line">      <span class="title function_">getFullName</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">firstName</span> + <span class="string">&quot; &quot;</span> + <span class="variable language_">this</span>.<span class="property">lastName</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="title function_">scoreLevel</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">score</span> &gt;= <span class="number">60</span> ? <span class="string">&#x27;及格&#x27;</span> : <span class="string">&#x27;不及格&#x27;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="title function_">reverseMessage</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">message</span>.<span class="title function_">split</span>(<span class="string">&quot; &quot;</span>).<span class="title function_">reverse</span>().<span class="title function_">join</span>(<span class="string">&quot; &quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h6 id="3-computed-实现"><a href="#3-computed-实现" class="headerlink" title="3.computed 实现"></a>3.computed 实现</h6><ul><li><p>注意：计算属性看起来像是一个函数，但是我们在使用的时候不需要加()，这个后面讲setter和getter时会讲到</p></li><li><p>发现无论是直观上，还是效果上计算属性都是更好的选择</p></li><li><p>并且计算属性是有缓存的</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">!-- 插值语法表达式直接拼接 --&gt;</span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123; fullName &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123; fullName &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">   &lt;!-- <span class="number">2.</span>显示等级 --&gt;</span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123; scoreLevel &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">   &lt;!-- <span class="number">3.</span>反转单词 --&gt;</span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123; reverseMessage &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"> <span class="attr">computed</span>: &#123;</span><br><span class="line">       <span class="comment">// 1.计算属性默认对应的是一个函数</span></span><br><span class="line">       <span class="title function_">fullName</span>(<span class="params"></span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">firstName</span> + <span class="string">&quot; &quot;</span> + <span class="variable language_">this</span>.<span class="property">lastName</span></span><br><span class="line">       &#125;,</span><br><span class="line">       <span class="title function_">scoreLevel</span>(<span class="params"></span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">score</span> &gt;= <span class="number">60</span> ? <span class="string">&quot;及格&quot;</span> : <span class="string">&quot;不及格&quot;</span></span><br><span class="line">       &#125;,</span><br><span class="line">       <span class="title function_">reverseMessage</span>(<span class="params"></span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">message</span>.<span class="title function_">split</span>(<span class="string">&quot; &quot;</span>).<span class="title function_">reverse</span>().<span class="title function_">join</span>(<span class="string">&quot; &quot;</span>)</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><h4 id="2-computed-和-methods-的区别"><a href="#2-computed-和-methods-的区别" class="headerlink" title="2.computed 和 methods 的区别"></a>2.computed 和 methods 的区别</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">methods</span>: &#123;</span><br><span class="line">     <span class="title function_">getFullName</span>(<span class="params"></span>) &#123;</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;methods--------&quot;</span>)  <span class="comment">// 调用几次执行几次</span></span><br><span class="line">       <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">firstName</span> + <span class="string">&quot; &quot;</span> + <span class="variable language_">this</span>.<span class="property">lastName</span></span><br><span class="line">     &#125;,</span><br><span class="line">     <span class="title function_">changeLastName</span>(<span class="params"></span>) &#123;</span><br><span class="line">       <span class="variable language_">this</span>.<span class="property">lastName</span> = <span class="string">&quot;why&quot;</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="attr">computed</span>: &#123;</span><br><span class="line">     <span class="title function_">fullName</span>(<span class="params"></span>) &#123;</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;--------&quot;</span>) <span class="comment">//执行一次 会有缓存</span></span><br><span class="line">       <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">firstName</span> + <span class="string">&quot; &quot;</span> + <span class="variable language_">this</span>.<span class="property">lastName</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>原因：</p><ul><li><p>计算属性会基于它们的依赖关系进行缓存</p></li><li><p>在数据不发生变化时，计算属性是不需要重新计算的</p></li><li><p>但是如果依赖的数据发生变化，在使用时，计算属性依然会重新进行计算</p></li></ul><h4 id="3-computed-的-setter-和-getter"><a href="#3-computed-的-setter-和-getter" class="headerlink" title="3.computed 的 setter 和 getter"></a>3.computed 的 setter 和 getter</h4><p>计算属性在大多数情况下，只需要一个getter方法即可，所以我们会将计算属性直接写成一个函数</p><p>如果我们确实想设置计算属性的值，也可以给计算属性设置一个setter的方法</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123; fullname &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;setFullName&quot;</span>&gt;</span>设置fullname<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;  </span><br><span class="line"> <span class="attr">methods</span>: &#123;</span><br><span class="line">      <span class="title function_">setFullName</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">fullname</span> = <span class="string">&quot;coder why&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,  </span><br><span class="line"> <span class="attr">computed</span>: &#123;</span><br><span class="line">      <span class="comment">// 语法糖的写法：</span></span><br><span class="line">      <span class="comment">// fullname() &#123;</span></span><br><span class="line">      <span class="comment">//   return this.firstName + &quot; &quot; + this.lastName</span></span><br><span class="line">      <span class="comment">// &#125;,</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 完整的写法:</span></span><br><span class="line">      <span class="attr">fullname</span>: &#123;</span><br><span class="line">        <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">firstName</span> + <span class="string">&quot; &quot;</span> + <span class="variable language_">this</span>.<span class="property">lastName</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">set</span>: <span class="keyword">function</span>(<span class="params">value</span>) &#123;</span><br><span class="line">          <span class="keyword">const</span> names = value.<span class="title function_">split</span>(<span class="string">&quot; &quot;</span>)</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">firstName</span> = names[<span class="number">0</span>]</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">lastName</span> = names[<span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>源码对setter和getter的处理</p><ul><li>Vue源码内部只是做了一个逻辑判断而已</li></ul><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230410210215389.png" alt="image-20230410210215389"></p><h3 id="2、侦听器watch"><a href="#2、侦听器watch" class="headerlink" title="2、侦听器watch"></a>2、侦听器watch</h3><h4 id="1-什么是侦听器"><a href="#1-什么是侦听器" class="headerlink" title="1.什么是侦听器"></a>1.什么是侦听器</h4><ul><li><p>开发中我们在data返回的对象中定义了数据，这个数据通过插值语法等方式绑定到template中</p></li><li><p>当数据变化时，template会自动进行更新来显示最新的数据</p></li><li><p>但是在某些情况下，我们希望在代码逻辑中监听某个数据的变化，这个时候就需要用侦听器watch来完成</p></li></ul><p>用法：</p><ul><li>选项：watch</li><li>类型：{ [key: string]: string | Function | Object | Array}</li></ul><h4 id="2-基本侦听"><a href="#2-基本侦听" class="headerlink" title="2.基本侦听"></a>2.基本侦听</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeMessage&quot;</span>&gt;</span>修改message<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;  </span><br><span class="line"></span><br><span class="line"> <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">message</span>: <span class="string">&quot;Hello Vue&quot;</span>,</span><br><span class="line">        <span class="attr">infos</span>: &#123; <span class="attr">name</span>:<span class="string">&#x27;why&#x27;</span>, <span class="attr">age</span>: <span class="number">23</span>&#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">methods</span>: &#123;</span><br><span class="line">      <span class="title function_">changeMessage</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">message</span> = <span class="string">&quot;dwsa&quot;</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">infos</span> = &#123; <span class="attr">name</span>:<span class="string">&#x27;kobe&#x27;</span> &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">watch</span>: &#123;</span><br><span class="line">      <span class="comment">// 1.默认有两个参数：newValue/oldVale</span></span><br><span class="line">      <span class="title function_">message</span>(<span class="params">newValue, oldValue</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;message数据发生了变化&quot;</span>, newValue, oldValue)</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="title function_">infos</span>(<span class="params">newValue, oldValue</span>) &#123;</span><br><span class="line">        <span class="comment">// 2.如果是对象类型，那么拿到的是代理对象 proxy</span></span><br><span class="line">        <span class="comment">// console.log(&quot;infos数据发生了变化&quot;, oldValue, newValue)</span></span><br><span class="line">        <span class="comment">// console.log(newValue.name, oldValue.name)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.获取原始对象</span></span><br><span class="line">        <span class="comment">// console.log(&#123; ...newValue &#125;)</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Vue</span>.<span class="title function_">toRaw</span>(oldValue))</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h4 id="3-侦听选项"><a href="#3-侦听选项" class="headerlink" title="3.侦听选项"></a>3.侦听选项</h4><p>例子:当我们点击按钮的时候会修改info.name的值</p><ul><li><p>这个时候使用watch来侦听info，可以侦听到吗？答案是不可以</p></li><li><p>这是因为默认情况下，watch只是在侦听info的引用变化，对于内部属性的变化是不会做出响应的</p><ul><li>这个时候我们可以使用一个选项deep进行更深层的侦听；</li></ul></li></ul><p>注意前面我们说过watch里面侦听的属性对应的也可以是一个Object</p><p>还有另外一个属性，是希望一开始的就会立即执行一次：</p><ul><li><p>使用immediate选项</p></li><li><p>这个时候无论后面数据是否有变化，侦听的函数都会先执行一次</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">     <span class="keyword">return</span> &#123;</span><br><span class="line">       <span class="attr">infos</span>: &#123; <span class="attr">name</span>:<span class="string">&#x27;why&#x27;</span>, <span class="attr">age</span>: <span class="number">23</span>&#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="attr">methods</span>: &#123;</span><br><span class="line">     <span class="title function_">changeMessage</span>(<span class="params"></span>) &#123;</span><br><span class="line">       <span class="comment">// 1.创建一个新对象，赋值给info</span></span><br><span class="line">       <span class="comment">// this.infos = &#123; name:&#x27;kobe&#x27; &#125;</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 2.直接修改原对象的某一个属性</span></span><br><span class="line">       <span class="variable language_">this</span>.<span class="property">infos</span>.<span class="property">name</span> = <span class="string">&quot;kobe&quot;</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="attr">watch</span>: &#123;</span><br><span class="line">     <span class="comment">// 默认watch的监听不会进行深度监听</span></span><br><span class="line">     <span class="comment">// infos(newValue, oldValue) &#123;</span></span><br><span class="line">     <span class="comment">//   console.log(&quot;侦听infos改变&quot;,newValue, oldValue)</span></span><br><span class="line">     <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">// 进行深度监听</span></span><br><span class="line">     <span class="attr">infos</span>: &#123;</span><br><span class="line">       <span class="title function_">handler</span>(<span class="params">newValue, oldValue</span>) &#123;</span><br><span class="line">         <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;侦听infos改变&quot;</span>, newValue, oldValue)</span><br><span class="line">         <span class="variable language_">console</span>.<span class="title function_">log</span>(newValue === oldValue)</span><br><span class="line">       &#125;,</span><br><span class="line">       <span class="comment">// 监听器的一个配置选项</span></span><br><span class="line">       <span class="comment">// infos进行深度监听</span></span><br><span class="line">       <span class="attr">deep</span>: <span class="literal">true</span>,</span><br><span class="line">       <span class="comment">// 第一次渲染直接执行一次监听器</span></span><br><span class="line">       <span class="attr">immediate</span>: <span class="literal">true</span></span><br><span class="line">     &#125;,</span><br><span class="line">     <span class="comment">// 监听name得到改变</span></span><br><span class="line">     <span class="string">&quot;infos.name&quot;</span>: <span class="keyword">function</span>(<span class="params">newValue, oldValue</span>) &#123;</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;侦听infos.name改变&quot;</span>, newValue, oldValue)</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><h4 id="4-其他的写法"><a href="#4-其他的写法" class="headerlink" title="4.其他的写法"></a>4.其他的写法</h4><p>可以在created的生命周期中，使用this.$watchs 来侦听</p><ul><li><p>第一个参数是要侦听的源</p></li><li><p>第二个参数是侦听的回调函数callback</p></li><li><p>第三个参数是额外的其他选项，比如deep、immediate</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 生命周期的回调函数:当前的组件被创建时自动执行</span></span><br><span class="line">   <span class="comment">// 一般在该函数中，会进行网络请求</span></span><br><span class="line">   <span class="title function_">created</span>(<span class="params"></span>) &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;created&quot;</span>)</span><br><span class="line"></span><br><span class="line">     <span class="variable language_">this</span>.$watch(<span class="string">&quot;message&quot;</span>, <span class="function">(<span class="params">newValue, oldValue</span>) =&gt;</span> &#123;</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;message数据变化&quot;</span>,newValue, oldValue)</span><br><span class="line">     &#125;, &#123;<span class="attr">deep</span>: <span class="literal">true</span>, <span class="attr">immediate</span>: <span class="literal">true</span>&#125;)</span><br><span class="line">   &#125;,</span><br></pre></td></tr></table></figure><h3 id="3、阶段练习"><a href="#3、阶段练习" class="headerlink" title="3、阶段练习"></a>3、阶段练习</h3><p>书籍购物车案例</p><h2 id="4-Vue-的双向绑定"><a href="#4-Vue-的双向绑定" class="headerlink" title="4. Vue 的双向绑定"></a>4. Vue 的双向绑定</h2><h3 id="1、基本使用"><a href="#1、基本使用" class="headerlink" title="1、基本使用"></a>1、基本使用</h3><p>表单提交是开发中非常常见的功能，也是和用户交互的重要手段：</p><ul><li><p>比如用户在登录、注册时需要提交账号密码</p></li><li><p>比如用户在检索、创建、更新信息时，需要提交一些数据</p></li></ul><p>这些都要求我们能在代码逻辑中获取到用户提交的数据，通常会使用v-model指令来完成</p><ul><li><p>v-model指令可以在表单 input、textarea以及select元素上创建双向数据绑定</p></li><li><p>它会根据控件类型自动选取正确的方法来更新元素</p></li><li><p>尽管有些神奇，但 v-model 本质上不过是语法糖，它负责监听用户的输入事件来更新数据，并在某种极端场景下进行一些特殊处理</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> v-model=<span class="string">&quot;message&quot;</span>&gt;</span><br></pre></td></tr></table></figure><h3 id="2、v-model-的原理"><a href="#2、v-model-的原理" class="headerlink" title="2、v-model 的原理"></a>2、v-model 的原理</h3><ul><li><p>v-bind绑定value属性的值</p></li><li><p>v-on绑定input事件监听到函数中，函数会获取最新的值赋值到绑定的属性中</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> :value=<span class="string">&quot;message&quot;</span> @input=<span class="string">&quot;inputChange&quot;</span>&gt;</span><br></pre></td></tr></table></figure><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230412110510508.png" alt="image-20230412110510508"></p><p>事实上v-model更加复杂</p><h3 id="3、绑定其他类型"><a href="#3、绑定其他类型" class="headerlink" title="3、绑定其他类型"></a>3、绑定其他类型</h3><h4 id="1-v-model-绑定-textarea"><a href="#1-v-model-绑定-textarea" class="headerlink" title="1.v-model 绑定 textarea"></a>1.v-model 绑定 textarea</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;textarea cols=<span class="string">&quot;30&quot;</span> rows=<span class="string">&quot;10&quot;</span> v-model=<span class="string">&quot;content&quot;</span>&gt;&lt;/textarea&gt;</span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;content&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h4 id="2-v-model-绑定-checkbox"><a href="#2-v-model-绑定-checkbox" class="headerlink" title="2.v-model 绑定 checkbox"></a>2.v-model 绑定 checkbox</h4><h5 id="单选框"><a href="#单选框" class="headerlink" title="单选框"></a>单选框</h5><ul><li><p>v-model 即为布尔值。</p></li><li><p>此时 input 的 value 属性并不影响 v-model 的值</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">   &lt;!-- <span class="number">1.</span>checkbox单选框，绑定到属性的值是一个<span class="title class_">Boolean</span> --&gt;</span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;agree&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;agree&quot;</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;isAgree&quot;</span>&gt;</span> 同意协议</span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">isAgree: false</span></span><br></pre></td></tr></table></figure><h5 id="多选框"><a href="#多选框" class="headerlink" title="多选框"></a>多选框</h5><ul><li><p>当是多个复选框时，因为可以选中多个，所以对应的 data 中属性是一个数组</p></li><li><p>当选中某一个时，就会将 input 的 value 添加到数组中</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">   &lt;label <span class="keyword">for</span>=<span class="string">&quot;sing&quot;</span>&gt;</span><br><span class="line">       <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;sing&quot;</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;hobbies&quot;</span> <span class="attr">value</span>=<span class="string">&quot;sing&quot;</span>&gt;</span> 唱</span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;jump&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;jump&quot;</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;hobbies&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jump&quot;</span>&gt;</span> 跳</span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">hobbies: []</span></span><br></pre></td></tr></table></figure><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230412110951563.png" alt="image-20230412110951563" style="zoom: 50%;" /><h4 id="3-v-model-绑定-radio"><a href="#3-v-model-绑定-radio" class="headerlink" title="3.v-model 绑定 radio"></a>3.v-model 绑定 radio</h4><p>v-model 绑定 radio，用于选择其中一项</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">   &lt;div <span class="keyword">class</span>=<span class="string">&quot;gender&quot;</span>&gt;</span><br><span class="line">     &lt;!-- v-model绑定同一个值 会自动radio的互斥 可以不需要name属性--&gt;</span><br><span class="line">     <span class="language-xml"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;male&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;male&quot;</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;male&quot;</span>&gt;</span> 男</span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;female&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;female&quot;</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;female&quot;</span>&gt;</span> 女de</span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;<span class="name">h2</span>&gt;</span>性别：&#123;&#123;gender&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">gender: &quot;male&quot;  // 可以默认初始值</span></span><br></pre></td></tr></table></figure><h4 id="4-v-model-绑定-select"><a href="#4-v-model-绑定-select" class="headerlink" title="4.v-model 绑定 select"></a>4.v-model 绑定 select</h4><p>单选：只能选中一个值</p><ul><li><p>v-model 绑定的是一个值</p></li><li><p>当我们选中 option 中的一个时，会将它对应的 value 赋值到 fruit 中</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">   &lt;!-- select的单选   v-model 绑定到的是 select 中--&gt;</span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">select</span> <span class="attr">v-model</span>=<span class="string">&quot;fruit&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;apple&quot;</span>&gt;</span>苹果<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;orange&quot;</span>&gt;</span>橘子<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;banana&quot;</span>&gt;</span>香蕉<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="attr">fruit</span>: <span class="string">&quot;orange&quot;</span>  <span class="comment">// 默认值</span></span><br></pre></td></tr></table></figure><p>多选：可以选中多个值</p><ul><li><p>v-model绑定的是一个数组</p></li><li><p>当选中多个值时，就会将选中的option对应的value添加到数组fruit中</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;select multiple size=<span class="string">&quot;3&quot;</span> v-model=<span class="string">&quot;fruits&quot;</span>&gt;</span><br><span class="line">     <span class="language-xml"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;apple&quot;</span>&gt;</span>苹果<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span></span><br><span class="line">     <span class="language-xml"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;orange&quot;</span>&gt;</span>橘子<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span></span><br><span class="line">     <span class="language-xml"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;banana&quot;</span>&gt;</span>香蕉<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span></span><br><span class="line">   &lt;/select&gt;</span><br><span class="line"></span><br><span class="line"><span class="attr">fruits</span>: []</span><br></pre></td></tr></table></figure><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230412111708135.png" alt="image-20230412111708135" style="zoom: 67%;" /><h4 id="5-v-model-的值绑定"><a href="#5-v-model-的值绑定" class="headerlink" title="5.v-model 的值绑定"></a>5.v-model 的值绑定</h4><p>目前我们在前面的案例中大部分的值都是在template中固定好的：</p><ul><li><p>比如gender的两个输入框值male、female</p></li><li><p>比如hobbies的三个输入框值basketball、football</p></li></ul><p>在开发中，数据可能是来自服务器的，那么可以先将值请求下来，绑定到data返回的对象中，再通过v-bind来进行值的绑定，这个过程就是值绑定</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- <span class="number">1.</span>select的值绑定 --&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">select</span> <span class="attr">multiple</span> <span class="attr">size</span>=<span class="string">&quot;3&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;fruits&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">option</span> <span class="attr">v-for</span>=<span class="string">&quot;item in allFruits&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;item.value&quot;</span> <span class="attr">:value</span>=<span class="string">&quot;item.value&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;&#123; item.text &#125;&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">option</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;!-- <span class="number">2.</span>checkbox的值绑定 --&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-for</span>=<span class="string">&quot;item in allHobbies&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;item.value&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">label</span> <span class="attr">:for</span>=<span class="string">&quot;item.value&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">:id</span>=<span class="string">&quot;item.value&quot;</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;hobbies&quot;</span> <span class="attr">:value</span>=<span class="string">&quot;item.value&quot;</span>&gt;</span> &#123;&#123;item.text&#125;&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="4-v-model-修饰符"><a href="#4-v-model-修饰符" class="headerlink" title="4.v-model 修饰符"></a>4.v-model 修饰符</h3><h4 id="1、lazy"><a href="#1、lazy" class="headerlink" title="1、lazy"></a>1、lazy</h4><ul><li><p>默认情况下，v-model在进行双向绑定时，绑定的是input事件，那么会在每次内容输入后就将最新的值和绑定的属性进行同步</p></li><li><p>如果我们在v-model后跟上lazy修饰符，那么会将绑定的事件切换为 change 事件，只有在提交时（比如回车）才会触发</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> v-model.<span class="property">lazy</span>=<span class="string">&quot;message&quot;</span>&gt;</span><br></pre></td></tr></table></figure><h4 id="2、number"><a href="#2、number" class="headerlink" title="2、number"></a>2、number</h4><p>绑定的 message 总是string类型，即使在我们设置 type 为 number 也是 string 类型</p><p>如果希望转换为数字类型，那么可以使用 .number 修饰符：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> v-model.<span class="property">number</span>=<span class="string">&quot;counter&quot;</span>&gt;</span><br></pre></td></tr></table></figure><p>在进行逻辑判断时，如果是一个string和数字类型对比，在可以转化的情况下会进行隐式转换</p><p>但typeof 查询的还是字符类型</p><h4 id="3、trim"><a href="#3、trim" class="headerlink" title="3、trim"></a>3、trim</h4><p>如果要自动过滤用户输入的守卫空白字符，可以给 v-model 添加 trim 修饰符</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> v-model.<span class="property">trim</span>=<span class="string">&quot;content&quot;</span>&gt;</span><br></pre></td></tr></table></figure><h4 id="4、多个修饰符一起使用"><a href="#4、多个修饰符一起使用" class="headerlink" title="4、多个修饰符一起使用"></a>4、多个修饰符一起使用</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> v-model.<span class="property">lazy</span>.<span class="property">trim</span>=<span class="string">&quot;content2&quot;</span>&gt;</span><br></pre></td></tr></table></figure><h2 id="5-组件化开发"><a href="#5-组件化开发" class="headerlink" title="5.组件化开发"></a>5.组件化开发</h2><h3 id="1、认识组件化开发"><a href="#1、认识组件化开发" class="headerlink" title="1、认识组件化开发"></a>1、认识组件化开发</h3><h4 id="1-开发思想"><a href="#1-开发思想" class="headerlink" title="1.开发思想"></a>1.开发思想</h4><ul><li><p>如果将一个页面中所有的处理逻辑全部放在一起，处理起来就会变得非常复杂，而且不利于后续的管理以及扩展</p></li><li><p>但如果们把一个页面拆分成一个个小的功能块，每个功能块完成属于自己这部分独立的功能，那么之后整个页面的管理和维护就变得非常容易</p></li><li><p>如果将一个个功能块拆分后，就可以像搭建积木一下来搭建我们的项目</p></li></ul><p>现在可以说整个的大前端开发都是组件化的天下</p><ul><li><p>无论从三大框架（Vue、React、Angular），还是跨平台方案的Flutter，甚至是移动端都在转向组件化开发，包括小程序的开发也是采用组件化开发的思想</p></li><li><p>所以，学习组件化最重要的是它的思想，每个框架或者平台可能实现方法不同，但是思想都是一样的</p></li></ul><p>组件化思想构建程序</p><ul><li><p>将一个完整的页面分成很多个组件</p></li><li><p>每个组件都用于实现页面的一个功能块</p></li><li><p>而每一个组件又可以进行细分</p></li><li><p>而组件本身又可以在多个地方进行复用</p></li></ul><h4 id="2-Vue-的组件化"><a href="#2-Vue-的组件化" class="headerlink" title="2.Vue 的组件化"></a>2.Vue 的组件化</h4><ul><li>createApp 函数传入了一个对象App，这个对象本质上就是一个组件，也是应用程序的根组件</li><li>组件化提供了一种抽象，让我们可以开发出一个个独立可复用的小组件来构造我们的应用</li><li>任何的应用都会被抽象成一颗组件树</li></ul><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230412113210135.png" alt="image-20230412113210135"></p><h3 id="2、注册组件"><a href="#2、注册组件" class="headerlink" title="2、注册组件"></a>2、注册组件</h3><p>注册组件分成两种：</p><ul><li><p>全局组件：在任何其他的组件中都可以使用的组件</p></li><li><p>局部组件：只有在注册的组件中才能使用的组件</p></li></ul><h4 id="1-注册全局组件"><a href="#1-注册全局组件" class="headerlink" title="1.注册全局组件"></a>1.注册全局组件</h4><ul><li><p>全局组件需要使用我们全局创建的app来注册组件</p></li><li><p>通过 component 方法传入组件名称、组件对象即可注册一个全局组件</p></li><li><p>之后，可以在 App 组件的template中直接使用这个全局组件</p></li><li><p>组件本身也可以有自己的代码逻辑，比如自己的data、methods等</p></li><li><p>全局组件的特点是：一旦注册成功后，可以在任意其他组件的template中使用</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- 组件 product-item的模板 --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;item&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;product&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span> </span><br><span class="line">   <span class="number">1.</span>通过app.<span class="property">component</span>（组件名称，组件的对象）</span><br><span class="line">    <span class="number">2.</span>在<span class="title class_">App</span>组件的模板中，可以直接使用product-item的组件</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1.组件：App组件（根组件）</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title class_">App</span> = &#123;&#125;</span><br><span class="line">  <span class="comment">// 2.创建app</span></span><br><span class="line">  <span class="keyword">const</span> app = <span class="title class_">Vue</span>.<span class="title function_">createApp</span>(<span class="title class_">App</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.注册一个全局组件</span></span><br><span class="line">  <span class="comment">// product-item全局组件</span></span><br><span class="line">  app.<span class="title function_">component</span>(<span class="string">&quot;product-item&quot;</span>, &#123;</span><br><span class="line">    <span class="comment">// 通过 id 使用在html中构建的模板 </span></span><br><span class="line">    <span class="attr">template</span>: <span class="string">&quot;#item&quot;</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><h4 id="2-组件的名称"><a href="#2-组件的名称" class="headerlink" title="2.组件的名称"></a>2.组件的名称</h4><p>通过app.component注册一个组件的时候，第一个参数是组件的名称</p><p>方法1：使用kebab-case（短横线分割符）</p><ul><li>当使用 kebab-case  定义一个组件时，你也必须在引用这个自定义元素时使用 kebab-case</li></ul><p>方法2：使用PascalCase（驼峰标识符）大驼峰</p><ul><li><p>当使用 PascalCase 定义一个组件时，你在引用这个自定义元素时两种命名法都可以使用</p></li><li><p>也就是说 my-component-name 和 MyComponentName 都是可接受的（大驼峰标签在.vue文件中才生效，在 html 文件中不能使用）</p></li></ul><h4 id="3-局部组件"><a href="#3-局部组件" class="headerlink" title="3.局部组件"></a>3.局部组件</h4><p>全局组件往往是在应用程序一开始就会全局组件完成，那么就意味着某些组件就算没有用到也会一起被注册：</p><ul><li><p>比如注册了三个全局组件：ComponentA、ComponentB、ComponentC</p></li><li><p>在开发中我们只使用了ComponentA、ComponentB，如果ComponentC没有用到但是我们依然在全局进行了注册，那么就意味着类似于webpack这种打包工具在打包项目时，依然会对其进行打包</p></li><li><p>这样最终打包出的 JavaScript 包就会有关于 ComponentC 的内容，用户在下载对应的 JavaScript 时也会增加包的大小</p></li></ul><p>开发中通常在使用组件的时候采用的都是局部注册：</p><ul><li><p>局部注册是在我们需要使用到的组件中，通过components属性选项来进行注册</p></li><li><p>比如之前的App组件中，我们有data、computed、methods等选项了，还可以有一个components选项</p></li><li><p>该components选项对应的是一个对象，对象中的键值对是 组件的名称: 组件对象</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">ProductItem</span> = &#123;</span><br><span class="line">     <span class="attr">template</span>: <span class="string">&quot;#product&quot;</span>,</span><br><span class="line">       <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> &#123;</span><br><span class="line">           <span class="attr">title</span>: <span class="string">&quot;我是商品&quot;</span>,</span><br><span class="line">           <span class="attr">price</span>: <span class="number">99.9</span></span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.创建app</span></span><br><span class="line">   <span class="comment">// 1.1组件打算在哪里被使用</span></span><br><span class="line">     <span class="keyword">const</span> app = <span class="title class_">Vue</span>.<span class="title function_">createApp</span>(&#123;</span><br><span class="line">     <span class="comment">// components: option api</span></span><br><span class="line">     <span class="attr">components</span>: &#123;</span><br><span class="line">       <span class="title class_">ProductItem</span>,   <span class="comment">// 对象抽出来了</span></span><br><span class="line">       <span class="title class_">HomeNav</span>: &#123;</span><br><span class="line">         <span class="attr">template</span>: <span class="string">&quot;#nav&quot;</span>,</span><br><span class="line">         <span class="attr">components</span>: &#123;</span><br><span class="line">           <span class="title class_">ProductItem</span></span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><h3 id="3、Vue-的开发模式"><a href="#3、Vue-的开发模式" class="headerlink" title="3、Vue 的开发模式"></a>3、Vue 的开发模式</h3><p>目前使用vue的过程都是在html文件中，通过template编写自己的模板、脚本逻辑、样式等。</p><p>但是随着项目越来越复杂，我们会采用组件化的方式来进行开发：</p><ul><li><p>这意味着每个组件都会有自己的模板、脚本逻辑、样式等</p></li><li><p>依然可以把它们抽离到单独的js、css文件中，但是它们还是会分离开来</p></li><li><p>也包括我们的script是在一个全局的作用域下，很容易出现命名冲突的问题</p></li><li><p>并且我们的代码为了适配一些浏览器，必须使用ES5的语法</p></li><li><p>在我们编写代码完成之后，依然需要通过工具对代码进行构建、代码</p></li></ul><p>所以开发中，可以通过一个后缀名为 .vue的single-file-components (单文件组件)来解决，并且可以使用webpack或vite或rollup等构建工具来对其进行处理</p><p>单文件的特点</p><p>在这个组件中我们可以获得非常多的特性：</p><ul><li><p>代码的高亮</p></li><li><p>ES6、CommonJS的模块化能力</p></li><li><p>组件作用域的CSS</p></li><li><p>可以使用预处理器来构建更加丰富的组件，比如TypeScript、Babel、Less、Sass等</p></li></ul><p>如何支持 SFC</p><p>使用SFC的.vue文件比较常见的两种方式</p><ul><li><p>方式一：使用Vue CLI来创建项目，项目会默认帮助我们配置好所有的配置选项，可以在其中直接使用.vue文件</p></li><li><p>方式二：自己使用webpack或rollup或vite这类打包工具，对其进行打包处理</p></li></ul><p>VSCode对SFC的支持</p><ul><li><p>插件一：Vetur，从Vue2开发就一直在使用的VSCode支持Vue的插件</p></li><li><p>插件二：Volar，官方推荐的插件</p></li></ul><h3 id="4、Vue-CLI-脚手架"><a href="#4、Vue-CLI-脚手架" class="headerlink" title="4、Vue CLI 脚手架"></a>4、Vue CLI 脚手架</h3><h4 id="1-什么是脚手架"><a href="#1-什么是脚手架" class="headerlink" title="1.什么是脚手架"></a>1.什么是脚手架</h4><ul><li><p>在真实开发中，我们通常会使用脚手架来创建一个项目，Vue的项目我们使用的就是Vue的脚手架</p></li><li><p>脚手架其实是建筑工程中的一个概念，在软件工程中也会将一些帮助我们搭建项目的工具称之为脚手架</p></li></ul><p>Vue的脚手架就是Vue CLI</p><ul><li><p>CLI是Command-Line Interface, 翻译为命令行界面</p></li><li><p>可以通过CLI选择项目的配置和创建出我们的项目</p></li><li><p>Vue CLI已经内置了webpack相关的配置，我们不需要从零来配置</p></li></ul><h4 id="2-Vue-CLI-安装和使用"><a href="#2-Vue-CLI-安装和使用" class="headerlink" title="2.Vue CLI 安装和使用"></a>2.Vue CLI 安装和使用</h4><p>安装 Vue CLI</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">全局安装：npm install @vue/cli -g</span><br><span class="line">升级：npm update @vue/cli -g</span><br><span class="line">查看版本：vue -V</span><br><span class="line">通过<span class="title class_">Vue</span>创建项目：vue create 项目名称</span><br></pre></td></tr></table></figure><p>使用</p><p>引入 Vue 的版本：</p><ul><li>App 对象可以在 App.vue 中引入，这样引入 Vue 的版本是：<ul><li>import { createApp } from ‘vue’</li></ul></li><li>也能在 main.js 中自己定义 App 对象，这样引入 Vue 的版本是：<ul><li>import { createApp } from ‘vue&#x2F;dist&#x2F;vue.esm-bundler’</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br></pre></td></tr></table></figure><p>在 App.vue 文件中设置根组件导出，并在 main.js 中导入注册挂载</p><p>全局组件也是类似的方法，需要使用 app.component 进行全局注册</p><p>局部组件则需要在使用的地方导入并注册就行</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根组件</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(<span class="title class_">App</span>)</span><br><span class="line">app.<span class="title function_">mount</span>(<span class="string">&quot;#app&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全局组件</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ProductItem</span> <span class="keyword">from</span> <span class="string">&#x27;./ProductItem.vue&#x27;</span></span><br><span class="line">app.<span class="title function_">component</span>(<span class="string">&quot;product-item&quot;</span>, <span class="title class_">ProductItem</span>)</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 局部组件</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ProductItem</span> <span class="keyword">from</span> <span class="string">&#x27;./ProductItem.vue&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">components</span>: &#123; <span class="title class_">ProductItem</span> &#125;,</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">title</span>: <span class="string">&quot;我也是标题&quot;</span>,</span><br><span class="line">      <span class="attr">counter</span>: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-项目文件夹说明"><a href="#3-项目文件夹说明" class="headerlink" title="3.项目文件夹说明"></a>3.项目文件夹说明</h4><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230412143013515.png" alt="image-20230412143013515" style="zoom: 50%;" /><h4 id="4-Vue-CLI-的运行原理"><a href="#4-Vue-CLI-的运行原理" class="headerlink" title="4.Vue CLI 的运行原理"></a>4.Vue CLI 的运行原理</h4><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230412143116839.png" alt="image-20230412143116839"></p><h4 id="5-补充"><a href="#5-补充" class="headerlink" title="5.补充"></a>5.补充</h4><h5 id="1、jsconfig-json"><a href="#1、jsconfig-json" class="headerlink" title="1、jsconfig.json"></a>1、jsconfig.json</h5><p>作用：给vscode来进行读取，vscode在读取到其中的内容时，给我们的代码更友好的支持</p><p>比如在一个文件嵌套很深的条件下，需要调用上层的函数，就会出现..&#x2F;..&#x2F;..&#x2F;这种不友好的路径表现，可以配置 vue.config.js</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">configureWebpack</span>: &#123;</span><br><span class="line">    <span class="attr">resolve</span>: &#123;</span><br><span class="line">      <span class="comment">// 配置路径别名</span></span><br><span class="line">      <span class="comment">// @是已经配置好的路径别名：对应的是src的路径</span></span><br><span class="line">      <span class="attr">alias</span>: &#123;</span><br><span class="line">        <span class="string">&quot;utils&quot;</span>: <span class="string">&quot;@/utils&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这样可以直接使用配置好的路径，但是 vscode 并不会对此有所提示</p><p>就该配置 jsconfig.json 文件的 path，就能得到友好的代码提示</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;utils/*&quot;</span>: [</span><br><span class="line">     <span class="string">&quot;src/utils/*&quot;</span></span><br><span class="line">   ]</span><br></pre></td></tr></table></figure><h5 id="2、引入Vue的版本"><a href="#2、引入Vue的版本" class="headerlink" title="2、引入Vue的版本"></a>2、引入Vue的版本</h5><p>上文有说明使用的区别</p><p>出现这种情况的本质：</p><ul><li>在以前创建 vue 项目时会出现选择 runtime  &#x2F; runtime + compile 编译两种选择</li><li>编译并不是说其不会编译 vue 文件，而是指对别的对象（vue文件之外）中的 template 模板中元素的编译</li><li>而默认版本是 vue，不会对上者情况的 template 编译，因为没有 compile 源码对其进行编译</li><li>所以在 main.js 中创建 App 根组件并使用的话，使用默认 vue 并不会对其进行渲染</li><li>这时该选择 vue.esm-bundler 版本</li></ul><h5 id="3、style-的作用域"><a href="#3、style-的作用域" class="headerlink" title="3、style 的作用域"></a>3、style 的作用域</h5><p>每一个组件都应该存在自己独立的作用域，不然在使用时会重复的覆盖，不便于对每一个组件的样式进行设置</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;&lt;/style scoped&gt;</span><br></pre></td></tr></table></figure><h5 id="4、vite-创建-vue-项目"><a href="#4、vite-创建-vue-项目" class="headerlink" title="4、vite 创建 vue 项目"></a>4、vite 创建 vue 项目</h5><p>创建 vue 项目的方式</p><p>方式1：vue cli：vue create   -&gt; 基于 webpack</p><p>方式2：npm init vue@latest  -&gt; 基于 vite</p><ul><li>1.安装一个本地工具：create-vue</li><li>2.使用create-vue创建一个 vue 项目</li></ul><p>编译速度更快，和其底层有关系</p><h2 id="6-组件间的通信"><a href="#6-组件间的通信" class="headerlink" title="6.组件间的通信"></a>6.组件间的通信</h2><h3 id="1、组件的嵌套关系"><a href="#1、组件的嵌套关系" class="headerlink" title="1、组件的嵌套关系"></a>1、组件的嵌套关系</h3><p>在之前只是创建了一个组件App</p><p>如果一个应用程序将所有的逻辑都放在一个组件中，那么这个组件就会变成非常的臃肿和难以维护</p><ul><li><p>所以组件化的核心思想应该是对组件进行拆分，拆分成一个个小的组件</p></li><li><p>再将这些组件组合嵌套在一起，最终形成我们的应用程序</p></li></ul><p>将所有的代码逻辑全部放到一个组件中，代码是非常的臃肿和难以维护的</p><ul><li><p>并且在开发中，会有更多的内容和代码逻辑，对于扩展性和可维护性来说都是非 常差的</p></li><li><p>所以，在真实的开发中会对组件进行拆分，拆分成一个个功能的小组件</p></li></ul><p>将各模块抽为单独的局部组件，在使用的地方进行引入</p><h4 id="组件的拆分"><a href="#组件的拆分" class="headerlink" title="组件的拆分"></a>组件的拆分</h4><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230412190521688.png" alt="image-20230412190521688"></p><h3 id="2、父组件传递子组件"><a href="#2、父组件传递子组件" class="headerlink" title="2、父组件传递子组件"></a>2、父组件传递子组件</h3><p>上面的嵌套逻辑如下，它们存在如下关系：</p><ul><li><p>App组件是Header、Main、Footer组件的父组件</p></li><li><p>Main组件是Banner、ProductList组件的父组件</p></li></ul><p>在开发过程中，我们会经常遇到需要组件之间相互进行通信：</p><ul><li><p>比如App可能使用了多个Header，每个地方的Header展示的内容不同，那么我们就需要使用者传递给Header一些数据，让其进行展示</p></li><li><p>又比如我们在Main中一次性请求了Banner数据和ProductList数据，那么就需要传递给它们来进行展示</p></li><li><p>也可能是子组件中发生了事件，需要由父组件来完成某些操作，那就需要子组件向父组件传递事件</p></li></ul><p>总之，在一个Vue项目中，组件之间的通信是非常重要的环节</p><h4 id="1-父子组件之间通信的方式"><a href="#1-父子组件之间通信的方式" class="headerlink" title="1.父子组件之间通信的方式"></a>1.父子组件之间通信的方式</h4><ul><li><p>父组件传递给子组件：通过props属性</p></li><li><p>子组件传递给父组件：通过$emit触发事件</p></li></ul><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230412204202490.png" alt="image-20230412204202490"></p><h4 id="2-父传子方法"><a href="#2-父传子方法" class="headerlink" title="2.父传子方法"></a>2.父传子方法</h4><p>通过props来完成组件之间的通信</p><p>什么是Props</p><ul><li><p>Props是你可以在组件上注册一些自定义的attribute</p></li><li><p>父组件给这些attribute赋值，子组件通过attribute的名称获取到对应的值</p></li></ul><p>Props有两种常见的用法</p><ul><li><p>方式一：字符串数组，数组中的字符串就是attribute的名称</p></li><li><p>方式二：对象类型，对象类型我们可以在指定attribute名称的同时，指定它需要传递的类型、是否是必须的、默认值等等</p></li></ul><h5 id="1、Props-的数组用法"><a href="#1、Props-的数组用法" class="headerlink" title="1、Props 的数组用法"></a>1、Props 的数组用法</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">子组件：</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;infos&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>姓名： &#123;&#123;name&#125;&#125; <span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>年龄： &#123;&#123;age&#125;&#125; <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;others&quot;</span> <span class="attr">v-bind</span>=<span class="string">&quot;$attrs&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// propos 作用：接受父组件传递过来的属性</span></span><br><span class="line">    <span class="comment">// 数组语法</span></span><br><span class="line">    <span class="comment">// 弊端：1&gt; 不能对类型进行验证 2&gt; 没有默认值的</span></span><br><span class="line">    <span class="comment">// props: [&quot;name&quot;, &quot;age&quot;, &quot;height&quot;]</span></span><br><span class="line"></span><br><span class="line">父组件：</span><br><span class="line"><span class="comment">// 补充 使用子组件的时候可以使用单标签，与双标签的区别在插槽中讲</span></span><br><span class="line">  &lt;show-infos name=<span class="string">&quot;mas&quot;</span> age=<span class="string">&quot;23&quot;</span>&gt;&lt;/show-infos&gt;</span><br></pre></td></tr></table></figure><h5 id="2、Props-的对象用法"><a href="#2、Props-的对象用法" class="headerlink" title="2、Props 的对象用法"></a>2、Props 的对象用法</h5><p>数组用法中我们只能说明传入的attribute的名称，并不能对其进行任何形式的限制，接下来我们来看一下对象的写法是如何让 我们的props变得更加完善的</p><p>当使用对象语法的时候，我们可以对传入的内容限制更多：</p><ul><li><p>比如指定传入的attribute的类型</p></li><li><p>比如指定传入的attribute是否是必传的</p></li><li><p>比如指定没有传入时，attribute的默认值</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">props</span>: &#123;</span><br><span class="line">     <span class="attr">name</span>: &#123;</span><br><span class="line">       <span class="attr">type</span>: <span class="title class_">String</span>,</span><br><span class="line">       <span class="attr">default</span>: <span class="string">&quot;默认值&quot;</span></span><br><span class="line">     &#125;,</span><br><span class="line">     <span class="attr">age</span>: &#123;</span><br><span class="line">       <span class="attr">type</span>: <span class="title class_">Number</span>,</span><br><span class="line">       <span class="attr">required</span>: <span class="literal">true</span>,</span><br><span class="line">       <span class="attr">default</span>: <span class="number">10</span></span><br><span class="line">     &#125;,</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h5 id="3、type-的类型"><a href="#3、type-的类型" class="headerlink" title="3、type 的类型"></a>3、type 的类型</h5><p>String、Number、Boolean、Array、Object、Date、Function、Symbol</p><p>对象类型的其他写法：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 重要的原则：对象类型写默认值时，需要编写default的函数，函数返回默认值</span></span><br><span class="line">      <span class="attr">friend</span>: &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="title class_">Object</span>,</span><br><span class="line">        <span class="attr">default</span>: <span class="function">() =&gt;</span> (&#123; <span class="attr">name</span>: <span class="string">&quot;james&quot;</span> &#125;)</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">hobbies</span>: &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="title class_">Array</span>,</span><br><span class="line">        <span class="attr">default</span>: <span class="function">() =&gt;</span> [<span class="string">&quot;篮球&quot;</span>, <span class="string">&quot;rap&quot;</span>]</span><br><span class="line">      &#125;,</span><br></pre></td></tr></table></figure><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230412205345651.png" alt="image-20230412205345651"></p><h5 id="4、Props的大小写"><a href="#4、Props的大小写" class="headerlink" title="4、Props的大小写"></a>4、Props的大小写</h5><p>Prop 的大小写命名(camelCase vs kebab-case)</p><ul><li><p>HTML 中的 attribute 名是大小写不敏感的，所以浏览器会把所有大写字符解释为小写字符</p></li><li><p>这意味着当你使用 DOM 中的模板时，camelCase (驼峰命名法) 的 prop 名需要使用其等价的 kebab-case (短横线分隔命名)  命名</p></li></ul><p>即在 props 中使用小驼峰，在父组件中传递过来可以使用小驼峰也能使用 - 连接</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">show-message=<span class="string">&quot;哈哈哈&quot;</span></span><br><span class="line">showMessage=<span class="string">&quot;哈哈哈&quot;</span></span><br><span class="line"><span class="attr">showMessage</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="title class_">String</span>,</span><br><span class="line">    <span class="attr">default</span>: <span class="string">&quot;dsa&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、非props的attribute"><a href="#3、非props的attribute" class="headerlink" title="3、非props的attribute"></a>3、非props的attribute</h3><p>什么是非Prop的Attribute</p><ul><li><p>当我们传递给一个组件某个属性，但是该属性并没有定义对应的 props 或者 emits 时，就称之为非Prop的Attribute</p></li><li><p>常见的包括class、style、id属性等</p></li></ul><p>Attribute继承</p><ul><li>当组件有单个根节点时，非Prop的Attribute将自动添加到根节点的Attribute中</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div <span class="keyword">class</span>=<span class="string">&quot;infos sws&quot;</span> address=<span class="string">&quot;北京&quot;</span>&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>禁用Attribute继承和多根节点</p><p>如果我们不希望组件的根元素继承attribute，可以在组件中设置 inheritAttrs: false</p><ul><li><p>禁用attribute继承的常见情况是需要将attribute应用于根元素之外的其他元素</p></li><li><p>我们可以通过 $attrs来访问所有的非props的attribute</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">inheritAttrs</span>: <span class="literal">false</span>  <span class="comment">// 写在options api</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用子节点来接收  不禁掉inheritAttrs时根节点也同时拿到</span></span><br><span class="line">&lt;h2 :<span class="keyword">class</span>=<span class="string">&quot;$attrs.address&quot;</span>&gt;姓名： &#123;&#123;name&#125;&#125; &lt;/h2&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多个根：使用另一个根节点接收非 props</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;others&quot;</span> <span class="attr">v-bind</span>=<span class="string">&quot;$attrs&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="4、子组件传递父组件"><a href="#4、子组件传递父组件" class="headerlink" title="4、子组件传递父组件"></a>4、子组件传递父组件</h3><p>子组件需要传递内容到父组件的情况</p><ul><li><p>当子组件有一些事件发生的时候，比如在组件中发生了点击，父组件需要切换内容</p></li><li><p>子组件有一些内容想要传递给父组件的时</p></li></ul><p>操作</p><ul><li><p>首先，我们需要在子组件中定义好在某些情况下触发的事件名称</p></li><li><p>其次，在父组件中以v-on的方式传入要监听的事件名称，并且绑定到对应的方法中</p></li><li><p>最后，在子组件中发生某个事件的时候，根据事件名称触发对应的事件</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">父组件：</span><br><span class="line">    &lt;h2&gt;当前计数: &#123;&#123;counter&#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;!-- <span class="number">1.</span>自定义 add-counter 并且监听内部的add事件 --&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">add-counter</span> @<span class="attr">add</span>=<span class="string">&quot;addBtnClick&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">add-counter</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="attr">methods</span>: &#123;</span><br><span class="line">      <span class="title function_">addBtnClick</span>(<span class="params">count</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">counter</span> += count</span><br><span class="line">      &#125;,</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">子组件：</span><br><span class="line">    &lt;button @click=<span class="string">&quot;btnClick(1)&quot;</span>&gt;+<span class="number">1</span>&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">    <span class="attr">methods</span>: &#123;</span><br><span class="line">      <span class="title function_">btnClick</span>(<span class="params">count</span>) &#123;</span><br><span class="line">        <span class="comment">// 让子组件发出去一个自定义事件</span></span><br><span class="line">        <span class="comment">// 第一个参数，自定义事件的名称</span></span><br><span class="line">        <span class="comment">// 第二个参数是传递的参数</span></span><br><span class="line">        <span class="variable language_">this</span>.$emit(<span class="string">&quot;add&quot;</span>, count)</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>自定义事件的参数和验证</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.emits的数组写法  options api 中</span></span><br><span class="line"><span class="attr">emits</span>: [<span class="string">&quot;add&quot;</span>],</span><br><span class="line"><span class="comment">// 2.emits的对象写法  vue3 新加的对参数验证  可以写一个函数</span></span><br><span class="line"><span class="comment">// emits: &#123;</span></span><br><span class="line"><span class="comment">//   add: function(count) &#123;</span></span><br><span class="line"><span class="comment">//     if (count &lt;= 10) &#123;   // 不符合也能看到  就是报警告</span></span><br><span class="line"><span class="comment">//       return true</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//     return false   </span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line"><span class="comment">// &#125;,</span></span><br></pre></td></tr></table></figure><h3 id="5、案例练习"><a href="#5、案例练习" class="headerlink" title="5、案例练习"></a>5、案例练习</h3><p>tab-control 的案例练习</p><h2 id="7-组件插槽"><a href="#7-组件插槽" class="headerlink" title="7.组件插槽"></a>7.组件插槽</h2><h3 id="1、认识插槽Slot作用"><a href="#1、认识插槽Slot作用" class="headerlink" title="1、认识插槽Slot作用"></a>1、认识插槽Slot作用</h3><p>在开发中，我们会经常封装一个个可复用的组件：</p><ul><li><p>前面我们会通过props传递给组件一些数据，让组件来进行展示</p></li><li><p>但是为了让这个组件具备更强的通用性，我们不能将组件中的内容限制为固定的div、span等等这些元素</p></li><li><p>比如某种情况下我们使用组件，希望组件显示的是一个按钮，某种情况下我们使用组件希望显示的是一张图片</p></li><li><p>我们应该让使用者可以决定某一块区域到底存放什么内容和元素</p></li></ul><p>举个栗子：假如定制一个通用的导航组件 — NavBar</p><ul><li><p>这个组件分成三块区域：左边-中间-右边，每块区域的内容是不固定</p></li><li><p>左边区域可能显示一个菜单图标，也可能显示一个返回按钮，可能什么都不显示</p></li><li><p>中间区域可能显示一个搜索框，也可能是一个列表，也可能是一个标题，等等</p></li><li><p>右边可能是一个文字，也可能是一个图标，也可能什么都不显示</p></li></ul><p>这时可以来定义插槽slot</p><ul><li><p>插槽的使用过程其实是抽取共性、预留不同</p></li><li><p>我们会将共同的元素、内容依然在组件内进行封装</p></li><li><p>同时会将不同的元素使用slot作为占位，让外部决定到底显示什么样的元素</p></li></ul><p>如何使用 slot</p><ul><li>Vue 中将 slot 元素作为承载分发内容的出口</li><li>在封装组件中，使用特殊的元素就可以为封装组件开启一个插槽</li><li>该插槽插入什么内容取决于父组件如何使用</li></ul><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230413113750153.png" alt="image-20230413113750153"></p><h3 id="2、插槽Slot基本使用"><a href="#2、插槽Slot基本使用" class="headerlink" title="2、插槽Slot基本使用"></a>2、插槽Slot基本使用</h3><p>有时候在使用插槽时，如果没有插入对应的内容，需要显示一个默认的内容</p><ul><li>这个默认的内容只会在没有提供插入的内容时，才会显示</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">父组件：</span><br><span class="line">&lt;show-message title=<span class="string">&quot;哈哈&quot;</span>&gt;</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">button</span>&gt;</span>我是按钮元素<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">    &lt;/show-message&gt;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">子组件：</span><br><span class="line">&lt;!-- 内容是一个按钮 --&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">slot</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是默认内容 哈哈哈<span class="tag">&lt;/<span class="name">p</span>&gt;</span>   // 默认内容</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="3、具名插槽Slot使用"><a href="#3、具名插槽Slot使用" class="headerlink" title="3、具名插槽Slot使用"></a>3、具名插槽Slot使用</h3><p>如果一个组件中含有多个插槽，会发现默认情况下每个插槽都会获取到我们插入的内容来显示</p><p>即多个元素都有在一个插槽中展示</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230413114755709.png" alt="image-20230413114755709"></p><p>而想要达到的效果是插槽对应的显示，这个时候我们就可以使用具名插槽</p><ul><li>具名插槽顾名思义就是给插槽起一个名字， 元素有一个特殊的 attribute：name</li><li>一个不带 name 的slot，会带有隐含的名字 default</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">父组件：</span><br><span class="line">  &lt;nav-bar&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">template</span> #<span class="attr">left</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span>&gt;</span> &#123;&#123;leftText&#125;&#125; <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">template</span> #<span class="attr">center</span>&gt;</span>  // # 语法糖</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">span</span>&gt;</span>内容<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:right</span>&gt;</span>  // 使用template元素 并 v-slot:name</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line">  &lt;/nav-bar&gt;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">子组件：</span><br><span class="line">  &lt;div <span class="keyword">class</span>=<span class="string">&quot;nav-bar&quot;</span>&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;left&quot;</span>&gt;</span>left<span class="tag">&lt;/<span class="name">slot</span>&gt;</span>   // 取 name</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;center&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;center&quot;</span>&gt;</span>center<span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;right&quot;</span>&gt;</span>right<span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &lt;/div&gt;</span><br></pre></td></tr></table></figure><p>动态插槽名：</p><p>目前我们使用的插槽名称都是固定的</p><ul><li>比如 v-slot:left、v-slot:center 等等</li><li>可以通过 v-slot:[dynamicSlotName] 方式动态绑定一个名称</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">父组件：</span><br><span class="line">  &lt;!-- nav-bar 只给一个插槽传入 --&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">nav-bar</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:</span>[<span class="attr">position</span>]&gt;</span>    // data 中定义默认的 position</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>注册<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">nav-bar</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;position=&#x27;left&#x27;&quot;</span>&gt;</span>左边<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;position = &#x27;center&#x27;&quot;</span>&gt;</span>中间<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;position = &#x27;right&#x27;&quot;</span>&gt;</span>右边<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">子组件：同上一个</span><br></pre></td></tr></table></figure><p>具名插槽使用的时候缩写</p><ul><li><p>跟 v-on 和 v-bind 一样，v-slot 也有缩写</p></li><li><p>即把参数之前的所有内容 (v-slot:) 替换为字符 #</p></li></ul><h3 id="4、作用域插槽Slot使用"><a href="#4、作用域插槽Slot使用" class="headerlink" title="4、作用域插槽Slot使用"></a>4、作用域插槽Slot使用</h3><p>在Vue中有渲染作用域的概念：</p><ul><li><p>父级模板里的所有内容都是在父级作用域中编译的</p></li><li><p>子模板里的所有内容都是在子作用域中编译的</p></li></ul><p>案例： </p><ul><li><p>案例中ChildCpn自然是可以访问自己作用域中的title内容的</p></li><li><p>但是在App中，是访问不了ChildCpn中的内容的，因为它们是跨作用域的访问</p></li></ul><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230413115537939.png" alt="image-20230413115537939"></p><h4 id="1-插槽作用域"><a href="#1-插槽作用域" class="headerlink" title="1.插槽作用域"></a>1.插槽作用域</h4><p>插槽可以访问到子组件中的内容是非常重要的</p><ul><li><p>当一个组件被用来渲染一个数组元素时，我们使用插槽，并且希望插槽中没有显示每项的内容</p></li><li><p>这个Vue给我们提供了作用域插槽</p></li></ul><p>案例：</p><ul><li><p>1.在App.vue中定义好数据</p></li><li><p>2.传递给 ShowNames 组件中</p></li><li><p>3.ShowNames 组件中遍历 names 数据</p></li><li><p>4.定义插槽的prop</p></li><li><p>5.通过 v-slot:default 的方式获取到 slot 的 props</p></li><li><p>6.使用 slotProps 中的 item 和 index</p></li></ul><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230413115833886.png" alt="image-20230413115833886"></p><p>简单理解：就是父组件传入数据插入到子组件，子组件对传入的数据进行遍历并插入到 slot 中，但是这时 slot 内默认的元素是写死的，我们希望这个元素可以被自定义，这时就使用作用域插槽</p><h4 id="2-使用"><a href="#2-使用" class="headerlink" title="2.使用"></a>2.使用</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">父组件：</span><br><span class="line">   &lt;tab-control :titles=<span class="string">&quot;[&#x27;衣服&#x27;, &#x27;裤子&#x27;, &#x27;鞋子&#x27;]&quot;</span> @tab-item-click=<span class="string">&quot;tabItemClick&quot;</span>&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:default</span>=<span class="string">&quot;props&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>&#123;&#123; props.item &#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span>   // 使用 a 元素展示传到子组件的 item</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line">   &lt;/tab-control&gt;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">子组件：</span><br><span class="line">&lt;template v-<span class="keyword">for</span>=<span class="string">&quot;(item, index) in titles&quot;</span> :key=<span class="string">&quot;item&quot;</span>&gt;</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;tab-control-item&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;itemClick(index)&quot;</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">:class</span>=<span class="string">&quot;&#123; active: index === currentIndex &#125;&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">slot</span> <span class="attr">:item</span>=<span class="string">&quot;item&quot;</span>&gt;</span>   // 定义 :item = &quot;item&quot;</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123; item &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span>  // 默认组件</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &lt;/template&gt;</span><br></pre></td></tr></table></figure><h5 id="1、独占默认插槽的缩写"><a href="#1、独占默认插槽的缩写" class="headerlink" title="1、独占默认插槽的缩写"></a>1、独占默认插槽的缩写</h5><ul><li>如果我们的插槽是默认插槽default，那么在使用的时候 v-slot:default&#x3D;”slotProps”可以简写为v-slot&#x3D;”slotProps”</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;tab-control :titles=<span class="string">&quot;[&#x27;衣服&#x27;, &#x27;裤子&#x27;, &#x27;鞋子&#x27;]&quot;</span> @tab-item-click=<span class="string">&quot;tabItemClick&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">template</span> #<span class="attr">default</span>=<span class="string">&quot;props&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="comment">&lt;!-- 独占默认插槽的简写 --&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="comment">&lt;!-- &lt;template v-slot=&quot;props&quot;&gt; --&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span>&gt;</span>&#123;&#123; props.item &#125;&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">tab-control</span>&gt;</span></span></span><br></pre></td></tr></table></figure><ul><li>并且如果我们的插槽只有默认插槽时，组件的标签可以被当做插槽的模板来使用，这样可以将 v-slot 直接用在组件上</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- 如果只有一个默认插槽 那么template可以省略 --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">tab-control</span> <span class="attr">:titles</span>=<span class="string">&quot;[&#x27;衣服&#x27;, &#x27;裤子&#x27;, &#x27;鞋子&#x27;]&quot;</span> @<span class="attr">tab-item-click</span>=<span class="string">&quot;tabItemClick&quot;</span> <span class="attr">v-slot</span>=<span class="string">&quot;props&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>&#123;&#123;props.item&#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">tab-control</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h5 id="2、默认插槽和具名插槽混合使用"><a href="#2、默认插槽和具名插槽混合使用" class="headerlink" title="2、默认插槽和具名插槽混合使用"></a>2、默认插槽和具名插槽混合使用</h5><ul><li><p>如果我们有默认插槽和具名插槽，那么按照完整的template来编写</p></li><li><p>只要出现多个插槽，请始终为所有的插槽使用完整的基于 template 的语法</p></li></ul><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230413120925169.png" alt="image-20230413120925169"></p><h3 id="5、非父子组件的通信"><a href="#5、非父子组件的通信" class="headerlink" title="5、非父子组件的通信"></a>5、非父子组件的通信</h3><p>在开发中构建了组件树之后，除了父子组件之间的通信之外，还会有非父子组件之间的通信</p><p>两种方式：</p><ul><li>Provide&#x2F;Inject</li><li>全局事件总线</li></ul><h4 id="1-依赖注入Provide-x2F-Inject"><a href="#1-依赖注入Provide-x2F-Inject" class="headerlink" title="1.依赖注入Provide&#x2F;Inject"></a>1.依赖注入Provide&#x2F;Inject</h4><h5 id="1、作用"><a href="#1、作用" class="headerlink" title="1、作用"></a>1、作用</h5><p>Provide&#x2F;Inject用于非父子组件之间共享数据</p><ul><li><p>比如有一些深度嵌套的组件，子组件想要获取父组件的部分内容</p></li><li><p>在这种情况下，如果我们仍然将props沿着组件链逐级传递下去，就会非常的麻烦</p></li></ul><p>对于这种情况可以使用 Provide 和 Inject </p><ul><li><p>无论层级结构有多深，父组件都可以作为其所有子组件的依赖提供者</p></li><li><p>父组件有一个 provide 选项来提供数据</p></li><li><p>子组件有一个 inject 选项来开始使用这些数据</p></li></ul><p>实际上可以将依赖注入看作是 “long range props”</p><ul><li><p>父组件不需要知道哪些子组件使用它 provide 的 property</p></li><li><p>子组件不需要知道 inject 的 property 来自哪里</p></li></ul><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230413160855262.png" alt="image-20230413160855262" style="zoom:50%;" /><h5 id="2、基本使用"><a href="#2、基本使用" class="headerlink" title="2、基本使用"></a>2、基本使用</h5><p>所使用结构类似于：</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230413161943865.png" alt="image-20230413161943865"></p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230413162151996.png" alt="image-20230413162151996"></p><h5 id="3、Provide-和-Inject-函数的写法"><a href="#3、Provide-和-Inject-函数的写法" class="headerlink" title="3、Provide 和 Inject 函数的写法"></a>3、Provide 和 Inject 函数的写法</h5><ul><li>如果Provide中提供的一些数据是来自data，那可能会想要通过 this 获取</li><li>由于 this 指向的问题，对象不能形成作用域，获取不了 data 中的数据，所以使用函数写法</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">App</span>.<span class="property">vue</span>:</span><br><span class="line">    <span class="comment">// provide 一般写为函数  options api</span></span><br><span class="line">    <span class="title function_">provide</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&quot;wbh&quot;</span>,</span><br><span class="line">        <span class="attr">age</span>: <span class="number">21</span>,</span><br><span class="line">        <span class="attr">message</span>: <span class="variable language_">this</span>.<span class="property">message</span></span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">HomeBanner</span>:</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>homebanner: &#123;&#123;name&#125;&#125; - &#123;&#123;age&#125;&#125;-&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">inject</span>: [<span class="string">&quot;name&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;message&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4、处理响应式数据"><a href="#4、处理响应式数据" class="headerlink" title="4、处理响应式数据"></a>4、处理响应式数据</h5><p>此时，如果我们修改了this.names的内容，那么使用 message 的子组件不是响应式的</p><ul><li>这是因为当我们修改了 message 之后，之前在 provide 中引入的 this.message 本身并不是响应式的</li></ul><p>怎么让的数据变成响应式</p><ul><li><p>可以使用响应式的一些API来完成这些功能，比如说computed函数</p></li><li><p>这个computed是vue3的新特性</p></li></ul><p>注意：</p><ul><li><p>在使用 message 的时候需要获取其中的 value</p></li><li><p>这是因为 computed 返回的是一个ref对象，需要取出其中的 value 来使用</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">App</span>.<span class="property">vue</span>:  </span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>app: &#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span>   <span class="comment">// 查看message的改变</span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;message = &#x27;hello wodrds&#x27;&quot;</span>&gt;</span>修改message<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">import</span> &#123; computed &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>  <span class="comment">// 引入 computed script中 export外</span></span><br><span class="line"></span><br><span class="line">    <span class="title function_">provide</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&quot;wbh&quot;</span>,</span><br><span class="line">        <span class="attr">age</span>: <span class="number">21</span>,</span><br><span class="line">        <span class="attr">message</span>: <span class="title function_">computed</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 拿到的是 message 的引用 返回的是一个ref对象，需要使用.value来解包才能获取其真正的值</span></span><br><span class="line">          <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">message</span></span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">HomeBanner</span>.<span class="property">vue</span>:</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>homebanner: &#123;&#123;name&#125;&#125; - &#123;&#123;age&#125;&#125;-&#123;&#123;message.value&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h4 id="2-全局事件总线使用"><a href="#2-全局事件总线使用" class="headerlink" title="2.全局事件总线使用"></a>2.全局事件总线使用</h4><p>Vue3从实例中移除了 $on、$off 和 $once 方法，如果希望继续使用全局事件总线，要通过第三方的库：</p><ul><li><p>Vue3官方有推荐一些库，例如 mitt 或 tiny-emitter</p></li><li><p>主要介绍 hy-event-store 的使用</p></li></ul><p>前期工作</p><ul><li><p>安装：npm install hy-event-bus</p></li><li><p>封装一个工具 eventBus.js</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">HYEventBus</span> &#125; <span class="keyword">from</span> <span class="string">&quot;hy-event-store&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> eventBus = <span class="keyword">new</span> <span class="title class_">HYEventBus</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> eventBus</span><br></pre></td></tr></table></figure><p>使用：监听，结构：App -&gt; Home -&gt; HomeBanner</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">App</span>.<span class="property">vue</span>:</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>App message: &#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">home</span>&gt;</span><span class="tag">&lt;/<span class="name">home</span>&gt;</span></span></span><br><span class="line">  <span class="keyword">import</span> eventBus <span class="keyword">from</span> <span class="string">&quot;./utils/event-bus&quot;</span>;  <span class="comment">// 在需要使用时间总线的地方导入</span></span><br><span class="line"></span><br><span class="line">    <span class="title function_">created</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// 事件监听</span></span><br><span class="line">      eventBus.<span class="title function_">on</span>(<span class="string">&quot;whyEvent&quot;</span>, <span class="function">(<span class="params">name, age, height</span>) =&gt;</span> &#123;  <span class="comment">// 监听事件</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;whyEvent事件在app中的监听&quot;</span>, name, age, height)</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">message</span> = <span class="string">`name:<span class="subst">$&#123;name&#125;</span>, age:<span class="subst">$&#123;age&#125;</span>,height:<span class="subst">$&#123;height&#125;</span>`</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">HomeBanner</span>:</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;bannerBtnClick&quot;</span>&gt;</span>banner按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">  <span class="keyword">import</span> eventBus <span class="keyword">from</span> <span class="string">&#x27;./utils/event-bus&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">methods</span>: &#123;</span><br><span class="line">      <span class="title function_">bannerBtnClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;bannerBtnClick&quot;</span>)</span><br><span class="line">        eventBus.<span class="title function_">emit</span>(<span class="string">&quot;whyEvent&quot;</span>, <span class="string">&quot;why&quot;</span>, <span class="number">23</span>, <span class="number">1.94</span>)  <span class="comment">// 传出事件，可以加参数</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>使用：事件取消，结构：App -&gt; Category</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">App</span>:  添加了按钮移除 category 页面的展示，目的：在目录页面销毁时给其取消事件监听</span><br><span class="line">&lt;button @click=<span class="string">&quot;isShowCategory = false&quot;</span>&gt;是否显示category&lt;/button&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">category</span> <span class="attr">v-if</span>=<span class="string">&quot;isShowCategory&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">category</span>&gt;</span></span>  <span class="comment">// 定义变量记录页面是否展示</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Category</span>:</span><br><span class="line">  <span class="keyword">import</span> eventBus <span class="keyword">from</span> <span class="string">&#x27;./utils/event-bus&#x27;</span>;</span><br><span class="line">    <span class="attr">methods</span>: &#123;</span><br><span class="line">      <span class="title function_">whyEventHandler</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;在category中监听&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,  </span><br><span class="line">    <span class="comment">// 由于这里需要使用箭头函数，便于使用 this，但是在移除监听时第二个参数需要是事件监听的函数</span></span><br><span class="line">    <span class="comment">// 为了拿到这个函数，可以将函数放在 methods 中，使用 this 指向这个函数</span></span><br><span class="line">    <span class="title function_">created</span>(<span class="params"></span>) &#123;</span><br><span class="line">      eventBus.<span class="title function_">on</span>(<span class="string">&quot;whyEvent&quot;</span>, <span class="variable language_">this</span>.<span class="property">whyEventHandler</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 移除监听</span></span><br><span class="line">    <span class="title function_">unmounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;categoty unmounted&quot;</span>)</span><br><span class="line">      eventBus.<span class="title function_">off</span>(<span class="string">&quot;whyEvent&quot;</span>, <span class="variable language_">this</span>.<span class="property">whyEventHandler</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li><p>在一般的组件通信应使用 Vue 官方推荐的方法</p></li><li><p>只有需要在很多组件中进行传递时才考虑使用事件总线</p></li></ul><h2 id="8-额外知识补充"><a href="#8-额外知识补充" class="headerlink" title="8.额外知识补充"></a>8.额外知识补充</h2><h3 id="1、生命周期"><a href="#1、生命周期" class="headerlink" title="1、生命周期"></a>1、生命周期</h3><p>什么是生命周期</p><ul><li><p>生物学上，生物生命周期指得是一个生物体在生命开始到结束周而复始所历经的一系列变化过程</p></li><li><p>每个组件都可能会经历从创建、挂载、更新、卸载等一系列的过程</p></li><li><p>在这个过程中的某一个阶段，我们可能会想要添加一些属于自己的代码逻辑（比如组件创建完后就请求一些服务器数据）</p></li><li><p>如何可以知道目前组件正在哪一个过程？Vue 提供了组件的生命周期函数</p></li></ul><p>生命周期函数</p><ul><li><p>生命周期函数是一些钩子函数（回调函数），在某个时间会被Vue源码内部进行回调</p></li><li><p>通过对生命周期函数的回调，我们可以知道目前组件正在经历什么阶段</p></li><li><p>那么我们就可以在该生命周期中编写属于自己的逻辑代码了</p></li></ul><h4 id="生命周期的流程"><a href="#生命周期的流程" class="headerlink" title="生命周期的流程"></a>生命周期的流程</h4><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230415110343000.png" alt="image-20230415110343000"></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">    <span class="comment">// 1.组件被创建之前</span></span><br><span class="line">    <span class="title function_">beforeCreate</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;beforeCreate&quot;</span>)</span><br><span class="line">    &#125;,  </span><br><span class="line">    <span class="comment">// 2.组件被创建完成</span></span><br><span class="line">    <span class="title function_">created</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;组件被创建完成&quot;</span>)</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;1.发送网络请求，请求数据&quot;</span>)</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;2.监听eventBus事件&quot;</span>)</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;3.监听watch数据&quot;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 3.组件template准备被挂载</span></span><br><span class="line">    <span class="title function_">beforeMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;beforeMount&quot;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 4.组件template被挂载：x虚拟DOM -&gt; 真实DOM</span></span><br><span class="line">    <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;mounted&quot;</span>)</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;1.获取DOM&quot;</span>)</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;2.使用DOM&quot;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 5.数据发生改变</span></span><br><span class="line">    <span class="comment">// 5.1准备更新DOM</span></span><br><span class="line">    <span class="title function_">beforeUpdate</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;beforeUpdate&quot;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 5.2 更新DOM</span></span><br><span class="line">    <span class="title function_">updated</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;updated&quot;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 6准备卸载VNode -&gt; DOM元素  </span></span><br><span class="line">    <span class="comment">// 6.1卸载之前</span></span><br><span class="line">    <span class="title function_">beforeUnmount</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;beforeUnmoute&quot;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 6.2 DOM元素被卸载完成</span></span><br><span class="line">    <span class="title function_">unmounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;unmounted&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">在 <span class="title class_">App</span>.<span class="property">vue</span>中查看不到卸载效果，在子组件中可以使用v-<span class="keyword">if</span>查看</span><br></pre></td></tr></table></figure><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230415110746460.png" alt="image-20230415110746460"></p><h3 id="2、ref-获取元素组件"><a href="#2、ref-获取元素组件" class="headerlink" title="2、ref 获取元素组件"></a>2、ref 获取元素组件</h3><p>某些情况下，我们在组件中想要直接获取到元素对象或者子组件实例</p><ul><li><p>在Vue开发中我们是不推荐进行DOM操作的</p></li><li><p>可以给元素或者组件绑定一个ref的attribute属性</p></li></ul><p>组件实例有一个$refs属性：</p><ul><li>它一个对象Object，持有注册过 ref attribute 的所有 DOM 元素和组件实例</li></ul><p>$parent和$root：可以通过$parent来访问父元素</p><ul><li>HelloWorld.vue的实现：<ul><li>这里我们也可以通过$root来实现，因为App是我们的根组件</li></ul></li></ul><p>注意：在Vue3中已经移除了$children的属性，所以不可以使用</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">   &lt;h2 ref=<span class="string">&quot;title&quot;</span> <span class="keyword">class</span>=<span class="string">&quot;title&quot;</span> :style=<span class="string">&quot;&#123; color: titleColor &#125;&quot;</span>&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt;</span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">ref</span>=<span class="string">&quot;btn&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;changeTitle&quot;</span>&gt;</span>修改title<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>    </span><br><span class="line"></span><br><span class="line"><span class="attr">methods</span>: &#123;</span><br><span class="line">     <span class="title function_">changeTitle</span>(<span class="params"></span>) &#123;</span><br><span class="line">       <span class="comment">// 1.不要主动的去获取DOM 并且修改DOM内容</span></span><br><span class="line">       <span class="comment">// this.message = &quot;你好啊，李银河!&quot;,</span></span><br><span class="line">       <span class="comment">// this.titleColor = &quot;blue&quot;</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 2.获取h2/button元素</span></span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">title</span>)</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">btn</span>)</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 3.获取 banner 子组件:组件实例</span></span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">banner</span>)</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 3.1 在父组件中可以主动调用子组件的对象方法</span></span><br><span class="line">       <span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">banner</span>.<span class="title function_">bannerClick</span>()</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 3.2 获取banner组件实例，获取banner组件中的元素</span></span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">banner</span>.<span class="property">$el</span>)</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 3.3 如果banner template是多个根 那么会拿到第一个node节点</span></span><br><span class="line">       <span class="comment">// 注意：在开发中不推荐一个组件的template中有多个根元素</span></span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">banner</span>.<span class="property">$el</span>.<span class="property">nextSibling</span>)</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 4.组件实例还有两个实例</span></span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$parent</span>)  <span class="comment">// 获取父组件</span></span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$root</span>)  <span class="comment">// 获取根组件</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="3、动态切换组件"><a href="#3、动态切换组件" class="headerlink" title="3、动态切换组件"></a>3、动态切换组件</h3><p>比如在想要实现了一个功能：点击一个tab-bar，切换不同的组件显示</p><p>可以通过两种不同的实现思路来实现：</p><ul><li>方式一：通过v-if来判断，显示不同的组件</li><li>方式二：动态组件的方式</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- <span class="number">1.</span>第一种做法：v-<span class="keyword">if</span>判断逻辑，以显示不同的组件 --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-if</span>=<span class="string">&quot;currentIndex === 0&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">home</span>&gt;</span><span class="tag">&lt;/<span class="name">home</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-else-if</span>=<span class="string">&quot;currentIndex === 1&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">About</span>&gt;</span><span class="tag">&lt;/<span class="name">About</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-else-if</span>=<span class="string">&quot;currentIndex === 2&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">Category</span>&gt;</span><span class="tag">&lt;/<span class="name">Category</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- <span class="number">2.</span>第二种做法：动态组件component --&gt;</span><br><span class="line">&lt;!-- is中的组件需要来自两个地方：全局注册的组件/局部注册的组件 --&gt;</span><br><span class="line"><span class="comment">//tabs </span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;tabs[currentIndex]&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h4 id="其它操作"><a href="#其它操作" class="headerlink" title="其它操作"></a>其它操作</h4><p>父组件传数据到子组件进行接收</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;component name=<span class="string">&quot;wbh&quot;</span> :age=<span class="string">&quot;age&quot;</span> :is=<span class="string">&quot;currentTab&quot;</span>&gt;&lt;/component&gt;</span><br></pre></td></tr></table></figure><p>在子组件使用 props 接收</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;h2&gt;<span class="title class_">Home</span>组件: &#123;&#123;name&#125;&#125;-&#123;&#123;age&#125;&#125;&lt;/h2&gt;    </span><br><span class="line"></span><br><span class="line">   <span class="attr">props</span>: &#123;</span><br><span class="line">      <span class="attr">name</span>: &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="title class_">String</span>,</span><br><span class="line">        <span class="attr">default</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">age</span>: &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="title class_">Number</span>,</span><br><span class="line">        <span class="attr">default</span>: <span class="number">0</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><p>子组件传数据（事件）到父组件</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">子组件定义事件并传出：</span><br><span class="line">&lt;button @click=<span class="string">&quot;homeClick&quot;</span>&gt;homeBtn&lt;/button&gt;</span><br><span class="line"><span class="attr">$emits</span>: [<span class="string">&quot;homeClick&quot;</span>],</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="title function_">homeClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.$emit(<span class="string">&quot;homeClick&quot;</span>, <span class="string">&quot;home&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">父组件接收并使用参数：</span><br><span class="line">&lt;component @homeClick=<span class="string">&quot;homeClick&quot;</span> :is=<span class="string">&quot;currentTab&quot;</span>&gt;&lt;/component&gt;</span><br><span class="line"></span><br><span class="line"><span class="title function_">homeClick</span>(<span class="params">arg</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;HomeClick:&quot;</span>, arg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、Keep-Alive-的使用"><a href="#4、Keep-Alive-的使用" class="headerlink" title="4、Keep-Alive 的使用"></a>4、Keep-Alive 的使用</h3><p>先对之前的案例中About组件进行改造：</p><ul><li>在其中增加了一个按钮，点击可以递增的功能</li></ul><p>比如将counter点到10，那么在切换到home再切换回来about时，状态是否可以保持？</p><ul><li><p>答案是否定的</p></li><li><p>因为默认情况下，在切换组件后，about组件会被销毁掉，再次回来时会重新创建组件</p></li></ul><p>但是，在开发中某些情况我们希望继续保持组件的状态，而不是销毁掉，这个时候我们就可以使用一个内置组件：keep-alive</p><p>keep-alive 的属性</p><ul><li>include - string | RegExp | Array。只有名称匹配的组件会被缓存</li><li>exclude - string | RegExp | Array。任何名称匹配的组件都不会被缓存</li><li>max - number | string。最多可以缓存多少组件实例，一旦达到这个数字，那么缓存组件中最近没有被访问的实例会被销毁</li></ul><p>include 和 exclude prop 允许组件有条件地缓存：</p><ul><li><p>二者都可以用逗号分隔字符串、正则表达式或一个数组来表示</p></li><li><p>匹配首先检查组件自身的 name 选项</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div <span class="keyword">class</span>=<span class="string">&quot;view&quot;</span>&gt;</span><br><span class="line">    &lt;!-- <span class="attr">include</span>:以逗号隔开且不能添加空格 --&gt;</span><br><span class="line">    &lt;!-- <span class="attr">include</span>:名称来自于组件定义时name选项 --&gt;</span><br><span class="line">    <span class="comment">// 对于需要保持活性的组件，需要在其根组件定义 name 属性，使用的便是此name名称</span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">include</span>=<span class="string">&quot;home,about&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;currentTab&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><h4 id="缓存组件的生命周期"><a href="#缓存组件的生命周期" class="headerlink" title="缓存组件的生命周期"></a>缓存组件的生命周期</h4><p>对于缓存的组件来说，再次进入时，我们是不会执行created或者mounted等生命周期函数的：</p><ul><li><p>但是有时候我们确实希望监听到何时重新进入到了组件，何时离开了组件</p></li><li><p>这个时候我们可以使用activated 和 deactivated 这两个生命周期钩子函数来监听</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对于保持keep-alive组件，监听有没有获取</span></span><br><span class="line"><span class="comment">// keep-alive组件进入活跃状态</span></span><br><span class="line"><span class="title function_">activated</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;home activated&quot;</span>)</span><br><span class="line">&#125;,</span><br><span class="line">    <span class="title function_">deactivated</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;home deactivated&quot;</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="5、异步组件的使用"><a href="#5、异步组件的使用" class="headerlink" title="5、异步组件的使用"></a>5、异步组件的使用</h3><p>在此之前，我们需要对项目通过 webpack 的打包进行了解</p><ul><li>一般在项目完成后，打包后 js 文件夹中有四个文件</li><li>app 中默认存放的是全部的逻辑代码</li><li>chunk-vendors 存放的是相关的第三方引入的库的版本</li></ul><h4 id="1-所以默认的打包过程"><a href="#1-所以默认的打包过程" class="headerlink" title="1.所以默认的打包过程"></a>1.所以默认的打包过程</h4><ul><li><p>默认情况下，在构建整个组件树的过程中，因为组件和组件之间是通过模块化直接依赖的，那么webpack在打包时就会将组 件模块打包到一起（比如一个app.js文件中）</p></li><li><p>这个时候随着项目的不断庞大，app.js文件的内容过大，会造成首屏的渲染速度变慢</p></li></ul><p>打包时，代码的分包：</p><ul><li>所以，对于一些不需要立即使用的组件，我们可以单独对它们进行拆分，拆分成一些小的代码块chunk.js</li><li>这些chunk.js会在需要时从服务器加载下来，并且运行代码，显示对应的内容</li></ul><h4 id="2-文件的分包"><a href="#2-文件的分包" class="headerlink" title="2.文件的分包"></a>2.文件的分包</h4><p>对于 utils 之类的 js 文件，想对其进行分包</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// import &#123; sum &#125; from &#x27;./utils/math.js&#x27;  </span></span><br><span class="line"><span class="comment">// sum(10, 20) // 默认在main.js中的引入与使用是不能对其进行分包</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// js 文件的分包</span></span><br><span class="line"><span class="comment">// import(&quot;./utils/math&quot;).then(res =&gt; &#123;</span></span><br><span class="line"><span class="comment">//   res.sum(10, 20)</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br></pre></td></tr></table></figure><h4 id="3-实现异步组件"><a href="#3-实现异步组件" class="headerlink" title="3.实现异步组件"></a>3.实现异步组件</h4><p>Vue中实现异步组件：对于想要单独分包的组件</p><ul><li>如果我们的项目过大了，对于某些组件我们希望通过异步的方式来进行加载（目的是可以对其进行分包处理），那么Vue中给我们提供了一个函数：defineAsyncComponent</li></ul><p>defineAsyncComponent接受两种类型的参数</p><ul><li><p>类型一：工厂函数，该工厂函数需要返回一个Promise对象</p></li><li><p>类型二：接受一个对象类型，对异步函数进行配置</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineAsyncComponent &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>  <span class="comment">// 先导入对应的方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">AsyncCategory</span> = <span class="title function_">defineAsyncComponent</span>(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&quot;./views/Category.vue&quot;</span>))  <span class="comment">// 导入方式</span></span><br><span class="line">  </span><br><span class="line"><span class="title class_">Category</span>: <span class="title class_">AsyncCategory</span>  <span class="comment">// 注册方式</span></span><br></pre></td></tr></table></figure><p>类型二的写法：</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230415171317358.png" alt="image-20230415171317358"></p><h3 id="6、组件的-v-model"><a href="#6、组件的-v-model" class="headerlink" title="6、组件的 v-model"></a>6、组件的 v-model</h3><h4 id="1-基本使用-1"><a href="#1-基本使用-1" class="headerlink" title="1.基本使用"></a>1.基本使用</h4><p>在input中可以使用v-model来完成双向绑定：</p><ul><li><p>这个时候往往会非常方便，因为v-model默认帮助我们完成了两件事</p></li><li><p>v-bind:value 的数据绑定和 @input 的事件监听</p></li></ul><p>如果现在封装了一个组件，其他地方在使用这个组件时，是否也可以使用 v-model 来同时完成这两个功能？</p><ul><li>也是可以的，vue也支持在组件上使用v-model</li></ul><p>当我们在组件上使用的时候，等价于如下的操作：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- <span class="number">2.</span>组件v-<span class="attr">model</span>:默认的 modelValue --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">counter</span> <span class="attr">v-model</span>=<span class="string">&quot;appCounter&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">counter</span>&gt;</span></span></span><br><span class="line"><span class="comment">// 两行代码等价  默认固定写为 modelValue</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">counter</span> <span class="attr">:modelValue</span>=<span class="string">&quot;appCounter&quot;</span> @<span class="attr">update:modelValue</span>=<span class="string">&quot;appCounter = $event&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">counter</span>&gt;</span></span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">在子组件中：</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Counter: &#123;&#123;modelValue&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeCounter&quot;</span>&gt;</span>修改counter<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">  &lt;/div&gt;</span><br><span class="line"><span class="comment">// 接受传过来的 modelValue</span></span><br><span class="line">    <span class="attr">props</span>: &#123;</span><br><span class="line">      <span class="attr">modelValue</span>: &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="title class_">Number</span>,</span><br><span class="line">        <span class="attr">default</span>: <span class="number">0</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"><span class="comment">// 修改modelValue：固定写法</span></span><br><span class="line">    <span class="attr">emits</span>: [<span class="string">&quot;update:modelValue&quot;</span>],</span><br><span class="line">    <span class="attr">methods</span>: &#123;</span><br><span class="line">      <span class="title function_">changeCounter</span>(<span class="params"></span>) &#123;</span><br><span class="line">          <span class="comment">// 999 是改变 App 中绑定的 appCounter 的值</span></span><br><span class="line">        <span class="variable language_">this</span>.$emit(<span class="string">&quot;update:modelValue&quot;</span>, <span class="number">999</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>和input元素不同的只是属性的名称和事件触发的名称而已；</p><h4 id="2-绑定多个属性"><a href="#2-绑定多个属性" class="headerlink" title="2.绑定多个属性"></a>2.绑定多个属性</h4><p>通过v-model是直接绑定了一个属性，如果想要绑定多个属性呢？也就是在一个组件上使用多个v-model是否可以实现呢？</p><ul><li><p>默认情况下的v-model其实是绑定了 modelValue 属性和 @update:modelValue的事件</p></li><li><p>如果希望绑定更多，可以给 v-model 传入一个参数，那么这个参数的名称就是我们绑定属性的名称</p></li></ul><p>v-model:why 相当于做了两件事：</p><ul><li><p>绑定了message 属性</p></li><li><p>监听了 @update:message 的事件</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- <span class="number">3.</span>组件的v-model：自定义名称counter --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">counter2</span> <span class="attr">v-model:counter</span>=<span class="string">&quot;appCounter&quot;</span> <span class="attr">v-model:why</span>=<span class="string">&quot;appWhy&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">counter2</span>&gt;</span></span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">props</span>: &#123;</span><br><span class="line">  <span class="attr">why</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="title class_">String</span>,</span><br><span class="line">    <span class="attr">default</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">emits</span>: [<span class="string">&quot;update:counter&quot;</span>, <span class="string">&quot;update:why&quot;</span>],</span><br><span class="line"><span class="attr">methods</span>: &#123;</span><br><span class="line">  <span class="title function_">changeCounter</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.$emit(<span class="string">&quot;update:counter&quot;</span>, <span class="number">999</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">changeWhy</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.$emit(<span class="string">&quot;update:why&quot;</span>, <span class="string">&quot;kobe&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7、组件的混入"><a href="#7、组件的混入" class="headerlink" title="7、组件的混入"></a>7、组件的混入</h3><h4 id="1-认识-Mixin"><a href="#1-认识-Mixin" class="headerlink" title="1.认识 Mixin"></a>1.认识 Mixin</h4><p>目前我们是使用组件化的方式在开发整个Vue的应用程序，但是组件和组件之间有时候会存在相同的代码逻辑，我们希望对相同的代码逻辑进行抽取</p><p>在 Vue2 和 Vue3 中都支持的一种方式就是使用Mixin来完成：</p><ul><li><p>Mixin提供了一种非常灵活的方式，来分发Vue组件中的可复用功能</p></li><li><p>一个Mixin对象可以包含任何组件选项</p></li><li><p>当组件使用 Mixin 对象时，所有 Mixin 对象的选项将被混合进入该组件本身的选项中</p></li></ul><h4 id="2-基本使用"><a href="#2-基本使用" class="headerlink" title="2.基本使用"></a>2.基本使用</h4><p>将重复的对象抽入一个 js 文件中：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">message</span>: <span class="string">&quot;hello world&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">created</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;message&quot;</span>, <span class="variable language_">this</span>.<span class="property">message</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在需要使用的地方引入</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> messageMixin <span class="keyword">from</span> <span class="string">&#x27;../mixins/message-mixin.js&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">mixins</span>: [messageMixin]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-合并规则"><a href="#3-合并规则" class="headerlink" title="3.合并规则"></a>3.合并规则</h4><p>如果Mixin对象中的选项和组件对象中的选项发生了冲突，那么Vue会如何操作呢？</p><p>这里分成不同的情况来进行处理</p><p>情况一：如果是data函数的返回值对象</p><ul><li><p>返回值对象默认情况下会进行合并</p></li><li><p>如果data返回值对象的属性发生了冲突，那么会保留组件自身的数据</p></li></ul><p>情况二：如何生命周期钩子函数</p><ul><li>生命周期的钩子函数会被合并到数组中，都会被调用</li></ul><p>情况三：值为对象的选项，例如 methods、components 和 directives，将被合并为同一个对象</p><ul><li><p>比如都有methods选项，并且都定义了方法，那么它们都会生效</p></li><li><p>但是如果对象的key相同，那么会取组件对象的键值对</p></li></ul><h4 id="4-全局混入-Mixin"><a href="#4-全局混入-Mixin" class="headerlink" title="4.全局混入 Mixin"></a>4.全局混入 Mixin</h4><p>如果组件中的某些选项，是所有的组件都需要拥有的，那这时可以使用全局的mixin</p><ul><li><p>全局的Mixin可以使用应用app的方法 mixin 来完成注册</p></li><li><p>一旦注册，那么全局混入的选项将会影响每一个组件</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(<span class="title class_">App</span>)</span><br><span class="line">app.<span class="title function_">mixin</span>(&#123;</span><br><span class="line">  <span class="title function_">created</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;mixin created&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">app.<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="9-Composition-API"><a href="#9-Composition-API" class="headerlink" title="9.Composition API"></a>9.Composition API</h2><h3 id="1、认识-CompositionAPI"><a href="#1、认识-CompositionAPI" class="headerlink" title="1、认识 CompositionAPI"></a>1、认识 CompositionAPI</h3><h4 id="1-Options-API的弊端"><a href="#1-Options-API的弊端" class="headerlink" title="1.Options API的弊端"></a>1.Options API的弊端</h4><ul><li><p>Options API的一大特点就是在对应的属性中编写对应的功能模块</p></li><li><p>比如data定义数据、methods中定义方法、computed中定义计算属性、watch中监听属性改变，也包括生命周期钩子</p></li></ul><p>但是这种代码有一个很大的弊端：</p><ul><li><p>当我们实现某一个功能时，这个功能对应的代码逻辑会被拆分到各个属性中</p></li><li><p>当我们组件变得更大、更复杂时，逻辑关注点的列表就会增长，那么同一个功能的逻辑就会被拆分的很分散</p></li><li><p>尤其对于那些一开始没有编写这些组件的人来说，这个组件的代码是难以阅读和理解的（阅读组件的其他人）</p></li></ul><p>对于非常大的组件</p><ul><li>这种碎片化的代码使用理解和维护这个复杂的组件变得异常困难，并且隐藏了潜在的逻辑问题</li><li>并且当我们处理单个逻辑关注点时，需要不断的跳到相应的代码块中</li></ul><p>如果我们能将同一个逻辑关注点相关的代码收集在一起会更好</p><p>这就是Composition API想要做的事情，以及可以帮助我们完成的事情</p><p>也有人把Vue Composition API简称为VCA</p><h4 id="2-认识-Composition-API"><a href="#2-认识-Composition-API" class="headerlink" title="2.认识 Composition API"></a>2.认识 Composition API</h4><p>编写位置：在Vue组件中，这个位置是 setup 函数</p><p>setup其实就是组件的另外一个选项：</p><ul><li><p>只不过这个选项强大到我们可以用它来替代之前所编写的大部分其他选项</p></li><li><p>比如methods、computed、watch、data、生命周期等等</p></li></ul><h3 id="2、Setup-函数的基本使用"><a href="#2、Setup-函数的基本使用" class="headerlink" title="2、Setup 函数的基本使用"></a>2、Setup 函数的基本使用</h3><h4 id="setup-函数的使用"><a href="#setup-函数的使用" class="headerlink" title="setup 函数的使用"></a>setup 函数的使用</h4><h5 id="1、setup-函数的参数"><a href="#1、setup-函数的参数" class="headerlink" title="1、setup 函数的参数"></a>1、setup 函数的参数</h5><p>它主要有两个参数：第一个参数：props；第二个参数：context</p><p>props 就是父组件传递过来的属性会被放到 props 对象中，我们在setup中如果需要使用，那么就可以直接通过props参数获取：</p><ul><li><p>对于定义props的类型，还是和之前的规则是一样的，在props选项中定义</p></li><li><p>并且在template中依然是可以正常去使用props中的属性，比如message</p></li><li><p>如果在setup函数中想要使用props，那么不可以通过 this 去获取</p></li><li><p>因为props有直接作为参数传递到setup函数中，所以可以直接通过参数来使用即可</p></li></ul><p>另一个参数：context，我们也称之为是一个SetupContext</p><p>它里面包含三个属性：</p><ul><li><p>attrs：所有的非prop的attribute</p></li><li><p>slots：父组件传递过来的插槽（这个在以渲染函数返回时会有作用）</p></li><li><p>emit：当我们组件内部需要发出事件时会用到emit（因为我们不能访问this，所以不可以通过 this.$emit发出事件）</p></li></ul><h5 id="2、setup-函数的返回值"><a href="#2、setup-函数的返回值" class="headerlink" title="2、setup 函数的返回值"></a>2、setup 函数的返回值</h5><p>setup既然是一个函数，那么它也可以有返回值</p><ul><li><p>setup的返回值可以在模板 template 中被使用</p></li><li><p>也就是说我们可以通过 setup 的返回值来替代data选项</p></li></ul><p>甚至是我们可以返回一个执行函数来代替在methods中定义的方法：</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230417193706344.png" alt="image-20230417193706344"></p><p>如果将 counter 在 increment 或者 decrement进行操作时，是否可以实现界面的响应式呢？</p><ul><li><p>答案是不可以</p></li><li><p>这是因为对于一个定义的变量来说，默认情况下，Vue并不会跟踪它的变化，来引起界面的响应式操作</p></li></ul><p>初体验：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">  &lt;div <span class="keyword">class</span>=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">    &lt;!-- 对于 template 中的 ref 对象会自动解包 不需要 .<span class="property">value</span>获取值 --&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>当前计数: &#123;&#123; counter &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;increment&quot;</span>&gt;</span>+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;decrement&quot;</span>&gt;</span>-1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">  &lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>  <span class="comment">// 数据只有在ref包裹来实现响应式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 1.定义counter的内容</span></span><br><span class="line">    <span class="comment">// 默认定义的数据都不是响应式数据</span></span><br><span class="line">    <span class="keyword">let</span> counter = <span class="title function_">ref</span>(<span class="number">100</span>)</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">increment</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">      counter.<span class="property">value</span>++</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(counter.<span class="property">value</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">decrement</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">      counter.<span class="property">value</span>--</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      counter, increment, decrement</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>抽取函数：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">抽取到 js 文件中：</span><br><span class="line">import &#123; ref &#125; from &quot;vue&quot;</span><br><span class="line"></span><br><span class="line">export default function useCounter() &#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">App</span>.<span class="property">vue</span>:</span><br><span class="line"><span class="keyword">import</span> useCounter <span class="keyword">from</span> <span class="string">&#x27;./hooks/useCounter.js&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> &#123; counter, increment, decrement &#125; = <span class="title function_">useCounter</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      ...<span class="title function_">useCounter</span>()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="3、Setup-中数据的响应式"><a href="#3、Setup-中数据的响应式" class="headerlink" title="3、Setup 中数据的响应式"></a>3、Setup 中数据的响应式</h3><h4 id="1-Reactive-API"><a href="#1-Reactive-API" class="headerlink" title="1.Reactive API"></a>1.Reactive API</h4><p>如果想为在 setup 中定义的数据提供响应式的特性，可以使用 reactive 的函数</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;h2&gt;<span class="attr">message</span>: &#123;&#123;message&#125;&#125;&lt;/h2&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>账号: &#123;&#123;account.username&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>密码: &#123;&#123;account.password&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 1.定义普通的数据：可以正常的被使用</span></span><br><span class="line">    <span class="comment">// 缺点：数据不是响应式的</span></span><br><span class="line">    <span class="keyword">let</span> message = <span class="string">&quot;hello world&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.定义响应式数据</span></span><br><span class="line">    <span class="comment">// 2.1 reactive函数：定义复杂类型的数据(数组、对象)</span></span><br><span class="line">    <span class="keyword">const</span> account = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">        <span class="attr">username</span>: <span class="string">&quot;coderwhy&quot;</span>,</span><br><span class="line">        <span class="attr">password</span>: <span class="string">&quot;123456&quot;</span></span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><p>原因：</p><ul><li><p>因为当使用reactive函数处理数据之后，数据再次被使用时就会进行依赖收集</p></li><li><p>当数据发生改变时，所有收集到的依赖都是进行对应的响应式操作（比如更新界面）</p></li><li><p>事实上，我们编写的data选项，也是在内部交给了reactive函数将其编程响应式对象的</p></li></ul><h4 id="2-Ref-API"><a href="#2-Ref-API" class="headerlink" title="2.Ref API"></a>2.Ref API</h4><p>reactive API对传入的类型是有限制的，它要求必须传入的是一个对象或者数组类型</p><p>如果传入一个基本数据类型（String、Number、Boolean）会报一个警告</p><p>Vue3 提供了另外一个API：ref API</p><ul><li><p>ref 会返回一个可变的响应式对象，该对象作为一个响应式的引用维护着它内部的值，这就是 ref 名称的来源</p></li><li><p>它内部的值是在 ref 的 value 属性中被维护的</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;h2&gt;当前计数: &#123;&#123;counter&#125;&#125;&lt;/h2&gt;</span><br><span class="line"><span class="comment">// 2.2 ref 函数：定义简单类型的数据（也可以定义复杂数据类型的数据）</span></span><br><span class="line"><span class="keyword">const</span> counter = <span class="title function_">ref</span>(<span class="number">0</span>)  <span class="comment">// 返回的是 ref 对象</span></span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>在模板中引入 ref 的值时，Vue 会自动帮助进行解包操作，所以并不需要在模板中通过 ref.value 的方式来使用</li><li>但是在 setup 函数内部，它依然是一个 ref 引用， 所以对其进行操作时依然需要使用 ref.value的方式</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- 默认情况下在template中使用ref时，vue会自动对其进行解包（取出value） --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>当前计数: &#123;&#123;counter&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;increment&quot;</span>&gt;</span>+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>  <span class="comment">// 调用函数</span></span><br><span class="line">&lt;!-- 也不需要写.<span class="property">value</span> --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;counter++&quot;</span>&gt;</span>+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">increment</span>(<span class="params"></span>) &#123;</span><br><span class="line">    counter.<span class="property">value</span>++  <span class="comment">// 在script中都需要写.value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-Ref-自动解包"><a href="#3-Ref-自动解包" class="headerlink" title="3.Ref 自动解包"></a>3.Ref 自动解包</h4><p>模板中的解包是浅层的解包</p><ul><li>在别的对象中引用 ref 对象时，如下</li><li>在以前是浅层解包（.value），现在是自动解包，除了在别的对象中引用 ref 对象且进行修改</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- vue3<span class="number">.1</span>之前需要添加value --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>当前计数: &#123;&#123; info.counter &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;!-- 这儿又必须加上.<span class="property">value</span> --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;info.counter.value++&quot;</span>&gt;</span>+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&lt;!-- 总结：使用时不需要使用.<span class="property">value</span>,修改时需要写上.<span class="property">value</span> --&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> counter = <span class="title function_">ref</span>(<span class="number">0</span>) </span><br><span class="line"><span class="keyword">const</span> info = &#123;</span><br><span class="line">    counter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果将 ref 放到一个 reactive 的属性当中，那么在模板中使用时，它会自动解包：</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230417200714193.png" alt="image-20230417200714193"></p><h4 id="4-reactive-和-ref-的使用总结"><a href="#4-reactive-和-ref-的使用总结" class="headerlink" title="4.reactive 和 ref 的使用总结"></a>4.reactive 和 ref 的使用总结</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">  <span class="comment">// 定义响应式数据：reactive/ref</span></span><br><span class="line">  <span class="comment">// 强调：ref也可以定义复杂的数据</span></span><br><span class="line">  <span class="keyword">const</span> info = <span class="title function_">ref</span>(&#123;&#125;)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(info.<span class="property">value</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1.reactive的应用场景</span></span><br><span class="line">  <span class="comment">// 1.1 条件一：reactive应用于本地的数据</span></span><br><span class="line">  <span class="comment">// 1.2 条件二：多个数据之间是有关系/联系（聚合的数据，组织在一起会有特定的作用）</span></span><br><span class="line">  <span class="keyword">const</span> account = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">      <span class="attr">username</span>: <span class="string">&#x27;coderwhy&#x27;</span>,</span><br><span class="line">      <span class="attr">password</span>: <span class="string">&#x27;123456&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> username = <span class="title function_">ref</span>(<span class="string">&quot;coderwhy&quot;</span>)</span><br><span class="line">  <span class="keyword">const</span> password = <span class="title function_">ref</span>(<span class="string">&quot;123456&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.ref 的应用场景：其他的场景基本都用ref（computed）</span></span><br><span class="line">  <span class="comment">// 2.1 定义本地的一些简单数据</span></span><br><span class="line">  <span class="keyword">const</span> message = <span class="title function_">ref</span>(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line">  <span class="keyword">const</span> counter = <span class="title function_">ref</span>(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">const</span> name = <span class="title function_">ref</span>(<span class="string">&#x27;why&#x27;</span>)</span><br><span class="line">  <span class="keyword">const</span> age = <span class="title function_">ref</span>(<span class="number">18</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.2 定义从网络中获取的数据也是使用ref</span></span><br><span class="line">  <span class="comment">// const musics = reactive([])</span></span><br><span class="line">  <span class="keyword">const</span> musics = <span class="title function_">ref</span>([])</span><br><span class="line">  <span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> serverMusics = [<span class="string">&quot;1s&quot;</span>, <span class="string">&quot;2s&quot;</span>, <span class="string">&quot;3s&quot;</span>]</span><br><span class="line">      musics.<span class="property">value</span> = serverMusics</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="5-认识-readonly"><a href="#5-认识-readonly" class="headerlink" title="5.认识 readonly"></a>5.认识 readonly</h4><p>通过reactive或者ref可以获取到一个响应式的对象，但是某些情况下，传入给其他地方（组件）的这个响应式对象希望在另外一个地方（组件）被使用，但是不能被修改，如何防止这种情况</p><ul><li><p>Vue3 提供了 readonly 的方法</p></li><li><p>readonly会返回原始对象的只读代理（也就是它依然是一个 Proxy，这是一个 proxy 的 set 方法被劫持，并且不能对其进行修改）</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">子组件接受数据并修改：可以修改的原因，这里父组件传来的是一个对象，即是一个对象的引用地址，所以可对其值进行修改</span><br><span class="line">&lt;h2&gt;<span class="title class_">ShowInfo</span>: &#123;&#123; info &#125;&#125;&lt;/h2&gt;</span><br><span class="line">&lt;!-- 代码没有错误，但是违背了规范(单向数据流) --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;info.name = &#x27;kobe&#x27;&quot;</span>&gt;</span>showinfo按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&lt;!-- 正确的做法: 通过emit向父组件发出事件，符合单向数据流 --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;showInfobtnClick&quot;</span>&gt;</span>showinfo按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>补充：单向数据流</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230417201301364.png" alt="image-20230417201301364"></p><h5 id="1、readonly-的使用"><a href="#1、readonly-的使用" class="headerlink" title="1、readonly 的使用"></a>1、readonly 的使用</h5><ul><li><p>readonly 返回的对象都是不允许修改的</p></li><li><p>但是经过 readonly 处理的原来的对象是允许被修改的</p><ul><li>比如 const info &#x3D; readonly(obj)，info对象是不允许被修改的</li><li>当 obj 被修改时，readonly 返回的 info 对象也会被修改</li><li>但是我们不能去修改 readonly 返回的对象 info</li></ul></li></ul><p>其实本质上就是 readonly 返回的对象的 setter 方法被劫持了而已</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- 使用readonly的数据 --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>readonly: &#123;&#123; roInfo &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">&lt;!-- 代码无效（报警告） --&gt;</span><br><span class="line">&lt;!-- <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;roInfo.name = &#x27;james&#x27;&quot;</span>&gt;</span>showinfo按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span> --&gt;</span><br><span class="line">&lt;!-- 正确的做法:使用emit向父组件发出修改事件 --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;roInfobtnClick&quot;</span>&gt;</span>roInfo按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h5 id="2、readonly-的应用"><a href="#2、readonly-的应用" class="headerlink" title="2、readonly 的应用"></a>2、readonly 的应用</h5><p>在传递给其他组件数据时，往往希望其他组件使用我们传递的内容，但是不允许它们修改时，就可以使用readonly了</p><h3 id="4、Reactive-知识点补充"><a href="#4、Reactive-知识点补充" class="headerlink" title="4、Reactive 知识点补充"></a>4、Reactive 知识点补充</h3><p>插件的使用：vue-devtools</p><h4 id="Reactive-判断的-API"><a href="#Reactive-判断的-API" class="headerlink" title="Reactive 判断的 API"></a>Reactive 判断的 API</h4><p>isProxy：检查对象是否是由 reactive 或 readonly创建的 proxy</p><p>isReactive</p><ul><li><p>检查对象是否是由 reactive创建的响应式代理</p></li><li><p>如果该代理是 readonly 建的，但包裹了由 reactive 创建的另一个代理，它也会返回 true</p></li></ul><p>isReadonly：检查对象是否是由 readonly 创建的只读代理</p><p>toRaw</p><ul><li>返回 reactive 或 readonly 代理的原始对象（不建议保留对原始对象的持久引用。请谨慎使用）</li></ul><p>shallowReactive</p><ul><li>创建一个响应式代理，它跟踪其自身 property 的响应性，但不执行嵌套对象的深层响应式转换 (深层还是原生对象)</li></ul><p>shallowReadonly</p><ul><li>创建一个 proxy，使其自身的 property 为只读，但不执行嵌套对象的深度只读转换（深层还是可读、可写的）</li></ul><h3 id="5、Ref-知识点补充"><a href="#5、Ref-知识点补充" class="headerlink" title="5、Ref 知识点补充"></a>5、Ref 知识点补充</h3><h4 id="1-toRefs"><a href="#1-toRefs" class="headerlink" title="1.toRefs"></a>1.toRefs</h4><p>如果使用ES6的解构语法，对 reactive 返回的对象进行解构获取值（有时解构是为了便于展示时书写），那么之后无论是修改结构后的变量，还是修改reactive 返回的state对象，数据都不再是响应式的</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;h2&gt;<span class="attr">info</span>: &#123;&#123;name&#125;&#125; - &#123;&#123;age&#125;&#125; - &#123;&#123;height&#125;&#125;&lt;/h2&gt;</span><br></pre></td></tr></table></figure><p>那么有没有办法让我们解构出来的属性是响应式的</p><ul><li><p>Vue为我们提供了一个toRefs的函数，可以将reactive返回的对象中的属性都转成ref</p></li><li><p>那么我们再次进行结构出来的 name 和 age 本身都是 ref的</p></li></ul><p>这种做法相当于已经在state.name和ref.value之间建立了 链接，任何一个修改都会引起另外一个变化</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// reactive 被解构后会变成普通的值，失去响应式</span></span><br><span class="line"><span class="comment">// const &#123; name, age &#125; = info</span></span><br><span class="line"><span class="keyword">const</span> &#123; name, age &#125; = <span class="title function_">toRefs</span>(info)</span><br><span class="line"><span class="keyword">return</span> &#123; name, age &#125;</span><br></pre></td></tr></table></figure><h4 id="2-toRef"><a href="#2-toRef" class="headerlink" title="2.toRef"></a>2.toRef</h4><p>如果我们只希望转换一个 reactive 对象中的属性为ref, 那么可以使用toRef的方法</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> height = <span class="title function_">toRef</span>(info, <span class="string">&quot;height&quot;</span>)  <span class="comment">// info 中的height属性</span></span><br><span class="line"><span class="keyword">return</span> &#123; height &#125;</span><br></pre></td></tr></table></figure><h4 id="3-ref-其他的-API"><a href="#3-ref-其他的-API" class="headerlink" title="3.ref 其他的 API"></a>3.ref 其他的 API</h4><p>unref：如果想要获取一个 ref 引用中的 value，那么也可以通过 unref 方法</p><ul><li>如果参数是一个 ref，则返回内部值，否则返回参数本身</li><li>这是 val &#x3D; isRef(val) ? val.value : val 的语法糖函数</li></ul><p>isRef：判断值是否是一个ref对象</p><p>shallowRef：创建一个浅层的ref对象</p><p>triggerRef：手动触发和 shallowRef 相关联的副作用</p><h3 id="6、setup-中禁用-this"><a href="#6、setup-中禁用-this" class="headerlink" title="6、setup 中禁用 this"></a>6、setup 中禁用 this</h3><p>官方关于 this 的描述：</p><ul><li>表达的含义是this并没有指向当前组件实例</li><li>并且在setup被调用之前，data、computed、methods等都没有被解析</li><li>所以无法在setup中获取this</li></ul><p>其实在之前的这段描述是和源码有出入的： </p><ul><li>之前的描述大概含义是不可以使用this是因为组件实例还没有被创建出来</li></ul><p>源码：</p><p>代码是按照如下顺序执行的：</p><ul><li><p>调用 createComponentInstance 创建组件实例</p></li><li><p>调用 setupComponent 初始化component内部的操作</p></li><li><p>调用 setupStatefulComponent 初始化有状态的组件</p></li><li><p>在 setupStatefulComponent 取出了 setup 函数</p></li><li><p>通过callWithErrorHandling 的函数执行 setup</p></li></ul><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230417203715822.png" alt="image-20230417203715822"></p><p>从上面的代码可以看出， 组件的instance肯定是在执行 setup 函数之前就创建出来的</p><h2 id="10-Composition-API"><a href="#10-Composition-API" class="headerlink" title="10.Composition API"></a>10.Composition API</h2><h3 id="1、computed"><a href="#1、computed" class="headerlink" title="1、computed"></a>1、computed</h3><p>在前面记录过计算属性computed：当某些属性是依赖其他状态时，可以使用计算属性来处理</p><ul><li><p>在前面的Options API中，是使用computed选项来完成的</p></li><li><p>在Composition API中，可以在 setup 函数中使用 computed 方法来编写一个计算属性</p></li></ul><p>如何使用 computed</p><ul><li><p>方式一：接收一个 getter 函数，并为 getter 函数返回的值，返回一个不变的 ref 对象</p></li><li><p>方式二：接收一个具有 get 和 set 的对象，返回一个可变的（可读写）ref 对象</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;h2&gt;&#123;&#123;fullName&#125;&#125;&lt;/h2&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;setFullName&quot;</span>&gt;</span>设置fullName<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> names = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">    <span class="attr">firstName</span>: <span class="string">&quot;kobe&quot;</span>,</span><br><span class="line">    <span class="attr">lastName</span>: <span class="string">&#x27;bryant&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">import</span> &#123; reactive, computed, ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">const</span> fullName = <span class="title function_">computed</span>(&#123;</span><br><span class="line">    <span class="attr">set</span>: <span class="keyword">function</span>(<span class="params">newValue</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> tempNmaes = newValue.<span class="title function_">split</span>(<span class="string">&quot; &quot;</span>)</span><br><span class="line">        names.<span class="property">firstName</span> = tempNmaes[<span class="number">0</span>]</span><br><span class="line">        names.<span class="property">lastName</span> = tempNmaes[<span class="number">1</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> names.<span class="property">firstName</span> + <span class="string">&quot; &quot;</span> + names.<span class="property">lastName</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">setFullName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    fullName.<span class="property">value</span> = <span class="string">&quot;coder why&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="setup中使用ref"><a href="#setup中使用ref" class="headerlink" title="setup中使用ref"></a>setup中使用ref</h4><p>只需要定义一个ref对象，绑定到元素或者组件的ref属性上即可</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;h2 ref=<span class="string">&quot;titleRef&quot;</span>&gt;我是标题&lt;/h2&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">ref</span>=<span class="string">&quot;btnRef&quot;</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="comment">// 先转换为ref对象</span></span><br><span class="line"><span class="keyword">const</span> titleRef = <span class="title function_">ref</span>()</span><br><span class="line"><span class="keyword">const</span> btnRef= <span class="title function_">ref</span>()</span><br><span class="line"><span class="keyword">const</span> showinfoRef= <span class="title function_">ref</span>()</span><br><span class="line"><span class="comment">// 直接获取的话是获取不到的，因为在解析时可能还没挂载便执行了获取代码，还没有元素</span></span><br><span class="line"><span class="comment">// 可以在页面渲染完成后，使用函数点击获取元素</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getElements</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(titleRef.<span class="property">value</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(btnRef.<span class="property">value</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(showinfoRef.<span class="property">value</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 也可以使用生命周期函数获取，等其挂载完成之后，所以选择onMounted</span></span><br><span class="line"><span class="comment">// onMounted 的生命周期函数</span></span><br><span class="line"><span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(titleRef.<span class="property">value</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(btnRef.<span class="property">value</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(showinfoRef.<span class="property">value</span>)</span><br><span class="line"></span><br><span class="line">    showinfoRef.<span class="property">value</span>.<span class="title function_">showinfofoo</span>()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="2、组件的生命周期函数"><a href="#2、组件的生命周期函数" class="headerlink" title="2、组件的生命周期函数"></a>2、组件的生命周期函数</h3><p>setup 可以用来替代 data 、 methods 、 computed 等等这些选项，也可以替代生命周期钩子</p><p>setup 中可以使用直接导入的 onX 函数注册生命周期钩子</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; onMounted, onUpdated, onUnmounted &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 在执行setup函数的过程中，你需要注册别的生命周期函数</span></span><br><span class="line">    <span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;onMounted&quot;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;onMounted&quot;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;onMounted&quot;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230417205134405.png" alt="image-20230417205134405"></p><h3 id="3、Provide-x2F-Inject-使用"><a href="#3、Provide-x2F-Inject-使用" class="headerlink" title="3、Provide&#x2F;Inject 使用"></a>3、Provide&#x2F;Inject 使用</h3><p>之前还学习过Provide和Inject，Composition API也可以替代之前的 Provide 和 Inject 的选项</p><h4 id="1-Provide-函数"><a href="#1-Provide-函数" class="headerlink" title="1.Provide 函数"></a>1.Provide 函数</h4><p>可以通过 provide来提供数据：可以通过 provide 方法来定义每个 Property</p><p>provide可以传入两个参数</p><ul><li><p>name：提供的属性名称</p></li><li><p>value：提供的属性值</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; provide, ref &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span></span><br><span class="line"><span class="title function_">provide</span>(<span class="string">&quot;name&quot;</span>, name)</span><br><span class="line"><span class="title function_">provide</span>(<span class="string">&quot;age&quot;</span>, <span class="number">18</span>)</span><br><span class="line"><span class="keyword">return</span> &#123; name &#125;</span><br></pre></td></tr></table></figure><h4 id="2-Inject函数"><a href="#2-Inject函数" class="headerlink" title="2.Inject函数"></a>2.Inject函数</h4><p>在后代组件中可以通过 inject 来注入需要的属性和对应的值</p><ul><li>可以通过 inject 来注入需要的内容</li></ul><p>inject可以传入两个参数</p><ul><li><p>要 inject 的 property 的 name</p></li><li><p>默认值</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以前的方法</span></span><br><span class="line"><span class="comment">// inject的options api注入，那么依然需要手动来解包，使用之后警告依旧存在</span></span><br><span class="line"><span class="comment">// inject: [&quot;name&quot;, &quot;age&quot;], </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 setup 不需要手动解包</span></span><br><span class="line"><span class="keyword">import</span> &#123; inject &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="title function_">inject</span>(<span class="string">&quot;name&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> age = <span class="title function_">inject</span>(<span class="string">&quot;age&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> &#123; name, age&#125;</span><br></pre></td></tr></table></figure><p>如果 Inject 接受的数据不存在，可以定义默认值</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> height = <span class="title function_">inject</span>(<span class="string">&quot;height&quot;</span>, <span class="number">1.58</span>)</span><br><span class="line"><span class="keyword">return</span> &#123; height &#125;</span><br></pre></td></tr></table></figure><h4 id="3-数据响应式"><a href="#3-数据响应式" class="headerlink" title="3.数据响应式"></a>3.数据响应式</h4><p>为了增加 provide 值和 inject 值之间的响应性，可以在 provide 值时使用 ref 和 reactive</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="title function_">ref</span>(<span class="string">&quot;why&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> info = <span class="title function_">reactive</span>(&#123;<span class="attr">name</span>: <span class="string">&quot;why&quot;</span>, <span class="attr">age</span>: <span class="number">15</span>&#125;)</span><br><span class="line"><span class="title function_">provide</span>(<span class="string">&quot;info&quot;</span>, info)</span><br></pre></td></tr></table></figure><h3 id="4、watch-x2F-watchEffect"><a href="#4、watch-x2F-watchEffect" class="headerlink" title="4、watch&#x2F;watchEffect"></a>4、watch&#x2F;watchEffect</h3><p>在Composition API中，可以使用watchEffect和watch来完成响应式数据的侦听</p><ul><li><p>watchEffect：用于自动收集响应式数据的依赖</p></li><li><p>watch：需要手动指定侦听的数据源</p></li></ul><h4 id="1-Watch-的使用"><a href="#1-Watch-的使用" class="headerlink" title="1.Watch 的使用"></a>1.Watch 的使用</h4><p>watch的API完全等同于组件watch选项的Property</p><ul><li>watch需要侦听特定的数据源，并且执行其回调函数</li><li>默认情况下它是惰性的，只有当被侦听的源发生变化时才会执行回调</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; reactive, ref, watch &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span></span><br><span class="line"><span class="title function_">watch</span>(message, <span class="function">(<span class="params">newValue, oldValue</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(newValue, oldValue)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="title function_">watch</span>(info, <span class="function">(<span class="params">newValue, oldValue</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(newValue, oldValue)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(newValue === oldValue)</span><br><span class="line">&#125;, &#123;</span><br><span class="line">    <span class="attr">immediate</span>: <span class="literal">true</span></span><br><span class="line">    <span class="comment">// 会默认有深度的监听</span></span><br><span class="line">&#125;) </span><br></pre></td></tr></table></figure><p>以上方法获取的是 proxy，要获取普通对象的话：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 3.侦听reactive数据变化后，获取普通对象</span></span><br><span class="line"><span class="title function_">watch</span>(<span class="function">() =&gt;</span> (&#123; ...info &#125;), <span class="function">(<span class="params">newValue, oldValue</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(newValue, oldValue)</span><br><span class="line">&#125;, &#123;</span><br><span class="line">    <span class="attr">immediate</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 需要打开 deep</span></span><br><span class="line">    <span class="attr">deep</span>: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>侦听多个数据源</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230417210813073.png" alt="image-20230417210813073"></p><p>watch 的选项</p><ul><li><p>如果希望侦听一个深层的侦听，那么依然需要设置 deep 为true</p></li><li><p>也可以传入 immediate 立即执行</p></li></ul><h4 id="2-WatchEffect"><a href="#2-WatchEffect" class="headerlink" title="2.WatchEffect"></a>2.WatchEffect</h4><p>当侦听到某些响应式数据变化时，希望执行某些操作，这个时候可以使用 watchEffect</p><p>案例：</p><ul><li>首先，watchEffect传入的函数会被立即执行一次，并且在执行的过程中会收集依赖</li><li>其次，只有收集的依赖发生变化时，watchEffect传入的函数才会再次执行</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; watchEffect, ref, watch &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="comment">// 1.watchEffect传入的函数默认会直接被执行</span></span><br><span class="line"><span class="comment">// 2.在执行的过程中，会自动的收集依赖（依赖哪些响应式的数据）</span></span><br><span class="line"><span class="title function_">watchEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;-------------&quot;</span>, counter.<span class="property">value</span>, name.<span class="property">value</span>)</span><br><span class="line">&#125;) </span><br></pre></td></tr></table></figure><h5 id="watchEffect-的停止侦听"><a href="#watchEffect-的停止侦听" class="headerlink" title="watchEffect 的停止侦听"></a>watchEffect 的停止侦听</h5><p>如果在发生某些情况下，希望停止侦听，这时可以获取watchEffect的返回值函数，调用该函数即可</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> stopWatch = <span class="title function_">watchEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;-------------&quot;</span>, counter.<span class="property">value</span>, name.<span class="property">value</span>)</span><br><span class="line">    <span class="comment">// 判断counter.value &gt; 10</span></span><br><span class="line">    <span class="keyword">if</span> (counter.<span class="property">value</span> &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="title function_">stopWatch</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="5、自定义-Hook-练习"><a href="#5、自定义-Hook-练习" class="headerlink" title="5、自定义 Hook 练习"></a>5、自定义 Hook 练习</h3><h4 id="1-useCounter-计数"><a href="#1-useCounter-计数" class="headerlink" title="1.useCounter 计数"></a>1.useCounter 计数</h4><p>见 composition api 9 初体验，抽取计数器 setup 中的函数至一个 js 文件，在需要使用的组件进行引入即可</p><h4 id="2-useTitle-切换title"><a href="#2-useTitle-切换title" class="headerlink" title="2.useTitle 切换title"></a>2.useTitle 切换title</h4><p>初使用：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref, watch &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">useTitle</span>(<span class="params">titleValue</span>) &#123;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">title</span> = title</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> useTitle <span class="keyword">from</span> <span class="string">&#x27;../hooks/useTitle.js&#x27;</span>;</span><br><span class="line"><span class="title function_">useTitle</span>(<span class="string">&quot;首页&quot;</span>)</span><br></pre></td></tr></table></figure><p>一般使用：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref, watch &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">useTitle</span>(<span class="params">titleValue</span>) &#123;</span><br><span class="line">  <span class="comment">// document.title = title</span></span><br><span class="line">  <span class="comment">// 定义ref应用的数据</span></span><br><span class="line">  <span class="keyword">const</span> title = <span class="title function_">ref</span>(titleValue)</span><br><span class="line"></span><br><span class="line">  <span class="title function_">watch</span>(title, <span class="function">(<span class="params">newValue</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">title</span> = newValue</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    <span class="attr">immediate</span>: <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 返回 ref 的值</span></span><br><span class="line">  <span class="keyword">return</span> title</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2.修改标题</span></span><br><span class="line"><span class="keyword">const</span> title = <span class="title function_">useTitle</span>(<span class="string">&quot;首页&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.监听按钮的点击</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">popularClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">    title.<span class="property">value</span> = <span class="string">&quot;首页-流行&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-useScrollPosition"><a href="#3-useScrollPosition" class="headerlink" title="3.useScrollPosition"></a>3.useScrollPosition</h4><p>监听界面的滚动位置</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> scrollPosition = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">y</span>: <span class="number">0</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.监听滚动</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;scroll&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    scrollPosition.<span class="property">x</span> = <span class="variable language_">window</span>.<span class="property">scrollX</span></span><br><span class="line">    scrollPosition.<span class="property">y</span> = <span class="variable language_">window</span>.<span class="property">scrollY</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.返回数据</span></span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">    scrollPosition</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div <span class="keyword">class</span>=<span class="string">&quot;scroll&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>x: &#123;&#123; scrollPosition.x &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>y: &#123;&#123; scrollPosition.y &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> useScrollPosition <span class="keyword">from</span> <span class="string">&quot;../hooks/useScrollPosition.js&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> &#123; scrollPosition &#125; = <span class="title function_">useScrollPosition</span>()</span><br><span class="line"><span class="keyword">return</span> &#123; scrollPosition &#125;</span><br></pre></td></tr></table></figure><h3 id="6、script-setup-语法糖"><a href="#6、script-setup-语法糖" class="headerlink" title="6、script setup 语法糖"></a>6、script setup 语法糖</h3><p><code>&lt;script setup&gt; </code>是在单文件组件 (SFC) 中使用组合式 API 的编译时语法糖，当同时使用 SFC 与组合式 API 时则推荐该语法</p><ul><li>更少的样板内容，更简洁的代码</li><li>能够使用纯 Typescript 声明 prop 和抛出事件</li><li>更好的运行时性能 </li><li>更好的 IDE 类型推断性能</li></ul><p>使用这个语法，需要将 setup attribute 添加到 <code>&lt;script&gt;&lt;/script&gt;</code>代码块上</p><p>里面的代码会被编译成组件 setup() 函数的内容</p><ul><li>这意味着与普通的<code>&lt;script&gt;</code>只在组件被首次引入的时候执行一次不同</li><li><code>&lt;script setup&gt;</code>中的代码会在每次组件实例被创建的时候执行</li></ul><h4 id="1-顶层的绑定会被暴露给模板"><a href="#1-顶层的绑定会被暴露给模板" class="headerlink" title="1.顶层的绑定会被暴露给模板"></a>1.顶层的绑定会被暴露给模板</h4><p>当使用 <code>&lt;script setup&gt;</code> 时，任何在<code>&lt;script setup&gt;</code>声明的顶层的绑定(包括变量，函数声明，以及 import 引入的内容) 都能在模板中直接使用</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.所有编写在顶层中的代码，都是默认暴露给template可以使用</span></span><br><span class="line"><span class="keyword">import</span> &#123; onMounted, ref &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span></span><br></pre></td></tr></table></figure><p>响应式数据需要通过ref、reactive来创建</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2.定义响应式数据</span></span><br><span class="line"><span class="keyword">const</span> message = <span class="title function_">ref</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="property">value</span>)</span><br></pre></td></tr></table></figure><h4 id="2-导入的组件直接使用"><a href="#2-导入的组件直接使用" class="headerlink" title="2.导入的组件直接使用"></a>2.导入的组件直接使用</h4><p><code>&lt;script setup&gt;</code>范围里的值也能被直接作为自定义组件的标签名使用</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">ShowInfo</span> <span class="keyword">from</span> <span class="string">&quot;./ShowInfo.vue&quot;</span> <span class="comment">// 不需要注册</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义绑定的函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">changeMessage</span>(<span class="params"></span>) &#123;</span><br><span class="line">    message.<span class="property">value</span> = <span class="string">&#x27;你好啊!&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-defineProps-和-defineEmits"><a href="#3-defineProps-和-defineEmits" class="headerlink" title="3.defineProps() 和 defineEmits()"></a>3.defineProps() 和 defineEmits()</h4><p>通过 props 传递给子组件时，子组件：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;<span class="title class_">ShowInfo</span>: &#123;&#123;name&#125;&#125; - &#123;&#123;age&#125;&#125;&lt;/div&gt;</span><br><span class="line"><span class="comment">// 定义props</span></span><br><span class="line"><span class="keyword">const</span> props = <span class="title function_">defineProps</span>(&#123;</span><br><span class="line">  <span class="attr">name</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="title class_">String</span>,</span><br><span class="line">    <span class="attr">default</span>: <span class="string">&quot;默认值&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">age</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="title class_">Number</span>,</span><br><span class="line">    <span class="attr">default</span>: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>子组件发出事件</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 子组件</span></span><br><span class="line"><span class="keyword">const</span> emits = <span class="title function_">defineEmits</span>([<span class="string">&quot;infoBtnClick&quot;</span>])</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">showInfoBtnClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">emits</span>(<span class="string">&quot;infoBtnClick&quot;</span>, <span class="string">&quot;showinfo内部发生了点击&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父组件：</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">infobtnclick</span>(<span class="params">payload</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;监听到showinfo内部的点击&quot;</span>, payload)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-defineExpose"><a href="#4-defineExpose" class="headerlink" title="4.defineExpose()"></a>4.defineExpose()</h4><p>使用语法糖的组件时默认关闭的：</p><ul><li>通过模板 ref 或者 $parent 链获取到的组件的公开实例，不会暴露任何在 <code>&lt;script setup&gt;</code> 中声明的绑定</li></ul><p>通过 defineExpose 编译器宏来显式指定在 <code>&lt;script setup&gt;</code> 组件中要暴露出去的 property</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 4.获取组件实例</span></span><br><span class="line"><span class="keyword">const</span> showInfoRef = <span class="title function_">ref</span>()  <span class="comment">// 获取子组件</span></span><br><span class="line"><span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">   showInfoRef.<span class="property">value</span>.<span class="title function_">foo</span>()  <span class="comment">// 获取子组件的foo函数</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 子组件定义foo的函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;这是showinfo的foo函数打印&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">defineExpose</span>(&#123;</span><br><span class="line">  foo</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="7、案例练习"><a href="#7、案例练习" class="headerlink" title="7、案例练习"></a>7、案例练习</h3><h4 id="1-创建项目获取数据"><a href="#1-创建项目获取数据" class="headerlink" title="1.创建项目获取数据"></a>1.创建项目获取数据</h4><p>按照区域划分相关的组件，对于整个也页面的重置，可以在 assets 中新建 reset.css 文件进行重置</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> assets <span class="keyword">from</span> <span class="string">&quot;./assets/reset.css&quot;</span></span><br></pre></td></tr></table></figure><p>获取数据：一般都是在 App 组件中获取，再传递给需要使用的组件</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> highScore <span class="keyword">from</span> <span class="string">&quot;./data/high_score.json&quot;</span></span><br></pre></td></tr></table></figure><h4 id="2-头部的封装与使用"><a href="#2-头部的封装与使用" class="headerlink" title="2.头部的封装与使用"></a>2.头部的封装与使用</h4><p>可以现在 App 中写出对应的效果，再将其抽取到独立的组件中，便于复用</p><p>传递数据与接受数据：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;area-header :title=<span class="string">&quot;areaData.title&quot;</span> :subtitle=<span class="string">&quot;areaData.subtitle&quot;</span>&gt;&lt;/area-header&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h3</span> <span class="attr">class</span>=<span class="string">&quot;title&quot;</span>&gt;</span>&#123;&#123; title &#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;subtitle&quot;</span>&gt;</span>&#123;&#123; subtitle &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="title function_">defineProps</span>(&#123;</span><br><span class="line">    <span class="attr">title</span>: &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="title class_">String</span>,</span><br><span class="line">        <span class="attr">default</span>: <span class="string">&quot;默认标题&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">subtitle</span>: &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="title class_">String</span>,</span><br><span class="line">        <span class="attr">default</span>: <span class="string">&quot;默认子标题&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="3-列表的展示"><a href="#3-列表的展示" class="headerlink" title="3.列表的展示"></a>3.列表的展示</h4><p>一样的做法，可以在 App 中完成之后再抽取，对于不便于展示的稍微复杂的数据可以先放着</p><p>在 style 样式调整中如果想要使用 less</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">先安装对应解析less的包： npm install less-loader</span><br><span class="line">再在标签中写入：&lt;style lang=<span class="string">&quot;less&quot;</span> scoped&gt;</span><br></pre></td></tr></table></figure><h4 id="4-组件的封装"><a href="#4-组件的封装" class="headerlink" title="4.组件的封装"></a>4.组件的封装</h4><p>一般可以将头部和 item 都各自抽离为一个组件使用，但是对于这两者合并的 area 也可能是一个可复用的模型，所以也可对其整体进行抽取，再从 App 中传递数据过来，再将此接受的数据向 header 和 item 发出（这两者需要的，此操作就是改个传出数据的名）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">defineProps</span>(&#123;</span><br><span class="line">  <span class="attr">areaData</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="title class_">Object</span>,</span><br><span class="line">    <span class="attr">default</span>: <span class="function">() =&gt;</span> (&#123;&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)  <span class="comment">// 接受数据名称是 areaData  原来是highScore传出，现在需在此组件中将其改正</span></span><br></pre></td></tr></table></figure><h4 id="5-组件中的数据"><a href="#5-组件中的数据" class="headerlink" title="5.组件中的数据"></a>5.组件中的数据</h4><p>对于不利于展示的数据，若是在标签中书写不利于代码阅读，可以使用计算属性</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// const titleText = computed(() =&gt; &#123;</span></span><br><span class="line"><span class="comment">//   return props.itemData.verify_info.messages.join(&quot; &quot;)</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br><span class="line"><span class="comment">// const titleColor = computed(() =&gt; &#123;</span></span><br><span class="line"><span class="comment">//   return props.itemData.verify_info.text_color</span></span><br><span class="line"><span class="comment">// &#125;) </span></span><br><span class="line"><span class="keyword">const</span> titleInfo = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">text</span>: props.<span class="property">itemData</span>.<span class="property">verify_info</span>.<span class="property">messages</span>.<span class="title function_">join</span>(<span class="string">&quot; &quot;</span>),</span><br><span class="line">        <span class="attr">color</span>: props.<span class="property">itemData</span>.<span class="property">verify_info</span>.<span class="property">text_color</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> bottomInfo = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">content</span>: props.<span class="property">itemData</span>.<span class="property">bottom_info</span>.<span class="property">content</span>,</span><br><span class="line">        <span class="attr">style</span>: &#123;</span><br><span class="line">            <span class="attr">color</span>: props.<span class="property">itemData</span>.<span class="property">bottom_info</span>.<span class="property">content_color</span>,</span><br><span class="line">            <span class="attr">fontSize</span>: props.<span class="property">itemData</span>.<span class="property">bottom_info</span>.<span class="property">font_size</span> + <span class="string">&quot;px&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="6-模拟网络请求"><a href="#6-模拟网络请求" class="headerlink" title="6.模拟网络请求"></a>6.模拟网络请求</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 刚开始传入的是空对象，页面会使用默认的数据进行展示</span></span><br><span class="line"><span class="keyword">const</span> highScore = <span class="title function_">ref</span>(&#123;&#125;)</span><br><span class="line"><span class="comment">// 在模拟请求完数据之后，页面会展示数据</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; </span><br><span class="line">  <span class="keyword">import</span>(<span class="string">&quot;./data/high_score.json&quot;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    highScore.<span class="property">value</span> = res.<span class="property">default</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, <span class="number">2000</span>)</span><br></pre></td></tr></table></figure><h2 id="11-Vue全家桶-Vue-Router"><a href="#11-Vue全家桶-Vue-Router" class="headerlink" title="11.Vue全家桶 - Vue-Router"></a>11.Vue全家桶 - Vue-Router</h2><p>Vue 全家桶</p><ul><li>vue 核心语法，又叫 vue core，在此之前学的语法包括 options api 和 composition api</li><li>插件：vue-router，路由管理前端页面切换</li><li>插件：vuex&#x2F;pinia，状态管理</li></ul><h3 id="1、前端路由的发展历程"><a href="#1、前端路由的发展历程" class="headerlink" title="1、前端路由的发展历程"></a>1、前端路由的发展历程</h3><p>路由是网络工程中的一个术语</p><ul><li><p>在架构一个网络时，非常重要的两个设备就是路由器和交换机</p></li><li><p>路由器主要维护的是一个映射表</p></li><li><p>映射表会决定数据的流向</p></li></ul><p>路由的概念在软件工程中出现，最早是在后端路由中实现的，web的发展主要经历</p><ul><li><p>后端路由阶段</p></li><li><p>前后端分离阶段</p></li><li><p>单页面富应用（SPA）</p></li></ul><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230418144437159.png" alt="image-20230418144437159"></p><h4 id="1-后端路由"><a href="#1-后端路由" class="headerlink" title="1.后端路由"></a>1.后端路由</h4><p>早期的网站开发整个HTML页面是由服务器来渲染的</p><ul><li>服务器直接生产渲染好对应的HTML页面, 返回给客户端进行展示</li></ul><p>但是, 一个网站, 这么多页面服务器如何处理呢</p><ul><li><p>一个页面有自己对应的网址, 也就是URL</p></li><li><p>URL会发送到服务器, 服务器会通过正则对该URL进行匹配, 并且最后交给一个Controller进行处理</p></li><li><p>Controller进行各种处理, 最终生成HTML或者数据, 返回给前端</p></li></ul><p>上面的这种操作, 就是后端路由</p><ul><li><p>当我们页面中需要请求不同的路径内容时, 交给服务器来进行处理, 服务器渲染好整个页面, 并且将页面返回给客户端</p></li><li><p>这种情况下渲染好的页面, 不需要单独加载任何的js和css, 可以直接交给浏览器展示, 这样也有利于SEO的优化</p></li></ul><p>后端路由的缺点</p><ul><li><p>一种情况是整个页面的模块由后端人员来编写和维护的</p></li><li><p>另一种情况是前端开发人员如果要开发页面, 需要通过PHP和Java等语言来编写页面代码</p></li><li><p>而且通常情况下HTML代码和数据以及对应的逻辑会混在一起，编写和维护都是非常糟糕的事情</p></li></ul><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230418144837435.png" alt="image-20230418144837435" style="zoom:50%;" /><h4 id="2-前后端分离阶段"><a href="#2-前后端分离阶段" class="headerlink" title="2.前后端分离阶段"></a>2.前后端分离阶段</h4><p>前端渲染的理解</p><ul><li><p>每次请求涉及到的静态资源都会从静态资源服务器获取，这些资源包括HTML+CSS+JS，然后在前端对这些请求回来的资源进行渲染</p></li><li><p>需要注意的是，客户端的每一次请求，都会从静态资源服务器请求文件</p></li><li><p>同时可以看到，和之前的后端路由不同，这时后端只是负责提供API了</p></li></ul><p>前后端分离阶段</p><ul><li><p>随着Ajax的出现, 有了前后端分离的开发模式</p></li><li><p>后端只提供API来返回数据，前端通过Ajax获取数据，并且可以通过JavaScript将数据渲染到页面中</p></li><li><p>这样做最大的优点就是前后端责任的清晰，后端专注于数据上，前端专注于交互和可视化上</p></li><li><p>并且当移动端(iOS&#x2F;Android)出现后，后端不需要进行任何处理，依然使用之前的一套API即可</p></li><li><p>目前比较少的网站采用这种模式开发</p></li></ul><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230418144935784.png" alt="image-20230418144935784" style="zoom:50%;" /><h4 id="3-前端路由"><a href="#3-前端路由" class="headerlink" title="3.前端路由"></a>3.前端路由</h4><p>单页面富应用阶段</p><ul><li><p>其实SPA最主要的特点就是在前后端分离的基础上加了一层前端路由</p></li><li><p>也就是前端来维护一套路由规则</p></li></ul><p>前端路由的核心是：改变URL，但是页面不进行整体的刷新</p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230418145207866.png" alt="image-20230418145207866" style="zoom: 33%;" /><h3 id="2、Vue-Router基本使用"><a href="#2、Vue-Router基本使用" class="headerlink" title="2、Vue-Router基本使用"></a>2、Vue-Router基本使用</h3><h4 id="1-URL-的-hash"><a href="#1-URL-的-hash" class="headerlink" title="1.URL 的 hash"></a>1.URL 的 hash</h4><p>前端路由是如何做到URL和内容进行映射呢？监听URL的改变</p><p>URL的hash</p><ul><li><p>URL的hash也就是锚点(#)，本质上是改变window.location的href属性</p></li><li><p>可以通过直接赋值location.hash来改变href，但是页面不发生刷新</p></li></ul><p>hash的优势就是兼容性更好，在老版IE中都可以运行，但是缺陷是有一个#，显得不像一个真实的路径</p><h4 id="2-HTML5-的-History"><a href="#2-HTML5-的-History" class="headerlink" title="2.HTML5 的 History"></a>2.HTML5 的 History</h4><p>history接口是HTML5新增的, 它有六种模式改变URL而不刷新页面</p><ul><li><p>replaceState：替换原来的路径</p></li><li><p>pushState：使用新的路径</p></li><li><p>popState：路径的回退</p></li><li><p>go：向前或向后改变路径</p></li><li><p>forward：向前改变路径</p></li><li><p>back：向后改变路径</p></li></ul><h4 id="3-认识-vue-router"><a href="#3-认识-vue-router" class="headerlink" title="3.认识 vue-router"></a>3.认识 vue-router</h4><p>目前前端流行的三大框架, 都有自己的路由实现</p><p>Angular 的 ngRouter、React 的 ReactRouter、Vue 的 vue-router</p><p>Vue Router 是 Vue.js 的官方路由</p><ul><li>它与 Vue.js 核心深度集成，让用 Vue.js 构建单页应用（SPA）变得非常容易</li></ul><p>vue-router 是基于路由和组件的</p><ul><li><p>路由用于设定访问路径, 将路径和组件映射起来</p></li><li><p>在 vue-router 的单页面应用中, 页面的路径的改变就是组件的切换</p></li></ul><p>安装 Vue Router：npm install vue-router</p><h4 id="4-使用步骤"><a href="#4-使用步骤" class="headerlink" title="4.使用步骤"></a>4.使用步骤</h4><p>使用 vue-router 的步骤</p><ul><li><p>第一步：创建路由需要映射的组件（打算显示的页面）</p></li><li><p>第二步：通过 createRouter 创建路由对象，并且传入 routes 和 history 模式</p><ul><li>配置路由映射：组件和路径映射关系的 routes 数组</li><li>创建基于 hash 或者 history 的模式</li></ul></li><li><p>第三步：使用 app 注册路由对象（use方法）</p></li><li><p>第四步：路由使用: 通过和<code>&lt;router-link&gt;</code>和<code>&lt;router-view&gt;</code></p></li></ul><p>详解：</p><p>1.创建路由对象（创建对应的 js 文件，引入 router 相关）</p><ul><li>routers：映射关系</li><li>history：修改 url 的模式（hash&#x2F;history）</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createRouter, createWebHashHistory, createWebHistory &#125; <span class="keyword">from</span> <span class="string">&quot;vue-router&quot;</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;</span><br><span class="line">  <span class="attr">history</span>: <span class="title function_">createWebHistory</span>(),</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&quot;/home&quot;</span>, <span class="attr">component</span>: <span class="title class_">Home</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&quot;/about&quot;</span>, <span class="attr">component</span>: <span class="title class_">About</span> &#125;,  ]</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure><p>2.让路由对象生效</p><ul><li>app.use(router)</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&quot;./router/index.js&quot;</span></span><br><span class="line">app.<span class="title function_">use</span>(router)</span><br></pre></td></tr></table></figure><p>3.router-view 占位</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;router-view&gt;&lt;/router-view&gt;</span><br></pre></td></tr></table></figure><p>4.router-link 进行路由的切换</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;router-link to=<span class="string">&quot;/home&quot;</span> replace active-<span class="keyword">class</span>=<span class="string">&quot;active&quot;</span>&gt;首页&lt;/router-link&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">&quot;&#123; path: &#x27;/about&#x27; &#125;&quot;</span> <span class="attr">replace</span> <span class="attr">active-class</span>=<span class="string">&quot;active&quot;</span>&gt;</span>关于<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230418151220193.png" alt="image-20230418151220193"></p><h4 id="5-路由的默认路径"><a href="#5-路由的默认路径" class="headerlink" title="5.路由的默认路径"></a>5.路由的默认路径</h4><p>默认情况下, 进入网站的首页, 希望渲染首页的内容</p><ul><li>但是在实现中, 默认没有显示首页组件, 必须让用户点击才可以</li></ul><p>routes中又配置了一个映射：</p><ul><li><p>path配置的是根路径: &#x2F;</p></li><li><p>redirect是重定向, 也就是我们将根路径重定向到&#x2F;home的路径下</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认路径</span></span><br><span class="line"><span class="comment">// &#123; path: &quot;/&quot;, component: Home&#125;,</span></span><br><span class="line">&#123; <span class="attr">path</span>: <span class="string">&quot;/&quot;</span>, <span class="attr">redirect</span>: <span class="string">&quot;/home&quot;</span> &#125;,</span><br></pre></td></tr></table></figure><h4 id="6-history-模式"><a href="#6-history-模式" class="headerlink" title="6.history 模式"></a>6.history 模式</h4><p>见上方代码块</p><h4 id="7-router-link"><a href="#7-router-link" class="headerlink" title="7.router-link"></a>7.router-link</h4><p>router-link事实上有很多属性可以配置</p><ul><li><p>to属性：是一个字符串，或者是一个对象</p></li><li><p>replace属性：设置 replace 属性的话，当点击时，会调用 router.replace()，而不是 router.push()，就是浏览器没有了缓存，返回上一级直接到了浏览器主页面</p></li><li><p>active-class属性：设置激活a元素后应用的class，默认是router-link-active</p><ul><li>可以对该值进行自定义命名：active-class&#x3D;”active”</li></ul></li><li><p>exact-active-class属性：链接精准激活时，应用于渲染的 <code>&lt;a&gt;</code>  的 class，默认是router-link-exact-active</p></li></ul><h3 id="3、路由懒加载分包处理"><a href="#3、路由懒加载分包处理" class="headerlink" title="3、路由懒加载分包处理"></a>3、路由懒加载分包处理</h3><p>当打包构建应用时，JavaScript 包会变得非常大，影响页面加载</p><ul><li><p>如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就会更加高效</p></li><li><p>也可以提高首屏的渲染效率</p></li></ul><p>通过 webpack 的分包知识，而 Vue Router 默认就支持动态来导入组件</p><ul><li><p>这是因为 component 可以传入一个组件，也可以接收一个函数，该函数需要返回一个Promise</p></li><li><p>而 import 函数就是返回一个 Promise</p></li></ul><p>在引入组件时</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 分包</span></span><br><span class="line"><span class="comment">// 路由的懒加载</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Home</span> = (<span class="params"></span>) =&gt; <span class="keyword">import</span>(<span class="string">&quot;../views/Home.vue&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">About</span> = (<span class="params"></span>) =&gt; <span class="keyword">import</span>(<span class="string">&quot;../views/About.vue&quot;</span>)</span><br></pre></td></tr></table></figure><p>也可以在使用组件时</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123; <span class="attr">path</span>: <span class="string">&quot;/home&quot;</span>, <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&quot;../views/Home.vue&quot;</span>)&#125;,</span><br></pre></td></tr></table></figure><p>打包效果分析</p><p>按以上方发进行引入组件可以实现分包，但是不能很直观的看出那一个包对应是那一个组件打包的</p><p>可以使用魔法注释来进行命名</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Home</span> = (<span class="params"></span>) =&gt; <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: &#x27;home&#x27; */</span><span class="string">&quot;../views/Home.vue&quot;</span>)</span><br></pre></td></tr></table></figure><p>路由的其他属性</p><ul><li><p>name属性：路由记录独一无二的名称</p></li><li><p>meta属性：自定义的数据</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">name</span>: <span class="string">&quot;home&quot;</span>,</span><br><span class="line">   <span class="attr">path</span>: <span class="string">&quot;/home&quot;</span>,</span><br><span class="line">   <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&quot;../views/Home.vue&quot;</span>),</span><br><span class="line">   <span class="attr">meta</span>: &#123;</span><br><span class="line">     <span class="attr">name</span>: <span class="string">&quot;why&quot;</span>,</span><br><span class="line">     <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h3 id="4、动态路由和路由嵌套"><a href="#4、动态路由和路由嵌套" class="headerlink" title="4、动态路由和路由嵌套"></a>4、动态路由和路由嵌套</h3><h4 id="1-路由动态的基本匹配"><a href="#1-路由动态的基本匹配" class="headerlink" title="1.路由动态的基本匹配"></a>1.路由动态的基本匹配</h4><p>很多时候需要将给定匹配模式的路由映射到同一个组件</p><ul><li><p>可能有一个 User 组件，它应该对所有用户进行渲染，但是用户的ID是不同的</p></li><li><p>在Vue Router中可以在路径中使用一个动态字段来实现，称之为路径参数</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 动态路由</span></span><br><span class="line"><span class="attr">path</span>: <span class="string">&quot;/user/:id&quot;</span>,</span><br><span class="line"><span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&quot;../views/User.vue&quot;</span>),</span><br></pre></td></tr></table></figure><p>在router-link中进行如下跳转：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;router-link to=<span class="string">&quot;/user/123&quot;</span>&gt;用户<span class="number">123</span>&lt;/router-link&gt;</span><br></pre></td></tr></table></figure><h4 id="2-获取动态路由的值"><a href="#2-获取动态路由的值" class="headerlink" title="2.获取动态路由的值"></a>2.获取动态路由的值</h4><p>在User中如何获取到对应的值</p><ul><li>在template中，直接通过 $route.params获取值</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- 在模板中获取id --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>user: &#123;&#123; $route.params.id &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br></pre></td></tr></table></figure><ul><li><p>在 created 中，通过 this.$route.params获取值</p></li><li><p>在setup中，我们要使用 vue-router库给我们提供的一个hook useRoute</p><ul><li>该 Hook 会返回一个Route对象，对象中保存着当前路由相关的值</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useRoute, onBeforeRouteUpdate &#125; <span class="keyword">from</span> <span class="string">&quot;vue-router&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 route 跳转 id</span></span><br><span class="line"><span class="keyword">const</span> route = <span class="title function_">useRoute</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;代码中拿到: &quot;</span>,route.<span class="property">params</span>.<span class="property">id</span>)</span><br><span class="line"><span class="title function_">onBeforeRouteUpdate</span>(<span class="function">(<span class="params">to, <span class="keyword">from</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;from &quot;</span>,<span class="keyword">from</span>.<span class="property">params</span>.<span class="property">id</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;to &quot;</span>,to.<span class="property">params</span>.<span class="property">id</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="3-NotFound"><a href="#3-NotFound" class="headerlink" title="3.NotFound"></a>3.NotFound</h4><p>对于哪些没有匹配到的路由，通常会匹配到固定的某个页面</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 如果匹配到任何一个不存在的路径，那么显示下面这个组件</span></span><br><span class="line">   <span class="attr">path</span>: <span class="string">&quot;/:pathMatch(.*)&quot;</span>,</span><br><span class="line">   <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&quot;../views/NotFound.vue&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以通过 $route.params.pathMatch 获取到传入的参数</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>NotFund: 您当前的路径&#123;&#123; $route.params.pathMatch &#125;&#125;不正确，请输入正确的路径<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>匹配规则加 *</p><p>在 &#x2F;:pathMatch(.*) 后面又加了一个 *</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">path</span>: <span class="string">&quot;/:pathMatch(.*)*&quot;</span></span><br></pre></td></tr></table></figure><p>区别：</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230418183914097.png" alt="image-20230418183914097"></p><h4 id="4-路由的嵌套"><a href="#4-路由的嵌套" class="headerlink" title="4.路由的嵌套"></a>4.路由的嵌套</h4><p>目前匹配的Home、About、User等都属于第一层路由，在它们之间可以来回进行切换</p><p>但是 Home 页面本身，也可能会在多个组件之间来回切换</p><ul><li><p>比如Home中包括Product、Message，它们可以在Home内部来回切换</p></li><li><p>这时就需要使用嵌套路由，在Home中也使用 router-view 来占位之后需要渲染的组件</p></li></ul><p>配置：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">children</span>: [</span><br><span class="line">  &#123;</span><br><span class="line">     <span class="attr">path</span>: <span class="string">&quot;/home&quot;</span>,</span><br><span class="line">     <span class="attr">redirect</span>: <span class="string">&quot;/home/recommend&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">     <span class="attr">path</span>: <span class="string">&quot;recommend&quot;</span>,  <span class="comment">//  /home/recommend</span></span><br><span class="line">     <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&quot;../views/HomeRecommend.vue&quot;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">     <span class="attr">path</span>: <span class="string">&quot;ranking&quot;</span>,  <span class="comment">//  /home/recommend</span></span><br><span class="line">     <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&quot;../views/HomeRanking.vue&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="5、路由的编程式导航"><a href="#5、路由的编程式导航" class="headerlink" title="5、路由的编程式导航"></a>5、路由的编程式导航</h3><h4 id="1-代码的页面跳转"><a href="#1-代码的页面跳转" class="headerlink" title="1.代码的页面跳转"></a>1.代码的页面跳转</h4><p>有时希望通过代码来完成页面的跳转，比如点击的是一个按钮</p><p>如果是在setup中编写的代码，可以通过 useRouter 来获取</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useRouter &#125; <span class="keyword">from</span> <span class="string">&quot;vue-router&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">useRouter</span>()</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">homeSpanClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">  router.<span class="title function_">push</span>(<span class="string">&quot;/home&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以传入一个对象</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">router.<span class="title function_">push</span>(&#123;</span><br><span class="line">    <span class="comment">// 使用 name 跳转的话不会做重定向</span></span><br><span class="line">    <span class="comment">// name: &quot;home&quot;,</span></span><br><span class="line">    <span class="attr">path</span>: <span class="string">&quot;/home&quot;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>methods的方法：</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230418185902226.png" alt="image-20230418185902226"></p><h4 id="2-query-方式的参数"><a href="#2-query-方式的参数" class="headerlink" title="2.query 方式的参数"></a>2.query 方式的参数</h4><p>可以通过query的方式来传递参数</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">router.<span class="title function_">push</span>(&#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&quot;/about&quot;</span>,</span><br><span class="line">    <span class="attr">query</span>: &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;whs&#x27;</span>,</span><br><span class="line">        <span class="attr">age</span>: <span class="number">25</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在 about 获取到 query 传的值</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;h2&gt;<span class="title class_">About</span>: &#123;&#123; $route.<span class="property">query</span> &#125;&#125;&lt;/h2&gt;</span><br></pre></td></tr></table></figure><h4 id="3-替换当前位置"><a href="#3-替换当前位置" class="headerlink" title="3.替换当前位置"></a>3.替换当前位置</h4><p>使用push的特点是压入一个新的页面，那么在用户点击返回时，上一个页面还可以回退，但是如果希望当前页面是一个替换操作，那么可以使用replace</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230418190206654.png" alt="image-20230418190206654"></p><h4 id="4-页面的前进后退"><a href="#4-页面的前进后退" class="headerlink" title="4.页面的前进后退"></a>4.页面的前进后退</h4><p>router 的 go 方法</p><p>router 也有 back</p><ul><li>通过调用 history.back() 回溯历史。相当于 router.go(-1)</li></ul><p>router 也有 forward</p><ul><li>通过调用 history.forward() 在历史中前进。相当于 router.go(1)</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useRouter &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">useRouter</span>()</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">backClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// router.back()</span></span><br><span class="line">  <span class="comment">// router.forward()</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// go(delta)</span></span><br><span class="line">  <span class="comment">// go(1) -&gt; forward()</span></span><br><span class="line">  <span class="comment">// go(-1) -&gt; back()</span></span><br><span class="line">  router.<span class="title function_">go</span>(-<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6、动态管理路由对象"><a href="#6、动态管理路由对象" class="headerlink" title="6、动态管理路由对象"></a>6、动态管理路由对象</h3><p>了解开发中的各种类别，数据来源与存放</p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230419155042718.png" alt="image-20230419155042718" style="zoom: 33%;" /><p>了解后台管理系统，对于不同的角色，能够使用系统中不同的功能</p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230419154915206.png" alt="image-20230419154915206" style="zoom: 67%;" /><h4 id="1-动态添加路由"><a href="#1-动态添加路由" class="headerlink" title="1.动态添加路由"></a>1.动态添加路由</h4><p>某些情况下可能需要动态的来添加路由</p><ul><li><p>比如根据用户不同的权限，注册不同的路由</p></li><li><p>可以使用一个方法 addRoute</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> isAdmin = <span class="literal">false</span>  <span class="comment">// 写死的</span></span><br><span class="line"><span class="keyword">if</span> (isAdmin) &#123;</span><br><span class="line">  <span class="comment">// 一级路由</span></span><br><span class="line">  router.<span class="title function_">addRoute</span>(&#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&quot;/admin&quot;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&quot;../views/Admin.vue&quot;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是为 route 添加一个 children 路由（二级路由），那么可以传入对应的 name</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">router.<span class="title function_">addRoute</span>(<span class="string">&quot;home&quot;</span>,&#123;</span><br><span class="line">  <span class="attr">path</span>: <span class="string">&quot;vip&quot;</span>,</span><br><span class="line">  <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&quot;../views/HomeSongs.vue&quot;</span>) </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="2-动态添加路由的其他方法"><a href="#2-动态添加路由的其他方法" class="headerlink" title="2.动态添加路由的其他方法"></a>2.动态添加路由的其他方法</h4><p>删除路由有以下三种方式</p><ul><li><p>方式一：添加一个 name 相同的路由（name 是唯一的，原理是覆盖上一个 name）</p></li><li><p>方式二：通过 removeRoute 方法，传入路由的名称</p></li><li><p>方式三：通过 addRoute 方法的返回值回调</p></li></ul><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230419160915567.png" alt="image-20230419160915567"></p><p>其他方法</p><ul><li>router.hasRoute()：检查路由是否存在</li><li>router.getRoutes()：获取一个包含所有路由记录的数组</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取router所有的映射路由对象</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(router.<span class="title function_">getRoutes</span>())</span><br></pre></td></tr></table></figure><h3 id="7、路由导航守卫钩子"><a href="#7、路由导航守卫钩子" class="headerlink" title="7、路由导航守卫钩子"></a>7、路由导航守卫钩子</h3><h4 id="1-基本使用-2"><a href="#1-基本使用-2" class="headerlink" title="1.基本使用"></a>1.基本使用</h4><p>在进入到某些页面时可能需要判断用户是否登录，如果没有登录则需要跳转到登录界面登录之后，才能进入到该页面</p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230419161510368.png" alt="image-20230419161510368" style="zoom: 67%;" /><p>vue-router 提供的导航守卫主要用来通过跳转或取消的方式守卫导航</p><p>全局的前置守卫 beforeEach 是在导航触发时会被回调的：</p><p>它有两个参数</p><ul><li><p>to：即将进入的路由Route对象</p></li><li><p>from：即将离开的路由Route对象</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 路由导航守卫</span></span><br><span class="line"><span class="comment">// 在进行任何的路由跳转之前，传入到beforeEach中的函数都会被回调</span></span><br><span class="line">router.<span class="title function_">beforeEach</span>(<span class="function">(<span class="params">to, <span class="keyword">from</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 1.进入到任何界面是都跳转到login页面</span></span><br><span class="line">  <span class="keyword">if</span> ( to.<span class="property">path</span> !== <span class="string">&quot;/login&quot;</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;/login&quot;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>它有返回值</p><ul><li>false：取消当前导航</li><li>不返回或者undefined：进行默认导航</li><li>返回一个路由地址<ul><li>可以是一个string类型的路径</li><li>可以是一个对象，对象中包含path、query、params等信息</li></ul></li></ul><p>可选的第三个参数：next（不推荐使用）</p><ul><li><p>在 Vue2 中是通过next函数来决定如何进行跳转的</p></li><li><p>但是在 Vue3 中是通过返回值来控制的，不再推荐使用 next 函数，这是因为开发中很容易调用多次 next</p></li></ul><h4 id="2-登录守卫功能"><a href="#2-登录守卫功能" class="headerlink" title="2.登录守卫功能"></a>2.登录守卫功能</h4><p>按需求：进入订单页面时进行判断登录</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 需求：进入到订单页面时，判断用是否登录（isLogin -&gt; LocalStorage保存token）</span></span><br><span class="line"><span class="comment">// 情况一：用户没有登录，那么跳转到登录页面，进行登录操作</span></span><br><span class="line"><span class="comment">// 情况二：用户已经登录，那么直接进入到订单页面</span></span><br><span class="line">router.<span class="title function_">beforeEach</span>(<span class="function">(<span class="params">to, <span class="keyword">from</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 2.进入到订单页面，判断是否登录</span></span><br><span class="line">  <span class="keyword">const</span> token = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&quot;token&quot;</span>)</span><br><span class="line">  <span class="keyword">if</span>(to.<span class="property">path</span> === <span class="string">&quot;/order&quot;</span> &amp;&amp; !token) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;/login&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>模拟在 login 登录之后进行跳转</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">loginClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// console.log(&quot;点击了登录操作&quot;)</span></span><br><span class="line">  <span class="comment">// 向服务器发送请求，服务器返回token</span></span><br><span class="line">  <span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&quot;token&quot;</span>, <span class="string">&quot;coderwhy&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 跳转到order页面</span></span><br><span class="line">  router.<span class="title function_">push</span>(<span class="string">&quot;/order&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模拟在别的页面退出登录（删除 token），测试登录功能</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">logoutClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">localStorage</span>.<span class="title function_">removeItem</span>(<span class="string">&quot;token&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-其他导航守卫"><a href="#3-其他导航守卫" class="headerlink" title="3.其他导航守卫"></a>3.其他导航守卫</h4><p>Vue-Router 还提供了很多的其他守卫函数，目的都是在某一个时刻给予我们回调，让我们可以更好的控制程序的流程或者功能</p><ul><li><a href="https://next.router.vuejs.org/zh/guide/advanced/navigation-guards.html">https://next.router.vuejs.org/zh/guide/advanced/navigation-guards.html</a></li></ul><p>完整的导航解析流程：</p><ul><li><p>导航被触发</p></li><li><p>在失活的组件里调用 beforeRouteLeave 守卫</p></li><li><p>调用全局的 beforeEach 守卫</p></li><li><p>在重用的组件里调用 beforeRouteUpdate 守卫(2.2+)</p></li><li><p>在路由配置里调用 beforeEnter</p></li><li><p>解析异步路由组件</p></li><li><p>在被激活的组件里调用 beforeRouteEnter</p></li><li><p>调用全局的 beforeResolve 守卫(2.5+)</p></li><li><p>导航被确认</p></li><li><p>调用全局的 afterEach 钩子</p></li><li><p>触发 DOM 更新</p></li><li><p>调用 beforeRouteEnter 守卫中传给 next 的回调函数，创建好的组件实例会作为回调函数的参数传入</p></li></ul><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230419163238823.png" alt="image-20230419163238823" style="zoom: 67%;" /><h2 id="12-Vue全家桶-Vuex状态管理"><a href="#12-Vue全家桶-Vuex状态管理" class="headerlink" title="12.Vue全家桶 - Vuex状态管理"></a>12.Vue全家桶 - Vuex状态管理</h2><h3 id="1、认识应用状态管理"><a href="#1、认识应用状态管理" class="headerlink" title="1、认识应用状态管理"></a>1、认识应用状态管理</h3><h4 id="1-什么是状态管理"><a href="#1-什么是状态管理" class="headerlink" title="1.什么是状态管理"></a>1.什么是状态管理</h4><p>在开发中，应用程序需要处理各种各样的数据，这些数据需要保存在应用程序中的某一个位置，对于这些数据的管理我们就称之为是状态管理</p><p>在前面的如何管理自己的状态方式</p><ul><li><p>在Vue开发中，使用组件化的开发方式</p></li><li><p>而在组件中定义 data 或者在 setup 中返回使用的数据，这些数据我们称之为 state</p></li><li><p>在模块 template 中可以使用这些数据，模块最终会被渲染成 DOM，称之为View</p></li><li><p>在模块中会产生一些行为事件，处理这些行为事件时，有可能会修改 state，这些行为事件称之为 actions</p></li></ul><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230419163423469.png" alt="image-20230419163423469" style="zoom:50%;" /><h4 id="2-复杂的状态管理"><a href="#2-复杂的状态管理" class="headerlink" title="2.复杂的状态管理"></a>2.复杂的状态管理</h4><p>JavaScript 开发的应用程序，已经变得越来越复杂</p><ul><li><p>JavaScript需要管理的状态越来越多，越来越复杂</p></li><li><p>这些状态包括服务器返回的数据、缓存数据、用户操作产生的数据等等</p></li><li><p>也包括一些UI的状态，比如某些元素是否被选中，是否显示加载动效，当前分页</p></li></ul><p>当应用遇到多个组件共享状态时，单向数据流的简洁性很容易被破坏</p><ul><li><p>多个视图依赖于同一状态</p></li><li><p>来自不同视图的行为需要变更同一状态</p></li></ul><p>是否可以通过组件数据的传递来完成</p><ul><li><p>对于一些简单的状态，可以通过props的传递或者Provide的方式来共享状态</p></li><li><p>但是对于复杂的状态管理来说，单纯通过传递和共享的方式是不足以解决问题的，比如兄弟组件共享数据</p></li></ul><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230419164257028.png" alt="image-20230419164257028" style="zoom: 33%;" /><h4 id="3-Vuex-的状态管理"><a href="#3-Vuex-的状态管理" class="headerlink" title="3.Vuex 的状态管理"></a>3.Vuex 的状态管理</h4><p>管理不断变化的state本身是非常困难的</p><ul><li>状态之间相互会存在依赖，一个状态的变化会引起另一个状态的变化，View页面也有可能会引起状态的变化</li><li>当应用程序复杂时，state在什么时候，因为什么原因而发生了变化，发生了怎么样的变化，会变得非常难以控制和追踪</li></ul><p>因此，需要考虑将组件的内部状态抽离出来，以一个全局单例的方式来管理</p><ul><li><p>在这种模式下，我们的组件树构成了一个巨大的 “试图View”</p></li><li><p>不管在树的哪个位置，任何组件都能获取状态或者触发行为</p></li><li><p>通过定义和隔离状态管理中的各个概念，并通过强制性的规则来维护视图和状态间的独立性，我们的代码边会变得更加结构化和易于维护、跟踪</p></li></ul><p>这就是Vuex背后的基本思想，它借鉴了Flux、Redux、Elm（纯函数语言，redux有借鉴它的思想）</p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230419164051648.png" alt="image-20230419164051648" style="zoom:67%;" /><h3 id="2、Vuex-的基本使用"><a href="#2、Vuex-的基本使用" class="headerlink" title="2、Vuex 的基本使用"></a>2、Vuex 的基本使用</h3><p>安装：npm install vuex</p><h4 id="1-创建-store"><a href="#1-创建-store" class="headerlink" title="1.创建 store"></a>1.创建 store</h4><p>每一个Vuex应用的核心就是store（仓库）</p><ul><li>store本质上是一个容器，它包含着你的应用中大部分的状态（state）</li></ul><p>Vuex和单纯的全局对象有什么区别</p><ul><li><p>第一：Vuex 的状态存储是响应式的</p><ul><li>当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会被更新</li></ul></li><li><p>第二：不能直接改变 store 中的状态</p><ul><li>改变 store 中的状态的唯一途径就显示提交 (commit) mutation</li><li>这样可以方便的跟踪每一个状态的变化，从而能够通过一些工具帮助更好的管理应用的状态</li></ul></li></ul><h4 id="2-基本使用-1"><a href="#2-基本使用-1" class="headerlink" title="2.基本使用"></a>2.基本使用</h4><p>使用步骤</p><ul><li>创建Store对象</li><li>在app中通过插件安装</li></ul><p>组件中使用 store</p><ul><li>在模板中使用</li><li>在options api中使用，比如computed</li><li>在setup中使用</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">创建store文件夹，写入 js 文件</span><br><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">&quot;vuex&quot;</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="title function_">createStore</span>(&#123;</span><br><span class="line">  <span class="comment">// state() &#123;</span></span><br><span class="line">  <span class="comment">//   return &#123;</span></span><br><span class="line">  <span class="comment">//   &#125;</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">    <span class="attr">state</span>: <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">        <span class="attr">counter</span>: <span class="number">100</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br><span class="line">                          </span><br><span class="line">在 main.<span class="property">js</span>中导入并使用：</span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&quot;./store&quot;</span>;</span><br><span class="line"><span class="title function_">createApp</span>(<span class="title class_">App</span>).<span class="title function_">use</span>(store).<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span><br><span class="line"></span><br><span class="line">在 template 中访问</span><br><span class="line">&lt;h2&gt;<span class="title class_">Home</span>页面计数：&#123;&#123; $store.<span class="property">state</span>.<span class="property">counter</span> &#125;&#125;&lt;/h2&gt;</span><br><span class="line"></span><br><span class="line">在 setup 中测试响应式</span><br><span class="line"><span class="keyword">import</span> &#123; useStore &#125; <span class="keyword">from</span> <span class="string">&quot;vuex&quot;</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="title function_">useStore</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">increment</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 也能修改，但是官发不建议并且说明了改变store的值的唯一方式是通过mutations</span></span><br><span class="line">  <span class="comment">// store.state.counter++</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 通过mutations  能够实时追踪更新 counter，不需要手动刷新，会自动刷新</span></span><br><span class="line">  store.<span class="title function_">commit</span>(<span class="string">&quot;increment&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// store 中的 mutations</span></span><br><span class="line"><span class="attr">mutations</span>: &#123;</span><br><span class="line">    <span class="title function_">increment</span>(<span class="params">state</span>) &#123;</span><br><span class="line">        state.<span class="property">counter</span>++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 options api 中使用</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">computed</span>: &#123;</span><br><span class="line">    <span class="title function_">storeCounter</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="property">state</span>.<span class="property">counter</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 setup 中使用注意</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> setupCounter = store.<span class="property">state</span>.<span class="property">counter</span>  <span class="comment">// 丢失响应式</span></span><br><span class="line"><span class="keyword">const</span> &#123; counter&#125;  = <span class="title function_">toRefs</span>(store.<span class="property">state</span>)  <span class="comment">// 不加 refs 也会丢失响应式</span></span><br></pre></td></tr></table></figure><h3 id="3、核心概念-State"><a href="#3、核心概念-State" class="headerlink" title="3、核心概念 State"></a>3、核心概念 State</h3><h4 id="1-单一状态树"><a href="#1-单一状态树" class="headerlink" title="1.单一状态树"></a>1.单一状态树</h4><p>Vuex 使用单一状态树</p><ul><li>用一个对象就包含了全部的应用层级的状态</li><li>采用的是SSOT，Single Source of Truth，也可以翻译成单一数据源</li></ul><p>这也意味着，每个应用将仅仅包含一个 store 实例</p><ul><li>单状态树和模块化并不冲突</li></ul><p>单一状态树的优势：</p><ul><li>如果你的状态信息是保存到多个Store对象中的，那么之后的管理和维护等等都会变得特别困难</li><li>所以Vuex也使用了单一状态树来管理应用层级的全部状态</li><li>单一状态树能够让我们最直接的方式找到某个状态的片段</li><li>而且在之后的维护和调试过程中，也可以非常方便的管理和维护</li></ul><h4 id="2-组件获取状态"><a href="#2-组件获取状态" class="headerlink" title="2.组件获取状态"></a>2.组件获取状态</h4><p>在前面已经学习过如何在组件中获取状态</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- <span class="number">1.</span>在模板中直接使用多个状态 --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>name: &#123;&#123; $store.state.name &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>level: &#123;&#123; $store.state.level &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span>  ... </span><br></pre></td></tr></table></figure><p>如果觉得有点繁琐（表达式过长），可以使用计算属性（opition api）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">    <span class="title function_">name</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="property">state</span>.<span class="property">name</span></span><br><span class="line">    &#125;,   <span class="comment">// 也是写多遍，还是繁琐</span></span><br></pre></td></tr></table></figure><p>但是，如果有很多个状态都需要获取，可以使用mapState的辅助函数</p><ul><li><p>mapState的方式一：数组类型</p></li><li><p>mapState的方式二：对象类型</p></li><li><p>也可以使用展开运算符和来原有的 computed 混合在一起</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- 计算属性（映射状态：数组写法） --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>name: &#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>level: &#123;&#123;level&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">&lt;!-- 计算属性（映射状态：对象写法） --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>name: &#123;&#123;sName&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>level: &#123;&#123;sLevel&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span> --&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; mapState &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">    <span class="comment">// 数组写法，可能会出现名称冲突</span></span><br><span class="line">    ...<span class="title function_">mapState</span>([<span class="string">&quot;counter&quot;</span>, <span class="string">&quot;level&quot;</span>, <span class="string">&quot;name&quot;</span>]),</span><br><span class="line">    <span class="comment">// 对象写法</span></span><br><span class="line">    ...<span class="title function_">mapState</span>(&#123;</span><br><span class="line">      <span class="attr">sName</span>: <span class="function"><span class="params">state</span> =&gt;</span> state.<span class="property">name</span>,</span><br><span class="line">      <span class="attr">sLevel</span>: <span class="function"><span class="params">state</span> =&gt;</span> state.<span class="property">level</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-在-setup-中使用-mapState"><a href="#3-在-setup-中使用-mapState" class="headerlink" title="3.在 setup 中使用 mapState"></a>3.在 setup 中使用 mapState</h4><p>在 setup 中如果单个获取装是非常简单的：通过useStore拿到store后去获取某个状态即可</p><p>但是如果需要使用 mapState 的功能</p><ul><li>默认情况下，Vuex并没有提供非常方便的使用mapState的方式，可以进行了一个函数的封装</li></ul><p>方法1：拿到函数，绑定 this</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; computed &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span></span><br><span class="line"><span class="keyword">import</span> &#123; mapState, useStore &#125; <span class="keyword">from</span> <span class="string">&quot;vuex&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法1.一步步完成</span></span><br><span class="line"><span class="keyword">const</span> &#123; name, level &#125; = <span class="title function_">mapState</span>([<span class="string">&quot;name&quot;</span>, <span class="string">&quot;level&quot;</span>])</span><br><span class="line"><span class="keyword">const</span> store = <span class="title function_">useStore</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cName = <span class="title function_">computed</span>(name.<span class="title function_">bind</span>(&#123; <span class="attr">$store</span>: store &#125;))</span><br><span class="line"><span class="keyword">const</span> cLevel = <span class="title function_">computed</span>(level.<span class="title function_">bind</span>(&#123; <span class="attr">$store</span>: store &#125;))</span><br></pre></td></tr></table></figure><p>方法2：封装函数</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> useState <span class="keyword">from</span> <span class="string">&quot;../hooks/useState&quot;</span></span><br><span class="line"><span class="keyword">const</span> &#123; name, level&#125; = <span class="title function_">useState</span>([<span class="string">&quot;name&quot;</span>, <span class="string">&quot;level&quot;</span>])</span><br></pre></td></tr></table></figure><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230419172451987.png" alt="image-20230419172451987" style="zoom: 67%;" /><p>对象写法：</p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230419173013463.png" alt="image-20230419173013463" style="zoom:67%;" /><p>方法3：解构再添加响应式</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 直接对store.state进行结构</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="title function_">useStore</span>()</span><br><span class="line"><span class="comment">// 可以起别名，防止重名</span></span><br><span class="line"><span class="keyword">const</span> &#123; name, level&#125; = <span class="title function_">toRefs</span>(store.<span class="property">state</span>)</span><br></pre></td></tr></table></figure><h3 id="4、核心概念-Getters"><a href="#4、核心概念-Getters" class="headerlink" title="4、核心概念 Getters"></a>4、核心概念 Getters</h3><h4 id="1-基本使用-3"><a href="#1-基本使用-3" class="headerlink" title="1.基本使用"></a>1.基本使用</h4><p>某些属性可能需要经过变化后来使用，这个时候可以使用getters</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">getters</span>: &#123;</span><br><span class="line">    <span class="title function_">doubleCounter</span>(<span class="params">state</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> state.<span class="property">counter</span> * <span class="number">2</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>在组件中获取</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;h2&gt;<span class="attr">doublecounter</span>: &#123;&#123; $store.<span class="property">getters</span>.<span class="property">doubleCounter</span> &#125;&#125;&lt;/h2&gt;</span><br></pre></td></tr></table></figure><p>稍微复杂一点的数据</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">users</span>: [</span><br><span class="line">    &#123;<span class="attr">id</span>:<span class="number">111</span>, <span class="attr">name</span>: <span class="string">&#x27;whd&#x27;</span>, <span class="attr">age</span>: <span class="number">23</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">id</span>:<span class="number">112</span>, <span class="attr">name</span>: <span class="string">&#x27;wh&#x27;</span>, <span class="attr">age</span>: <span class="number">21</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">id</span>:<span class="number">113</span>, <span class="attr">name</span>: <span class="string">&#x27;wd&#x27;</span>, <span class="attr">age</span>: <span class="number">13</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">id</span>:<span class="number">114</span>, <span class="attr">name</span>: <span class="string">&#x27;wds&#x27;</span>, <span class="attr">age</span>: <span class="number">22</span>&#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="title function_">totalAge</span>(<span class="params">state</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> state.<span class="property">users</span>.<span class="title function_">reduce</span>(<span class="function">(<span class="params">preValue,item</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> preValue + item.<span class="property">age</span></span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;,</span><br><span class="line">    </span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>usersTotalAge: &#123;&#123; $store.getters.totalAge &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h4 id="2-getters-第二个参数"><a href="#2-getters-第二个参数" class="headerlink" title="2.getters 第二个参数"></a>2.getters 第二个参数</h4><p>getters 可以接收第二个参数</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在该getters属性中，获取其他的getters</span></span><br><span class="line"><span class="title function_">message</span>(<span class="params">state, getters</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`name:<span class="subst">$&#123;state.name&#125;</span> level:<span class="subst">$&#123;state.level&#125;</span> friendAge: <span class="subst">$&#123;getters.totalAge&#125;</span>`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;h2&gt;<span class="attr">message</span>: &#123;&#123; $store.<span class="property">getters</span>.<span class="property">message</span> &#125;&#125;&lt;/h2&gt;</span><br></pre></td></tr></table></figure><h4 id="3-getter-的返回函数"><a href="#3-getter-的返回函数" class="headerlink" title="3.getter 的返回函数"></a>3.getter 的返回函数</h4><p>getters中的函数本身，可以返回一个函数，那么在使用的地方相当于可以调用这个函数</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- 根据id获取某一个用户的信息 --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>获取id为111的信息: &#123;&#123; $store.getters.getUserById(111)&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="title function_">getUserById</span>(<span class="params">state</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">id</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> user = state.<span class="property">users</span>.<span class="title function_">find</span>(<span class="function"><span class="params">item</span> =&gt;</span> item.<span class="property">id</span> === id)</span><br><span class="line">        <span class="keyword">return</span> user</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-mapGetters-的辅助函数"><a href="#4-mapGetters-的辅助函数" class="headerlink" title="4.mapGetters 的辅助函数"></a>4.mapGetters 的辅助函数</h4><p>映射</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;h2&gt;<span class="attr">doublecounter</span>: &#123;&#123; doubleCounter &#125;&#125;&lt;/h2&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>usersTotalAge: &#123;&#123; totalAge &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>message: &#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>id为111的用户信息: &#123;&#123; getUserById(111)&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span>  </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; mapGetters &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">computed</span>: &#123;</span><br><span class="line">        ...<span class="title function_">mapGetters</span>([<span class="string">&quot;doubleCounter&quot;</span>, <span class="string">&quot;totalAge&quot;</span>, <span class="string">&quot;message&quot;</span>]),</span><br><span class="line">        ...<span class="title function_">mapGetters</span>([<span class="string">&quot;getUserById&quot;</span>])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 setup 中使用</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">一般使用</span><br><span class="line"><span class="keyword">import</span> &#123; computed &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; mapGetters, useStore &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="title function_">useStore</span>()</span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">message</span>:messageFn&#125; = <span class="title function_">mapGetters</span>([<span class="string">&quot;message&quot;</span>])</span><br><span class="line"><span class="keyword">const</span> message = <span class="title function_">computed</span>(messageFn.<span class="title function_">bind</span>(&#123; <span class="attr">$store</span>:store&#125;))</span><br><span class="line"></span><br><span class="line">解构方法  </span><br><span class="line">报警告 <span class="title function_">toRefs</span>() expects a reactive object but received a plain one.</span><br><span class="line"><span class="keyword">const</span> &#123; message &#125; =  <span class="title function_">toRefs</span>(store.<span class="property">getters</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment">// 针对某一个getters属性使用computed</span></span><br><span class="line"><span class="keyword">const</span> message = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> store.<span class="property">getters</span>.<span class="property">message</span>)</span><br></pre></td></tr></table></figure><h3 id="5、核心概念-Mutations"><a href="#5、核心概念-Mutations" class="headerlink" title="5、核心概念 Mutations"></a>5、核心概念 Mutations</h3><h4 id="1-基本使用-4"><a href="#1-基本使用-4" class="headerlink" title="1.基本使用"></a>1.基本使用</h4><p>更改 Vuex 的 store 中的状态的唯一方法是提交 mutation</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">mutations</span>: &#123;</span><br><span class="line">    <span class="title function_">changeName</span>(<span class="params">state</span>) &#123;</span><br><span class="line">      state.<span class="property">name</span> = <span class="string">&quot;wangxiaobo&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="title function_">changeName</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// this.$store.state.name = &quot;李银河&quot;</span></span><br><span class="line">      <span class="comment">// 可以跟踪修改</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">commit</span>(<span class="string">&quot;changeName&quot;</span>)</span><br><span class="line">&#125;,&#125;</span><br></pre></td></tr></table></figure><h4 id="2-携带数据"><a href="#2-携带数据" class="headerlink" title="2.携带数据"></a>2.携带数据</h4><p>携带数据：简单数据</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">mutations</span>: &#123;</span><br><span class="line">  <span class="title function_">changeName</span>(<span class="params">state, payload</span>) &#123;</span><br><span class="line">    state.<span class="property">name</span> = payload</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">changeName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">commit</span>(<span class="string">&quot;changeName&quot;</span>, <span class="string">&quot;wxb&quot;</span>)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>携带数据：对象</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">changeInfo</span>(<span class="params">state, newInfo</span>) &#123;</span><br><span class="line">    state.<span class="property">name</span> = newInfo.<span class="property">name</span></span><br><span class="line">    state.<span class="property">level</span> = newInfo.<span class="property">level</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">changeInfo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">commit</span>(<span class="string">&quot;changeInfo&quot;</span>, &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&quot;网二&quot;</span>,</span><br><span class="line">        <span class="attr">level</span>: <span class="number">99</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对象风格的提交方式</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">incrementLevel</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">commit</span>(&#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&quot;incrementLevel&quot;</span>,</span><br><span class="line">        <span class="attr">counter</span>: <span class="number">100</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h4 id="3-常量类型"><a href="#3-常量类型" class="headerlink" title="3.常量类型"></a>3.常量类型</h4><p>目的：在组件中的提交名称与 mutation 中的方法的名称是需要保持一致的，担心名字写错，可以使用常量</p><p>方法：</p><ul><li>定义 muutation_type.js 文件存放常量</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">CHANGE_INFO</span> = <span class="string">&quot;CHANGE_INFO&quot;</span></span><br></pre></td></tr></table></figure><ul><li>在 store 中使用常量</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="variable constant_">CHANGE_INFO</span> &#125; <span class="keyword">from</span> <span class="string">&quot;./mutation_types&quot;</span></span><br><span class="line">[<span class="variable constant_">CHANGE_INFO</span>](state, newInfo) &#123;</span><br><span class="line">    state.<span class="property">name</span> = newInfo.<span class="property">name</span></span><br><span class="line">    state.<span class="property">level</span> = newInfo.<span class="property">level</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在组件中使用常量</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="variable constant_">CHANGE_INFO</span> &#125; <span class="keyword">from</span> <span class="string">&quot;../store/mutation_types&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">changeInfo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">commit</span>(<span class="variable constant_">CHANGE_INFO</span>, &#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&quot;网二&quot;</span>,</span><br><span class="line">      <span class="attr">level</span>: <span class="number">99</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-mapMutation-辅助函数"><a href="#4-mapMutation-辅助函数" class="headerlink" title="4.mapMutation 辅助函数"></a>4.mapMutation 辅助函数</h4><h5 id="1、options-api-中"><a href="#1、options-api-中" class="headerlink" title="1、options api 中"></a>1、options api 中</h5><p>不带参数</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapMutations &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">      ...<span class="title function_">mapMutations</span>([<span class="string">&quot;changeName&quot;</span>, <span class="string">&quot;incrementLevel&quot;</span>, <span class="variable constant_">CHANGE_INFO</span>])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;button @click=<span class="string">&quot;incrementLevel&quot;</span>&gt;递增level&lt;/button&gt;</span><br></pre></td></tr></table></figure><p>带普通参数</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;button @click=<span class="string">&quot;changeName(&#x27;王小波i&#x27;)&quot;</span>&gt;修改name&lt;/button&gt;</span><br></pre></td></tr></table></figure><p>带对象参数</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;button @click=<span class="string">&quot;changeInfo(&#123; name:&#x27;dws&#x27;, level: 105&#125;)&quot;</span>&gt;修改info&lt;/button&gt;</span><br></pre></td></tr></table></figure><p>带对象参数最好不要使用常量</p><p>可以修改一下常量</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">CHANGE_INFO</span> = <span class="string">&quot;changeInfo&quot;</span></span><br></pre></td></tr></table></figure><h5 id="2、在-setup-中"><a href="#2、在-setup-中" class="headerlink" title="2、在 setup() 中"></a>2、在 setup() 中</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapMutations,useStore &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="variable constant_">CHANGE_INFO</span>&#125; <span class="keyword">from</span> <span class="string">&quot;../store/mutation_types&quot;</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="title function_">useStore</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 手动的映射和绑定</span></span><br><span class="line"><span class="keyword">const</span> mutations = <span class="title function_">mapMutations</span>([<span class="string">&quot;changeName&quot;</span>, <span class="string">&quot;incrementLevel&quot;</span>, <span class="variable constant_">CHANGE_INFO</span>])</span><br><span class="line"><span class="keyword">const</span> newMutations = &#123;&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(mutations).<span class="title function_">forEach</span>(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">    newMutations[key] = mutations[key].<span class="title function_">bind</span>(&#123; <span class="attr">$store</span>: store&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> &#123; changeName, incrementLevel, changeInfo &#125; = newMutations</span><br></pre></td></tr></table></figure><h4 id="5-mutation-重要原则"><a href="#5-mutation-重要原则" class="headerlink" title="5.mutation 重要原则"></a>5.mutation 重要原则</h4><p>一条重要的原则就是要记住 mutation 必须是同步函数</p><ul><li>这是因为 devtool 工具会记录 mutation 的日记</li><li>每一条mutation被记录，devtools 都需要捕捉到前一状态和后一状态的快照</li><li>但是在 mutation 中执行异步操作，就无法追踪到数据的变化</li></ul><p>所以 Vuex 的重要原则中要求 mutation必须是同步函数</p><p>但是如果希望在 Vuex 中发送网络请求的话需要如何操作：Actions</p><h3 id="6、核心概念-Actions"><a href="#6、核心概念-Actions" class="headerlink" title="6、核心概念 Actions"></a>6、核心概念 Actions</h3><p>Action 类似于 mutation，不同在于：</p><ul><li><p>Action 提交的是 mutation，而不是直接变更状态</p></li><li><p>Action 可以包含任意异步操作</p></li></ul><p>这里有一个非常重要的参数 context：</p><ul><li><p>context 是一个和 store 实例均有相同方法和属性的 context 对象</p></li><li><p>所以我们可以从其中获取到 commit 方法来提交一个 mutation，或者通过 context.state 和 context.getters 来获取 state 和 getters</p></li></ul><p>但是为什么它不是store对象呢？等到 Modules 具体来说</p><h4 id="1-基本操作"><a href="#1-基本操作" class="headerlink" title="1.基本操作"></a>1.基本操作</h4><p>使用action 分发</p><ul><li>分发使用的是 store 上的dispatch函数</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">actions</span>: &#123;</span><br><span class="line">    <span class="title function_">incrementAction</span>(<span class="params">context</span>) &#123;</span><br><span class="line">        <span class="comment">// console.log(context.commit) // 用于提交mutation</span></span><br><span class="line">        <span class="comment">// console.log(context.getters) // getters</span></span><br><span class="line">        <span class="comment">// console.log(context.state)  // state</span></span><br><span class="line">    context.<span class="title function_">commit</span>(<span class="string">&quot;increment&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">methods中：</span><br><span class="line"><span class="title function_">counterBtnClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">dispatch</span>(<span class="string">&quot;incrementAction&quot;</span>)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>同样的，它也可以携带参数</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">changeNameAction</span>(<span class="params">context, payload</span>) &#123;</span><br><span class="line">    context.<span class="title function_">commit</span>(<span class="string">&quot;changeName&quot;</span>, payload)</span><br><span class="line">&#125;</span><br><span class="line">methods中:</span><br><span class="line"><span class="title function_">nameBtnClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">dispatch</span>(<span class="string">&quot;changeNameAction&quot;</span>, <span class="string">&quot;why&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以以对象的形式进行分发</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230420081706466.png" alt="image-20230420081706466"></p><h4 id="2-actions-辅助函数"><a href="#2-actions-辅助函数" class="headerlink" title="2.actions 辅助函数"></a>2.actions 辅助函数</h4><p>action 也有对应的辅助函数</p><ul><li>数组类型的写法</li></ul><p>options api</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">...<span class="title function_">mapActions</span>([<span class="string">&quot;incrementAction&quot;</span>, <span class="string">&quot;changeNameAction&quot;</span>])</span><br></pre></td></tr></table></figure><p>composition api</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapActions, useStore &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="title function_">useStore</span>()</span><br><span class="line"><span class="number">1.</span>在setup中使用mapactions辅助函数</span><br><span class="line"><span class="keyword">const</span> actions = <span class="title function_">mapActions</span>([<span class="string">&quot;incrementAction&quot;</span>, <span class="string">&quot;changeNameAction&quot;</span>])</span><br><span class="line"><span class="keyword">const</span> newActions = &#123;&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(actions).<span class="title function_">forEach</span>( <span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    newActions[key] = actions[key].<span class="title function_">bind</span>(&#123; <span class="attr">$store</span>: store&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> &#123; incrementAction, changeNameAction&#125; = newActions</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.默认做法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">increment</span>(<span class="params"></span>) &#123;</span><br><span class="line">    store.<span class="title function_">dispatch</span>(<span class="string">&quot;incrementAction&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>对象写法</li></ul><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230420081726099.png" alt="image-20230420081726099"></p><h4 id="3-actions-发起网络请求"><a href="#3-actions-发起网络请求" class="headerlink" title="3.actions 发起网络请求"></a>3.actions 发起网络请求</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="title function_">fetchHomeMultidataAction</span>(<span class="params">context</span>) &#123;</span><br><span class="line">    <span class="comment">// 1返回promise,给promise设置then</span></span><br><span class="line">    <span class="comment">// fetch(&quot;http://123.207.32.32:8000/home/multidata&quot;).then(res =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//   res.json().then(data =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//     console.log(data)</span></span><br><span class="line">    <span class="comment">//   &#125;)</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.promise的链式调用</span></span><br><span class="line">    <span class="comment">// fetch(&quot;http://123.207.32.32:8000/home/multidata&quot;).then(res =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//   return res.json()</span></span><br><span class="line">    <span class="comment">//   &#125;).then(data =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//     console.log(data)</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.awiat/async</span></span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&quot;http://123.207.32.32:8000/home/multidata&quot;</span>)</span><br><span class="line">    <span class="keyword">const</span> data = <span class="keyword">await</span> res.<span class="title function_">json</span>()</span><br><span class="line">    <span class="comment">// console.log(data)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改state数据</span></span><br><span class="line">    context.<span class="title function_">commit</span>(<span class="string">&quot;changeBanners&quot;</span>, data.<span class="property">data</span>.<span class="property">banner</span>.<span class="property">list</span>)</span><br><span class="line">    context.<span class="title function_">commit</span>(<span class="string">&quot;changeRecommends&quot;</span>, data.<span class="property">data</span>.<span class="property">recommend</span>.<span class="property">list</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">store.<span class="title function_">dispatch</span>(<span class="string">&quot;fetchHomeMultidataAction&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="title function_">changeBanners</span>(<span class="params">state, banners</span>) &#123;</span><br><span class="line">    state.<span class="property">banners</span> = banners</span><br><span class="line">&#125;,</span><br><span class="line"><span class="title function_">changeRecommends</span>(<span class="params">state, recommends</span>) &#123;</span><br><span class="line">    state.<span class="property">recommends</span> = recommends</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-actions-的异步操作"><a href="#4-actions-的异步操作" class="headerlink" title="4.actions 的异步操作"></a>4.actions 的异步操作</h4><p>Action 通常是异步的，如何知道 action 的结束</p><ul><li>可以通过让 action 返回 Promise，在 Promise 的 then 中来处理完成后的操作</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">fetchHomeMultidataAction</span>(<span class="params">context</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">async</span> (resolve, reject) =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&quot;http://123.207.32.32:8000/home/multidata&quot;</span>)</span><br><span class="line">        <span class="keyword">const</span> data = <span class="keyword">await</span> res.<span class="title function_">json</span>()</span><br><span class="line">        context.<span class="title function_">commit</span>(<span class="string">&quot;changeBanners&quot;</span>, data.<span class="property">data</span>.<span class="property">banner</span>.<span class="property">list</span>)</span><br><span class="line">        context.<span class="title function_">commit</span>(<span class="string">&quot;changeRecommends&quot;</span>, data.<span class="property">data</span>.<span class="property">recommend</span>.<span class="property">list</span>)</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="string">&quot;sdw&quot;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">store.<span class="title function_">dispatch</span>(<span class="string">&quot;fetchHomeMultidataAction&quot;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&quot;home中的then回调&quot;</span>, res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="7、核心概念-Modules"><a href="#7、核心概念-Modules" class="headerlink" title="7、核心概念 Modules"></a>7、核心概念 Modules</h3><h4 id="1-module-的基本使用"><a href="#1-module-的基本使用" class="headerlink" title="1.module 的基本使用"></a>1.module 的基本使用</h4><p>什么是Module</p><ul><li><p>由于使用单一状态树，应用的所有状态会集中到一个比较大的对象，当应用变得非常复杂时，store 对象就有可能变得相当臃肿</p></li><li><p>为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）</p></li><li><p>每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块</p></li></ul><p>做法：</p><ul><li>新建 modules 文件夹，将需要抽出的组件的数据抽离并导出</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">state</span>: <span class="function">() =&gt;</span> (&#123; &#125;),</span><br><span class="line">  <span class="attr">mutations</span>: &#123; &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在 store 中导入并放入 module 中</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> homeModule <span class="keyword">from</span> <span class="string">&quot;./modules/home&quot;</span></span><br><span class="line"><span class="attr">modules</span>: &#123;</span><br><span class="line">    <span class="attr">home</span>: homeModule</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在组件中获取 module 中的数据</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template v-<span class="keyword">for</span>=<span class="string">&quot;item in $store.state.home.banners&quot;</span> :key=<span class="string">&quot;item.acm&quot;</span>&gt;</span><br></pre></td></tr></table></figure><p>在抽离之前发起的 dispatch 形式暂时不需要修改</p><h4 id="2-module-的局部状态"><a href="#2-module-的局部状态" class="headerlink" title="2.module 的局部状态"></a>2.module 的局部状态</h4><p>对于模块内部的 mutation 和 getter，接收的第一个参数是模块的局部状态对象</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">counter模块中：</span><br><span class="line"><span class="attr">mutations</span>: &#123;</span><br><span class="line">    <span class="title function_">incrementCount</span>(<span class="params">state</span>) &#123;</span><br><span class="line">    state.<span class="property">count</span>++</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">getters</span>: &#123;</span><br><span class="line">    <span class="title function_">doubleCount</span>(<span class="params">state, getters, rootState</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> state.<span class="property">count</span> + rootState.<span class="property">rootCounter</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">actions</span>: &#123;</span><br><span class="line">    <span class="title function_">incrementCountAction</span>(<span class="params">context</span>) &#123;</span><br><span class="line">        context.<span class="title function_">commit</span>(<span class="string">&quot;incrementCount&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template 中：</span><br><span class="line">&lt;!-- <span class="number">1.</span>使用state时，是需要通过state.<span class="property">moduleName</span>.<span class="property">xxx</span> --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Counter模块中的count： &#123;&#123; $store.state.counter.count&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">&lt;!-- <span class="number">2.</span>使用getters时，是直接getters.<span class="property">xxx</span> --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Counter模块中的doubleCount： &#123;&#123; $store.getters.doubleCount&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">setup 中：</span><br><span class="line"><span class="comment">// 派发事件时，默认也是不需要根模块</span></span><br><span class="line"><span class="comment">// 提交mutation时，默认也是不需要模块名称</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">incrementCount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    store.<span class="title function_">dispatch</span>(<span class="string">&quot;incrementCountAction&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-module-的命名空间"><a href="#3-module-的命名空间" class="headerlink" title="3.module 的命名空间"></a>3.module 的命名空间</h4><p>默认情况下，模块内部的 action 和 mutation 仍然是注册在全局的命名空间中的</p><ul><li><p>这样使得多个模块能够对同一个 action 或 mutation 作出响应</p></li><li><p>Getter 同样也默认注册在全局命名空间</p></li></ul><p>如果我们希望模块具有更高的封装度和复用性，可以添加 namespaced: true 的方式使其成为带命名空间的模块</p><ul><li>当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">counter模块中:</span><br><span class="line"><span class="attr">namespaced</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要加上命名空间</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Counter模块中的doubleCount： &#123;&#123; $store.getters[&quot;counter/doubleCount&quot;] &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">incrementCount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    store.<span class="title function_">dispatch</span>(<span class="string">&quot;counter/incrementCountAction&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-module-修改或派发根组件"><a href="#4-module-修改或派发根组件" class="headerlink" title="4.module 修改或派发根组件"></a>4.module 修改或派发根组件</h4><p>如果希望在action中修改root中的state，那么有如下的方式</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230420104445571.png" alt="image-20230420104445571"></p><h2 id="13-Vue全家桶-Pinia状态管理"><a href="#13-Vue全家桶-Pinia状态管理" class="headerlink" title="13.Vue全家桶 - Pinia状态管理"></a>13.Vue全家桶 - Pinia状态管理</h2><h3 id="1、Pinia-和-Vuex-的对比"><a href="#1、Pinia-和-Vuex-的对比" class="headerlink" title="1、Pinia 和 Vuex 的对比"></a>1、Pinia 和 Vuex 的对比</h3><h4 id="1-什么是-Pinia"><a href="#1-什么是-Pinia" class="headerlink" title="1.什么是 Pinia"></a>1.什么是 Pinia</h4><ul><li><p>Pinia开始于大概2019年，最初是作为一个实验为Vue重新设计状态管理，让它用起来像组合式API（Composition API）</p></li><li><p>从那时到现在，最初的设计原则依然是相同的，并且目前同时兼容Vue2、Vue3，也并不要求你使用Composition API</p></li><li><p>Pinia本质上依然是一个状态管理的库，用于跨组件、页面进行状态共享（这点和Vuex、Redux一样）</p></li></ul><h4 id="2-Pinia-和-Vuex-的区别"><a href="#2-Pinia-和-Vuex-的区别" class="headerlink" title="2.Pinia 和 Vuex 的区别"></a>2.Pinia 和 Vuex 的区别</h4><p>有 Vuex 为什么还要用 Pinia</p><ul><li><p>Pinia 最初是为了探索 Vuex 的下一次迭代会是什么样子，结合了 Vuex 5 核心团队讨论中的许多想法</p></li><li><p>最终，团队意识到 Pinia 已经实现了 Vuex5 中大部分内容，所以最终决定用 Pinia 来替代 Vuex</p></li><li><p>与 Vuex 相比，Pinia 提供了一个更简单的 API，具有更少的仪式，提供了 Composition-API 风格的 API</p></li><li><p>最重要的是，在与 TypeScript 一起使用时具有可靠的类型推断支持</p></li></ul><p>和 Vuex 相比，Pinia 有很多的优势</p><ul><li><p>mutations 不再存在：</p><ul><li>他们经常被认为是非常冗长</li><li>他们最初带来了 devtools 集成，但这不再是问题</li></ul></li><li><p>更友好的 TypeScript 支持，Vuex 之前对 TS 的支持很不友好</p></li><li><p>不再有 modules 的嵌套结构：</p><ul><li>你可以灵活使用每一个 store，它们是通过扁平化的方式来相互使用的</li></ul></li><li><p>也不再有命名空间的概念，不需要记住它们的复杂关系</p></li></ul><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230420110608336.png" alt="image-20230420110608336" style="zoom:50%;" /><h3 id="2、创建-Pinia-的-Store"><a href="#2、创建-Pinia-的-Store" class="headerlink" title="2、创建 Pinia 的 Store"></a>2、创建 Pinia 的 Store</h3><h4 id="1-认识-store"><a href="#1-认识-store" class="headerlink" title="1.认识 store"></a>1.认识 store</h4><ul><li><p>一个 Store （如 Pinia）是一个实体，它会持有为绑定到你组件树的状态和业务逻辑，也就是保存了全局的状态</p></li><li><p>它有点像始终存在，并且每个人都可以读取和写入的组件</p></li><li><p>可以在你的应用程序中定义任意数量的Store来管理你的状态</p></li></ul><p> Store有三个核心概念：</p><ul><li>state、getters、actions</li><li>等同于组件的data、computed、methods</li><li>一旦 store 被实例化，就可以直接在 store 上访问 state、getters 和 actions 中定义的任何属性</li></ul><h4 id="2-基本使用-2"><a href="#2-基本使用-2" class="headerlink" title="2.基本使用"></a>2.基本使用</h4><ul><li><p>定义一个Store</p><ul><li>需要知道 Store 是使用 defineStore() 定义的</li><li>并且它需要一个唯一名称，作为第一个参数传递</li><li>这个 name，也称为 id，是必要的，Pinia 使用它来将 store 连接到 devtools</li><li>返回的函数统一使用useX作为命名方案，这是约定的规范</li></ul></li><li><p>使用定义的 Store</p><ul><li>Store 在它被使用之前是不会创建的，可以通过调用 use 函数来使用 Store</li><li>注意Store获取到后不能被解构，那么会失去响应式</li><li>为了从 Store 中提取属性同时保持其响应式，需要使用storeToRefs()。</li></ul></li></ul><p>安装：npm install pinia or yarn add pinia</p><h4 id="3-详细使用"><a href="#3-详细使用" class="headerlink" title="3.详细使用"></a>3.详细使用</h4><ul><li>创建一个 pinia，并且将其传递给应用程序</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">index.<span class="property">js</span>：</span><br><span class="line"><span class="keyword">import</span> &#123; createPinia &#125; <span class="keyword">from</span> <span class="string">&quot;pinia&quot;</span></span><br><span class="line"><span class="keyword">const</span> pinia = <span class="title function_">createPinia</span>()</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> pinia</span><br><span class="line"></span><br><span class="line">main.<span class="property">js</span>：</span><br><span class="line"><span class="keyword">import</span> pinia <span class="keyword">from</span> <span class="string">&#x27;./stores&#x27;</span></span><br><span class="line"><span class="title function_">createApp</span>(<span class="title class_">App</span>).<span class="title function_">use</span>(pinia).<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li>创建页面的 store</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义关于counter的store</span></span><br><span class="line"><span class="keyword">import</span> &#123; defineStore &#125; <span class="keyword">from</span> <span class="string">&quot;pinia&quot;</span></span><br><span class="line"><span class="keyword">const</span> useCounter = <span class="title function_">defineStore</span>(<span class="string">&quot;counter&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">state</span>: <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">99</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> useCounter</span><br></pre></td></tr></table></figure><ul><li>组件中使用数据</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;h2&gt;<span class="attr">count</span>: &#123;&#123; counterStore.<span class="property">count</span> &#125;&#125;&lt;/h2&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> useCounter <span class="keyword">from</span> <span class="string">&#x27;@/stores/counter&#x27;</span></span><br><span class="line"><span class="keyword">const</span> counterStore = <span class="title function_">useCounter</span>()</span><br></pre></td></tr></table></figure><p>解构之后失去响应式</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; count &#125; = counterStore</span><br><span class="line">&lt;h2&gt;<span class="attr">count</span>: &#123;&#123;count&#125;&#125;&lt;/h2&gt;</span><br></pre></td></tr></table></figure><p>获取响应式</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">方法<span class="number">1</span>：</span><br><span class="line"><span class="keyword">import</span> &#123; toRefs &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> &#123; count &#125; = <span class="title function_">toRefs</span>(counterStore)</span><br><span class="line"></span><br><span class="line">方法<span class="number">2</span>：</span><br><span class="line"><span class="keyword">import</span> &#123; storeToRefs &#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> &#123; count&#125; = <span class="title function_">storeToRefs</span>(counterStore)</span><br></pre></td></tr></table></figure><h3 id="3、Pinia-核心概念-State"><a href="#3、Pinia-核心概念-State" class="headerlink" title="3、Pinia 核心概念 State"></a>3、Pinia 核心概念 State</h3><p>state 是 store 的核心部分，因为store是用来帮助我们管理状态的</p><ul><li>在 Pinia 中，状态被定义为返回初始状态的函数</li></ul><h4 id="操作-State"><a href="#操作-State" class="headerlink" title="操作 State"></a>操作 State</h4><p>读取和写入 State</p><ul><li>默认情况下，可以通过 store 实例访问状态来直接读取和写入状态</li></ul><p>改变 State</p><ul><li>除了直接用 store.counter++ 修改 store，你还可以调用 $patch 方法</li><li>它允许您使用部分“state”对象同时应用多个更改</li></ul><p>替换 State</p><ul><li>可以通过将其 $state 属性设置为新对象来替换 Store 的整个状态</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">changeState</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 1.修改state(一个一个修改状态)</span></span><br><span class="line">  <span class="comment">// useStore.name = &#x27;kobe&#x27;</span></span><br><span class="line">  <span class="comment">// useStore.age = 30</span></span><br><span class="line">  <span class="comment">// useStore.level = 200</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.一次性修改多个状态</span></span><br><span class="line">  <span class="comment">// useStore.$patch(&#123;</span></span><br><span class="line">  <span class="comment">//   name: &quot;james&quot;,</span></span><br><span class="line">  <span class="comment">//   age: 35,</span></span><br><span class="line">  <span class="comment">// &#125;)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.替换state为新的对象</span></span><br><span class="line">  <span class="keyword">const</span> oldState = useStore.<span class="property">$state</span></span><br><span class="line">  useStore.<span class="property">$state</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;curry&quot;</span>,</span><br><span class="line">    <span class="attr">level</span>: <span class="number">199</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 并不是完全替换，应该是有劫持，发生了融合，指向同一个地址</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(oldState === useStore.<span class="property">$state</span>) <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重置 State</p><ul><li>你可以通过调用 store 上的 $reset() 方法将状态重置到其初始值</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">resetState</span>(<span class="params"></span>) &#123;</span><br><span class="line">  useStore.$reset()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、Pinia-核心概念-Getters"><a href="#4、Pinia-核心概念-Getters" class="headerlink" title="4、Pinia 核心概念 Getters"></a>4、Pinia 核心概念 Getters</h3><p>Getters 相当于 Store 的计算属性</p><ul><li>它们可以用 defineStore() 中的 getters 属性定义</li><li>getters 中可以定义接受一个 state 作为参数的函数</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">getters</span>: &#123;</span><br><span class="line">    <span class="title function_">doubleCount</span>(<span class="params">state</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> state.<span class="property">count</span> * <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在页面中访问 store 中的 getters</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;h2&gt;<span class="attr">doubleCount</span>: &#123;&#123; counterStore.<span class="property">doubleCount</span> &#125;&#125;&lt;/h2&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>doubleCountAddOne: &#123;&#123; counterStore.doubleCountAddOne &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>Getters 中访问自己的其他 Getters</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">doubleCountAddOne</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// this是store实例</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">doubleCount</span> + <span class="number">1</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>访问其他store的Getters</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> useUser <span class="keyword">from</span> <span class="string">&quot;./user&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">showMessage</span>(<span class="params">state</span>) &#123;</span><br><span class="line">    <span class="comment">// 1.获取user信息</span></span><br><span class="line">    <span class="keyword">const</span> userStore = <span class="title function_">useUser</span>()</span><br><span class="line">    <span class="comment">// 2.获取自己的信息</span></span><br><span class="line">    <span class="comment">// 3.拼接信息</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">`name:<span class="subst">$&#123;userStore.name&#125;</span>-count:<span class="subst">$&#123;state.count&#125;</span>`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;h2&gt;<span class="attr">showMessage</span>: &#123;&#123; counterStore.<span class="property">showMessage</span> &#125;&#125;&lt;/h2&gt;</span><br></pre></td></tr></table></figure><p>Getters也可以返回一个函数，这样就可以接受参数</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">getFriendById</span>(<span class="params">state</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">id</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; state.<span class="property">friends</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> friend = state.<span class="property">friends</span>[i]</span><br><span class="line">            <span class="keyword">if</span>(friend.<span class="property">id</span> === id) &#123;</span><br><span class="line">                <span class="keyword">return</span> friend</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">    </span><br><span class="line">在页面中使用：</span><br><span class="line"><span class="keyword">import</span> useCounter <span class="keyword">from</span> <span class="string">&quot;@/stores/counter&quot;</span></span><br><span class="line"><span class="keyword">const</span> counterStore = <span class="title function_">useCounter</span>()</span><br><span class="line"></span><br><span class="line">&lt;h2&gt;friend-<span class="number">112</span>: &#123;&#123; counterStore.<span class="title function_">getFriendById</span>(<span class="number">112</span>) &#125;&#125;&lt;/h2&gt;</span><br></pre></td></tr></table></figure><h3 id="5、Pinia-核心概念-Actions"><a href="#5、Pinia-核心概念-Actions" class="headerlink" title="5、Pinia 核心概念 Actions"></a>5、Pinia 核心概念 Actions</h3><p>Actions 相当于组件中的 methods</p><ul><li>可以使用 defineStore() 中的 actions 属性定义，并且它们非常适合定义业务逻辑</li></ul><p>和getters一样，在action中可以通过this访问整个store实例的所有操作</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">actions</span>: &#123;</span><br><span class="line">    <span class="title function_">increment</span>(<span class="params">num</span>) &#123;</span><br><span class="line">        <span class="comment">// console.log(state)</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">count</span> += num</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> useCounter <span class="keyword">from</span> <span class="string">&quot;@/stores/counter&quot;</span></span><br><span class="line"><span class="keyword">const</span> counterStore = <span class="title function_">useCounter</span>()</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">changeState</span>(<span class="params"></span>) &#123;</span><br><span class="line">    counterStore.<span class="title function_">increment</span>(<span class="number">10</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;button @click=<span class="string">&quot;changeState&quot;</span>&gt;修改state&lt;/button&gt;</span><br></pre></td></tr></table></figure><p>Action 执行异步操作</p><ul><li>可以编写异步函数，在函数中使用await</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> useHome = <span class="title function_">defineStore</span>(<span class="string">&quot;home&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">state</span>: <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">    <span class="attr">banners</span>: [],</span><br><span class="line">    <span class="attr">recommends</span>: []</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="attr">actions</span>: &#123;</span><br><span class="line">    <span class="keyword">async</span> <span class="title function_">fetchHomeMultidata</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&quot;http://123.207.32.32:8000/home/multidata&quot;</span>)</span><br><span class="line">      <span class="keyword">const</span> data = <span class="keyword">await</span> res.<span class="title function_">json</span>()</span><br><span class="line">      </span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">banners</span> = data.<span class="property">data</span>.<span class="property">banner</span>.<span class="property">list</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">recommends</span> = data.<span class="property">data</span>.<span class="property">recommend</span>.<span class="property">list</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;adsdw&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> useHome <span class="keyword">from</span> <span class="string">&quot;@/stores/home&quot;</span></span><br><span class="line"><span class="keyword">const</span> homeStore = <span class="title function_">useHome</span>()</span><br><span class="line">homeStore.<span class="title function_">fetchHomeMultidata</span>().<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;fetchHomeMultidata已经完成了&quot;</span>, res)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&lt;!-- 展示数据-------- --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-for</span>=<span class="string">&quot;item in homeStore.banners&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123;item.title&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="14-网络请求库-axios库"><a href="#14-网络请求库-axios库" class="headerlink" title="14.网络请求库 - axios库"></a>14.网络请求库 - axios库</h2><h3 id="1、认识-Axios-库"><a href="#1、认识-Axios-库" class="headerlink" title="1、认识 Axios 库"></a>1、认识 Axios 库</h3><p>安装：npm install axios</p><p>功能特点</p><ul><li><p>在浏览器中发送 XMLHttpRequests 请求</p></li><li><p>在 node.js 中发送 http请求</p></li><li><p>支持 Promise API</p></li><li><p>拦截请求和响应</p></li><li><p>转换请求和响应数据</p></li></ul><h3 id="2、axios-发送请求"><a href="#2、axios-发送请求" class="headerlink" title="2、axios 发送请求"></a>2、axios 发送请求</h3><h4 id="请求方式"><a href="#请求方式" class="headerlink" title="请求方式"></a>请求方式</h4><p>支持多种请求方式</p><ul><li>axios(config)</li><li>axios.request(config)</li><li>axios.get(url[, config])</li><li>axios.delete(url[, config])</li><li>axios.head(url[, config])</li><li>axios.post(url[, data[, config]])</li><li>axios.put(url[, data[, config]])</li><li>axios.patch(url[, data[, config]])</li></ul><p>有时候可能需求同时发送两个请求</p><ul><li>使用axios.all, 可以放入多个请求的数组</li><li>axios.all([]) 返回的结果是一个数组，使用 axios.spread 可将数组 [res1,res2] 展开为 res1, res2</li></ul><h4 id="常见配置"><a href="#常见配置" class="headerlink" title="常见配置"></a>常见配置</h4><p>请求地址</p><ul><li>url: ‘&#x2F;user’,</li></ul><p>请求类型</p><ul><li>method: ‘get’,</li></ul><p>请求根路径</p><ul><li>baseURL: ‘<a href="http://www.mt.com/api">http://www.mt.com/api</a>‘,</li></ul><p>请求前的数据处理</p><ul><li>transformRequest:[function(data){}],</li></ul><p>请求后的数据处理</p><ul><li>transformResponse: [function(data){}],</li></ul><p>自定义的请求头</p><ul><li>headers:{‘x-Requested-With’:’XMLHttpRequest’},</li></ul><p>URL查询对象</p><ul><li>params:{ id: 12 },</li></ul><p>查询对象序列化函数</p><ul><li>paramsSerializer: function(params){ }</li></ul><p>request body</p><ul><li>data: { key: ‘aa’},</li></ul><p>超时设置</p><ul><li>timeout: 1000</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">axios.<span class="title function_">post</span>(<span class="string">&quot;http://123.207.32.32:1888/02_param/postjson&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;coderwhy&quot;</span>,</span><br><span class="line">    <span class="attr">password</span>: <span class="string">&quot;123456&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;).<span class="title function_">then</span>( <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;res:&quot;</span>, res.<span class="property">data</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="额外补充"><a href="#额外补充" class="headerlink" title="额外补充"></a>额外补充</h4><p>baseURL</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.baseURL</span></span><br><span class="line"><span class="keyword">const</span> baseURL = <span class="string">&quot;http://123.207.32.32:8000&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 给axios实例配置公共的基础配置</span></span><br><span class="line">axios.<span class="property">defaults</span>.<span class="property">baseURL</span> = baseURL</span><br><span class="line">axios.<span class="property">defaults</span>.<span class="property">timeout</span> = <span class="number">10000</span></span><br><span class="line">axios.<span class="property">defaults</span>.<span class="property">headers</span> = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.1 get:/home/multidata</span></span><br><span class="line">axios.<span class="title function_">get</span>(<span class="string">&quot;/home/multidata&quot;</span>).<span class="title function_">then</span>( <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;res:&quot;</span>, res.<span class="property">data</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>发送多个请求</p><ul><li>所有的请求完成之后才会调用 then</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">axios.<span class="title function_">all</span>([</span><br><span class="line">  axios.<span class="title function_">get</span>(<span class="string">&quot;/home/multidata&quot;</span>),</span><br><span class="line">  axios.<span class="title function_">post</span>(<span class="string">&quot;http://123.207.32.32:1888/02_param/postjson&quot;</span>, &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;coderwhy&quot;</span>,</span><br><span class="line">    <span class="attr">password</span>: <span class="string">&quot;123456&quot;</span></span><br><span class="line">  &#125;)</span><br><span class="line">]).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;res&quot;</span>, res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="3、axios-创建实例"><a href="#3、axios-创建实例" class="headerlink" title="3、axios 创建实例"></a>3、axios 创建实例</h3><p>为什么要创建axios的实例</p><ul><li>当我们从axios模块中导入对象时, 使用的实例是默认的实例</li><li>当给该实例设置一些默认配置时, 这些配置就被固定下来了</li><li>但是后续开发中, 某些配置可能会不太一样</li><li>比如某些请求需要使用特定的baseURL或者timeout等</li><li>这个时候就可以创建新的实例, 并且传入属于该实例的配置信息</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// axios默认库提供给我们的实例对象</span></span><br><span class="line"><span class="comment">// axios.get(&quot;url&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建其他的实例发送网络请求</span></span><br><span class="line"><span class="keyword">const</span> instance1 = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">  <span class="attr">baseURL</span>: <span class="string">&quot;http://132.207.32.32:8000&quot;</span>,</span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">10000</span>,</span><br><span class="line">  <span class="attr">headers</span>: &#123;&#125;</span><br><span class="line">&#125;)</span><br><span class="line">instance1.<span class="title function_">get</span>(<span class="string">&quot;/lyric&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">params</span>: &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="number">500665346</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res.<span class="property">data</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> instance2 = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">  <span class="attr">baseURL</span>: <span class="string">&quot;http://132.207.32.32:9001&quot;</span>,</span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">1000</span>,</span><br><span class="line">  <span class="attr">headers</span>: &#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="4、axios-的拦截器"><a href="#4、axios-的拦截器" class="headerlink" title="4、axios 的拦截器"></a>4、axios 的拦截器</h3><p>axios的也可以设置拦截器：拦截每次请求和响应</p><ul><li><p>axios.interceptors.request.use(请求成功拦截, 请求失败拦截)</p></li><li><p>axios.interceptors.response.use(响应成功拦截, 响应失败拦截)</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对实例配置拦截器</span></span><br><span class="line">axios.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(<span class="function">(<span class="params">config</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 请求成功的拦截</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;请求成功&quot;</span>)</span><br><span class="line">  <span class="comment">// 开始loading动画</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对原来的配置文件进行修改</span></span><br><span class="line">  <span class="comment">// 2.1 heder</span></span><br><span class="line">  <span class="comment">// 2.2 认证登录：token/cookie</span></span><br><span class="line">  <span class="comment">// 2.3 请求参数进行某些转化</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// if (config.url === &quot;/user/info&quot;)&#123;</span></span><br><span class="line">  <span class="comment">//   config.header[&quot;token&quot;] = &quot;coderwhy&quot;</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> config</span><br><span class="line">&#125;, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;请求失败的拦截&quot;</span>)</span><br><span class="line">  <span class="keyword">return</span> err</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">axios.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 这里拦截之后返回res.data，在下方则不需要写为res.data了。这里已经做了转换</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;响应成功拦截&quot;</span>)</span><br><span class="line">  <span class="comment">// 结束loading动画</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对数据进行转化，再返回数据</span></span><br><span class="line">  <span class="keyword">return</span> res.<span class="property">data</span></span><br><span class="line">&#125;, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;响应失败的拦截:&quot;</span>, err)</span><br><span class="line">  <span class="keyword">return</span> err</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">axios.<span class="title function_">get</span>(<span class="string">&quot;http://123.207.32.32:8000/home/multidata&quot;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;res:&quot;</span>, res)</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;err:&quot;</span>, err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="5、axios-请求封装"><a href="#5、axios-请求封装" class="headerlink" title="5、axios 请求封装"></a>5、axios 请求封装</h3><p>封装的目的：为了防止 axios 突然不维护，而项目与 axios 的耦合度太高，以至于修改项目的成本太高与过于复杂</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HYRequest</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">baseURL, timeout=<span class="number">10000</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">instance</span> = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">      baseURL,</span><br><span class="line">      timeout</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">request</span>(<span class="params">config</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">instance</span>.<span class="title function_">request</span>(config).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(res.<span class="property">data</span>)</span><br><span class="line">      &#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">reject</span>(err)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">get</span>(<span class="params">config</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">request</span>(&#123;...config, <span class="attr">method</span>:<span class="string">&quot;get&quot;</span>&#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">post</span>(<span class="params">config</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">request</span>(&#123;...config, <span class="attr">method</span>: <span class="string">&quot;post&quot;</span>&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以创建多个实例</span></span><br><span class="line"><span class="comment">// const hyRequest1 = new HYRequest(&quot;&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置baseURL</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">HYRequest</span>(<span class="string">&quot;http://123.207.32.32:8000&quot;</span>)</span><br><span class="line"></span><br><span class="line">使用：</span><br><span class="line"><span class="keyword">import</span> hyRequest <span class="keyword">from</span> <span class="string">&quot;./service&quot;</span></span><br><span class="line">hyRequest.<span class="title function_">request</span>(&#123;</span><br><span class="line">  <span class="attr">url</span>: <span class="string">&quot;/home/multidata&quot;</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;res:&quot;</span>, res)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">hyRequest.<span class="title function_">get</span>(&#123;</span><br><span class="line">  <span class="attr">url</span>: <span class="string">&quot;/home/multidata&quot;</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;res:&quot;</span>, res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="15-项目实战"><a href="#15-项目实战" class="headerlink" title="15.项目实战"></a>15.项目实战</h2><h3 id="1、初始项目步骤"><a href="#1、初始项目步骤" class="headerlink" title="1、初始项目步骤"></a>1、初始项目步骤</h3><p>安装项目—&gt;npm install —&gt;npm run xx —&gt;去除默认样式—&gt;添加jsconfig（代码提示友好）—&gt;创建项目结构（目录）—&gt;CSS样式的重置（npm i normalize  main中引入）—&gt;创建路由—&gt;开发</p><p>修改第三方UI组件库的样式</p><p>1.插槽：插入自己的元素：那么可以在自己的作用域中直接修改这个元素</p><p>2.全局定义一个变量，覆盖它默认的值，但会修改全局</p><p>3.布局定义一个变量，覆盖它默认变量的值，优点：局部修改</p><p>4.直接查找对应的子组件选择器，进行修改</p><ul><li>:deep(子组件元素的选择器)进行修改</li><li>直接修改CSS</li></ul>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IT前端 </tag>
            
            <tag> Vue </tag>
            
            <tag> 前端框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端工程化</title>
      <link href="/archives/7db00131.html"/>
      <url>/archives/7db00131.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前端工程化"><a href="#前端工程化" class="headerlink" title="前端工程化"></a>前端工程化</h1><h2 id="1-邂逅-Node-js-开发"><a href="#1-邂逅-Node-js-开发" class="headerlink" title="1.邂逅 Node.js 开发"></a>1.邂逅 Node.js 开发</h2><h3 id="1、Node-js-是什么"><a href="#1、Node-js-是什么" class="headerlink" title="1、Node.js 是什么"></a>1、Node.js 是什么</h3><p>官方对 Node.js 的定义：</p><p>Node.js是一个基于V8 JavaScript引擎的JavaScript运行时环境</p><p>也就是说 Node.js 基于 V8 引擎来执行 JavaScript 的代码，但是不仅仅只有 V8 引擎：</p><ul><li><p>V8 可以嵌入到任何C ++应用程序中，无论是Chrome还是Node.js，事实上都是嵌入了V8引擎来执行JavaScript代码</p></li><li><p>但是在Chrome浏览器中，还需要解析、渲染HTML、CSS等相关渲染引擎，另外还需要提供支持浏览器操作的API、浏览器自己的事件循环等</p></li><li><p>另外，在Node.js中也需要进行一些额外的操作，比如文件系统读&#x2F;写、网络IO、加密、压缩解压文件等操作</p></li></ul><p>Node.js 和浏览器的差异：</p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230424132947218.png" alt="image-20230424132947218" style="zoom:50%;" /><p>单独的Node.js的架构图：</p><ul><li><p>JavaScript代码会经过V8引擎，再通过Node.js的Bindings，将任务放到Libuv的事件循环中</p></li><li><p>libuv（Unicorn Velociraptor—独角伶盗龙）是使用C语言编写的库</p></li><li><p>libuv 提供了事件循环、文件系统读写、网络IO、线程池等等内容</p></li></ul><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230424133049086.png" alt="image-20230424133049086" style="zoom:50%;" /><h3 id="2、Node-js-的应用场景"><a href="#2、Node-js-的应用场景" class="headerlink" title="2、Node.js 的应用场景"></a>2、Node.js 的应用场景</h3><p>应用一：目前前端开发的库都是以node包的形式进行管理</p><p>应用二：npm、yarn、pnpm工具成为前端开发使用最多的工具</p><p>应用三：越来越多的公司使用Node.js作为web服务器开发、中间件、代理服务器</p><p>应用四：大量项目需要借助Node.js完成前后端渲染的同构应用</p><p>应用五：资深前端工程师需要为项目编写脚本工具（前端工程师编写脚本通常会使用JavaScript，而不是Python或者shell）</p><p>应用六：很多企业在使用Electron来开发桌面应用程序</p><h3 id="3、Node-js-安装和管理"><a href="#3、Node-js-安装和管理" class="headerlink" title="3、Node.js 安装和管理"></a>3、Node.js 安装和管理</h3><p>Node.js是在2009年诞生的，版本分别是 LTS 以及 Current 18.4.0</p><ul><li><p>LTS版本：（Long-term support, 长期支持）相对稳定一些，推荐线上环境使用该版本</p></li><li><p>Current版本：最新的Node版本，包含很多新特性</p></li></ul><p>选择</p><ul><li><p>如果你是学习使用，可以选择current版本</p></li><li><p>如果你是公司开发，建议选择LTS版本（面向工作，选择LTS版本）</p></li></ul><p>Node的安装方式有很多：</p><ul><li><p>可以借助于一些操作系统上的软件管理工具，比如Mac上的homebrew，Linux上的yum、dnf等</p></li><li><p>也可以直接下载对应的安装包下载安装</p></li></ul><h4 id="1-下载安装"><a href="#1-下载安装" class="headerlink" title="1.下载安装"></a>1.下载安装</h4><ul><li><p>window选择.msi安装包，Mac选择.pkg安装包，Linux会在后续部署中讲解</p></li><li><p>安装过程中会配置环境变量（让我们可以在命令行使用）</p></li><li><p>并且会安装npm（Node Package Manager）工具</p></li></ul><h4 id="2-版本工具"><a href="#2-版本工具" class="headerlink" title="2.版本工具"></a>2.版本工具</h4><p>如果希望通过可以快速更新或切换多个版本时，可以借助于一些工具：</p><ul><li><p>nvm：Node Version Manager</p></li><li><p>n：Interactively Manage Your Node.js Versions（交互式管理你的Node.js版本）</p></li></ul><p>问题：这两个工具都不支持window</p><ul><li><p>n：n is not supported natively on Windows</p></li><li><p>nvm：nvm does not support Windows</p></li></ul><p>针对nvm，在GitHub上有提供对应的window版本：<a href="https://github.com/coreybutler/nvm-windows">https://github.com/coreybutler/nvm-windows</a></p><ul><li><p>通过 nvm install latest 安装最新的node版本</p></li><li><p>通过 nvm list 展示目前安装的所有版本</p></li><li><p>通过 nvm use 切换版本</p></li></ul><p>安装n：直接使用npm安装</p><ul><li><p>npm install -g n</p></li><li><p>n –version</p></li><li><p>安装最新的 lts 版本：n lts</p></li><li><p>前面添加的sudo是权限问题</p></li><li><p>可以两个版本都安装，之后我们可以通过n快速在两个版本间切换</p></li><li><p>安装最新的版本：n lastest</p></li><li><p>查看所有的版本：n</p></li></ul><h3 id="4、JavaScript-代码执行"><a href="#4、JavaScript-代码执行" class="headerlink" title="4、JavaScript 代码执行"></a>4、JavaScript 代码执行</h3><p>如果我们编写一个 js 文件，里面存放 JavaScript 代码，目前有两种方式可以执行：</p><ul><li><p>将代码交给浏览器执行</p></li><li><p>将代码载入到node环境中执行</p></li></ul><p>如果我们希望把代码交给浏览器执行</p><ul><li><p>需要通过让浏览器加载、解析html代码，所以我们需要创建一个html文件</p></li><li><p>在html中通过script标签，引入js文件</p></li><li><p>当浏览器遇到script标签时，就会根据src加载执行JavaScript代码</p></li></ul><p>如果希望把js文件交给node执行</p><ul><li><p>首先电脑上需要安装Node.js环境，安装过程中会自动配置环境变量</p></li><li><p>可以通过终端命令node js文件的方式来载入和执行对应的js文件</p></li></ul><h4 id="Node-的-REPL"><a href="#Node-的-REPL" class="headerlink" title="Node 的 REPL"></a>Node 的 REPL</h4><ul><li><p>REPL 是 Read-Eval-Print Loop的简称，翻译为“读取-求值-输出-循环”</p></li><li><p>REPL是一个简单的、交互式的编程环境</p></li><li><p>浏览器的console就可以看成一个REPL</p></li><li><p>Node也提供了一个REPL环境，可以在其中演练简单的代码</p></li></ul><h3 id="5、Node-的输入和输出"><a href="#5、Node-的输入和输出" class="headerlink" title="5、Node 的输入和输出"></a>5、Node 的输入和输出</h3><h4 id="1-node-的输入"><a href="#1-node-的输入" class="headerlink" title="1.node 的输入"></a>1.node 的输入</h4><p>正常情况下执行一个node程序，直接跟上对应的文件即可：node inde.js</p><p>但是，在某些情况下执行node程序的过程中，可能希望给node传递一些参数：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">node index.<span class="property">js</span> env=development coderwhy</span><br></pre></td></tr></table></figure><p>如果我们这样来使用程序，就意味着我们需要在程序中获取到传递的参数：</p><ul><li><p>获取参数其实是在process的内置对象中的</p></li><li><p>如果直接打印这个内置对象，它里面包含特别的信息：</p><ul><li>其他的一些信息，比如版本、操作系统等</li></ul></li></ul><p>其中的argv属性：</p><ul><li>它是一个数组，里面包含了我们需要的参数</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 给程序输入内容</span></span><br><span class="line"><span class="comment">// console.log(process.argv)</span></span><br><span class="line"><span class="keyword">const</span> arg1 = process.<span class="property">argv</span>[<span class="number">2</span>]</span><br><span class="line"><span class="keyword">const</span> arg2 = process.<span class="property">argv</span>[<span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>为什么叫argv</p><p>在C&#x2F;C++程序中的main函数中，实际上可以获取到两个参数：</p><ul><li><p>argc：argument counter的缩写，传递参数的个数</p></li><li><p>argv：argument vector（向量、矢量）的缩写，传入的具体参数</p><ul><li>vector翻译过来是矢量的意思，在程序中表示的是一种数据结构</li><li>在C++、Java中都有这种数据结构，是一种数组结构</li><li>在JavaScript中也是一个数组，里面存储一些参数信息</li></ul></li></ul><h4 id="2-node-的输出"><a href="#2-node-的输出" class="headerlink" title="2.node 的输出"></a>2.node 的输出</h4><p>console.log</p><ul><li>最常用的输入内容的方式：console.log</li></ul><p>console.clear</p><ul><li>清空控制台：console.clear</li></ul><p>console.trace</p><ul><li>打印函数的调用栈：console.trace</li></ul><p>其他的一些console方法：<a href="https://nodejs.org/dist/latest-v16.x/docs/api/console.html">https://nodejs.org/dist/latest-v16.x/docs/api/console.html</a></p><h3 id="6、Node-的全局对象"><a href="#6、Node-的全局对象" class="headerlink" title="6、Node 的全局对象"></a>6、Node 的全局对象</h3><p>类似于 window 的全局对象：global</p><h4 id="特殊的全局对象"><a href="#特殊的全局对象" class="headerlink" title="特殊的全局对象"></a>特殊的全局对象</h4><ul><li><p>这些全局对象实际上是模块中的变量，只是每个模块都有，看来像是全局变量</p></li><li><p>在命令行交互中是不可以使用的</p></li><li><p>包括：__dirname、__filename、exports、module、require()</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// __dirname当前文件所在的目录结构</span></span><br><span class="line"><span class="comment">// console.log(__dirname)</span></span><br><span class="line"><span class="comment">// __filename当前目录+文件名称</span></span><br><span class="line"><span class="comment">// console.log(__filename)</span></span><br></pre></td></tr></table></figure><h4 id="常见的全局对象"><a href="#常见的全局对象" class="headerlink" title="常见的全局对象"></a>常见的全局对象</h4><p>process对象：process提供了Node进程中相关的信息：</p><ul><li>比如Node的运行环境、参数信息等</li></ul><p>console对象：提供了简单的调试控制台，在前面讲解输入内容时已经学习过了</p><ul><li>更加详细的查看官网文档：<a href="https://nodejs.org/api/console.html">https://nodejs.org/api/console.html</a></li></ul><p>定时器函数：在Node中使用定时器有好几种方式：</p><ul><li><p>setTimeout(callback, delay[, …args])：callback在delay毫秒后执行一次</p></li><li><p>setInterval(callback, delay[, …args])：callback每delay毫秒重复执行一次</p></li><li><p>setImmediate(callback[, …args])：callbackI &#x2F; O事件后的回调的“立即”执行</p><ul><li>这里先不展开讨论它和setTimeout(callback, 0)之间的区别</li><li>它涉及到事件循环的阶段问题，后续详细讲解</li></ul></li></ul><p>pprocess.nextTick(callback[, …args])：添加到下一次tick队列中</p><h4 id="global对象"><a href="#global对象" class="headerlink" title="global对象"></a>global对象</h4><p>global是一个全局对象，事实上前面提到的process、console、setTimeout等都有被放到global中：</p><ul><li><p>之前讲过：在新的标准中还有一个globalThis，也是指向全局对象的</p></li><li><p>类似于浏览器中的window</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">在浏览器其中使用 <span class="variable language_">window</span>,node 中使用 <span class="variable language_">global</span>，可以统一使用 globalThis</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(globalThis === <span class="variable language_">global</span>)</span><br></pre></td></tr></table></figure><p>global 与 window 的区别</p><p>在浏览器中，全局变量都是在window上的，比如有document、setInterval、setTimeout、alert、console等等</p><p>在Node中，也有一个global属性，并且它里面有很多其他对象</p><ul><li><p>但是在浏览器中执行的JavaScript代码，如果在顶级范围内通过var定义的一个属性，默认会被添加到window对象上</p></li><li><p>但是在node中，通过var定义一个变量，它只是在当前模块中有一个变量，不会放到全局中</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;coderwhy&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">global</span>.<span class="property">name</span>)  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><h2 id="2-JavaScript-模块化开发"><a href="#2-JavaScript-模块化开发" class="headerlink" title="2.JavaScript 模块化开发"></a>2.JavaScript 模块化开发</h2><h3 id="1、认识模块化开发"><a href="#1、认识模块化开发" class="headerlink" title="1、认识模块化开发"></a>1、认识模块化开发</h3><h4 id="1-什么是模块化开发"><a href="#1-什么是模块化开发" class="headerlink" title="1.什么是模块化开发"></a>1.什么是模块化开发</h4><ul><li><p>事实上模块化开发最终的目的是将程序划分成一个个小的结构</p></li><li><p>这个结构中编写属于自己的逻辑代码，有自己的作用域，定义变量名词时不会影响到其他的结构</p></li><li><p>这个结构可以将自己希望暴露的变量、函数、对象等导出给其结构使用</p></li><li><p>也可以通过某种方式，导入另外结构中的变量、函数、对象等</p></li></ul><p>上面说提到的结构，就是模块；按照这种结构划分开发程序的过程，就是模块化开发的过程</p><h4 id="2-早期-JavaScript-的缺陷"><a href="#2-早期-JavaScript-的缺陷" class="headerlink" title="2.早期 JavaScript 的缺陷"></a>2.早期 JavaScript 的缺陷</h4><ul><li><p>比如var定义的变量作用域问题</p></li><li><p>比如JavaScript的面向对象并不能像常规面向对象语言一样使用class</p></li><li><p>比如JavaScript没有模块化的问题</p></li></ul><p>随着前端和JavaScript的快速发展，JavaScript代码变得越来越复杂</p><ul><li><p>ajax的出现，前后端开发分离，意味着后端返回数据后，需要通过JavaScript进行前端页面的渲染</p></li><li><p>SPA的出现，前端页面变得更加复杂：包括前端路由、状态管理等等一系列复杂的需求需要通过JavaScript来实现</p></li><li><p>包括Node的实现，JavaScript编写复杂的后端程序，没有模块化是致命的硬伤</p></li></ul><p>所以，模块化已经是JavaScript一个非常迫切的需求：</p><ul><li><p>但是JavaScript本身，直到ES6（2015）才推出了自己的模块化方案：ESModule</p></li><li><p>在此之前，为了让JavaScript支持模块化，涌现出了很多不同的模块化规范：AMD、CMD、CommonJS等</p></li></ul><h4 id="3-没有模块化带来的问题"><a href="#3-没有模块化带来的问题" class="headerlink" title="3.没有模块化带来的问题"></a>3.没有模块化带来的问题</h4><p>命名冲突的问题：使用立即函数调用表达式</p><p>新的问题：</p><ul><li><p>第一，必须记得每一个模块中返回对象的命名，才能在其他模块使用过程中正确的使用</p></li><li><p>第二，代码写起来混乱不堪，每个文件中的代码都需要包裹在一个匿名函数中来编写</p></li><li><p>第三，在没有合适的规范情况下，每个人、每个公司都可能会任意命名、甚至出现模块名称相同的情况</p></li></ul><p>所以，虽然实现了模块化，但是实现过于简单，并且是没有规范的</p><ul><li><p>需要制定一定的规范来约束每个人都按照这个规范去编写模块化的代码</p></li><li><p>这个规范中应该包括核心功能：模块本身可以导出暴露的属性，模块又可以导入自己需要的属性</p></li><li><p>JavaScript社区为了解决上面的问题，涌现出一系列好用的规范，接下来就学习具有代表性的一些规范</p></li></ul><h3 id="2、CommonJS和Node"><a href="#2、CommonJS和Node" class="headerlink" title="2、CommonJS和Node"></a>2、CommonJS和Node</h3><p>CommonJS是一个规范，最初提出来是在浏览器以外的地方使用，并且当时被命名为ServerJS，后来为了体现它的广泛性，修改为CommonJS，平时也会简称为CJS</p><ul><li><p>Node是CommonJS在服务器端一个具有代表性的实现</p></li><li><p>Browserify是CommonJS在浏览器中的一种实现</p></li><li><p>webpack打包工具具备对CommonJS的支持和转换</p></li></ul><p>Node中对CommonJS进行了支持和实现，使得在开发node的过程中可以方便的进行模块化开发</p><ul><li><p>在Node中每一个js文件都是一个单独的模块</p></li><li><p>这个模块中包括CommonJS规范的核心变量：exports、module.exports、require</p></li><li><p>可以使用这些变量来方便的进行模块化开发</p></li></ul><p>前面提到过模块化的核心是导出和导入，Node中对其进行了实现：</p><ul><li><p>exports和module.exports可以负责对模块中的内容进行导出</p></li><li><p>require函数可以帮助我们导入其他模块（自定义模块、系统模块、第三方库模块）中的内容</p></li></ul><h4 id="1-exports-导出（少用）"><a href="#1-exports-导出（少用）" class="headerlink" title="1.exports 导出（少用）"></a>1.exports 导出（少用）</h4><p>注意：exports是一个对象，我们可以在这个对象中添加很多个属性，添加的属性会导出</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">UTIL_NAME</span> = <span class="string">&quot;util_name&quot;</span></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">UTIL_NAME</span> = <span class="variable constant_">UTIL_NAME</span></span><br></pre></td></tr></table></figure><p>另外一个文件中可以导入</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> util = <span class="built_in">require</span>(<span class="string">&quot;./util.js&quot;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(util.<span class="property">UTIL_NAME</span>)</span><br></pre></td></tr></table></figure><p>完成了什么（require 的本质：引用赋值）？</p><ul><li><p>意味着 main 中的 bar 变量等于 exports 对象</p></li><li><p>也就是 require 通过各种查找方式，最终找到了 exports 这个对象</p></li><li><p>并且将这个 exports 对象赋值给了 bar 变量</p></li><li><p>bar 变量就是 exports 对象了</p></li></ul><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230501175035236.png" alt="image-20230501175035236" style="zoom: 33%;" /><h4 id="2-module-exports-导出"><a href="#2-module-exports-导出" class="headerlink" title="2.module.exports 导出"></a>2.module.exports 导出</h4><p>但是Node中经常导出东西的时候，又是通过module.exports导出的：</p><ul><li>module.exports和exports有什么关系或者区别呢？</li></ul><p>追根溯源，通过维基百科中对CommonJS规范的解析</p><ul><li><p>CommonJS中是没有module.exports的概念的</p></li><li><p>但是为了实现模块的导出，Node中使用的是Module的类，每一个模块都是Module的一个实例，也就是module</p></li><li><p>所以在Node中真正用于导出的其实根本不是exports，而是module.exports</p></li><li><p>因为module才是导出的真正实现者</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 结论：Node导出的本质是在导出module.exports对象</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>.<span class="property">name</span> = name</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>.<span class="property">age</span> = age</span><br></pre></td></tr></table></figure><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230501175130500.png" alt="image-20230501175130500" style="zoom:33%;" /><p>但是，为什么exports也可以导出呢？</p><ul><li><p>这是因为 module 对象的 exports 属性是 exports 对象的一个引用</p></li><li><p>也就是说 module.exports &#x3D; exports &#x3D; main 中的 bar</p></li></ul><h4 id="3-开发中常用写法"><a href="#3-开发中常用写法" class="headerlink" title="3.开发中常用写法"></a>3.开发中常用写法</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  name,</span><br><span class="line">  age,</span><br><span class="line">  sayHello</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// exports.name = &#x27;哈哈&#x27; // 无效了</span></span><br><span class="line"><span class="comment">// module.exports.name = &#x27;哈哈&#x27;  // 有效</span></span><br></pre></td></tr></table></figure><p>在这种写法中，就不再像上面两种方式（本质不同了）</p><p>上面两种方式实际是相同的，exports 对象指向的都是同一个内存地址（比如0x100），修改的都是这个对象中的属性</p><p>但是现在这种写法相当于添加了一个新的对象，exports 指向新的内存地址（比如0x200），就不再是原来的内存地址，通过 exports. 修改导出的属性不会生效了，需要通过 module.exports.X 才能找到正确的内存地址，才能对导出的数据进行修改</p><p>改变代码发生了什么？</p><p>1.在三者项目引用的情况下，修改 exports 中的 name 属性到底发生了什么？</p><p>2.在三者引用的情况下，修改了 main 中的 bar 的 name 属性，在 bar 模块中会发生什么？</p><p>3.如果 module.exports 不再引用 exports 对象了，那么修改 exports 还有意义吗？</p><h3 id="3、require函数解析"><a href="#3、require函数解析" class="headerlink" title="3、require函数解析"></a>3、require函数解析</h3><p>require是一个函数，可以帮助我们引入一个文件（模块）中导出的对象</p><p>require的查找规则，导入格式：require(X)</p><p>情况一：X是一个Node核心模块，比如path、http</p><ul><li>直接返回核心模块，并且停止查找</li></ul><p>情况二：X是以 .&#x2F; 或 ..&#x2F; 或 &#x2F;（根目录）开头的</p><ul><li><p>第一步：将X当做一个文件在对应的目录下查找</p><ul><li>1.如果有后缀名，按照后缀名的格式查找对应的文件</li><li>2.如果没有后缀名，会按照如下顺序：<ul><li>1&gt; 直接查找文件X</li><li>2&gt; 查找X.js文件</li><li>3&gt; 查找X.json文件</li><li>4&gt; 查找X.node文件</li></ul></li></ul></li><li><p>第二步：没有找到对应的文件，将X作为一个目录</p><ul><li>查找目录下面的index文件</li><li>1&gt; 查找X&#x2F;index.js文件</li><li>2&gt; 查找X&#x2F;index.json文件</li><li>3&gt; 查找X&#x2F;index.node文件</li></ul></li></ul><p>如果没有找到，那么报错：not found</p><p>情况三：直接是一个X（没有路径），并且X不是一个核心模块</p><ul><li><p>没有 node_modules 文件会往上层查找继续查找，找不到则报错</p></li><li><p>存在该文件，会在 node_modules 文件寻找对应的文件夹下的 index.js 文件</p></li></ul><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230501181302080.png" alt="image-20230501181302080" style="zoom:67%;" /><h4 id="模块的加载过程"><a href="#模块的加载过程" class="headerlink" title="模块的加载过程"></a>模块的加载过程</h4><p>结论一：模块在被第一次引入时，模块中的js代码会被运行一次</p><p>结论二：模块被多次引入时，会缓存，最终只加载（运行）一次</p><p>为什么只会加载运行一次呢？</p><ul><li><p>这是因为每个模块对象module都有一个属性：loaded</p></li><li><p>为false表示还没有加载，为true表示已经加载</p></li></ul><p>结论三：如果有循环引入，那么加载顺序是什么？</p><p>如果出现下图模块的引用关系，那么加载顺序是什么呢？</p><p>这个其实是一种数据结构：图结构</p><ul><li><p>图结构在遍历的过程中，有深度优先搜索（DFS, depth first search）和广度优先搜索（BFS, breadth first search）</p></li><li><p>Node采用的是深度优先算法：main -&gt; aaa -&gt; ccc -&gt; ddd -&gt; eee -&gt;bbb</p></li></ul><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230501180441881.png" alt="image-20230501180441881" style="zoom: 50%;" /><h3 id="4、AMD和CMD（了解）"><a href="#4、AMD和CMD（了解）" class="headerlink" title="4、AMD和CMD（了解）"></a>4、AMD和CMD（了解）</h3><h4 id="1-CommonJS规范缺点"><a href="#1-CommonJS规范缺点" class="headerlink" title="1.CommonJS规范缺点"></a>1.CommonJS规范缺点</h4><p>CommonJS加载模块是同步的：</p><ul><li><p>同步的意味着只有等到对应的模块加载完毕，当前模块中的内容才能被运行</p></li><li><p>这个在服务器不会有什么问题，因为服务器加载的js文件都是本地文件，加载速度非常快</p></li></ul><p>如果将它应用于浏览器</p><ul><li><p>浏览器加载js文件需要先从服务器将文件下载下来，之后再加载运行</p></li><li><p>那么采用同步的就意味着后续的js代码都无法正常运行，即使是一些简单的DOM操作</p></li></ul><p>所以在浏览器中，通常不使用CommonJS规范</p><ul><li><p>当然在webpack中使用CommonJS是另外一回事</p></li><li><p>因为它会将我们的代码转成浏览器可以直接执行的代码</p></li></ul><p>在早期为了可以在浏览器中使用模块化，通常会采用AMD或CMD</p><ul><li><p>但是目前一方面现代的浏览器已经支持ES Modules，另一方面借助于webpack等工具可以实现对CommonJS或者ES Module代码的转换</p></li><li><p>AMD和CMD已经使用非常少了</p></li></ul><h4 id="2-AMD-规范"><a href="#2-AMD-规范" class="headerlink" title="2.AMD 规范"></a>2.AMD 规范</h4><p>AMD主要是应用于浏览器的一种模块化规范：</p><ul><li><p>AMD是Asynchronous Module Definition（异步模块定义）的缩写</p></li><li><p>它采用的是异步加载模块</p></li><li><p>事实上AMD的规范还要早于CommonJS，但是CommonJS目前依然在被使用，而AMD使用的较少</p></li></ul><p>规范只是定义代码的应该如何去编写，只有有了具体的实现才能被应用：</p><ul><li>AMD实现的比较常用的库是require.js和curl.js</li></ul><p>require.js 的使用</p><ul><li><p>第一步：下载require.js</p><ul><li>下载地址：<a href="https://github.com/requirejs/requirejs">https://github.com/requirejs/requirejs</a></li><li>找到其中的require.js文件</li></ul></li><li><p>第二步：定义HTML的script标签引入require.js和定义入口文件</p><ul><li>data-main属性的作用是在加载完src的文件后会加载执行该文件</li></ul></li></ul><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230501181844399.png" alt="image-20230501181844399" style="zoom:67%;" /><h4 id="3-CMD-规范"><a href="#3-CMD-规范" class="headerlink" title="3.CMD 规范"></a>3.CMD 规范</h4><p>CMD规范也是应用于浏览器的一种模块化规范：</p><ul><li><p>CMD 是Common Module Definition（通用模块定义）的缩写</p></li><li><p>它也采用的也是异步加载模块，但是它将CommonJS的优点吸收了过来</p></li><li><p>但是目前CMD使用也非常少了</p></li></ul><p>CMD也有自己比较优秀的实现方案：SeaJS</p><p>SeaJS的使用</p><ul><li><p>第一步：下载SeaJS</p><ul><li>下载地址：<a href="https://github.com/seajs/seajs">https://github.com/seajs/seajs</a></li><li>找到dist文件夹下的sea.js</li></ul></li><li><p>第二步：引入sea.js和使用主入口文件</p><ul><li>seajs是指定主入口文件的</li></ul></li></ul><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230501182050054.png" alt="image-20230501182050054" style="zoom:67%;" /><h3 id="5、ESModule用法详解"><a href="#5、ESModule用法详解" class="headerlink" title="5、ESModule用法详解"></a>5、ESModule用法详解</h3><h4 id="1-前端使用模块化的方案"><a href="#1-前端使用模块化的方案" class="headerlink" title="1.前端使用模块化的方案"></a>1.前端使用模块化的方案</h4><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230507104204048.png" alt="image-20230507104204048" style="zoom:33%;" /><p>JavaScript没有模块化一直是它的痛点，所以才会产生我们前面学习的社区规范：CommonJS、AMD、CMD等，所以在ECMA推出自己的模块化系统时，大家也是兴奋异常</p><p>ES Module和CommonJS的模块化有一些不同之处：</p><ul><li><p>一方面它使用了import和export关键字</p></li><li><p>另一方面它采用编译期的静态分析，并且也加入了动态引用的方式</p></li></ul><p>ES Module模块采用export和import关键字来实现模块化</p><ul><li><p>export负责将模块内的内容导出</p></li><li><p>import负责从其他模块导入内容</p></li></ul><p>了解：采用ES Module将自动采用严格模式：use strict</p><h4 id="2-基本使用"><a href="#2-基本使用" class="headerlink" title="2.基本使用"></a>2.基本使用</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">引入js文件：</span><br><span class="line">&lt;!-- 注意：在我们打开对应的html时，如果html中有使用模块化的代码，必须通过开启本地服务打开 --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./foo.js&quot;</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./main.js&quot;</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>浏览器进行模块化编译需要使用特定的协议，默认打开html的话使用的是file协议，这个协议不支持模块化的加载解析。所以，直接在浏览器中运行代码会报错</p><p>这个在MDN上面有给出解释：</p><ul><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Modules">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Modules</a></p></li><li><p>需要注意本地测试 — 如果通过本地加载Html 文件 (比如一个 file:&#x2F;&#x2F; 路径的文件)，将会遇到 CORS 错误，因为Javascript 模块安全性需要</p></li><li><p>需要通过一个服务器来测试</p></li></ul><p>使用的VSCode插件：Live Server</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">导入导出：</span><br><span class="line">导出</span><br><span class="line"><span class="comment">// 导出的 &#123;&#125; 不是对象了，是特殊的语法</span></span><br><span class="line"><span class="comment">// export &#123; 标识符1, 标识符2, 标识符3 &#125;</span></span><br><span class="line"><span class="keyword">export</span> &#123; name, age, sayHello &#125;</span><br><span class="line">导入</span><br><span class="line"><span class="comment">// 导入 import</span></span><br><span class="line"><span class="comment">// 注意：在浏览器中使用esmodule时，必须在文件后面添加 .js 后缀名</span></span><br><span class="line"><span class="keyword">import</span> &#123; name, age, sayHello &#125; <span class="keyword">from</span> <span class="string">&quot;./foo.js&quot;</span></span><br></pre></td></tr></table></figure><p>问题：在导入的模块如果还是用name的话是不允许的，它已经被定义了，那导入模块怎么定义name</p><h4 id="3-export-关键字"><a href="#3-export-关键字" class="headerlink" title="3.export 关键字"></a>3.export 关键字</h4><p>export 关键字将一个模块中的变量、函数、类等导出</p><p>希望将其他中内容全部导出，它可以有如下的方式</p><ul><li><p>方式一：在语句声明的前面直接加上export关键字</p></li><li><p>方式二：将所有需要导出的标识符，放到export后面的 {}中</p><ul><li>注意：这里的 {}里面不是ES6的对象字面量的增强写法，{}也不是表示一个对象的</li><li>所以： export {name: name}，是错误的写法</li></ul></li><li><p>方式三：导出时给标识符起一个别名</p><ul><li>通过as关键字起别名</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导出方式1：</span></span><br><span class="line"><span class="comment">// export &#123; name, age, sayHello &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出方式2：导出时给我们的标识符起别名 as 关键字</span></span><br><span class="line"><span class="comment">// export &#123;</span></span><br><span class="line"><span class="comment">//   name as fname,</span></span><br><span class="line"><span class="comment">//   age,</span></span><br><span class="line"><span class="comment">//   sayHello</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出方式3：不能起别名</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> name = <span class="string">&quot;why&quot;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> age = <span class="number">18</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">sayHello</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;sayhello&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="4-import-关键字"><a href="#4-import-关键字" class="headerlink" title="4.import 关键字"></a>4.import 关键字</h4><p>import关键字负责从另外一个模块中导入内容</p><p>导入内容的方式也有多种</p><ul><li><p>方式一：import {标识符列表} from ‘模块’</p><ul><li>注意：这里的{}也不是一个对象，里面只是存放导入的标识符列表内容</li></ul></li><li><p>方式二：导入时给标识符起别名</p><ul><li>通过as关键字起别名</li></ul></li><li><p>方式三：通过 * 将模块功能放到一个模块功能对象（a module object）上</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入方式1:import</span></span><br><span class="line"><span class="keyword">import</span> &#123; name, age, sayHello &#125; <span class="keyword">from</span> <span class="string">&quot;./foo.js&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入方式2：导入时给我们的标识符起别名</span></span><br><span class="line"><span class="comment">// import &#123; name as fname, age, sayHello&#125; from &quot;./foo.js&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入方式3：导入时可以给整个模块起别名</span></span><br><span class="line"><span class="comment">// import * as foo from &quot;./foo.js&quot;</span></span><br><span class="line"><span class="comment">// console.log(foo.name)</span></span><br><span class="line"><span class="comment">// console.log(foo.age)</span></span><br><span class="line"><span class="comment">// foo.sayHello()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const name = &#x27;dws&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name)</span><br><span class="line"><span class="comment">// console.log(fname)</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(age)</span><br><span class="line"><span class="title function_">sayHello</span>()</span><br></pre></td></tr></table></figure><p>通过别名就可以在自己模块定义自己的 name</p><h4 id="5-export-与-import-结合使用"><a href="#5-export-与-import-结合使用" class="headerlink" title="5.export 与 import 结合使用"></a>5.export 与 import 结合使用</h4><p>补充：export和import可以结合使用</p><p>为什么要这样做</p><ul><li><p>在开发和封装一个功能库时，通常希望将暴露的所有接口放到一个文件中</p></li><li><p>这样方便指定统一的接口规范，也方便阅读</p></li><li><p>这个时候就可以使用export和import结合使用</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认在工具文件夹中新建index.js文件，将别的工具函数都进行导出</span></span><br><span class="line"><span class="comment">// 在index中进行导入，再导出</span></span><br><span class="line"><span class="comment">// 在使用时就直接从index中进行导入使用即可</span></span><br><span class="line"><span class="number">1.</span>默认导入导出</span><br><span class="line"><span class="comment">// import &#123; formatCount, formatData&#125; from &quot;./format&quot;</span></span><br><span class="line"><span class="comment">// import &#123; parseLyric &#125; from &quot;./parse&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// export &#123;</span></span><br><span class="line"><span class="comment">//   formatCount,</span></span><br><span class="line"><span class="comment">//   formatData,</span></span><br><span class="line"><span class="comment">//   parseLyric</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">优化<span class="number">1</span>：</span><br><span class="line"><span class="comment">// export &#123; formatCount, formatData &#125; from &quot;./format.js&quot;</span></span><br><span class="line"><span class="comment">// export &#123; parseLyric &#125; from &quot;./parse.js&quot;</span></span><br><span class="line"></span><br><span class="line">优化<span class="number">2</span>：</span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">&quot;./format.js&quot;</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">&quot;./parse.js&quot;</span></span><br><span class="line"></span><br><span class="line">使用时导入：</span><br><span class="line"><span class="keyword">import</span> &#123; formatCount, formatData, parseLyric &#125; <span class="keyword">from</span> <span class="string">&quot;./utils/index.js&quot;</span></span><br></pre></td></tr></table></figure><h4 id="6-default-用法"><a href="#6-default-用法" class="headerlink" title="6.default 用法"></a>6.default 用法</h4><p>前面我们学习的导出功能都是有名字的导出（named exports）</p><ul><li><p>在导出 export 时指定了名字</p></li><li><p>在导入 import 时需要知道具体的名字</p></li></ul><p>还有一种导出叫做默认导出（default export）</p><ul><li><p>默认导出 export 时可以不需要指定名字</p></li><li><p>在导入时不需要使用 {}，并且可以自己来指定名字</p></li><li><p>它也方便我们和现有的 CommonJS 等规范相互操作</p></li></ul><p>注意：在一个模块中，只能有一个默认导出（default export）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.1</span> 定义函数</span><br><span class="line"><span class="number">1.2</span> 默认导出定义的函数：</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> parseLyric</span><br><span class="line"><span class="number">2.</span>定义标识符直接作为默认导出</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="string">&quot;新的歌词&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注意事项：一个模块只能有一个默认导出</span></span><br><span class="line"></span><br><span class="line">对于默认导出使用默认导入：</span><br><span class="line"><span class="comment">// import &#123; parseLyric &#125; from &quot;./parseLyric.js&quot;;</span></span><br><span class="line">定义标识符直接默认导出的导入：</span><br><span class="line"><span class="comment">// 引用所使用的标识符是随便取的 parseLyric 这里是可以自己随便定义的，可以取为aaa</span></span><br><span class="line"><span class="keyword">import</span> aaa <span class="keyword">from</span> <span class="string">&quot;./parseLyric.js&quot;</span></span><br></pre></td></tr></table></figure><h4 id="7-import-函数、import-meta"><a href="#7-import-函数、import-meta" class="headerlink" title="7. import 函数、import meta"></a>7. import 函数、import meta</h4><p>通过import加载一个模块，是不可以在其放到逻辑代码中的，比如</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> flag = <span class="literal">true</span></span><br><span class="line"><span class="keyword">if</span>(flag) &#123;</span><br><span class="line">  <span class="comment">// 不允许在逻辑代码中编写import导入语法，只能写到js代码顶层</span></span><br><span class="line">  <span class="keyword">import</span> &#123; name, age, sayHello &#125; <span class="keyword">from</span> <span class="string">&quot;./foo.js&quot;</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(name,age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原因：</p><ul><li><p>这是因为ES Module在被JS引擎解析时，就必须知道它的依赖关系</p></li><li><p>由于这个时候js代码没有任何的运行，所以无法在进行类似于if判断中根据代码的执行情况</p></li><li><p>甚至拼接路径的写法也是错误的：因为我们必须到运行时能确定path的值</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不允许拼接路径</span></span><br><span class="line"><span class="comment">// import &#123; name, age, sayHello&#125; from (&quot;./foo&quot; + &quot;.js&quot;)</span></span><br></pre></td></tr></table></figure><p>但是某些情况下，确实希望动态的来加载某一个模块：</p><ul><li><p>如果根据不同的条件，动态来选择加载模块的路径</p></li><li><p>这个时候我们需要使用 import() 函数来动态加载</p><ul><li>import函数返回一个Promise，可以通过then获取结果</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> flag = <span class="literal">true</span></span><br><span class="line"><span class="keyword">if</span>(flag) &#123;</span><br><span class="line">  <span class="comment">// 如果确实是某些逻辑成立时，才需要导入某个模块</span></span><br><span class="line">  <span class="comment">// import 函数 返回值是一个Promise</span></span><br><span class="line">  <span class="keyword">const</span> importPromise = <span class="keyword">import</span>(<span class="string">&quot;./foo.js&quot;</span>)</span><br><span class="line">  importPromise.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res.<span class="property">name</span>, res.<span class="property">age</span>, res.<span class="title function_">sayHello</span>())</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// import(&quot;./foo.js&quot;).then( res =&gt; &#123;</span></span><br><span class="line">    <span class="comment">// console.log(res.name, res.age, res.sayHello())</span></span><br><span class="line">  <span class="comment">// &#125;)</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;==========&quot;</span>)</span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><p>import.meta是一个给JavaScript模块暴露特定上下文的元数据属性的对象</p><ul><li><p>它包含了这个模块的信息，比如说这个模块的URL</p></li><li><p>在ES11（ES2020）中新增的特性</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">在模块中：</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">import</span>.<span class="property">meta</span>)</span><br><span class="line"><span class="comment">// &#123;url: &#x27;http://127.0.0.1:5500/02-%E5%89%8D%E7%AB%AF%E6%A8%…%E5%8C%96%E5%BC%80%E5%8F%91/10-ESModule-05/foo.js&#x27;, resolve: ƒ&#125;</span></span><br></pre></td></tr></table></figure><h3 id="6、ESModule运行原理"><a href="#6、ESModule运行原理" class="headerlink" title="6、ESModule运行原理"></a>6、ESModule运行原理</h3><p>ES Module 是如何被浏览器解析并且让模块之间可以相互引用的</p><ul><li><a href="https://hacks.mozilla.org/2018/03/es-modules-a-cartoon-deep-dive/">https://hacks.mozilla.org/2018/03/es-modules-a-cartoon-deep-dive/</a></li></ul><p>ES Module的解析过程可以划分为三个阶段：</p><ul><li><p>阶段一：构建（Construction），根据地址查找js文件，并且下载，将其解析成模块记录（Module Record）</p></li><li><p>阶段二：实例化（Instantiation），对模块记录进行实例化，并且分配内存空间，解析模块的导入和导出语句，把模块指向对应的内存地址</p></li><li><p>阶段三：运行（Evaluation），运行代码，计算值，并且将值填充到内存地址中</p></li></ul><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230507104455586.png" alt="image-20230507104455586" style="zoom:50%;" /><p>完整流程</p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230507104522375.png" alt="image-20230507104522375" style="zoom:33%;" /><p>详细流程</p><ul><li>构建阶段</li></ul><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230507104606931.png" alt="image-20230507104606931" style="zoom:33%;" /><ul><li>实例化阶段—求值阶段</li></ul><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230507104654591.png" alt="image-20230507104654591" style="zoom: 25%;" /><h2 id="3-包管理工具详解"><a href="#3-包管理工具详解" class="headerlink" title="3.包管理工具详解"></a>3.包管理工具详解</h2><p>了解代码共享方案</p><p>已经学习了在JavaScript中可以通过模块化的方式将代码划分成一个个小的结构：</p><ul><li><p>在以后的开发中就可以通过模块化的方式来封装自己的代码，并且封装成一个工具</p></li><li><p>这个工具可以让同事通过导入的方式来使用，甚至可以分享给世界各地的程序员来使用</p></li></ul><p>如果分享给所有的程序员使用，有哪些方式</p><ul><li>方式一：上传到GitHub上、其他程序员通过GitHub下载我们的代码手动的引用<ul><li>缺点是大家必须知道你的代码GitHub的地址，并且从GitHub上手动下载</li><li>需要在自己的项目中手动的引用，并且管理相关的依赖</li><li>不需要使用的时候，需要手动来删除相关的依赖</li><li>当遇到版本升级或者切换时，需要重复上面的操作</li></ul></li></ul><p>显然，上面的方式是有效的，但是这种传统的方式非常麻烦，并且容易出错</p><ul><li>方式二：使用一个专业的工具来管理我们的代码<ul><li>通过工具将代码发布到特定的位置</li><li>其他程序员直接通过工具来安装、升级、删除我们的工具代码</li></ul></li></ul><p>通过第二种方式可以更好的管理自己的工具包，其他人也可以更好的使用我们的工具包</p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230507095403415.png" alt="image-20230507095403415" style="zoom: 33%;" /><h3 id="1、npm-包管理工具"><a href="#1、npm-包管理工具" class="headerlink" title="1、npm 包管理工具"></a>1、npm 包管理工具</h3><p>包管理工具npm</p><ul><li>Node Package Manager，也就是Node包管理器</li><li>但是目前已经不仅仅是Node包管理器了，在前端项目中我们也在使用它来管理依赖的包</li><li>比如vue、vue-router、vuex、express、koa、react、react-dom、axios、babel、webpack等</li></ul><p>下载和安装npm工具</p><ul><li>npm属于node的一个管理工具，所以需要先安装Node</li><li>node管理工具：<a href="https://nodejs.org/en/%EF%BC%8C%E5%AE%89%E8%A3%85Node%E7%9A%84%E8%BF%87%E7%A8%8B%E4%BC%9A%E8%87%AA%E5%8A%A8%E5%AE%89%E8%A3%85npm%E5%B7%A5%E5%85%B7">https://nodejs.org/en/，安装Node的过程会自动安装npm工具</a></li></ul><p>npm管理的包可以在哪里查看、搜索</p><ul><li>安装相关的npm包的官网：<a href="https://www.npmjs.org/">https://www.npmjs.org/</a></li></ul><p>npm管理的包存放在哪里</p><ul><li><p>我们发布自己的包其实是发布到 registry 上面的</p></li><li><p>当我们安装一个包时其实是从 registry 上面下载的包</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">安装对应的库：npm install dayjs</span><br><span class="line"><span class="comment">// 使用：</span></span><br><span class="line"><span class="keyword">const</span> dayjs = <span class="built_in">require</span>(<span class="string">&quot;dayjs&quot;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">dayjs</span>())</span><br></pre></td></tr></table></figure><h3 id="2、package-配置文件"><a href="#2、package-配置文件" class="headerlink" title="2、package 配置文件"></a>2、package 配置文件</h3><p>对于一个项目来说，如何使用npm来管理这么多包</p><ul><li><p>事实上，每一个项目都会有一个对应的配置文件，无论是前端项目（Vue、React）还是后端项目（Node）</p></li><li><p>这个配置文件会记录着项目的名称、版本号、项目描述等</p></li><li><p>也会记录着项目所依赖的其他库的信息和依赖库的版本号</p></li><li><p>这个配置文件就是package.json</p></li></ul><p>如何得到这个配置文件</p><ul><li>方式一：手动从零创建项目，npm init –y（-y 表示所有的选项都默认为 yes）</li><li>方式二：通过脚手架创建项目，脚手架会帮助我们生成package.json，并且里面有相关的配置</li></ul><h4 id="1-常见的属性"><a href="#1-常见的属性" class="headerlink" title="1.常见的属性"></a>1.常见的属性</h4><p>必须填写的属性：name、version</p><ul><li>name是项目的名称</li><li>version是当前项目的版本号</li><li>description是描述信息，很多时候是作为项目的基本描述</li><li>author是作者相关信息（发布时用到）</li><li>license是开源协议（发布时用到）</li></ul><p>private属性：</p><ul><li>private属性记录当前的项目是否是私有的</li><li>当值为true时，npm是不能发布它的，这是防止私有项目或模块发布出去的方式</li></ul><p>main属性：</p><ul><li>设置程序的入口<ul><li>比如我们使用axios模块 const axios &#x3D; require(‘axios’)</li><li>如果有main属性，实际上是找到对应的main属性查找文件的</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;main&quot;</span>: <span class="string">&quot;index.js&quot;</span>,</span><br></pre></td></tr></table></figure><p>scripts属性：</p><ul><li><p>scripts属性用于配置一些脚本命令，以键值对的形式存在</p></li><li><p>配置后可以通过 npm run 命令的key来执行这个命令</p></li><li><p>npm start和npm run start的区别是什么</p><ul><li>它们是等价的</li><li>对于常用的 start、 test、stop、restart可以省略掉run直接通过 npm start等方式运行</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;start&quot;</span>: <span class="string">&quot;node ./src/main.js&quot;</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>dependencies属性：</p><ul><li>dependencies属性是指定无论开发环境还是生成环境都需要依赖的包</li><li>通常是我们项目实际开发用到的一些库模块vue、vuex、vue-router、react、react-dom、axios等等</li><li>与之对应的是devDependencies</li><li>在给别人发送自己的代码时，就不需要加上 node_modules 文件夹，可以直接在这查看所需的依赖来进行安装，或者直接 npm install 即可自己安装对应的依赖</li></ul><p>devDependencies属性（开发依赖）：</p><ul><li>一些包在生成环境是不需要的，比如webpack、babel等</li><li>这个时候我们会通过 npm install webpack –save-dev，将它安装到devDependencies属性中</li><li>npm install xxx –save-dev 等价于 npm install xxx -D</li></ul><p>peerDependencies属性：</p><ul><li>还有一种项目依赖关系是对等依赖，也就是你依赖的一个包，它必须是以另外一个宿主包为前提的</li><li>比如element-plus是依赖于vue3的，ant design是依赖于react、react-dom</li></ul><p>engines属性：</p><ul><li><p>engines属性用于指定Node和NPM的版本号</p></li><li><p>在安装的过程中，会先检查对应的引擎版本，如果不符合就会报错</p></li><li><p>事实上也可以指定所在的操作系统 “os” : [ “darwin”, “linux” ]，只是很少用到</p></li></ul><p>browserslist属性：</p><ul><li>用于配置打包后的JavaScript浏览器的兼容情况，参考</li><li>否则我们需要手动的添加polyfills来让支持某些语法</li><li>也就是说它是为webpack等打包工具服务的一个属性</li></ul><h4 id="2-依赖的版本管理"><a href="#2-依赖的版本管理" class="headerlink" title="2.依赖的版本管理"></a>2.依赖的版本管理</h4><p>我们会发现安装的依赖版本出现：^2.0.3或~2.0.3，这是什么意思</p><p>npm的包通常需要遵从semver版本规范：</p><ul><li>semver：<a href="https://semver.org/lang/zh-CN/">https://semver.org/lang/zh-CN/</a></li><li>npm semver：<a href="https://www.npmjs.cn/misc/semver/">https://www.npmjs.cn/misc/semver/</a></li></ul><p>semver版本规范是X.Y.Z：</p><ul><li>X主版本号（major）：当你做了不兼容的 API 修改（可能不兼容之前的版本）</li><li>Y次版本号（minor）：当你做了向下兼容的功能性新增（新功能增加，但是兼容之前的版本）</li><li>Z修订号（patch）：当你做了向下兼容的问题修正（没有新功能，修复了之前版本的bug）</li></ul><p>^和~的区别：</p><ul><li>x.y.z：表示一个明确的版本号</li><li>^x.y.z：表示x是保持不变的，y和z永远安装最新的版本</li><li>~x.y.z：表示x和y保持不变的，z永远安装最新的版本</li></ul><h3 id="3、npm-install-原理"><a href="#3、npm-install-原理" class="headerlink" title="3、npm install 原理"></a>3、npm install 原理</h3><h4 id="1-npm-install-命令"><a href="#1-npm-install-命令" class="headerlink" title="1.npm install 命令"></a>1.npm install 命令</h4><p>安装npm包分两种情况：</p><ul><li>全局安装（global install）： npm install webpack -g</li><li>项目（局部）安装（local install）： npm install webpack</li></ul><p>全局安装</p><ul><li>全局安装是直接将某个包安装到全局</li><li>比如全局安装yarn</li></ul><p>但是很多人对全局安装有一些误会</p><ul><li>通常使用npm全局安装的包都是一些工具包：yarn、webpack等</li><li>并不是类似于 axios、express、koa等库文件</li><li>所以全局安装了之后并不能让我们在所有的项目中使用 axios 等库</li></ul><h4 id="2-项目安装"><a href="#2-项目安装" class="headerlink" title="2.项目安装"></a>2.项目安装</h4><p>项目安装会在当前目录下生成一个 node_modules 文件夹，之前讲解require查找顺序时有讲解过这个包在什么情况下被查找</p><p>局部安装分为开发时依赖和生产时依赖</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">项目安装</span><br><span class="line"># 默认安装开发和生产依赖</span><br><span class="line">npm install axios</span><br><span class="line">npm i axios</span><br><span class="line"># 开发依赖</span><br><span class="line">npm install webpack --save-dev</span><br><span class="line">npm install webpack -D</span><br><span class="line">npm i webpack –D</span><br><span class="line"># 根据package.<span class="property">json</span>中的依赖包</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><h4 id="3-npm-install-原理"><a href="#3-npm-install-原理" class="headerlink" title="3.npm install 原理"></a>3.npm install 原理</h4><p>执行 npm install 它背后帮助我们完成了什么操作？</p><p>我们会发现还有一个称之为 package-lock.json 的文件，它的作用是什么？</p><p>从 npm5 开始，npm 支持缓存策略（来自 yarn 的压力），缓存有什么作用呢？</p><p>npm install 原理图：</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230507152924931.png" alt="image-20230507152924931"></p><p>原理图解析：</p><p>npm install会检测是有package-lock.json文件：</p><ul><li><p>没有lock文件 </p><ul><li>分析依赖关系，这是因为我们可能包会依赖其他的包，并且多个包之间会产生相同依赖的情况</li><li>从registry仓库中下载压缩包（如果设置了镜像，那么会从镜像服务器下载压缩包）</li><li>获取到压缩包后会对压缩包进行缓存（从npm5开始有的）</li><li>将压缩包解压到项目的node_modules文件夹中（require的查找顺序会在该包下面查找）</li></ul></li><li><p>有lock文件</p><ul><li><p>检测lock中包的版本是否和package.json中一致（会按照semver版本规范检测）</p><ul><li>不一致，那么会重新构建依赖关系，直接会走顶层的流程</li></ul></li><li><p>一致的情况下，会去优先查找缓存</p><ul><li>没有找到，会从registry仓库下载，直接走顶层流程</li></ul></li><li><p>查找到，会获取缓存中的压缩文件，并且将压缩文件解压到node_modules文件夹中</p></li></ul></li></ul><h4 id="4-package-lock-json"><a href="#4-package-lock-json" class="headerlink" title="4.package-lock.json"></a>4.package-lock.json</h4><p>package-lock.json文件解析： </p><ul><li><p>name：项目的名称</p></li><li><p>version：项目的版本</p></li><li><p>lockfileVersion：lock文件的版本</p></li><li><p>requires：使用requires来跟踪模块的依赖关系</p></li><li><p>dependencies：项目的依赖</p><ul><li><p>当前项目依赖axios，但是axios依赖follow-redireacts</p></li><li><p>axios中的属性如下：</p><ul><li>version 表示实际安装的 axios 的版本</li><li>resolved 用来记录下载的地址，registry 仓库中的位置</li><li>requires&#x2F;dependencies 记录当前模块的依赖</li><li>integrity 用来从缓存中获取索引，再通过索引去获取压缩包文件</li></ul></li></ul></li></ul><h4 id="5-npm-其他命令"><a href="#5-npm-其他命令" class="headerlink" title="5.npm 其他命令"></a>5.npm 其他命令</h4><p>卸载某个依赖包：</p><ul><li><p>npm uninstall package</p></li><li><p>npm uninstall package –save-dev</p></li><li><p>npm uninstall package -D</p></li></ul><p>强制重新build：npm rebuild</p><p>查看缓存所在文件：npm config get cache</p><p>清除缓存：npm cache clean</p><p>npm的命令官网：</p><ul><li><a href="https://docs.npmjs.com/cli-documentation/cli">https://docs.npmjs.com/cli-documentation/cli</a></li></ul><h3 id="4、yarn、cnpm、npx"><a href="#4、yarn、cnpm、npx" class="headerlink" title="4、yarn、cnpm、npx"></a>4、yarn、cnpm、npx</h3><h4 id="1-yarn-工具"><a href="#1-yarn-工具" class="headerlink" title="1.yarn 工具"></a>1.yarn 工具</h4><p>另一个node包管理工具yarn</p><ul><li>yarn是由Facebook、Google、Exponent 和 Tilde 联合推出了一个新的 JS 包管理工具</li><li>yarn 是为了弥补 早期npm 的一些缺陷而出现的</li><li>早期的npm存在很多的缺陷，比如安装依赖速度很慢、版本依赖混乱等等一系列的问题</li><li>虽然从npm5版本开始，进行了很多的升级和改进，但是依然很多人喜欢使用yarn</li></ul><p>安装 yarn：npm install yarn -g</p><p>使用差异：</p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230507155916441.png" alt="image-20230507155916441" style="zoom: 80%;" /><h4 id="2-cnpm-工具"><a href="#2-cnpm-工具" class="headerlink" title="2.cnpm 工具"></a>2.cnpm 工具</h4><p>由于一些特殊的原因，某些情况下没办法很好的从 <a href="https://registry.npmjs.org下载一些需要的包/">https://registry.npmjs.org下载一些需要的包</a></p><p>查看npm镜像：</p><ul><li>npm config get registry</li></ul><p>可以直接设置npm的镜像：</p><ul><li>npm config set registry <a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a></li></ul><p>但是对于大多数人来说并不希望将 npm 镜像修改了</p><ul><li><p>第一，不太希望随意修改 npm 原本从官方下来包的渠道</p></li><li><p>第二，担心某天淘宝的镜像挂了或者不维护了，又要改来改去</p></li></ul><p>这个时候，可以使用 cnpm，并且将 cnpm 设置为淘宝的镜像：</p><ul><li><p>npm install -g cnpm –registry&#x3D;<a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a> </p></li><li><p>cnpm config get registry</p></li></ul><p>镜像服务器的作用：</p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230507162508281.png" alt="image-20230507162508281" style="zoom: 33%;" /><h4 id="3-npx-工具"><a href="#3-npx-工具" class="headerlink" title="3.npx 工具"></a>3.npx 工具</h4><p>npx是npm5.2之后自带的一个命令</p><ul><li>npx的作用非常多，但是比较常见的是使用它来调用项目中的某个模块的指令</li></ul><p>以webpack为例：</p><ul><li>全局安装的是 webpack5.1.3</li><li>项目安装的是 webpack3.6.0</li></ul><p>如果在终端执行 webpack –version使用的是哪一个命令呢？</p><ul><li>显示结果会是 webpack 5.1.3，事实上使用的是全局的，为什么呢？</li><li>原因非常简单，在当前目录下找不到 webpack 时，就会去全局找，并且执行命令</li></ul><p>当前版本现象：</p><ul><li>使用 cmd 查看 webpack –version 显示的是：全局版本</li><li>在当前项目指定安装的 webpack 查看：当前项目安装的版本</li><li>npx 似乎被集成了</li><li>而早期的时候直接使用 webpack –version 查找当前项目安装的版本时是查找不到的，必须进入当前 node_modules 文件才能查找到</li><li>后面就可以使用 npx 直接查找到 webpack 版本</li></ul><p>出现不同结果原因：</p><ul><li>webpack 包比较特殊</li><li>使用 babel&#x2F;yarn 测试是没有问题的，先在该文件目录下查找，没有则使用全局的</li></ul><p>局部命令的执行</p><p>使用项目（局部）的webpack，常见的是两种方式：</p><ul><li>方式一：明确查找到node_module下面的webpack</li><li>方式二：在 scripts定义脚本，来执行webpack</li></ul><p>方式一：在终端中使用如下命令（在项目根目录下）</p><ul><li>.&#x2F;node_modules&#x2F;.bin&#x2F;webpack –version</li></ul><p>方式二：修改package.json中的scripts</p><ul><li>“scripts”: { “webpack”: “webpack –version” }</li></ul><p>方式三：使用 npx</p><ul><li>npx webpack –version</li></ul><p>npx的原理非常简单，它会到当前目录的node_modules&#x2F;.bin目录下查找对应的命令</p><h3 id="5、发布自己的开发包"><a href="#5、发布自己的开发包" class="headerlink" title="5、发布自己的开发包"></a>5、发布自己的开发包</h3><p>注册npm账号：<a href="https://www.npmjs.com/">https://www.npmjs.com/</a></p><p>在命令行登录：npm login</p><p>修改package.json</p><p>发布到npm registry上：npm publish</p><p>更新仓库：</p><ul><li>1.修改版本号(最好符合semver规范)</li><li>2.重新发布</li></ul><p>删除发布的包：npm unpublish</p><p>让发布的包过期：npm deprecate</p><p>注意：使用命令行登录会跳转到网页，是因为npm的源的问题，需要进行修改，也有可能是node版本的问题(网上有说)</p><h3 id="6、pnpm-使用和原理"><a href="#6、pnpm-使用和原理" class="headerlink" title="6、pnpm 使用和原理"></a>6、pnpm 使用和原理</h3><h4 id="1-什么是-pnpm"><a href="#1-什么是-pnpm" class="headerlink" title="1.什么是 pnpm"></a>1.什么是 pnpm</h4><p>pnpm：可以理解成是performant npm缩写</p><p>特点：</p><ul><li>快速：pnpm 比其它包管理器快两倍</li><li>高效：node_modules 中的文件链接自特定的内容寻址存储库</li><li>支持 monorepos：pnpm 内置支持单仓多包</li><li>严格：pnpm 默认创建了一个非平铺的 node_modules，因此代码无法访问任意包</li></ul><p>包括Vue在内的很多公司或者开源项目的包管理工具都切换到了pnpm</p><h4 id="2-硬链接和软连接的概念"><a href="#2-硬链接和软连接的概念" class="headerlink" title="2.硬链接和软连接的概念"></a>2.硬链接和软连接的概念</h4><p>硬链接（hard link）</p><ul><li><p>硬链接（英语：hard link）是电脑文件系统中的多个文件平等地共享同一个文件存储单元</p></li><li><p>删除一个文件名字后，还可以用其它名字继续访问该文件</p></li></ul><p>符号链接（软链接soft link、Symbolic link）</p><ul><li><p>符号链接（软链接、Symbolic link）是一类特殊的文件</p></li><li><p>其包含有一条以绝对路径或者相对路径的形式指向其它文件或者目录的引用</p></li></ul><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230508095118780.png" alt="image-20230508095118780"></p><h4 id="3-硬链接和软连接的使用"><a href="#3-硬链接和软连接的使用" class="headerlink" title="3.硬链接和软连接的使用"></a>3.硬链接和软连接的使用</h4><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230508141006516.png" alt="image-20230508141006516" style="zoom:67%;" /><h4 id="4-pnpm的作用"><a href="#4-pnpm的作用" class="headerlink" title="4.pnpm的作用"></a>4.pnpm的作用</h4><p>当使用 npm 或 Yarn 时，如果有 100 个项目，并且所有项目都有一个相同的依赖包，那么，在硬盘上就需要保存 100 份该相同依赖包的副本</p><p>如果是使用 pnpm，依赖包将被 存放在一个统一的位置，因此：</p><ul><li>如果你对同一依赖包使用相同的版本，那么磁盘上只有这个依赖包的一份文件</li><li>如果你对同一依赖包需要使用不同的版本，则仅有 版本之间不同的文件会被存储起来</li><li>所有文件都保存在硬盘上的统一的位置：<ul><li>当安装软件包时， 其包含的所有文件都会硬链接到此位置，而不会占用额外的硬盘空间</li><li>这让你可以在项目之间方便地共享相同版本的依赖包</li></ul></li></ul><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230508141033817.png" alt="image-20230508141033817" style="zoom: 67%;" /><p>当使用 npm 或 Yarn Classic 安装依赖包时，所有软件包都将被提升到 node_modules 的 根目录下</p><ul><li>其结果是，源码可以访问本不属于当前项目所设定的依赖包</li></ul><p>pnpm 创建非扁平化的 node_modules 目录</p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230508140816573.png" alt="image-20230508140816573" style="zoom: 67%;" /><h4 id="5-pnpm-的安装和使用"><a href="#5-pnpm-的安装和使用" class="headerlink" title="5.pnpm 的安装和使用"></a>5.pnpm 的安装和使用</h4><p>官网提供了很多种方式来安装pnpm：<a href="https://www.pnpm.cn/installation">https://www.pnpm.cn/installation</a></p><p>因为都安装过Node，Node中有npm，所以通过npm安装即可</p><ul><li>npm install -g pnpm</li></ul><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230508140659540.png" alt="image-20230508140659540"></p><p>参考pnpm的官网：<a href="https://pnpm.io/zh/">https://pnpm.io/zh/</a></p><h4 id="6-pnpm-的存储-store"><a href="#6-pnpm-的存储-store" class="headerlink" title="6.pnpm 的存储 store"></a>6.pnpm 的存储 store</h4><p>在pnpm7.0之前，统一的存储位置是 ~&#x2F;.pnpm-store中的</p><p>在pnpm7.0之后，统一的存储位置进行了更改：<code>&lt;pnpm home directory&gt;</code>&#x2F;store</p><p>可以通过一些终端命令获取这个目录：获取当前活跃的store目录</p><ul><li>pnpm store path</li></ul><p>另外一个非常重要的store命令是prune（修剪）：从store中删除当前未被引用的包来释放store的空间</p><ul><li>pnpm store prune</li></ul><h2 id="4-邂逅Webpack和打包过程"><a href="#4-邂逅Webpack和打包过程" class="headerlink" title="4.邂逅Webpack和打包过程"></a>4.邂逅Webpack和打包过程</h2><p>前端开发的流程</p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230508142918317.png" alt="image-20230508142918317" style="zoom: 33%;" /><h3 id="1、内置模块path"><a href="#1、内置模块path" class="headerlink" title="1、内置模块path"></a>1、内置模块path</h3><p>path模块用于对路径和文件进行处理，提供了很多好用的方法</p><p>在Mac OS、Linux和window上的路径时不一样的</p><ul><li><p>window上会使用 \或者 \ 来作为文件路径的分隔符，目前也支持 &#x2F;</p></li><li><p>在Mac OS、Linux的Unix操作系统上使用 &#x2F; 来作为文件路径的分隔符</p></li></ul><p>那么如果在window上使用来作为分隔符开发了一个应用程序，要部署到Linux上面应该怎么办</p><ul><li><p>显示路径会出现一些问题</p></li><li><p>所以为了屏蔽他们之间的差异，在开发中对于路径的操作可以使用 path 模块</p></li></ul><p>可移植操作系统接口（英语：Portable Operating System Interface，缩写为POSIX）</p><ul><li><p>Linux和Mac OS都实现了POSIX接口</p></li><li><p>Window部分电脑实现了POSIX接口</p></li></ul><p>path常见的API</p><p>从路径中获取信息</p><ul><li><p>dirname：获取文件的父文件夹</p></li><li><p>basename：获取文件名</p></li><li><p>extname：获取文件扩展名</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> filepath = <span class="string">&quot;D://acs/sdx/ad.txt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.可以从一个路径来获取一些信息</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(path.<span class="title function_">extname</span>(filepath))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(path.<span class="title function_">basename</span>(filepath))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(path.<span class="title function_">dirname</span>(filepath))</span><br></pre></td></tr></table></figure><p>路径的拼接：path.join</p><ul><li><p>如果希望将多个路径进行拼接，但是不同的操作系统可能使用的是不同的分隔符</p></li><li><p>这时可以使用path.join函数</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2.将多个路径拼接在一起</span></span><br><span class="line"><span class="keyword">const</span> path1 = <span class="string">&quot;/acs/dsw&quot;</span></span><br><span class="line"><span class="keyword">const</span> path2 = <span class="string">&quot;../dd/wa/dx.txt&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(path.<span class="title function_">join</span>(path1, path2))</span><br></pre></td></tr></table></figure><p>拼接绝对路径：path.resolve</p><ul><li><p>path.resolve() 方法会把一个路径或路径片段的序列解析为一个绝对路径</p></li><li><p>给定的路径的序列是从右往左被处理的，后面每个 path 被依次解析，直到构造完成一个绝对路径</p></li><li><p>如果在处理完所有给定path的段之后，还没有生成绝对路径，则使用当前工作目录</p></li><li><p>生成的路径被规范化并删除尾部斜杠，零长度path段被忽略</p></li><li><p>如果没有path传递段，path.resolve()将返回当前工作目录的绝对路径</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 3.将多个路径拼接在一起，最终一定返回一个绝对路径：path.resolve</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;------------resolve---------------&quot;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(path.<span class="title function_">resolve</span>(path1,path2))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(path.<span class="title function_">resolve</span>(<span class="string">&quot;./sdw/sxx&quot;</span>, <span class="string">&quot; &quot;</span>, <span class="string">&quot;../dww/rwr&quot;</span>, <span class="string">&quot;./dff.txt/&quot;</span>))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(path.<span class="title function_">resolve</span>())</span><br></pre></td></tr></table></figure><p>在webpack中的使用：在webpack中获取路径或者起别名的地方也可以使用</p><h3 id="2、认识-webpack"><a href="#2、认识-webpack" class="headerlink" title="2、认识 webpack"></a>2、认识 webpack</h3><p>随着前端的快速发展，目前前端的开发已经变的越来越复杂了：</p><ul><li><p>比如开发过程中需要通过模块化的方式来开发</p></li><li><p>比如也会使用一些高级的特性来加快开发效率或者安全性，比如通过ES6+、TypeScript开发脚本逻辑，通过sass、less等方式来编写css样式代码</p></li><li><p>比如开发过程中，还希望实时的监听文件的变化来并且反映到浏览器上，提高开发的效率</p></li><li><p>比如开发完成后还需要将代码进行压缩、合并以及其他相关的优化</p></li><li><p>等等….</p></li></ul><p>但是对于很多的前端开发者来说，并不需要思考这些问题，日常的开发中根本就没有面临这些问题</p><ul><li><p>这是因为目前前端开发通常都会直接使用三大框架来开发：Vue、React、Angular</p></li><li><p>但是事实上，这三大框架的创建过程都是借助于脚手架（CLI）的</p></li><li><p>事实上Vue-CLI、create-react-app、Angular-CLI都是基于webpack来帮助我们支持模块化、less、TypeScript、打包优化等的</p></li></ul><p>脚手架依赖于 webpack</p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230508161909817.png" alt="image-20230508161909817" style="zoom:67%;" /><h4 id="1-什么是webpack"><a href="#1-什么是webpack" class="headerlink" title="1.什么是webpack"></a>1.什么是webpack</h4><p>官方解释：webpack is a static module bundler for modern JavaScript applications.</p><p>webpack是一个静态的模块化打包工具，为现代的JavaScript应用程序</p><p>对上面的解释进行拆解：</p><ul><li><p>打包bundler：webpack可以将帮助进行打包，所以它是一个打包工具</p></li><li><p>静态的static：这样表述的原因是最终可以将代码打包成最终的静态资源（部署到静态服务器）</p></li><li><p>模块化module：webpack默认支持各种模块化开发，ES Module、CommonJS、AMD等</p></li><li><p>现代的modern：正是因为现代前端开发面临各种各样的问题，才催生了webpack的出现和发展</p></li></ul><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230508162141066.png" alt="image-20230508162141066" style="zoom: 25%;" /><p>Vue项目加载的文件有哪些</p><ul><li><p>JavaScript的打包：</p><ul><li><p>将ES6转换成ES5的语法</p></li><li><p>TypeScript的处理，将其转换成JavaScript</p></li></ul></li><li><p>Css的处理：</p><ul><li>CSS文件模块的加载、提取</li><li>Less、Sass等预处理器的处理</li></ul></li><li><p>资源文件img、font：</p><ul><li>图片img文件的加载</li><li>字体font文件的加载</li></ul></li><li><p>HTML资源的处理</p><ul><li>打包HTML资源文件</li></ul></li><li><p>处理vue项目的SFC文件.vue文件</p></li></ul><h4 id="2-webpack-的安装"><a href="#2-webpack-的安装" class="headerlink" title="2.webpack 的安装"></a>2.webpack 的安装</h4><p>webpack的官方文档是<a href="https://webpack.js.org/">https://webpack.js.org/</a></p><ul><li><p>webpack的中文官方文档是<a href="https://webpack.docschina.org/">https://webpack.docschina.org/</a></p></li><li><p>DOCUMENTATION：文档详情，也是我们最关注的</p></li></ul><p>Webpack的运行是依赖Node环境的，所以必须有Node环境</p><ul><li>所以需要先安装Node.js，并且同时会安装npm</li></ul><p>Node官方网站：<a href="https://nodejs.org/">https://nodejs.org/</a></p><p>webpack的安装目前分为两个：webpack、webpack-cli（webpack4之后需要安装）</p><p>它们是什么关系</p><ul><li><p>执行webpack命令，会执行node_modules下的.bin目录下的webpack</p></li><li><p>webpack在执行时是依赖webpack-cli的，如果没有安装就会报错</p></li><li><p>而webpack-cli中代码执行时，才是真正利用webpack进行编译和打包的过程</p></li><li><p>所以在安装webpack时，需要同时安装webpack-cli（第三方的脚手架事实上是没有使用webpack-cli的，而是类似于自己的vue-service-cli的东西）</p></li></ul><p>全局安装：npm install webpack webpack-cli -g</p><p>局部安装：npm install webpack webpack-cli -D</p><p>使用最多的是局部安装，因为不同的项目（ts\vue）所依赖的webpack可能是不同的</p><h4 id="3-webpack的默认打包"><a href="#3-webpack的默认打包" class="headerlink" title="3.webpack的默认打包"></a>3.webpack的默认打包</h4><p>可以直接在目录通过webpack命令进行打包，通过html运行打包之后的代码</p><p>生成一个dist文件夹，里面存放一个main.js的文件，就是打包之后的文件：</p><ul><li><p>这个文件中的代码被压缩和丑化了</p></li><li><p>另外代码中依然存在ES6的语法，比如箭头函数、const等，这是因为默认情况下webpack并不清楚打包后的文件是否需要转成ES5之前的语法，后续需要通过babel来进行转换和设置</p></li></ul><p>webpack是如何确定我们的入口的</p><ul><li><p>事实上，当运行webpack时，webpack会查找当前目录下的 src&#x2F;index.js作为入口</p></li><li><p>所以，如果当前项目中没有存在src&#x2F;index.js文件，那么会报错</p></li></ul><p>也可以通过配置来指定入口和出口</p><ul><li>npx webpack –entry .&#x2F;src&#x2F;main.js –output-filename bundle.js –output-path .&#x2F;build</li></ul><p>创建局部的webpack：</p><ul><li>第一步：npm init -y</li><li>第二步：安装局部的webpack</li><li>第三步：使用局部的webpack</li><li>第四步：在package.json中创建script脚本，执行脚本进行打包即可</li></ul><h3 id="3、webpack配置文件"><a href="#3、webpack配置文件" class="headerlink" title="3、webpack配置文件"></a>3、webpack配置文件</h3><p>在通常情况下，webpack需要打包的项目是非常复杂的，并且需要一系列的配置来满足要求，默认配置必然是不可以的</p><p>可以在根目录下创建一个webpack.config.js文件，来作为webpack的配置文件</p><p>默认文件名是固定的：webpack.config.js</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">   <span class="attr">entry</span>: <span class="string">&quot;./src/main.js&quot;</span>,</span><br><span class="line">   <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&quot;bundle.js&quot;</span>,</span><br><span class="line">    <span class="comment">// path 的路径需为绝对路径 </span></span><br><span class="line">    <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&quot;./build&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时可以直接运行：npx webpack 即可</p><p>要是对文件名进行了修改，比如为 wk.config.js</p><p>则运行命令：npx webpack –config wk.config.js</p><p>每次都这么书写命令过于麻烦，可以将其添加到scripts中</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">   <span class="string">&quot;build&quot;</span>: <span class="string">&quot;webpack --config wk.config.js&quot;</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>只需运行：npm run build即可</p><h3 id="4、编写和打包CSS文件"><a href="#4、编写和打包CSS文件" class="headerlink" title="4、编写和打包CSS文件"></a>4、编写和打包CSS文件</h3><h3 id="5、编写和打包Less文件"><a href="#5、编写和打包Less文件" class="headerlink" title="5、编写和打包Less文件"></a>5、编写和打包Less文件</h3><h3 id="6、postcss工具处理CSS"><a href="#6、postcss工具处理CSS" class="headerlink" title="6、postcss工具处理CSS"></a>6、postcss工具处理CSS</h3>]]></content>
      
      
      <categories>
          
          <category> 前端工程化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IT前端 </tag>
            
            <tag> Node </tag>
            
            <tag> Webpack </tag>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法</title>
      <link href="/archives/0.html"/>
      <url>/archives/0.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="数据结构与算法结合-JavaScript"><a href="#数据结构与算法结合-JavaScript" class="headerlink" title="数据结构与算法结合 JavaScript"></a>数据结构与算法结合 JavaScript</h4><h4 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h4><p>数据结构与算法是什么？</p><p>数据结构：计算机存储、组织数据的方式，就像锅碗瓢盆。</p><p>算法：一系列解决问题的清晰指令，就像食谱。</p><p>程序 &#x3D; 数据结构 + 算法</p><p>数据结构为算法提供服务，算法围绕数据结构操作。</p><p>有序：栈、队列、链表</p><p>无需：集合、字典</p><p>树、堆、图</p><h4 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h4><h5 id="时间复杂度计算"><a href="#时间复杂度计算" class="headerlink" title="时间复杂度计算"></a>时间复杂度计算</h5><p>定性描述该算法的运行时间</p><h5 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h5><p>算法在运行过程中临时占用存储空间大小的量度</p><h4 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h4><h5 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h5><p>一个后进先出的数据结构</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> stack = [];</span><br><span class="line">stack.<span class="title function_">push</span>(<span class="number">1</span>);              <span class="comment">//[1]</span></span><br><span class="line">stack.<span class="title function_">push</span>(<span class="number">2</span>);              <span class="comment">//[1,2]</span></span><br><span class="line"><span class="keyword">const</span> item1 = stack.<span class="title function_">pop</span>();   <span class="comment">//[1]</span></span><br><span class="line"><span class="keyword">const</span> item2 = stack.<span class="title function_">pop</span>()    <span class="comment">//[]</span></span><br></pre></td></tr></table></figure><h5 id="栈的应用场景："><a href="#栈的应用场景：" class="headerlink" title="栈的应用场景："></a>栈的应用场景：</h5><p>需要后进先出的场景</p><p>比如：十进制转二进制、判断字符串的括号是否有效、函数调用堆栈…</p><p>例1: 判断括号是否有效：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isValid = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(s.<span class="property">length</span> % <span class="number">2</span> === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> stack = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i&lt;s.<span class="property">length</span>; i+=<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> c = s[i];</span><br><span class="line">        <span class="keyword">if</span>(c === <span class="string">&#x27;(&#x27;</span> || c===<span class="string">&#x27;&#123;&#x27;</span>|| c===<span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">            stack.<span class="title function_">push</span>(c);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> t = stack[stack.<span class="property">length</span> -<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(</span><br><span class="line">                (t === <span class="string">&#x27;(&#x27;</span> &amp;&amp; c ===<span class="string">&#x27;)&#x27;</span>) ||</span><br><span class="line">                (t === <span class="string">&#x27;&#123;&#x27;</span> &amp;&amp; c ===<span class="string">&#x27;&#125;&#x27;</span>) ||</span><br><span class="line">                (t === <span class="string">&#x27;[&#x27;</span> &amp;&amp; c ===<span class="string">&#x27;]&#x27;</span>)</span><br><span class="line">            )&#123;</span><br><span class="line">                stack.<span class="title function_">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.<span class="property">length</span> === <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>例2: 函数调用堆栈</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">func1</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line"><span class="title function_">func2</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">func2</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line"><span class="title function_">func3</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">func3</span> = (<span class="params"></span>) =&gt; &#123;&#125;</span><br><span class="line"><span class="title function_">func1</span>();</span><br></pre></td></tr></table></figure><h4 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h4><h5 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h5><p>一个先进先出的数据结构</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> queue = [];</span><br><span class="line">queue.<span class="title function_">push</span>(<span class="number">1</span>);   <span class="comment">//[1]</span></span><br><span class="line">queue.<span class="title function_">push</span>(<span class="number">2</span>);    <span class="comment">//[1,2]</span></span><br><span class="line"><span class="keyword">const</span> item1 = queue.<span class="title function_">shift</span>();  <span class="comment">//[2]</span></span><br><span class="line"><span class="keyword">const</span> item2 = queue.<span class="title function_">shift</span>();  <span class="comment">//[]</span></span><br></pre></td></tr></table></figure><h5 id="队列的应用场景"><a href="#队列的应用场景" class="headerlink" title="队列的应用场景"></a>队列的应用场景</h5><p>需要先进先出，保证有序性。</p><p>比如食堂买饭、js异步中的任务队列、计算最近请求次数。</p><p>例1：js异步中的任务队列</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>),<span class="number">0</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">先打印<span class="number">2</span> 再打印<span class="number">1</span></span><br></pre></td></tr></table></figure><p>例2:  计算最近请求次数</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">RecentCounter</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">q</span>=[];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">t</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">RecentCounter</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">ping</span> = <span class="keyword">function</span>(<span class="params">t</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">q</span>.<span class="title function_">push</span>(t);</span><br><span class="line">    <span class="keyword">while</span>(<span class="variable language_">this</span>.<span class="property">q</span>[<span class="number">0</span>] &lt; t-<span class="number">3000</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">q</span>.<span class="title function_">shift</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">q</span>.<span class="property">length</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your RecentCounter object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * var obj = new RecentCounter()</span></span><br><span class="line"><span class="comment"> * var param_1 = obj.ping(t)</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h4 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h4><h5 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h5><p>多个元素组成的列表</p><p>元素存储不连续，用 next 指针连在一起。</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20221011201543267.png" alt="image-20221011201543267"></p><h5 id="数组-vs-链表"><a href="#数组-vs-链表" class="headerlink" title="数组 vs 链表"></a>数组 vs 链表</h5><p>数组：增删非首尾元素时往往需要移动元素。</p><p>链表：增删非首尾元素，不需要移动元素，只需要更改 next 的指向即可。</p><p>javascript中没有链表，可以用object模仿。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;<span class="attr">val</span>:<span class="string">&#x27;a&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> b = &#123;<span class="attr">val</span>:<span class="string">&#x27;b&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> c = &#123;<span class="attr">val</span>:<span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> d = &#123;<span class="attr">val</span>:<span class="string">&#x27;d&#x27;</span>&#125;;</span><br><span class="line">a.<span class="property">next</span> = b;</span><br><span class="line">b.<span class="property">next</span> = c;</span><br><span class="line">c.<span class="property">next</span> = d;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历链表</span></span><br><span class="line"><span class="keyword">let</span> p = a;  <span class="comment">// 需声明一个指针指向表头</span></span><br><span class="line"><span class="keyword">while</span>(p)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">val</span>);</span><br><span class="line">p=p.<span class="property">next</span>;</span><br><span class="line">&#125;   <span class="comment">// a b c d</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入</span></span><br><span class="line"><span class="keyword">const</span> e = &#123;<span class="attr">val</span>:<span class="string">&#x27;e&#x27;</span>&#125;;</span><br><span class="line">c.<span class="property">next</span> = e;</span><br><span class="line">e.<span class="property">next</span> = d;    <span class="comment">// a b c e d</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除</span></span><br><span class="line">c.<span class="property">next</span> = d;</span><br></pre></td></tr></table></figure><p>反转链表（206）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">head</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">ListNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverseList = <span class="keyword">function</span>(<span class="params">head</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> p1 = head;</span><br><span class="line">    <span class="keyword">let</span> p2 = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(p1)&#123;</span><br><span class="line">        <span class="keyword">const</span> tmp = p1.<span class="property">next</span>;</span><br><span class="line">        p1.<span class="property">next</span> = p2;</span><br><span class="line">        p2=p1;</span><br><span class="line">        p1=p1.<span class="property">next</span>;</span><br><span class="line">        p1 = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>两数相加（2）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">l1</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">l2</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">ListNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> addTwoNumbers = <span class="keyword">function</span>(<span class="params">l1, l2</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> l3 = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> p1 = l1;</span><br><span class="line">    <span class="keyword">let</span> p2 = l2;</span><br><span class="line">    <span class="keyword">let</span> p3 = l3;</span><br><span class="line">    <span class="keyword">let</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p1 || p2)&#123;</span><br><span class="line">        <span class="keyword">const</span> v1 = p1 ? p1.<span class="property">val</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">const</span> v2 = p2 ? p2.<span class="property">val</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">const</span> val = v1 + v2 + carry;</span><br><span class="line">        carry = <span class="title class_">Math</span>.<span class="title function_">floor</span>(val/<span class="number">10</span>);</span><br><span class="line">        p3.<span class="property">next</span> = <span class="keyword">new</span> <span class="title class_">ListNode</span>(val % <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span>(p1) p1= p1.<span class="property">next</span>;</span><br><span class="line">        <span class="keyword">if</span>(p2) p2 = p2.<span class="property">next</span>;</span><br><span class="line">        p3 = p3.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(carry)&#123;</span><br><span class="line">        p3.<span class="property">next</span> = <span class="keyword">new</span> <span class="title class_">ListNode</span>(carry);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l3.<span class="property">next</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>删除排序链表中的重复元素（83）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">head</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">ListNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> deleteDuplicates = <span class="keyword">function</span>(<span class="params">head</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> p = head;</span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; p.<span class="property">next</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(p.<span class="property">val</span> === p.<span class="property">next</span>.<span class="property">val</span>) &#123;</span><br><span class="line">            p.<span class="property">next</span> = p.<span class="property">next</span>.<span class="property">next</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p = p.<span class="property">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>环形链表（141）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> * @param &#123;<span class="title class_">ListNode</span>&#125; head</span><br><span class="line"> * @<span class="keyword">return</span> &#123;boolean&#125;</span><br><span class="line"> */</span><br><span class="line"><span class="keyword">var</span> hasCycle = <span class="keyword">function</span>(<span class="params">head</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> p1 = head;  <span class="comment">// 快的指针</span></span><br><span class="line">    <span class="keyword">let</span> p2 = head;  <span class="comment">// 慢的指针</span></span><br><span class="line">    <span class="keyword">while</span>(p1 &amp;&amp; p2 &amp;&amp; p2.<span class="property">next</span>) &#123;</span><br><span class="line">        p1=p1.<span class="property">next</span>;</span><br><span class="line">        p2=p2.<span class="property">next</span>.<span class="property">next</span>;</span><br><span class="line">        <span class="keyword">if</span>(p1 === p2)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="前端与链表"><a href="#前端与链表" class="headerlink" title="前端与链表"></a>前端与链表</h5><h5 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h5><p>原型链的本质是链表。</p><p>原型链上的节点是各种原型对象，比如：Function。prototype、Object.prototype….</p><p>原型链通过_ proto_ 属性连接各种原型对象。（不是.next）</p><p>obj -&gt; Object.prototype -&gt; null</p><p>func -&gt; Function.prototype -&gt; Object.prototype -&gt; null</p><p>arr -&gt; Array.prototype -&gt; Object.prototype -&gt; null</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const obj = &#123;&#125;;</span><br><span class="line">const func = () =&gt; &#123;&#125;;</span><br><span class="line">const arr = [];</span><br></pre></td></tr></table></figure><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20221012152006352.png" alt="image-20221012152006352"></p><h5 id="原型链知识点"><a href="#原型链知识点" class="headerlink" title="原型链知识点"></a>原型链知识点</h5><p>如果 A 沿着原型链能找到 B.prototype，那么 A instanceof B 为true。</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20221012151915876.png" alt="image-20221012151915876"></p><p>如果在 A 对象上没有找到 x 属性，那么会沿着原型链找 x 属性。</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20221012152348319.png" alt="image-20221012152348319"></p><p>面试题1：instanceof 的原理，并用代码实现</p><p>知识点：如果A沿着原型链能找到 B.prototype，那么A instanceof B为 true。</p><p>解法：遍历A的原型链，如果找到 B.prototype，返回 true，否则返回 false。</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20221012153221227.png" alt="image-20221012153221227"></p><p>面试题2：</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20221012153435595.png" alt="image-20221012153435595"></p><p>知识点：如果在 A 对象上没有找到 x 属性，那么会沿着原型链找 x 属性。</p><p>解法：明确 foo 和 F 变量的原型链，沿着原型链找 a 属性和 b 属性。</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20221012153840827.png" alt="image-20221012153840827"></p><h5 id="使用链表指针获取-JSON-的节点值"><a href="#使用链表指针获取-JSON-的节点值" class="headerlink" title="使用链表指针获取 JSON 的节点值"></a>使用链表指针获取 JSON 的节点值</h5><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20221012154813607.png" alt="image-20221012154813607"></p><h5 id="技术要点"><a href="#技术要点" class="headerlink" title="技术要点"></a>技术要点</h5><p>链表里的元素存储不是连续的，之间通过 next 连接。</p><p>JavaScript 中没有链表，但可以用 Object 模拟链表。</p><p>链表常用操作：修改 next 、遍历链表。</p><h4 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h4><h5 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h5><p>一种无序且唯一的数据结构。</p><p>ES6中有集合，名为 set。</p><p>集合的常用操作：去重、判断某元素是否在集合中、求交集…</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20221012160819142.png" alt="image-20221012160819142"></p><p>两个数组的交集（349）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums1</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums2</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> intersection = <span class="keyword">function</span>(<span class="params">nums1, nums2</span>) &#123;</span><br><span class="line"><span class="comment">// return [...new Set(nums1)].filter(n =&gt; new Set(nums2).has(n))</span></span><br><span class="line">    <span class="keyword">return</span> [...<span class="keyword">new</span> <span class="title class_">Set</span>(nums1)].<span class="title function_">filter</span>(<span class="function"><span class="params">n</span> =&gt;</span> nums2.<span class="title function_">includes</span>(n))</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="set-操作"><a href="#set-操作" class="headerlink" title="set 操作"></a>set 操作</h5><p>使用 Set 对象：new、add、delete、has、size</p><p>迭代 Set：多种迭代方法、Set 与 Array 互转、求交集&#x2F;差集</p><p>add 方法</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20221012181036153.png" alt="image-20221012181036153"></p><p>has 方法</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20221012181331923.png" alt="image-20221012181331923"></p><p>delete 方法</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20221012181551547.png" alt="image-20221012181551547"></p><p>迭代对象：for_of 方法</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20221012181923579.png" alt="image-20221012181923579"></p><p>keys 方法</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20221012182037679.png" alt="image-20221012182037679"></p><p>value 方法</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20221012182110785.png" alt="image-20221012182110785"></p><p>entries 方法：key 和 value 的值是一样的。</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20221012182309636.png" alt="image-20221012182309636"></p><h5 id="set-和-arr-互转"><a href="#set-和-arr-互转" class="headerlink" title="set 和 arr 互转"></a>set 和 arr 互转</h5><p>set 转换为 arr：（1）</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20221012182518662.png" alt="image-20221012182518662"></p><p>（2）：Array 方法</p><p><img src="C:\Users\王邦辉\AppData\Roaming\Typora\typora-user-images\image-20221012182715677.png" alt="image-20221012182715677"></p><p>arr 转换为 set：</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20221012182949771.png" alt="image-20221012182949771"></p><h5 id="求交集和差集"><a href="#求交集和差集" class="headerlink" title="求交集和差集"></a>求交集和差集</h5><p>交集</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20221012183644381.png" alt="image-20221012183644381"></p><p>差集</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20221012183926481.png" alt="image-20221012183926481"></p><h5 id="技术要点-1"><a href="#技术要点-1" class="headerlink" title="技术要点"></a>技术要点</h5><p>集合是一种无序且唯一的数据结构。</p><p>ES6 中有集合，名为 Set。</p><h4 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h4><h5 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h5><p>与集合类似，字典也是一种存储唯一值的数据结构，但它是以键值对的形式来存储。</p><p>ES6 中有字典，名为 Map。</p><p>字典的常用操作：键值对的增删改查。</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20221012184824452.png" alt="image-20221012184824452"></p><p>删除</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20221012185106637.png" alt="image-20221012185106637"></p><p>改</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20221012185210902.png" alt="image-20221012185210902"></p><p>求数组交集（349）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> intersection = <span class="keyword">function</span>(<span class="params">nums1, nums2</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">    nums1.<span class="title function_">forEach</span>(<span class="function"><span class="params">n</span>=&gt;</span>&#123;</span><br><span class="line">    map.<span class="title function_">set</span>(n,<span class="literal">true</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">const</span> res = [];</span><br><span class="line">    nums2.<span class="title function_">forEach</span>(<span class="function"><span class="params">n</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(map.<span class="title function_">get</span>(n))&#123;</span><br><span class="line">    res.<span class="title function_">push</span>(n);</span><br><span class="line">    map.<span class="title function_">delete</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>有效地括号（优化）（20）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isValid = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(s.<span class="property">length</span> % <span class="number">2</span> === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> stack = [];</span><br><span class="line">    <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">    map.<span class="title function_">set</span>(<span class="string">&#x27;(&#x27;</span>,<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">    map.<span class="title function_">set</span>(<span class="string">&#x27;[&#x27;</span>,<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">    map.<span class="title function_">set</span>(<span class="string">&#x27;&#123;&#x27;</span>,<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i&lt;s.<span class="property">length</span>; i+=<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> c = s[i];</span><br><span class="line">        <span class="keyword">if</span>(map.<span class="title function_">has</span>(c)) &#123;</span><br><span class="line">            stack.<span class="title function_">push</span>(c);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> t = stack[stack.<span class="property">length</span> -<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(map.<span class="title function_">get</span>(t) === c)&#123;</span><br><span class="line">                stack.<span class="title function_">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.<span class="property">length</span> === <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>两数之和（1）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>无重复字符的最长子串（3）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> lengthOfLongestSubstring = <span class="keyword">function</span>(<span class="params">s</span>) &#123; <span class="comment">// 双指针滑动窗口</span></span><br><span class="line">    <span class="keyword">let</span> l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> r = <span class="number">0</span>; r&lt;s.<span class="property">length</span>;r++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(map.<span class="title function_">has</span>(s[r]) &amp;&amp; map.<span class="title function_">get</span>(s[r]) &gt;= l)&#123;</span><br><span class="line">            l = map.<span class="title function_">get</span>(s[r])+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="title class_">Math</span>.<span class="title function_">max</span>(res,r-l+<span class="number">1</span>);</span><br><span class="line">        map.<span class="title function_">set</span>(s[r],r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>最小覆盖子串（76）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">t</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">string</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> minWindow = <span class="keyword">function</span>(<span class="params">s, t</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span>(s.<span class="property">length</span> &lt; t.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> need = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> c <span class="keyword">of</span> t) &#123;</span><br><span class="line">        need.<span class="title function_">set</span>(c,need.<span class="title function_">has</span>(c) ? need.<span class="title function_">get</span>(c)+<span class="number">1</span> :<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> needType = need.<span class="property">size</span>;</span><br><span class="line">    <span class="keyword">while</span>(r &lt; s.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> c = s[r];</span><br><span class="line">        <span class="keyword">if</span>(need.<span class="title function_">has</span>(c))&#123;</span><br><span class="line">            need.<span class="title function_">set</span>(c,need.<span class="title function_">get</span>(c)-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(need.<span class="title function_">get</span>(c) === <span class="number">0</span>) needType--</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(needType === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> newRes = s.<span class="title function_">substring</span>(l,r+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(!res || newRes.<span class="property">length</span> &lt; res.<span class="property">length</span>) res=newRes</span><br><span class="line">            <span class="keyword">const</span>  c2 = s[l];</span><br><span class="line">            <span class="keyword">if</span>(need.<span class="title function_">has</span>(c2)) &#123;</span><br><span class="line">                need.<span class="title function_">set</span>(c2,need.<span class="title function_">get</span>(c2) + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(need.<span class="title function_">get</span>(c2) ===<span class="number">1</span>) needType++;</span><br><span class="line">            &#125;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        r++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="技术要点-2"><a href="#技术要点-2" class="headerlink" title="技术要点"></a>技术要点</h5><p>与集合类似，字典也是一种存储唯一值的数据结构， 但它是以键值对的形式来存储。</p><h4 id="第八章"><a href="#第八章" class="headerlink" title="第八章"></a>第八章</h4><h5 id="树"><a href="#树" class="headerlink" title="树"></a>树</h5><p>一种分层数据的抽象模型</p><p>前端工作中常见的树包括：DOM树、级联选择、树形控件……</p><p>JS中没有树，但是可以用Object和Array构建树</p><p>树的常用操作：深度&#x2F;广度优先遍历、先中后序遍历</p><h5 id="深度-x2F-广度优先遍历"><a href="#深度-x2F-广度优先遍历" class="headerlink" title="深度&#x2F;广度优先遍历"></a>深度&#x2F;广度优先遍历</h5><p>深度优先遍历：尽可能深的搜索树的分支（尽可能访问完每一个分支）</p><p>广度优先遍历：先访问离根节点最近的节点（每层每层的来）</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20221015183033642.png" alt="image-20221015183033642"></p><h5 id="深度优先遍历算法口诀（递归）"><a href="#深度优先遍历算法口诀（递归）" class="headerlink" title="深度优先遍历算法口诀（递归）"></a>深度优先遍历算法口诀（递归）</h5><p>（1）访问根节点</p><p>（2）对根节点的 children 挨个进行深度优先遍历</p><p>树节点：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> tree = &#123;</span><br><span class="line">  <span class="attr">val</span>:<span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">  <span class="attr">children</span>:[</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">val</span>:<span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">      <span class="attr">children</span>:[</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">val</span>:<span class="string">&#x27;d&#x27;</span>,</span><br><span class="line">          <span class="attr">children</span>:[]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">val</span>:<span class="string">&#x27;e&#x27;</span>,</span><br><span class="line">          <span class="attr">children</span>:[]</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">val</span>:<span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">      <span class="attr">children</span>:[</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">val</span>:<span class="string">&#x27;f&#x27;</span>,</span><br><span class="line">          <span class="attr">children</span>:[]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">val</span>:<span class="string">&#x27;g&#x27;</span>,</span><br><span class="line">          <span class="attr">children</span>:[]</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">dfs</span> = (<span class="params">root</span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(root.<span class="property">val</span>);</span><br><span class="line">  root.<span class="property">children</span>.<span class="title function_">forEach</span>(dfs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">dfs</span>(tree);</span><br></pre></td></tr></table></figure><h5 id="广度优先遍历算法口诀"><a href="#广度优先遍历算法口诀" class="headerlink" title="广度优先遍历算法口诀"></a>广度优先遍历算法口诀</h5><p>（1）新建一个队列，把根节点入队</p><p>（2）把队头出队并访问</p><p>（3）把队头的 children 挨个入队</p><p>（4）重复第二、三步，直到队列为空</p><p>代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">bfs</span> = (<span class="params">root</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> q = [root];</span><br><span class="line">  <span class="keyword">while</span>(q.<span class="property">length</span>&gt;<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> n = q.<span class="title function_">shift</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(n.<span class="property">val</span>);</span><br><span class="line">    n.<span class="property">children</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">child</span> =&gt;</span> &#123;</span><br><span class="line">      q.<span class="title function_">push</span>(child);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">bfs</span>(tree);</span><br></pre></td></tr></table></figure><h5 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h5><p>树中每个节点最多只能有两个子节点</p><p>在 JS 中通常用 Object 来模拟二叉树</p><h5 id="二叉树先序遍历算法口诀（递归）（根左右）"><a href="#二叉树先序遍历算法口诀（递归）（根左右）" class="headerlink" title="二叉树先序遍历算法口诀（递归）（根左右）"></a>二叉树先序遍历算法口诀（递归）（根左右）</h5><p>（1）访问根节点</p><p>（2）对根节点的左子树进行先序遍历</p><p>（3）对根节点的右子树进行先序遍历</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20221015185206420.png" alt="image-20221015185206420"></p><p>节点：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> bt = &#123;</span><br><span class="line">  <span class="attr">val</span>:<span class="number">1</span>,</span><br><span class="line">  <span class="attr">left</span>: &#123;</span><br><span class="line">    <span class="attr">val</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="attr">left</span>:&#123;</span><br><span class="line">      <span class="attr">val</span>:<span class="number">4</span>,</span><br><span class="line">      <span class="attr">left</span>:<span class="literal">null</span>,</span><br><span class="line">      <span class="attr">right</span>:<span class="literal">null</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">right</span>:&#123;</span><br><span class="line">      <span class="attr">val</span>:<span class="number">5</span>,</span><br><span class="line">      <span class="attr">left</span>:<span class="literal">null</span>,</span><br><span class="line">      <span class="attr">right</span>:<span class="literal">null</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">right</span>:&#123;</span><br><span class="line">    <span class="attr">val</span>:<span class="number">3</span>,</span><br><span class="line">    <span class="attr">left</span>:&#123;</span><br><span class="line">      <span class="attr">val</span>:<span class="number">6</span>,</span><br><span class="line">      <span class="attr">left</span>:<span class="literal">null</span>,</span><br><span class="line">      <span class="attr">right</span>:<span class="literal">null</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">right</span>:&#123;</span><br><span class="line">      <span class="attr">val</span>:<span class="number">7</span>,</span><br><span class="line">      <span class="attr">left</span>:<span class="literal">null</span>,</span><br><span class="line">      <span class="attr">right</span>:<span class="literal">null</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = bt;</span><br></pre></td></tr></table></figure><p>代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> bt = <span class="built_in">require</span>(<span class="string">&#x27;./bt&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">preorder</span> = (<span class="params">root</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span>(!root) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(root.<span class="property">val</span>);</span><br><span class="line">  <span class="title function_">preorder</span>(root.<span class="property">left</span>);</span><br><span class="line">  <span class="title function_">preorder</span>(root.<span class="property">right</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">preorder</span>(bt);</span><br></pre></td></tr></table></figure><h5 id="二叉树中序遍历算法口诀（递归）"><a href="#二叉树中序遍历算法口诀（递归）" class="headerlink" title="二叉树中序遍历算法口诀（递归）"></a>二叉树中序遍历算法口诀（递归）</h5><p>（1）对根节点的左子树进行中序遍历</p><p>（2）访问根节点</p><p>（3）对根节点的右子树进行中序遍历</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20221015193416827.png" alt="image-20221015193416827"></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> bt = <span class="built_in">require</span>(<span class="string">&#x27;./bt&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">inorder</span> = (<span class="params">root</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span>(!root) &#123;<span class="keyword">return</span>;&#125;</span><br><span class="line">  <span class="title function_">inorder</span>(root.<span class="property">left</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(root.<span class="property">val</span>);</span><br><span class="line">  <span class="title function_">inorder</span>(root.<span class="property">right</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">inorder</span>(bt);</span><br></pre></td></tr></table></figure><h5 id="二叉树后序遍历算法口诀（递归）（左右根）"><a href="#二叉树后序遍历算法口诀（递归）（左右根）" class="headerlink" title="二叉树后序遍历算法口诀（递归）（左右根）"></a>二叉树后序遍历算法口诀（递归）（左右根）</h5><p>（1）对根节点的左子树进行后序遍历</p><p>（2）对根节点的右子树进行后序遍历</p><p>（3）访问根节点</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20221016101116303.png" alt="image-20221016101116303"></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> bt = <span class="built_in">require</span>(<span class="string">&#x27;./bt&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">postorder</span> = (<span class="params">root</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span>(!root) &#123;<span class="keyword">return</span>;&#125;</span><br><span class="line">  <span class="title function_">postorder</span>(root.<span class="property">left</span>);</span><br><span class="line">  <span class="title function_">postorder</span>(root.<span class="property">right</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(root.<span class="property">val</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">postorder</span>(bt);</span><br></pre></td></tr></table></figure><h5 id="二叉树的先序遍历（非递归）"><a href="#二叉树的先序遍历（非递归）" class="headerlink" title="二叉树的先序遍历（非递归）"></a>二叉树的先序遍历（非递归）</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">preorder</span> = (<span class="params">root</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span>(!root) &#123;<span class="keyword">return</span>;&#125;</span><br><span class="line">  <span class="keyword">const</span> stack = [root];</span><br><span class="line">  <span class="keyword">while</span>(stack.<span class="property">length</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> n = stack.<span class="title function_">pop</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(n.<span class="property">val</span>);</span><br><span class="line">    <span class="keyword">if</span>(n.<span class="property">right</span>) stack.<span class="title function_">push</span>(n.<span class="property">right</span>);</span><br><span class="line">    <span class="keyword">if</span>(n.<span class="property">left</span>) stack.<span class="title function_">push</span>(n.<span class="property">left</span>);</span><br><span class="line">  &#125; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">preorder</span>(bt);</span><br></pre></td></tr></table></figure><h5 id="二叉树的中序遍历（非递归）"><a href="#二叉树的中序遍历（非递归）" class="headerlink" title="二叉树的中序遍历（非递归）"></a>二叉树的中序遍历（非递归）</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">inorder</span> = (<span class="params">root</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span>(!root) &#123;<span class="keyword">return</span>;&#125;</span><br><span class="line">  <span class="keyword">const</span> stack = [];</span><br><span class="line">  <span class="keyword">let</span> p = root;</span><br><span class="line">  <span class="keyword">while</span>(stack.<span class="property">length</span> || p) &#123;</span><br><span class="line">    <span class="keyword">while</span>(p) &#123;</span><br><span class="line">      stack.<span class="title function_">push</span>(p)</span><br><span class="line">      p = p.<span class="property">left</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> n = stack.<span class="title function_">pop</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(n.<span class="property">val</span>);</span><br><span class="line">    p = n.<span class="property">right</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">inorder</span>(bt);</span><br></pre></td></tr></table></figure><h5 id="二叉树的后序遍历（非递归）"><a href="#二叉树的后序遍历（非递归）" class="headerlink" title="二叉树的后序遍历（非递归）"></a>二叉树的后序遍历（非递归）</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">postorder</span> = (<span class="params">root</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span>(!root) &#123;<span class="keyword">return</span>;&#125;</span><br><span class="line">  <span class="keyword">const</span> stack = [root];</span><br><span class="line">  <span class="keyword">const</span> outputStack = [];</span><br><span class="line">  <span class="keyword">while</span>(stack.<span class="property">length</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> n = stack.<span class="title function_">pop</span>();</span><br><span class="line">    outputStack.<span class="title function_">push</span>(n)</span><br><span class="line">    <span class="keyword">if</span>(n.<span class="property">left</span>) stack.<span class="title function_">push</span>(n.<span class="property">left</span>);</span><br><span class="line">    <span class="keyword">if</span>(n.<span class="property">right</span>) stack.<span class="title function_">push</span>(n.<span class="property">right</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(outputStack.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> n = outputStack.<span class="title function_">pop</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(n.<span class="property">val</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">postorder</span>(bt);</span><br></pre></td></tr></table></figure><p>二叉树的最大深度（104）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxDepth = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">dfs</span> = (<span class="params">n,l</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span>(!n) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line">        <span class="keyword">if</span>(!n.<span class="property">left</span> &amp;&amp; !n.<span class="property">right</span>) &#123;</span><br><span class="line">            res = <span class="title class_">Math</span>.<span class="title function_">max</span>(res, l)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">dfs</span>(n.<span class="property">left</span>,l+<span class="number">1</span>);</span><br><span class="line">        <span class="title function_">dfs</span>(n.<span class="property">right</span>,l+<span class="number">1</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="title function_">dfs</span>(root,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>二叉树的最小深度（111）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IT前端 </tag>
            
            <tag> JavaScript </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git的基本使用</title>
      <link href="/archives/163a8691.html"/>
      <url>/archives/163a8691.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Github社区基本使用"><a href="#Github社区基本使用" class="headerlink" title="Github社区基本使用"></a>Github社区基本使用</h2><h3 id="Git基础概念"><a href="#Git基础概念" class="headerlink" title="Git基础概念"></a>Git基础概念</h3><h4 id="Git-的特性"><a href="#Git-的特性" class="headerlink" title="Git 的特性"></a>Git 的特性</h4><p>Git 是一个开源的分布式版本控制系统，是目前世界上最先进、最流行的版本控制系统。可以快速高效地处理从很小到非常大的项目版本管理。</p><p>特点：项目越大越复杂，协同开发者越多，越能体现出 Git 的高性能和高可用性！</p><h5 id="Git-之所以快速和高效，主要依赖于它的如下两个特性："><a href="#Git-之所以快速和高效，主要依赖于它的如下两个特性：" class="headerlink" title="Git 之所以快速和高效，主要依赖于它的如下两个特性："></a>Git 之所以快速和高效，主要依赖于它的如下两个特性：</h5><p>①直接记录快照，而非差异比较</p><p>②近乎所有操作都是本地执行</p><h5 id="SVN-的差异比较"><a href="#SVN-的差异比较" class="headerlink" title="SVN 的差异比较"></a>SVN 的差异比较</h5><p>传统的版本控制系统（例如 SVN）是基于差异的版本控制，它们存储的是一组基本文件和每个文件随时间逐步累积的差异。</p><p>好处：节省磁盘空间</p><p>缺点：耗时、效率低</p><p>​在每次切换版本的时候，都需要在基本文件的基础上，应用每个差异，从而生成目标版本对应的文件。</p><p><strong>Git</strong> <strong>的记录快照</strong></p><p>Git 快照是在原有文件版本的基础上重新生成一份新的文件，类似于备份。为了效率，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。</p><p>缺点：占用磁盘空间较大</p><p>优点：版本切换时非常快，因为每个版本都是完整的文件快照，切换版本时直接恢复目标版本的快照即可。</p><p>特点：空间换时间</p><h5 id="近乎所有操作都是本地执行"><a href="#近乎所有操作都是本地执行" class="headerlink" title="近乎所有操作都是本地执行"></a>近乎所有操作都是本地执行</h5><p>在 Git 中的绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其它计算机的信息。</p><p>特性：</p><p>①断网后依旧可以在本地对项目进行版本管理</p><p>②联网后，把本地修改的记录同步到云端服务器即可</p><h5 id="Git-中的三个区域"><a href="#Git-中的三个区域" class="headerlink" title="Git 中的三个区域"></a>Git 中的三个区域</h5><p>使用 Git 管理的项目，拥有三个区域，分别是工作区（处理工作的区域）、暂存区（已完成的工作的临时存放区域，等待被提交）、Git 仓库（最终的存放区域）。</p><h5 id="Git-中的三种状态"><a href="#Git-中的三种状态" class="headerlink" title="Git 中的三种状态"></a>Git 中的三种状态</h5><p>已修改：表示修改了文件，但还没将修改的结果放到暂存区</p><p>已暂存：表示对已修改文件的当前版本做了标记，使之包含在下次提交的列表中</p><p>已提交：表示文件已经安全地保存在本地的 Git 仓库中</p><p>注意：</p><p>工作区的文件被修改了，但还没有放到暂存区，就是已修改状态。</p><p>如果文件已修改并放入暂存区，就属于已暂存状态。</p><p>如果 Git 仓库中保存着特定版本的文件，就属于已提交状态。</p><h5 id="基本的-Git-工作流程如下"><a href="#基本的-Git-工作流程如下" class="headerlink" title="基本的 Git 工作流程如下"></a>基本的 Git 工作流程如下</h5><p>①在工作区中修改文件</p><p>②将你想要下次提交的更改进行暂存</p><p>③提交更新，找到暂存区的文件，将快照永久性存储到 Git 仓库</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>​在开始使用 Git 管理项目的版本之前，需要将它安装到计算机上。可以使用浏览器访问如下的网址，根据自己的操作系统，选择下载对应的 Git 安装包：</p><p><a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a></p><h4 id="配置用户信息"><a href="#配置用户信息" class="headerlink" title="配置用户信息"></a>配置用户信息</h4><p>​安装完 Git 之后，要做的第一件事就是设置自己的用户名和邮件地址。因为通过 Git 对项目进行版本管理的时候，Git 需要使用这些基本信息，来记录是谁对项目进行了操作：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;wangbanghui&quot;</span><br><span class="line">git config --global user.email &quot;546836216@qq.com&quot;</span><br></pre></td></tr></table></figure><p>注意：如果使用了 –global 选项，那么该命令只需要运行一次，即可永久生效。</p><p>​通过 git config –global user.name 和 git config –global user.email 配置的用户名和邮箱地址，会被写入到 C:&#x2F;Users&#x2F;用户名文件夹&#x2F;.gitconfig 文件中。这个文件是 Git 的全局配置文件，配置一次即可永久生效。</p><p>可以使用记事本打开此文件，从而查看自己曾经对 Git 做了哪些全局性的配置。</p><p>除了使用记事本查看全局的配置信息之外，还可以运行如下的终端命令，快速的查看 Git 的全局配置信息：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查看所有的全局配置项</span><br><span class="line">git config --list --global</span><br><span class="line"># 查看指定的全局配置项</span><br><span class="line">git config user.name</span><br><span class="line">git config user.email</span><br></pre></td></tr></table></figure><p>可以使用 git help <verb> 命令，无需联网即可在浏览器中打开帮助手册，例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 要想打开 git config 命令的帮助手册</span><br><span class="line">git help config</span><br></pre></td></tr></table></figure><p>如果不想查看完整的手册，那么可以用 -h 选项获得更简明的“help”输出：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config -h</span><br></pre></td></tr></table></figure><h4 id="Git-的基本操作"><a href="#Git-的基本操作" class="headerlink" title="Git 的基本操作"></a>Git 的基本操作</h4><h5 id="获取-Git-仓库的两种方式"><a href="#获取-Git-仓库的两种方式" class="headerlink" title="获取 Git 仓库的两种方式"></a>获取 Git 仓库的两种方式</h5><p>①将尚未进行版本控制的本地目录转换为 Git 仓库</p><p>②从其它服务器克隆一个已存在的 Git 仓库</p><p>以上两种方式都能够在自己的电脑上得到一个可用的 Git 仓库</p><h5 id="在现有目录中初始化仓库"><a href="#在现有目录中初始化仓库" class="headerlink" title="在现有目录中初始化仓库"></a>在现有目录中初始化仓库</h5><p>如果自己有一个尚未进行版本控制的项目目录，想要用 Git 来控制它，需要执行如下两个步骤：</p><p>①在项目目录中，通过鼠标右键打开“Git Bash”</p><p>②执行 git init 命令将当前的目录转化为 Git 仓库</p><p>git init 命令会创建一个名为 .git 的隐藏目录，这个 .git 目录就是当前项目的 Git 仓库，里面包含了初始的必要文件，这些文件是 Git 仓库的必要组成部分。</p><h5 id="工作区中文件的-4-种状态"><a href="#工作区中文件的-4-种状态" class="headerlink" title="工作区中文件的 4 种状态"></a>工作区中文件的 4 种状态</h5><p>工作区中的每一个文件可能有 4 种状态，这四种状态共分为两大类，</p><p>未跟踪（Untracked）：不被 Git 所管理的文件</p><p>未修改（Unmodified）：工作区中文件的内容和 Git 仓库中文件的内容保持一致</p><p>已修改（Modified）：工作区中文件的内容和 Git 仓库中文件的内容不一致</p><p>已暂存（Staged）：工作区中被修改的文件已被放到暂存区，准备将修改后的文件保存到 Git 仓库中</p><p>Git 操作的终极结果：让工作区中的文件都处于“未修改”的状态。</p><h5 id="检查文件的状态"><a href="#检查文件的状态" class="headerlink" title="检查文件的状态"></a>检查文件的状态</h5><p>可以使用 git status 命令查看文件处于什么状态</p><p>以精简的方式显示文件状态</p><p>使用 git status 输出的状态报告很详细，但有些繁琐。如果希望以精简的方式显示文件的状态，可以使用如下两条完全等价的命令，其中 <strong>-s</strong> 是 <strong>–short</strong> 的简写形式：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git status -s</span><br><span class="line">git status --short</span><br></pre></td></tr></table></figure><p>未跟踪文件前面有红色的 ?? 标记</p><h5 id="跟踪新文件"><a href="#跟踪新文件" class="headerlink" title="跟踪新文件"></a>跟踪新文件</h5><p>使用命令 git add 开始跟踪一个文件。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add index.html</span><br></pre></td></tr></table></figure><p>此时再运行 git status 命令，会看到 indegit sat.html 文件在 Changes to be committed 这行的下面，说明已被跟踪，并处于暂存状态。</p><p>以精简的方式显示文件的状态：新添加到暂存区中的文件前面有绿色的 A 标记</p><h5 id="提交更新"><a href="#提交更新" class="headerlink" title="提交更新"></a>提交更新</h5><p>现在暂存区中有一个 index.html 文件等待被提交到 Git 仓库中进行保存。可以执行 git commit 命令进行提交,其中 -m 选项后面是本次的提交消息，用来对提交的内容做进一步的描述。提交成功之后，会显示信息：新建了 index.html 文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit -m &quot;新建了index.html文件&quot;</span><br></pre></td></tr></table></figure><p>提交成之后，再次检查文件的状态：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">On branch master</span><br><span class="line">nothing to commit,working tree clean</span><br></pre></td></tr></table></figure><p>证明工作区中所有的文件都处于“未修改”的状态，没有任何文件需要被提交。</p><h5 id="对已提交的文件进行修改"><a href="#对已提交的文件进行修改" class="headerlink" title="对已提交的文件进行修改"></a>对已提交的文件进行修改</h5><p>目前，index.html 文件已经被 Git 跟踪，并且工作区和 Git 仓库中的 index.html 文件内容保持一致。当我们修改了工作区中 index.html 的内容之后，再次运行 git status 和 git status -s 命令，会看到如下的内容：</p><p>文件 index.html 出现在 Changes not staged for commit 这行下面，说明已跟踪文件的内容发生了变化，但还没有放到暂存区。</p><p>注意：修改过的、没有放入暂存区的文件前面有红色的 M 标记。</p><h5 id="暂存已修改的文件"><a href="#暂存已修改的文件" class="headerlink" title="暂存已修改的文件"></a>暂存已修改的文件</h5><p>目前，工作区中的 index.html 文件已被修改，如果要暂存这次修改，需要再次运行 git add 命令，这个命令是个多功能的命令，主要有如下 3 个功效：</p><p>① 可以用它开始跟踪新文件</p><p>② 把已跟踪的、且已修改的文件放到暂存区</p><p>③ 把有冲突的文件标记为已解决状态</p><h5 id="提交已暂存的文件"><a href="#提交已暂存的文件" class="headerlink" title="提交已暂存的文件"></a>提交已暂存的文件</h5><p>再次运行 git commit -m “提交消息” 命令，即可将暂存区中记录的 index.html 的快照，提交到 Git 仓库中进行保存：</p><h5 id="撤销对文件的修改"><a href="#撤销对文件的修改" class="headerlink" title="撤销对文件的修改"></a>撤销对文件的修改</h5><p>撤销对文件的修改指的是：把对工作区中对应文件的修改，还原成 Git 仓库中所保存的版本。</p><p>操作的结果：所有的修改会丢失，且无法恢复！危险性比较高，请慎重操作！</p><p>撤销操作的本质：用 Git 仓库中保存的文件，覆盖工作区中指定的文件。</p><h5 id="向暂存区中一次性添加多个文件"><a href="#向暂存区中一次性添加多个文件" class="headerlink" title="向暂存区中一次性添加多个文件"></a>向暂存区中一次性添加多个文件</h5><p>如果需要被暂存的文件个数比较多，可以使用如下的命令，一次性将所有的新增和修改过的文件加入暂存区：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure><p>今后在项目开发中，会经常使用这个命令，将新增和修改过后的文件加入暂存区。</p><h5 id="取消暂存的文件"><a href="#取消暂存的文件" class="headerlink" title="取消暂存的文件"></a>取消暂存的文件</h5><p>如果需要从暂存区中移除对应的文件，可以使用如下的命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git reset HEAD 要移除的文件名</span><br></pre></td></tr></table></figure><h5 id="跳过使用暂存区域"><a href="#跳过使用暂存区域" class="headerlink" title="跳过使用暂存区域"></a>跳过使用暂存区域</h5><p>Git 标准的工作流程是工作区 → 暂存区 → Git 仓库，但有时候这么做略显繁琐，此时可以跳过暂存区，直接将工作区中的修改提交到 Git 仓库，这时候 Git 工作的流程简化为了工作区 → Git 仓库。</p><p>Git 提供了一个跳过使用暂存区域的方式， 只要在提交的时候，给 git commit 加上 -a 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 git add 步骤：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git  commit -a -m &quot;描述信息&quot;</span><br></pre></td></tr></table></figure><h5 id="移除文件"><a href="#移除文件" class="headerlink" title="移除文件"></a>移除文件</h5><p>从 Git 仓库中移除文件的方式有两种：</p><p>①从 Git 仓库和工作区中同时移除对应的文件</p><p>②只从 Git 仓库中移除指定的文件，但保留工作区中对应的文件</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"># 从 Git 仓库和工作区中同时移除 index.js 文件</span><br><span class="line">git rm -f index.js</span><br><span class="line"># 只从 Git 仓库中移除 index.css 但保留工作区中的 index.css 文件</span><br><span class="line">git rm --cached index.css</span><br></pre></td></tr></table></figure><h5 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h5><p>一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。 在这种情况下，我们可以创建一个名为 .gitignore 的配置文件，列出要忽略的文件的匹配模式。</p><p>文件 .gitignore 的格式规范如下：</p><p>①以 # 开头的是注释</p><p>②以 &#x2F; 结尾的是目录</p><p>③以 &#x2F; 开头防止递归</p><p>④以 ! 开头表示取反</p><p>⑤可以使用 glob 模式进行文件和文件夹的匹配（glob 指简化了的正则表达式）</p><h5 id="glob-模式"><a href="#glob-模式" class="headerlink" title="glob 模式"></a>glob 模式</h5><p>所谓的 glob 模式是指简化了的正则表达式：</p><p>① <strong>星号 *</strong> 匹配零个或多个任意字符</p><p>② <strong>[abc]</strong> 匹配任何一个列在方括号中的字符 （此案例匹配一个 a 或匹配一个 b 或匹配一个 c）</p><p>③ <strong>问号</strong> <strong>?</strong> 只匹配一个任意字符</p><p>④ 在方括号中使用<strong>短划线</strong>分隔两个字符， 表示所有在这两个字符范围内的都可以匹配（比如 [0-9] 表示匹配所有 0 到 9 的数字）</p><p>⑤ <strong>两个星号 *</strong>* 表示匹配任意中间目录（比如 a&#x2F;**&#x2F;z 可以匹配 a&#x2F;z 、 a&#x2F;b&#x2F;z 或 a&#x2F;b&#x2F;c&#x2F;z 等）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 忽略所有的.a文件</span><br><span class="line">*.a</span><br><span class="line"># 但跟踪所有的lib.a, 即便你在前面忽略了.a文件</span><br><span class="line">!lib.a</span><br><span class="line"># 只忽略当前目录下的TODO文件，而不忽略subdir/TODO </span><br><span class="line">/TODO</span><br><span class="line"># 忽略任何目录下名为build的文件夹</span><br><span class="line">build/</span><br><span class="line"># 忽略doc/notes.txt,但不忽略doc/server/arch.txt</span><br><span class="line">doc/*.txt</span><br><span class="line"># 忽略doc/目录及其所有子目录下的.pdf文件</span><br><span class="line">doc/**/*.pdf</span><br></pre></td></tr></table></figure><h5 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h5><p>如果希望回顾项目的提交历史，可以使用 git log 这个简单且有效的命令</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 按时间先后顺序列出所有的提交历史，最近的提交排在最上面</span><br><span class="line">git log</span><br><span class="line"># 只展示最新的两条提交历史，数字可以按需进行填写</span><br><span class="line">git log -2</span><br><span class="line"># 在一行上展示最近两条提交历史的信息</span><br><span class="line">git log -2 --pretty=oneline</span><br><span class="line"># 在一行上展示最近两条提交历史的信息，并自定义输出的格式</span><br><span class="line"># %h提交的简写哈希值  %an作者名字  %ar作者修订日期，按多久以前的方式显示  %s提交说明</span><br><span class="line">git log -2 --pretty=format:&quot;%h | %an | %ar | %s&quot;</span><br></pre></td></tr></table></figure><h5 id="回退到指定的版本"><a href="#回退到指定的版本" class="headerlink" title="回退到指定的版本"></a>回退到指定的版本</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 在一行上展示所有的提交历史</span><br><span class="line">git log --pretty=oneline</span><br><span class="line"># 使用git reset --hard 命令，根据指定的提交ID回退到指定版本</span><br><span class="line">git reset --hard &lt;CommitID&gt; </span><br><span class="line"># 在旧版本中使用git reflog --pretty=oneline 命令，查看命令操作的历史</span><br><span class="line">git reflog --pretty=oneline</span><br><span class="line"># 再次根据最新的提交ID, 跳转到最新的版本</span><br><span class="line">git reset --hard &lt;CommitID&gt;</span><br></pre></td></tr></table></figure><h5 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h5><p>① 初始化 Git 仓库的命令</p><p>git init</p><p>② 查看文件状态的命令</p><p>git status 或 git status -s</p><p>③ 一次性将文件加入暂存区的命令</p><p>git add .</p><p>④ 将暂存区的文件提交到 Git 仓库的命令</p><p>git commit -m “提交消息”</p><h3 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h3><h5 id="开源许可协议"><a href="#开源许可协议" class="headerlink" title="开源许可协议"></a>开源许可协议</h5><p>开源并不意味着完全没有限制，为了限制使用者的使用范围和保护作者的权利，每个开源项目都应该遵守开源许可协议（ Open Source License ）。</p><p>常见的 5 种开源许可协议</p><p>① BSD（Berkeley Software Distribution）</p><p>② Apache Licence 2.0</p><p>③ <strong>GPL</strong>（GNU General Public License）</p><p>​具有传染性的一种开源协议，不允许修改后和衍生的代码做为闭源的商业软件发布和销售</p><p>​使用 GPL 的最著名的软件项目是：Linux</p><p>④ LGPL（GNU Lesser General Public License）</p><p>⑤ <strong>MIT</strong>（Massachusetts Institute of Technology, MIT）</p><p>​是目前限制最少的协议，唯一的条件：在修改后的代码或者发行包中，必须包含原作者的许可信息</p><p>​使用 MIT 的软件项目有：jquery、Node.js</p><p>关于更多开源许可协议的介绍，可以参考博客 <a href="https://www.runoob.com/w3cnote/open-source-license.html">https://www.runoob.com/w3cnote/open-source-license.html</a></p><p>专门用于免费存放开源项目源代码的网站，叫做<strong>开源项目托管平台</strong>。目前世界上比较出名的开源项目托管平台主要有以下 3 个：</p><p>​Github（全球最牛的开源项目托管平台，没有之一）</p><p>​Gitlab（对代码私有性支持较好，因此企业用户较多）</p><p>​Gitee（又叫做码云，是国产的开源项目托管平台。访问速度快、纯中文界面、使用友好）</p><p>注意：以上 3 个开源项目托管平台，只能托管以 Git 管理的项目源代码，因此，它们的名字都以 Git 开头。</p><p>Github 的官网首页 <a href="https://github.com/">https://github.com/</a></p><h5 id="远程仓库的两种访问方式"><a href="#远程仓库的两种访问方式" class="headerlink" title="远程仓库的两种访问方式"></a>远程仓库的两种访问方式</h5><p>Github 上的远程仓库，有两种访问方式，分别是 HTTPS 和 SSH。它们的区别是：</p><p>①HTTPS：零配置；但是每次访问仓库时，需要重复输入 Github 的账号和密码才能访问成功</p><p>②SSH：需要进行额外的配置；但是配置成功后，每次访问仓库时，不需重复输入 Github 的账号和密码</p><p>注意：在实际开发中，推荐使用 SSH 的方式访问远程仓库。</p><h5 id="SSH-key"><a href="#SSH-key" class="headerlink" title="SSH key"></a>SSH key</h5><p>SSH key 的<strong>作用</strong>：实现本地仓库和 Github 之间免登录的加密数据传输。</p><p>SSH key 的<strong>好处</strong>：免登录身份认证、数据加密传输。</p><p>SSH key 由<strong>两部分组成</strong>，分别是：</p><p>①id_rsa（私钥文件，存放于客户端的电脑中即可）</p><p>②id_rsa.pub（公钥文件，需要配置到 Github 中）</p><h6 id="生成-SSH-key"><a href="#生成-SSH-key" class="headerlink" title="生成 SSH key"></a>生成 SSH key</h6><p>①打开 Git Bash</p><p>②粘贴如下的命令，并将 <a href="mailto:&#121;&#x6f;&#117;&#x72;&#x5f;&#101;&#109;&#x61;&#x69;&#x6c;&#x40;&#x65;&#x78;&#x61;&#109;&#112;&#x6c;&#101;&#46;&#99;&#111;&#109;">&#121;&#x6f;&#117;&#x72;&#x5f;&#101;&#109;&#x61;&#x69;&#x6c;&#x40;&#x65;&#x78;&#x61;&#109;&#112;&#x6c;&#101;&#46;&#99;&#111;&#109;</a> 替换为注册 Github 账号时填写的邮箱：</p><p>l ssh-keygen -t rsa -b 4096 -C “<a href="mailto:&#121;&#x6f;&#117;&#x72;&#x5f;&#x65;&#109;&#97;&#x69;&#x6c;&#x40;&#101;&#120;&#x61;&#x6d;&#112;&#x6c;&#101;&#46;&#x63;&#111;&#x6d;">&#121;&#x6f;&#117;&#x72;&#x5f;&#x65;&#109;&#97;&#x69;&#x6c;&#x40;&#101;&#120;&#x61;&#x6d;&#112;&#x6c;&#101;&#46;&#x63;&#111;&#x6d;</a>“</p><p>③连续敲击 3 次回车，即可在 C:\Users\用户名文件夹.ssh 目录中生成 id_rsa 和 id_rsa.pub 两个文件</p><h6 id="配置-SSH-key"><a href="#配置-SSH-key" class="headerlink" title="配置 SSH key"></a><strong>配置</strong> SSH key</h6><p>①使用记事本打开 id_rsa.pub 文件，复制里面的文本内容</p><p>②在浏览器中登录 Github，点击头像 -&gt; Settings -&gt; SSH and GPG Keys -&gt; New SSH key</p><p>③将 id_rsa.pub 文件中的内容，粘贴到 Key 对应的文本框中</p><p>④在 Title 文本框中任意填写一个名称，来标识这个 Key 从何而来</p><h6 id="检测-Github-的-SSH-key-是否配置成功"><a href="#检测-Github-的-SSH-key-是否配置成功" class="headerlink" title="检测 Github 的 SSH key 是否配置成功"></a><strong>检测</strong> <strong>Github</strong> <strong>的</strong> <strong>SSH key</strong> 是否配置成功</h6><p>打开 Git Bash，输入如下的命令并回车执行：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br><span class="line">The authenticity of host &#x27; github.com (IP ADDRESS)&#x27;</span><br><span class="line">can&#x27;t be established. </span><br><span class="line">RSA key fingerprint is SHA256: nThbg6kXUpJWG17E1 IGOCspRomTxdCARLvi KW6E5SY8</span><br><span class="line">Are you sure you want to continue connecting (yes/no)?  输入 yes</span><br><span class="line">输入 yes 之后，如果能看到类似于下面的提示消息，证明 SSH key 已经配置成功了：</span><br><span class="line">Hi wangabnghui! You&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure><p>便可以基于 ssh 将本地仓库上传到Github</p><h6 id="将远程仓库克隆到本地"><a href="#将远程仓库克隆到本地" class="headerlink" title="将远程仓库克隆到本地"></a><strong>将远程仓库克隆到本地</strong></h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone 远程仓库的地址</span><br></pre></td></tr></table></figure><h3 id="Git-分支"><a href="#Git-分支" class="headerlink" title="Git 分支"></a>Git 分支</h3><h4 id="master-主分支"><a href="#master-主分支" class="headerlink" title="master 主分支"></a>master 主分支</h4><p>在初始化本地 Git 仓库的时候，Git 默认已经帮我们创建了一个名字叫做 master 的分支。通常我们把这个 master 分支叫做主分支。</p><p>在实际工作中，master 主分支的作用是：<strong>用来保存和记录整个项目已完成的功能代码</strong>。</p><p>因此，不允许程序员直接在 master 分支上修改代码，因为这样做的风险太高，容易导致整个项目崩溃。</p><p>由于程序员不能直接在 master 分支上进行功能的开发，所以就有了功能分支的概念。</p><p><strong>功能分支</strong>指的是专门用来开发新功能的分支，它是临时从 master 主分支上分叉出来的，当新功能开发且测试完毕后，最终需要合并到 master 主分支上。</p><h5 id="查看分支列表"><a href="#查看分支列表" class="headerlink" title="查看分支列表"></a>查看分支列表</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure><p>注意：分支名字前面的 ***** 号表示当前所处的分支。</p><h5 id="创建新分支"><a href="#创建新分支" class="headerlink" title="创建新分支"></a>创建新分支</h5><p>使用如下的命令，可以基于当前分支，创建一个新的分支，此时，新分支中的代码和当前分支完全一样：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch 分支名称</span><br></pre></td></tr></table></figure><h5 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout login # 切换到 login 上</span><br></pre></td></tr></table></figure><h5 id="分支的快速创建和切换"><a href="#分支的快速创建和切换" class="headerlink" title="分支的快速创建和切换"></a>分支的快速创建和切换</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout -b 分支名称</span><br></pre></td></tr></table></figure><p>注意：</p><p>“git checkout -b 分支名称” 是下面两条命令的简写形式：</p><p>①git branch 分支名称</p><p>②git checkout 分支名称</p><h5 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h5><p>功能分支的代码开发测试完毕之后，可以使用如下的命令，将完成后的代码合并到 master 主分支上：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout master  # 先切换值主分支</span><br><span class="line">git merge login   #合并</span><br></pre></td></tr></table></figure><p>合并分支时的注意点：</p><p>假设要把 C 分支的代码合并到 A 分支，则必须<strong>先切换到</strong> <strong>A</strong> <strong>分支</strong>上，<strong>再运行</strong> <strong>git merge</strong> <strong>命令</strong>，来合并 C 分支！</p><h5 id="遇到冲突时的分支合并"><a href="#遇到冲突时的分支合并" class="headerlink" title="遇到冲突时的分支合并"></a>遇到冲突时的分支合并</h5><p>如果在两个不同的分支中，对同一个文件进行了不同的修改，Git 就没法干净的合并它们。 此时，我们需要打开这些包含冲突的文件然后<strong>手动解决冲突</strong>。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 假设:在把reg分支合并到 master 分支期间，代码发生了冲突</span><br><span class="line">git checkout master</span><br><span class="line">git merge reg</span><br><span class="line"># 打开包含冲突的文件，手动解决冲突之后，再执行如下的命令</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;解决了分支合并冲突的问题”</span><br></pre></td></tr></table></figure><h5 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h5><p>当把功能分支的代码合并到 master 主分支上以后，就可以使用如下的命令，删除对应的功能分支：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch -d 分支名称</span><br></pre></td></tr></table></figure><h4 id="远程分支操作"><a href="#远程分支操作" class="headerlink" title="远程分支操作"></a>远程分支操作</h4><p>将本地分支推送到远程仓库</p><p>如果是<strong>第一次</strong>将本地分支推送到远程仓库，需要运行如下的命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># -u 表示把本地分支和远程分支进行关联，只在第一次推送的时候需要带 -u 参数</span><br><span class="line">git push -u 远程仓库的别名本地分支名称:远程分支名称</span><br><span class="line"># 实际案例:</span><br><span class="line">git push -u origin payment:pay</span><br><span class="line"># 如果希望远程分支的名称和本地分支名称保持一致，可以对命令进行简化:</span><br><span class="line">git push -u origin payment</span><br></pre></td></tr></table></figure><p>注意：第一次推送分支需要带 -u 参数，此后可以直接使用 git push 推送代码到远程分支。</p><h5 id="查看远程仓库中所有的分支列表"><a href="#查看远程仓库中所有的分支列表" class="headerlink" title="查看远程仓库中所有的分支列表"></a>查看远程仓库中所有的分支列表</h5><p>通过如下的命令，可以查看远程仓库中，所有的分支列表的信息：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote show 远程仓库名称</span><br></pre></td></tr></table></figure><h5 id="跟踪分支"><a href="#跟踪分支" class="headerlink" title="跟踪分支"></a>跟踪分支</h5><p>跟踪分支指的是：从远程仓库中，把远程分支下载到本地仓库中。需要运行的命令如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 从远程仓库中，把对应的远程分支下载到本地仓库，保持本地分支和远程分支名称相同</span><br><span class="line">git checkout 远程分支的名称</span><br><span class="line"># 示例:</span><br><span class="line">git checkout pay</span><br><span class="line"># 从远程仓库中，把对应的远程分支下载到本地仓库，并把下载的本地分支进行重命名</span><br><span class="line">git checkout -b 本地分支名称 远程仓库名称/远程分支名称</span><br><span class="line"># 示例:</span><br><span class="line">git checkout -b payment origin/pay</span><br></pre></td></tr></table></figure><h5 id="拉取远程分支的最新的代码"><a href="#拉取远程分支的最新的代码" class="headerlink" title="拉取远程分支的最新的代码"></a>拉取远程分支的最新的代码</h5><p>可以使用如下的命令，把远程分支最新的代码下载到本地对应的分支中：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure><h5 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h5><p>可以使用如下的命令，删除远程仓库中指定的分支：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#删除远程仓库中，指定名称的远程分支</span><br><span class="line">git push 远程仓库名称 --delete 远程分支名称</span><br><span class="line">#示例:</span><br><span class="line">git push origin --delete pay</span><br></pre></td></tr></table></figure><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>①能够掌握 Git 中基本命令的使用</p><p>git init</p><p>git add .</p><p>git commit –m “提交消息”</p><p>git status 和 git status -s</p><p>②能够使用 Github 创建和维护远程仓库</p><p>能够配置 Github 的 SSH 访问</p><p>能够将本地仓库上传到 Github</p><p>③能够掌握 Git 分支的基本使用</p><p>git checkout -b 新分支名称</p><p>git push -u origin 新分支名称</p><p>git checkout 分支名称</p><p>git branch</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发工具 </tag>
            
            <tag> IT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络规划与设计</title>
      <link href="/archives/974a452e.html"/>
      <url>/archives/974a452e.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
      
      <categories>
          
          <category> 网络设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IT </tag>
            
            <tag> 网络设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript基础</title>
      <link href="/archives/4b0178e0.html"/>
      <url>/archives/4b0178e0.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><h2 id="1-邂逅JavaScript"><a href="#1-邂逅JavaScript" class="headerlink" title="1.邂逅JavaScript"></a>1.邂逅JavaScript</h2><h3 id="1、认识编程语言"><a href="#1、认识编程语言" class="headerlink" title="1、认识编程语言"></a>1、认识编程语言</h3><p>计算机语言就是我们人和计算机进行交流要学习的语言</p><p>HTML：标记语言；CSS：样式语言；都属于计算机语言</p><p>JavaScript也是计算机语言，更精确来说是一门编程语言</p><p><strong>计算机语言：</strong>人与计算机之间通讯的语言，是人与计算机之间传递信息的介质，其概念比通用的编程语言要更广泛；</p><p><strong>编程语言</strong>：用来定义计算机程序的形式语言。它是一种被标准化的交流技巧，用来向计算机发出指令，一种能让程序员准确定义计算机所需使用数据的计算机语言，并准确的定义在不同情况下所应采取的行动。</p><p><strong>编程语言特点</strong>：</p><ul><li>数据和数据结构</li><li>指令及流程控制</li><li>引用机制和重用机制</li><li>设计哲学</li></ul><h3 id="2、编程语言发展史"><a href="#2、编程语言发展史" class="headerlink" title="2、编程语言发展史"></a>2、编程语言发展史</h3><p><strong>阶段一：</strong>机器语言，只由0和1组成 </p><p><strong>阶段二：</strong>汇编语言，用符号来代替冗长的、难以记忆的0和1代码，经过汇编器转化为0和1</p><p><strong>阶段三：</strong>高级语言，接近自然语言，更符合人类的思维方式</p><h3 id="3、JavaScript的历史"><a href="#3、JavaScript的历史" class="headerlink" title="3、JavaScript的历史"></a>3、JavaScript的历史</h3><p>javascript是一门高级的、解释型的编程语言</p><p>是一门基于原型的、头等函数的语言，是一门多范式的语言，支持面向对象程序设计、指令式编程、以及函数式编程</p><p>94年网景公司发布navigator浏览器0.9版，但是只能用于浏览，不具备与用户的交互能力。</p><p>95年招募Brendan Eich，希望将scheme语言作为网页脚本语言的可能性</p><p>同时，sun公司将oak语言更名为Java，管理层倾向于java，希望能简化java来适应脚本的需求</p><p>brendan eich不感兴趣并且用了十天设计了js，最初叫做mocha，在navigator2.0 beta更名为livescript，在navigator3.0beta 3 改名为javascript，为了搭上java热度</p><p>95年微软首推IE，并对navigator进行逆向发明了jscript</p><p>96.11月，网景正式向ECMA提交了语言规范</p><ul><li>97.6月，ECMA为javascript制定了ECMAScript标准规范</li></ul><p>所以，ecmascript是一种规范，而javascript是这种规范的一种实现</p><h3 id="4、JavaScript的组成"><a href="#4、JavaScript的组成" class="headerlink" title="4、JavaScript的组成"></a>4、JavaScript的组成</h3><p>定义语言规范：ECMAScript</p><p>DOM：用于操作文档的API</p><p>BOM：用于操作浏览器的API</p><h3 id="5、JavaScript运行引擎"><a href="#5、JavaScript运行引擎" class="headerlink" title="5、JavaScript运行引擎"></a>5、JavaScript运行引擎</h3><p>常见的js引擎：</p><ul><li>javascriptCore：webkit中的js引擎，apple公司开发</li><li>v8：Goole开发的强大的js引擎</li></ul><p>浏览器内核与js引擎的关系</p><p>webkit为例：</p><ul><li>webcore：负责html的解析、布局、渲染等相关工作（渲染层）</li><li>javascriptcore：解析、执行js代码（逻辑层）</li></ul><h3 id="6、JavaScript应用场景"><a href="#6、JavaScript应用场景" class="headerlink" title="6、JavaScript应用场景"></a>6、JavaScript应用场景</h3><p>web开发、移动端开发、小程序端开发、桌面应用开发、后端开发</p><h2 id="2-JavaScript的基本语法"><a href="#2-JavaScript的基本语法" class="headerlink" title="2.JavaScript的基本语法"></a>2.JavaScript的基本语法</h2><h3 id="1、javascript编写方式"><a href="#1、javascript编写方式" class="headerlink" title="1、javascript编写方式"></a>1、javascript编写方式</h3><ul><li>HTML代码内</li><li>script标签内</li><li>外部的js文件</li></ul><h3 id="2、noscript元素的使用"><a href="#2、noscript元素的使用" class="headerlink" title="2、noscript元素的使用"></a>2、noscript元素的使用</h3><p>如果运行的浏览器不支持js，需要一直优雅的处理方式</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;noscript&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>您的浏览器不支持js<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">&lt;/noscript&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">alert</span>(<span class="string">&#x27;您的浏览器正在运行js代码&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="3、javascript注意事项"><a href="#3、javascript注意事项" class="headerlink" title="3、javascript注意事项"></a>3、javascript注意事项</h3><ul><li>script元素不能写成单标签，在外联引用js文件时，script标签内不能编写js代码</li><li>省略type属性，以前的script标签中：type&#x3D;”text&#x2F;javascrpit”</li><li>加载顺序：自上而下，推荐放在body子元素的最后一行</li><li>js代码严格区分大小写</li></ul><h3 id="4、javascript交互方式"><a href="#4、javascript交互方式" class="headerlink" title="4、javascript交互方式"></a>4、javascript交互方式</h3><p>alert：接受一个参数，弹窗查看</p><p>console.log：接收多个参数，在浏览器控制台查看</p><p>document.write：接受多个字符串，在浏览器页面查看</p><p>prompt：接受一个参数，在浏览器接受用户输入</p><ul><li>代码出错可以再控制台console查看</li><li>控制台 &gt; 可以直接编写js代码，回车执行代码，shift+enter可以写多行代码</li><li>debug进行调试，查看代码的执行流程</li></ul><h3 id="5、javascript语句和分号"><a href="#5、javascript语句和分号" class="headerlink" title="5、javascript语句和分号"></a>5、javascript语句和分号</h3><p>语句是向浏览器发出的指令，通常表达为一个操作或行为</p><p>通常情况下每条语句的后面会添一个分号，表示语句的结束：</p><ul><li>当存在换行符时，在大多数情况下可以省略分号</li><li>js将换行理解为”隐式”分号</li><li>也称之为自动插入分号</li></ul><p>注释方式：&#x2F;*  … *&#x2F;：多行注释      &#x2F;&#x2F;：单行注释</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">文档注释  <span class="comment">// js文件中</span></span><br><span class="line"><span class="comment">/**.....*/</span></span><br></pre></td></tr></table></figure><p>Js中不支持注释的嵌套</p><p>插件：</p><p>log快速：react：clg</p><p>括号范围：bracket pair colorizer，里面配置设置.json</p><h2 id="3-JavaScript的变量和数据结构"><a href="#3-JavaScript的变量和数据结构" class="headerlink" title="3.JavaScript的变量和数据结构"></a>3.JavaScript的变量和数据结构</h2><h3 id="1、认识JavaScript变量"><a href="#1、认识JavaScript变量" class="headerlink" title="1、认识JavaScript变量"></a>1、认识JavaScript变量</h3><p>程序中变量的数据：</p><ul><li>购物车商品的数量、价格</li><li>游戏技能时间的冷却、血量</li></ul><h4 id="1-变化数据的记录—变量"><a href="#1-变化数据的记录—变量" class="headerlink" title="1.变化数据的记录—变量"></a>1.变化数据的记录—变量</h4><ul><li>一个变量就是用于存放数值的容器</li><li>这个数字可能是一个用于计算的数字，或字符串，或其他的任意数据</li><li>变量的独特之处在于它存放的数量是可以改变的</li></ul><p>可以把变量看做一个盒子，盒子里面装着我们的数据</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var message = &#x27;hello&#x27;</span><br><span class="line">message = &#x27;why&#x27;</span><br></pre></td></tr></table></figure><h4 id="2-变量的命名格式"><a href="#2-变量的命名格式" class="headerlink" title="2.变量的命名格式"></a>2.变量的命名格式</h4><p>定义一个变量包含两部分</p><ul><li>变量的声明：告诉js引擎接下来我要定一个变量</li><li>变量的赋值：使用  &#x3D;  给变量进行赋值</li></ul><p>可以同时声明多个变量</p><h3 id="2、变量的定义、规范"><a href="#2、变量的定义、规范" class="headerlink" title="2、变量的定义、规范"></a>2、变量的定义、规范</h3><p><strong>变量命名规则：</strong>必须遵守</p><ul><li>第一个字符必须是一个英文字母、下划线（_）、$符号</li><li>其他字符可以是字母、下划线、美元符号或数字</li><li>不能使用关键字和保留字命名</li><li>变量严格区分大小写</li></ul><p><strong>规范：</strong></p><ul><li>多个单词，驼峰命名法</li><li>推荐等号两边添加一个空格，结构清晰</li><li>语句结束加上分号</li><li>变量名字尽量见名知意</li></ul><p>如果变量未声明就使用，会直接报错  not defined</p><p>如果一个变量有声明但是没有赋值，会打印undefined</p><p>在js中也可以不使用var在全局声明一个变量（不推荐），如果不使用var来声明一个变量，也是可以声明成功的，而且这个变量会被加入到window对象中</p><h3 id="3、数据类型和typeof"><a href="#3、数据类型和typeof" class="headerlink" title="3、数据类型和typeof"></a>3、数据类型和typeof</h3><p>js中的值都有特定的类型，将值赋值给一个变量，那这么变量就具备了特定的类型</p><p>一个变量可以在前一刻是个字符串，下一刻就存储一个数字</p><p>允许这种操作的编程语言，比如js，称之为动态类型的编程语言</p><p>在js中有八种基本的数据类型（7中原始类型和一种复杂类型）</p><ul><li>Number（包括小数）</li><li>String</li><li>Boolean</li><li>Undefined</li><li>Null</li><li>Object</li><li>Bigint</li><li>Symbol</li></ul><p>因为ECMAScript的类型系统是松散的，所以需要一种手段来确定任意变量的数据类型</p><p>typeof应运而生，返回值：</p><p>“undefined”表示值未定义；</p><p>“boolean”表示值为布尔值；</p><p>“string”表示值为字符串；</p><p>“number”表示值为数值；</p><p>“object”表示值为对象（而不是函数）或null；</p><p>“function”表示值为函数；</p><p>“symbol”表示值为符号；</p><p>typeof(x)  它与typeof x 相同</p><p>typeof是一个操作符，它并非是一个函数，()只是将后续的内容当作一个整体而已</p><h3 id="4、常见的数据类型"><a href="#4、常见的数据类型" class="headerlink" title="4、常见的数据类型"></a>4、常见的数据类型</h3><h4 id="number类型"><a href="#number类型" class="headerlink" title="number类型"></a>number类型</h4><p>代表整数和浮点数，可以进行加减乘除，除了常规的数字，还包括特殊数值也属于number类型</p><ul><li>Infinity：代表无穷大，负无穷大：1&#x2F;0</li><li>NaN：代表一个计算错误，比如数字乘字符串</li></ul><p>最大的数字：Number.MAX_VALUE</p><p>最小的数字：Number.MIN_VALUE，小于这个数字会被转化为0</p><p>isNaN()来判断一个数字是不是数字，不是数字返回true</p><h4 id="string类型：字符串类型"><a href="#string类型：字符串类型" class="headerlink" title="string类型：字符串类型"></a>string类型：字符串类型</h4><p>在开发中我们经常会有一些文本需要表示，这个时候我们会使用字符串String：</p><ul><li>比如人的姓名：coderwhy。地址：广州市。简介：认真是一种可怕的力量</li></ul><p>JavaScript 中的字符串必须被括在引号里，有三种包含字符串的方式</p><ul><li><p>双引号：”Hello”</p></li><li><p>单引号：’Hello’</p></li><li><p>反引号：<code>Hello</code></p></li></ul><p>前后的引号类型必须一致：</p><ul><li><p>如果在字符串里面本身包括单引号，可以使用双引号</p></li><li><p>如果在字符串里面本身包括双引号，可以使用单引号</p></li></ul><p>引号：单引号、双引号、反引号（支持${表达式&#x2F;变量}）</p><p>前后的引号必须一致</p><p>转义字符：除了普通可打印的字符，一些特殊的字符可以通过转义字符的形式放在字符串中</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230227141333739.png" alt="image-20230227141333739"></p><p>字符串的操作：</p><ul><li>字符串拼接（+）</li><li>获取字符串长度（.length）</li></ul><h4 id="Boolean类型：用于表示真假"><a href="#Boolean类型：用于表示真假" class="headerlink" title="Boolean类型：用于表示真假"></a>Boolean类型：用于表示真假</h4><p>包含两个值：true；false</p><h4 id="Undefined类型"><a href="#Undefined类型" class="headerlink" title="Undefined类型"></a>Undefined类型</h4><p>只有一个值，undefined：声明了变量未赋值（未进行初始化）</p><ul><li>定义变量时候最好进行赋值，而不是只是声明</li><li>不要显示的将一个变量赋值为undefined<ul><li>可以初始化为0\null\空字符串等值</li></ul></li></ul><h4 id="Object类型"><a href="#Object类型" class="headerlink" title="Object类型"></a>Object类型</h4><p>是一个特殊的类型，通常称之为引用类型或者复杂类型</p><p>其他的数据类型我们称之为原始类型，因为它们的值只包含一个单独的内容</p><p>Object往往可以表示一组数据，是其他数据的一个集合，用{}表示一个对象</p><h4 id="Null类型"><a href="#Null类型" class="headerlink" title="Null类型"></a>Null类型</h4><p>只有一个值：null</p><p>通常用来表示一个对象为空，所以我们通常再给一个对象进行初始化时，会赋值为null</p><p>typeof识别为object</p><p>null与undefined的关系：</p><ul><li>undefined通常只有在一个变量声明但是未初始化时，默认为undefined才使用</li><li>并且我们不推荐给一个变量直接赋值为undefined，所以很少使用</li><li>null值非常常用，当一个变量准备保存一个对象，但是这个对象不确定时，可以先赋值为null</li></ul><h4 id="数据类型总结"><a href="#数据类型总结" class="headerlink" title="数据类型总结"></a>数据类型总结</h4><p>JavaScript 中有八种基本的数据类型（前七种为基本数据类型，也称为原始类型，而 object 为复杂数据类型，也称为引用类型）</p><ul><li>number 用于任何类型的数字：整数或浮点数</li><li>string 用于字符串：一个字符串可以包含 0 个或多个字符，所以没有单独的单字符类型</li><li>boolean 用于 true 和 false</li><li>undefined 用于未定义的值 —— 只有一个 undefined 值的独立类型</li><li>object 用于更复杂的数据结构</li><li>null 用于未知的值 —— 只有一个 null 值的独立类型</li><li>symbol 用于唯一的标识符</li><li>bigint 用于任意长度的整数。</li></ul><h3 id="5、数据类型的转换"><a href="#5、数据类型的转换" class="headerlink" title="5、数据类型的转换"></a>5、数据类型的转换</h3><p>在大多数情况下，运算符和函数会自动将赋予它们的值转换为正确的类型，这是一种隐式转换</p><p>我们也可通过显式的方式来对数据进行类型转换</p><h4 id="1-字符串String的转换"><a href="#1-字符串String的转换" class="headerlink" title="1.字符串String的转换"></a>1.字符串String的转换</h4><p>方式1：隐式转换</p><ul><li>一个字符串和其他类型进行+操作<ul><li>+运算符左右两边有一个是字符串，那么另一边会自动转换为字符串再进行拼接操作</li></ul></li><li>某些函数的执行也会自动将参数转为字符串类型<ul><li>比如log函数</li></ul></li></ul><p>方式2：显式转换</p><ul><li>调用String()函数</li><li>调用toString方法</li></ul><h4 id="2-数字类型Number的转换"><a href="#2-数字类型Number的转换" class="headerlink" title="2.数字类型Number的转换"></a>2.数字类型Number的转换</h4><p>方式1：隐式转换</p><ul><li>在算数运算中，通常会将其他类型转换为数字类型来进行计算<ul><li>比如：“6”&#x2F;“2”</li><li>但是如果是+运算，并且其中一边有字符串，那么还是按照字符串来连接的</li></ul></li></ul><p>方式2：显示转换</p><ul><li>Numbe() 函数</li></ul><h5 id="其他类型转换数字的规则"><a href="#其他类型转换数字的规则" class="headerlink" title="其他类型转换数字的规则"></a>其他类型转换数字的规则</h5><p>undefined—&gt;NaN</p><p>null—&gt;0</p><p>true和false—&gt;1and0</p><p>string—&gt;去掉首尾空格后的纯数字字符串中含有的数字；如果剩余字符串为空，则转换为0；否则，将会从剩余字符串中“读取”数字；当类型转换出现error时返回NaN</p><h4 id="3-布尔类型Boolean的转换"><a href="#3-布尔类型Boolean的转换" class="headerlink" title="3.布尔类型Boolean的转换"></a>3.布尔类型Boolean的转换</h4><p> 隐式转换的规则：</p><p>1.直观上为空的值转换成boolean类型都是false</p><ul><li><p>直观上空的值：0&#x2F;“”&#x2F;undefined&#x2F;null&#x2F;NaN -&gt; false</p></li><li><p>其他值：true</p></li></ul><p>2.显示转换</p><ul><li>Boolean()</li></ul><p>包含0的字符串转化是true</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Boolean</span>(<span class="string">&quot;&quot;</span>));  <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Boolean</span>(<span class="string">&quot;0&quot;</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="4-JavaScript基础运算符"><a href="#4-JavaScript基础运算符" class="headerlink" title="4.JavaScript基础运算符"></a>4.JavaScript基础运算符</h2><h3 id="1、运算符和运算元"><a href="#1、运算符和运算元" class="headerlink" title="1、运算符和运算元"></a>1、运算符和运算元</h3><p>认识运算符（operators）：加（+）、减（-）、乘（*）、除（&#x2F;）</p><p>运算元：运算符应用的对象</p><ul><li>5*2: 5 和 2 就是运算元</li></ul><p>如果一个运算符对应的只有一个运算元，那么它是一元运算符</p><ul><li>-10</li></ul><p>如果一个运算符拥有两个运算元，那么就是二元运算符</p><h3 id="2、算术运算符"><a href="#2、算术运算符" class="headerlink" title="2、算术运算符"></a>2、算术运算符</h3><p>用在数学表达式中，与数学方法一致</p><p>算术运算符是对数据进行计算的符号</p><p>Math.pow(2,3)  表示 2 的3次幂（es6）；   **  也是幂（es7）</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230405151813539.png" alt="image-20230405151813539"></p><h3 id="3、赋值运算符"><a href="#3、赋值运算符" class="headerlink" title="3、赋值运算符"></a>3、赋值运算符</h3><p>使用的 &#x3D; 就是赋值运算符</p><p>语句 x &#x3D; value 将value写入 x 然后返回 x</p><p>链式赋值（不推荐）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 = num2 = num3 = <span class="number">321</span></span><br></pre></td></tr></table></figure><ul><li>链式赋值从右往左计算</li><li>所有的变量共享一个值</li></ul><h5 id="原地修改"><a href="#原地修改" class="headerlink" title="原地修改"></a>原地修改</h5><p>我们经常需要对变量做运算，并将新的结果存放在同一变量中</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">100</span></span><br><span class="line">num = num + <span class="number">10</span></span><br></pre></td></tr></table></figure><ul><li>可以使用 +&#x3D;  *&#x3D; 来缩写</li></ul><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230227165921852.png" alt="image-20230227165921852"></p><p>所有的算术运算符都有简短的“修改并赋值”运算符：&#x2F;&#x3D; 和 -&#x3D; 等</p><h3 id="4、自增和自减"><a href="#4、自增和自减" class="headerlink" title="4、自增和自减"></a>4、自增和自减</h3><p>对一个数进行加一、减一是最常见的数学运算符之一</p><p>自增 ++ 将变量加一</p><p>自减 – 将变量减一</p><p>自增&#x2F;自减只能用于变量</p><ul><li>用在数值（5–）则会报错</li></ul><h5 id="和–的位置"><a href="#和–的位置" class="headerlink" title="++和–的位置"></a>++和–的位置</h5><p>独立使用的话++、–放在前后无所谓，放在后面称之为后置形式，放在前面称之为前置形式</p><p>都是+1，单独使用是看不到区别</p><p>如果我们要对变量进行自增操作时，并且需要立即使用自增后的值，那么需要使用前置形式</p><p>前置形式返回一个新的值，但后置返回原来的值</p><h3 id="5、运算符优先级"><a href="#5、运算符优先级" class="headerlink" title="5、运算符优先级"></a>5、运算符优先级</h3><p>运算符放在一起使用时会有一定的优先级</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence</a></p><h3 id="6、比较运算符"><a href="#6、比较运算符" class="headerlink" title="6、比较运算符"></a>6、比较运算符</h3><p>比大小的运算符</p><p>大于&#x2F;小于： &gt;   &lt;</p><p>大于等于：&gt;&#x3D;</p><p>相等：&#x3D;&#x3D;</p><p>不相等：！&#x3D;</p><p>比较运算符的结果都是boolean类型</p><h3 id="额外知识补充"><a href="#额外知识补充" class="headerlink" title="额外知识补充"></a>额外知识补充</h3><h4 id="x3D-x3D-和-x3D-x3D-x3D-的区别"><a href="#x3D-x3D-和-x3D-x3D-x3D-的区别" class="headerlink" title="&#x3D;&#x3D;和&#x3D;&#x3D;&#x3D;的区别"></a>&#x3D;&#x3D;和&#x3D;&#x3D;&#x3D;的区别</h4><p>&#x3D;&#x3D; 普通相等运算符，在类型不相同的情况下，会将运算元先转成Number类型的值，再进行比较</p><p>空字符串和false也是如此，会进行隐式转换</p><p>null比较特殊，内存地址：0X0，应该会被当成一个对象与原生类型进行比较</p><p>&#x3D;&#x3D;&#x3D; 严格相等运算符，在类型不相同的情况下，直接返回false</p><p>不相等：!&#x3D;；  严格不相等：!&#x3D;&#x3D;</p><p>严格代码稍长，但是能体现代码的意图</p><h2 id="5-JavaScript分支语句"><a href="#5-JavaScript分支语句" class="headerlink" title="5.JavaScript分支语句"></a>5.JavaScript分支语句</h2><h3 id="1、if分支语句"><a href="#1、if分支语句" class="headerlink" title="1、if分支语句"></a>1、if分支语句</h3><p>程序的三种执行方式</p><ul><li>顺序：从上到下，顺序执行</li><li>分支：根据条件判断，决定执行代码的分支</li><li>循环：让特定代码重复执行</li></ul><p>代码块：是多行执行代码的集合，通过一个{}放在一起</p><ul><li>在开发中，一行代码很难完成某一个特定的功能，我们将这些代码放在一个代码块中</li></ul><p>在js中，我们通过流程控制语句来决定如何执行一段代码块</p><ul><li>关键字</li><li>分支语句、循环语句</li></ul><p>分支结构</p><ul><li>根据条件来决定代码的执行</li><li>也称为判断结构或选择结构</li><li>几乎所有的编程语言都有分支结构</li></ul><p>js常见的分支结构</p><ul><li>if分支结构<ul><li>单分支结构<ul><li>if…</li></ul></li><li>多分支结构<ul><li>if…else…</li><li>if…esle if…else…</li></ul></li></ul></li><li>switch分支结构</li></ul><p>if 单分支结构</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件判断) &#123; 执行代码块 &#125; <span class="comment">// 条件判断为true就执行代码块</span></span><br></pre></td></tr></table></figure><p>如果代码块中只有一行代码，那么可以省略花括号，写在一排</p><p>if(…)语句会计算圆括号中的表达式，并将计算结果转换为布尔值，规则同Boolean函数</p><h3 id="2、if…else…语句"><a href="#2、if…else…语句" class="headerlink" title="2、if…else…语句"></a>2、if…else…语句</h3><p>多分支语句，if 语句有时会包含可选的else模块</p><p>如果判断条件不成立，就会执行它内部的代码</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件成立) &#123;成立的代码块&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;不成立的代码块&#125;</span><br></pre></td></tr></table></figure><h3 id="3、if…else-if…else语句"><a href="#3、if…else-if…else语句" class="headerlink" title="3、if…else if…else语句"></a>3、if…else if…else语句</h3><p>判断多个条件，可以使用 else if 实现</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件<span class="number">1</span>) &#123;代码块&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(条件<span class="number">2</span>) &#123;代码块&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;前面所有条件不成立&#125;</span><br></pre></td></tr></table></figure><h3 id="4、三元运算符"><a href="#4、三元运算符" class="headerlink" title="4、三元运算符"></a>4、三元运算符</h3><p>只是用if else语句可能会导致代码臃肿</p><p>三元运算符通过<code>？</code>表示</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> result = condition ? value1 : value2</span><br><span class="line"><span class="keyword">var</span> result = num1 &gt; num2 ? num1 : num2  <span class="comment">// 比较大小</span></span><br></pre></td></tr></table></figure><h3 id="5、逻辑运算符"><a href="#5、逻辑运算符" class="headerlink" title="5、逻辑运算符"></a>5、逻辑运算符</h3><p>主要有三个：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">||(或)：一个为真   &amp;&amp;(与)：同时为真    ！(非)：取反</span><br></pre></td></tr></table></figure><p>可以将多个表达式或值放在一起来获取到一个最终的结果</p><h5 id="逻辑-的本质"><a href="#逻辑-的本质" class="headerlink" title="逻辑||的本质"></a>逻辑||的本质</h5><ul><li>也称之为短路或</li><li>从左到右依次计算操作数</li><li>处理每一个操作数时，都会将其转化为布尔值</li><li>如果结果是true，就停止计算，返回这个<strong>操作数的初始值</strong></li><li>如果所有操作数都被计算过(也就是，转换结果都是false)，则返回最后一个<strong>操作数</strong></li></ul><p>返回的值是操作数的初始形式，不会转换为boolean类型</p><p>换句话说，一个或运算的链，将返回第一个真值，如果不存在真值，就返回该链的最后一个值</p><h5 id="逻辑-amp-amp-的本质"><a href="#逻辑-amp-amp-的本质" class="headerlink" title="逻辑&amp;&amp;的本质"></a>逻辑&amp;&amp;的本质</h5><ul><li>也称之为短路与</li><li>从左到右依次计算操作数</li><li>处理每一个操作数时，都会将其转化为布尔值</li><li>如果结果是false，就停止计算，返回这个<strong>操作数的原始值</strong></li><li>如果所有操作数都被计算过(都是真值)，则返回最后一个<strong>操作数</strong></li></ul><p>换句话说，与运算返回第一个假值，如果没有假值就返回最后一个值</p><h5 id="逻辑非的补充"><a href="#逻辑非的补充" class="headerlink" title="逻辑非的补充"></a>逻辑非的补充</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> message = <span class="string">&#x27;hello world&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Boolean</span>(message))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(!!message)</span><br></pre></td></tr></table></figure><p>逻辑非运算符接受一个参数，并按如下运算：</p><ul><li><p>步骤一：将操作数转化为布尔类型：true&#x2F;false</p></li><li><p>步骤二：返回相反的值；</p></li></ul><p>两个非运算 !! 有时候用来将某个值转化为布尔类型</p><ul><li><p>也就是，第一个非运算将该值转化为布尔类型并取反，第二个非运算再次取反</p></li><li><p>最后我们就得到了一个任意值到布尔值的转化。</p></li></ul><h3 id="6、switch语句"><a href="#6、switch语句" class="headerlink" title="6、switch语句"></a>6、switch语句</h3><p>switch 是分支结构的一种语句</p><ul><li>通过判断表达式的结果（或者变量）是否等于case语句的常量，来执行相应的分支体的</li></ul><p>与if不同的是，switch语句只能做值的严格相等判断（&#x3D;&#x3D;&#x3D;），而 if 语句可以做值的范围判断</p><ul><li><p>switch语句至少一个 case 代码块和一个可选的 default 代码块</p></li><li><p>默认情况下会有 case 穿透，case语句结束后会执行下一条case语句，添加break会跳出 switch，不执行后续代码</p></li></ul><h2 id="6-JavaScript循环语句"><a href="#6-JavaScript循环语句" class="headerlink" title="6.JavaScript循环语句"></a>6.JavaScript循环语句</h2><h3 id="1、认识循环语句"><a href="#1、认识循环语句" class="headerlink" title="1、认识循环语句"></a>1、认识循环语句</h3><p>生活中：对一个列表进行累加、将1到10数字逐个输出等等</p><p>循环是一种重复运行同一代码的方法</p><ul><li>如果是对某一列表进行循环操作，我们通常称之为遍历或者迭代</li></ul><p>三种循环方式：</p><ul><li>while循环</li><li>do…while循环</li><li>for循环</li></ul><h3 id="2、while-循环"><a href="#2、while-循环" class="headerlink" title="2、while 循环"></a>2、while 循环</h3><p>当条件成立时，执行代码块</p><p>当条件不成立时，跳出代码块</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(循环条件) &#123;</span><br><span class="line">    <span class="comment">// 循环代码块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果条件一直成立，那么会产生死循环</p><ul><li><p>这时候必须通过关闭网页来停止死循环</p></li><li><p>开发中一定要避免死循环的产生</p></li></ul><h3 id="3、do…while-循环"><a href="#3、do…while-循环" class="headerlink" title="3、do…while 循环"></a>3、do…while 循环</h3><p>do…while 循环与while循环非常像，二者经常可以相互替代</p><p>但是do…while的特点是不管条件成不成立，do循环都会先执行一次</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    <span class="comment">//循环代码块</span></span><br><span class="line">&#125; <span class="keyword">while</span>(循环条件)</span><br></pre></td></tr></table></figure><h3 id="4、for-循环"><a href="#4、for-循环" class="headerlink" title="4、for 循环"></a>4、for 循环</h3><p>for循环更加复杂，但它是最常用的循环形式</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(begin;condition;step)&#123;</span><br><span class="line">    <span class="comment">//循环代码块body</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>begin：进入循环时执行一次</li><li>condition：在每次循环迭代之前检查：如果为false，停止循环</li><li>循环体：条件为真时，重复运行</li><li>step：在每次循环迭代后执行</li></ul><p>begin执行一次，然后进行迭代：每次检查condition后，执行body和step</p><p><strong>for循环的嵌套</strong></p><ul><li>在开发中，某下情况下一次循环是无法达到目的的，需要使用循环的嵌套</li></ul><p>for循环的嵌套：循环中执行体又嵌套了循环</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">九九乘法表</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&#x27;&lt;table&gt;&#x27;</span>)</span><br><span class="line"><span class="comment">// 九九乘法表</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&quot;&lt;tr&gt;&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>;j &lt; i + <span class="number">1</span>; j++)&#123;</span><br><span class="line">        <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">`&lt;td&gt;<span class="subst">$&#123;j+<span class="number">1</span>&#125;</span>×<span class="subst">$&#123;i+<span class="number">1</span>&#125;</span>=<span class="subst">$&#123;(j+<span class="number">1</span>)*(i+<span class="number">1</span>)&#125;</span>&lt;/td&gt;`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&quot;&lt;/tr&gt;&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&#x27;&lt;/table&gt;&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="5、循环控制—break、continue"><a href="#5、循环控制—break、continue" class="headerlink" title="5、循环控制—break、continue"></a>5、循环控制—break、continue</h3><p>在执行循环过程中，遇到某一个条件时</p><ul><li>循环体不再执行(即使没有执行完)，跳出循环</li><li>本次循环体不再执行，执行下一次的循环体</li></ul><p>break：直接跳出循环，循环结束</p><ul><li>break在某一条件满足时，退出循环，不再执行后续重复的代码</li></ul><p>continue：跳过本次循环次，执行下一次循环体</p><ul><li>continue是break的”轻量版”</li><li>continue 在满足某一条件时，不执行后续重复的代码</li></ul><h3 id="6、案例练习"><a href="#6、案例练习" class="headerlink" title="6、案例练习"></a>6、案例练习</h3><p>随机数的生成</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">100</span>)    <span class="comment">// [0,1)</span></span><br></pre></td></tr></table></figure><h2 id="7-JavaScript函数"><a href="#7-JavaScript函数" class="headerlink" title="7.JavaScript函数"></a>7.JavaScript函数</h2><h3 id="1、认识-JavaScript-函数"><a href="#1、认识-JavaScript-函数" class="headerlink" title="1、认识 JavaScript 函数"></a>1、认识 JavaScript 函数</h3><p>foo、bar、baz：通常被用做函数、变量、文件的名词，计算机编程术语的一部分，本身没有别的用途和意义，被称为“伪变量”</p><p>什么是函数呢？</p><p>alert函数、prompt函数、log函数、String&#x2F;Number&#x2F;Boolean函数</p><p>函数是某种特定功能的代码的封装，帮助我们完成特定的功能</p><p>函数的使用</p><ul><li>声明函数—封装独立的功能</li><li>调用函数—享受封装的成果</li></ul><p>函数的作用：在开发程序时，使用函数可以提高编写的效率以及代码的重用</p><h3 id="2、函数的声明和调用"><a href="#2、函数的声明和调用" class="headerlink" title="2、函数的声明和调用"></a>2、函数的声明和调用</h3><p>声明函数使用function关键字：这种写法称之为函数的定义</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> 函数名() &#123; 函数封装的代码块 &#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>函数名的命名规则和前面变量名的命名规则是相同的</li><li>函数要尽量做到见名知意（一般是动词）</li><li>函数定义完后里面的代码是不会执行的，函数必须调用才会执行</li></ul><p>函数的参数：增加函数的通用性，针对相同的数据处理逻辑，能够适应更多的数据</p><ul><li>在函数内部，把参数当做变量使用，进行需要的数据处理</li><li>在函数调用时，按照函数定义的参数顺序，把希望在函数内部处理的数据，通过参数传递</li></ul><p>形参和实参</p><ul><li>形参（parameters）：定义函数时，小括号中的参数，是用来接收参数用的，在函数内部作为变量使用</li><li>实参（arguments）：调用函数时，小括号里的参数，是用来把数据传递到函数内部用的</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// name 称之为函数的参数（形参，形式参数）</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printInfo</span>(<span class="params">name</span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`my name is <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &#x27;wbh&#x27; 称之为函数的参数（实参，实际参数）</span></span><br><span class="line"><span class="title function_">printInfo</span>(<span class="string">&#x27;wbh&#x27;</span>)</span><br></pre></td></tr></table></figure><p>函数的返回值</p><p>函数不仅可以有参数，还可以有返回值</p><ul><li>使用return关键字来返回结果</li><li>一旦函数中执行returan操作，那么当前函数会终止</li><li>如果函数中没有使用return语句，那么函数会有默认的返回值：undefined</li><li>如果函数使用return语句，但是return后面没有任何值，那么函数的返回值也是undefined</li></ul><p>事实上在函数中有一个特别的对象：arguments对象</p><ul><li>默认情况下，arguments对象是所有(非箭头)函数中都可用的局部变量</li><li>该对象中存放着所有调用者传入的参数，从0位置开始，依次存放</li><li>arguments变量的类型是一个object类型(array-like)，不是一个数组，但是和数组的用法看起来很像</li><li>如果调用者传入的参数多于函数接收的参数，可以通过arguments去获取所有的参数</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(name)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>)</span><br><span class="line">    <span class="comment">// arguments是一个对象</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="variable language_">arguments</span>) </span><br><span class="line">    <span class="comment">// 对arguments进行遍历</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;<span class="variable language_">arguments</span>.<span class="property">length</span>;i++) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>[i])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>(<span class="string">&#x27;why&#x27;</span>,<span class="number">23</span>,<span class="number">445</span>,<span class="string">&quot;大连市&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="3、函数的递归调用"><a href="#3、函数的递归调用" class="headerlink" title="3、函数的递归调用"></a>3、函数的递归调用</h3><p>在开发中，函数内部是可以调用另外一个函数的</p><p>那么可以调用自己吗？</p><ul><li>可以的</li><li>但是必须有结束条件，否则会产生无限调用，造成报错</li></ul><p>函数调用自己—递归（recursion）</p><p>编程的递归调用</p><ul><li>将一个复杂的任务，转化成可以重复执行的相同任务</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">pow</span>(<span class="params">x,n</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(n=<span class="number">1</span>) <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">return</span> x*<span class="title function_">pow</span>(x,n-<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、局部和全局变量"><a href="#4、局部和全局变量" class="headerlink" title="4、局部和全局变量"></a>4、局部和全局变量</h3><p>在 javascript（es5之前）中没有块级作用域的概念，var 定义的变量是没有块级作用域</p><p>但是函数可以定义自己的作用域（scope）</p><p>作用域：表示一些标识符的作用有效范围</p><p>函数的作用域表示在函数内部定义的变量，只有在函数内部可以被访问到</p><ul><li><p>es5 之前函数代码块是会形成自己的作用域的</p></li><li><p>在函数内部定义的变量在外面是拿不到的</p></li></ul><p>全局变量：在全局（script元素中）定义一个变量，那么这个变量是可以在定义之后的任何范围内被访问到，那么称这个变量为全局变量，在任何函数中可见，通过var定义的变量会被添加到window中</p><p>内部变量：局部变量，在函数内部定义的变量，只有在函数的内部才能访问，称之为局部变量</p><p>外部变量：在函数内部去访问函数之外的变量，被访问的变量称之为外部变量，（定义在函数外部的变量）</p><p>在函数中，访问变量的顺序</p><ul><li>优先访问自己函数中的变量，没有找到时，在外部中访问</li></ul><h3 id="5、函数表达式的写法"><a href="#5、函数表达式的写法" class="headerlink" title="5、函数表达式的写法"></a>5、函数表达式的写法</h3><p>在js中，函数并不是一种神奇的语法结构，而是一种特殊的值</p><ul><li>前面定义函数的方式，我们称之为函数的声明</li></ul><p>函数表达式写法：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> bar = <span class="keyword">function</span>(<span class="params"></span>) &#123; &#125;</span><br></pre></td></tr></table></figure><p>function关键字后面没有函数名</p><ul><li>函数表达式允许省略函数名</li></ul><p>无论函数是如何创建的，函数都是一个值</p><p>在js开发中，我们可以将函数作为头等公民</p><h5 id="声明-vs-表达式"><a href="#声明-vs-表达式" class="headerlink" title="声明 vs 表达式"></a>声明 vs 表达式</h5><ul><li>语法不同<ul><li>函数声明：在主代码流中声明为单独的语句的函数</li><li>函数表达式：在一个表达式中或另一个语法结构中创建的函数</li></ul></li><li>创建函数的时机不同<ul><li>函数表达式是在代码执行到达时被创建，并且仅在那一刻起可用</li><li>在函数声明被定义之前，它就可以被调用<ul><li>这是内部算法的缘故</li><li>当javascript准备运行脚本时，首先会在脚本中寻找全局函数声明，并创建这些函数</li></ul></li></ul></li></ul><h5 id="开发中如何选择"><a href="#开发中如何选择" class="headerlink" title="开发中如何选择"></a>开发中如何选择</h5><p>首选考虑函数声明语法</p><p>它能够为组织代码提供更多的灵活性，因为我们可以在声明这些函数之前调用这些函数</p><h3 id="6、函数的头等公民"><a href="#6、函数的头等公民" class="headerlink" title="6、函数的头等公民"></a>6、函数的头等公民</h3><p>头等函数（第一等函数）：是指在程序设计语言中，函数被当做头等公民</p><ul><li>这意味着，函数可以作为别的函数的参数、函数的返回值，赋值给变量或存储在数据结构中</li><li>有人主张也应包括支持匿名函数</li></ul><p>通常对作为头等公民的编程方式，称之为函数式编程</p><ul><li>JavaScript 就是符合函数式编程的语言，这也是 js 的一大特点</li></ul><h5 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h5><p>既然一个函数可以在变量中来回传递，那么也可以传递给另外一个函数</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">fn</span>)&#123;</span><br><span class="line">    <span class="title function_">fn</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;执行了bar函数&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>(bar)</span><br></pre></td></tr></table></figure><p>foo这种函数我们也可以称之为高阶函数</p><h5 id="高阶函数必须满足两个条件之一"><a href="#高阶函数必须满足两个条件之一" class="headerlink" title="高阶函数必须满足两个条件之一"></a>高阶函数必须满足两个条件之一</h5><ul><li>接受一个或者多个函数作为输入</li><li>输出一个函数</li></ul><h5 id="匿名函数的理解"><a href="#匿名函数的理解" class="headerlink" title="匿名函数的理解"></a>匿名函数的理解</h5><p>如果在传入一个函数时，我们没有指定这个函数的名称或者通过函数表达式指定函数对应的变量，那么这个函数称之为匿名函数</p><h3 id="7、立即执行函数"><a href="#7、立即执行函数" class="headerlink" title="7、立即执行函数"></a>7、立即执行函数</h3><p>一个函数定义完后被立即执行</p><ul><li>第一部分是定义了一个匿名函数，这个函数有自己独立的作用域</li><li>第二部分是后面的()，表示这个函数被执行了</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>)&#123;  <span class="comment">// 函数名可以删除</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;bar函数被立刻执行&#x27;</span>)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p>会创建一个独立的执行上下文环境，可以避免外界访问或修改内部的变量，也避免了对内部变量的修改</p><h5 id="立即执行函数的其他写法"><a href="#立即执行函数的其他写法" class="headerlink" title="立即执行函数的其他写法"></a>立即执行函数的其他写法</h5><p>立即执行函数必须是一个表达式，不能是函数声明</p><p>当圆括号出现在匿名函数的末尾想要调用函数时，会默认将函数当成是函数声明</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="title function_">clg</span>(<span class="string">&quot;立即执行函数&quot;</span>) </span><br><span class="line">&#125;()  <span class="comment">// 错误写法</span></span><br></pre></td></tr></table></figure><p>当圆括号包裹函数时，会默认将函数作为表达式去解析，而不是函数声明</p><p>下面方法也可</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 3.其他写法</span></span><br><span class="line"><span class="comment">// 匿名函数</span></span><br><span class="line"><span class="comment">// (function(fn) &#123;</span></span><br><span class="line"><span class="comment">//   console.log(&#x27;立即执行函数被调用&#x27;)</span></span><br><span class="line"><span class="comment">// &#125;())</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// + - !</span></span><br><span class="line">+<span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;立即执行函数&#x27;</span>)</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><h3 id="8、代码规范"><a href="#8、代码规范" class="headerlink" title="8、代码规范"></a>8、代码规范</h3><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230302102120792.png" alt="image-20230302102120792"></p><h2 id="8-JavaScript的面向对象"><a href="#8-JavaScript的面向对象" class="headerlink" title="8.JavaScript的面向对象"></a>8.JavaScript的面向对象</h2><h3 id="1、对象类型的使用"><a href="#1、对象类型的使用" class="headerlink" title="1、对象类型的使用"></a>1、对象类型的使用</h3><p>对象类型是一种存储键值对（key-value）的更复杂的数据类型</p><ul><li>键值对可以是属性和方法</li><li>其中key是字符串<ul><li>key是字符串类型，但是在定义对象的属性名时，大部分情况下引号都是可以省略的</li></ul></li><li>value可以是任意类型，包括基本数据类型、函数类型、对象类型等</li></ul><p>两个术语：函数&#x2F;方法</p><p>​    函数（function）：如果在js中通过function默认定义一个结构，称之为函数</p><p>​    方法(method)：如果将一个函数放到对象中，并作为对象的一个属性，那么这个函数称之为方法</p><h5 id="创建对象和使用对象"><a href="#创建对象和使用对象" class="headerlink" title="创建对象和使用对象"></a>创建对象和使用对象</h5><p>创建对象的方式很多，包括三种：</p><ul><li>对象字面量：通过{}</li><li>new Object + 动态添加属性</li><li>new 其他类</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.字面量创建</span></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;why&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2.new object</span></span><br><span class="line"><span class="comment">// Object 构造函数</span></span><br><span class="line"><span class="keyword">var</span> obj2 = <span class="keyword">new</span> <span class="title class_">Object</span>()</span><br><span class="line">obj2.<span class="property">name</span> = <span class="string">&#x27;kobe&#x27;</span></span><br><span class="line"><span class="comment">// 3.new 其他类()</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> obj3 = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj3)</span><br></pre></td></tr></table></figure><p>属性之间是以逗号分割的</p><p>对象的使用：</p><ul><li>访问对象的属性</li><li>修改对象的属性</li><li>添加对象的属性</li><li>删除对象的属性：delete 关键字</li></ul><h5 id="方括号和引用的使用"><a href="#方括号和引用的使用" class="headerlink" title="方括号和引用的使用"></a>方括号和引用的使用</h5><p>对于多词属性来说，js是无法理解的</p><p>而点符号要求key是有效的变量标识符</p><ul><li>不包含空格、不以数字开头、也不包含特殊字符(允许使用$和_)</li></ul><p>这时候可以使用方括号来获取对象的属性 </p><h5 id="对象的遍历"><a href="#对象的遍历" class="headerlink" title="对象的遍历"></a>对象的遍历</h5><p>表示获取对象中所有的属性和方法</p><p>Object.keys() 方法会返回一个由一个给定对象的自身可枚举属性组成的数组</p><ul><li>普通的for循环</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> userKeys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(user)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; userKeys.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> key = userKeys[i]</span><br><span class="line">  <span class="keyword">var</span> value = user[key]</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`key: <span class="subst">$&#123;key&#125;</span>, value: <span class="subst">$&#123;value&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>for…in…遍历，key 即是属性，user[key] 这是对应的值</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> user) &#123;</span><br><span class="line">  <span class="keyword">var</span> value = user[key]</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`key: <span class="subst">$&#123;key&#125;</span>, value: <span class="subst">$&#123;value&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>for…of..不能遍历，因为对象默认是不可迭代的，for of 对数组有效</li></ul><h5 id="栈内存和堆内存"><a href="#栈内存和堆内存" class="headerlink" title="栈内存和堆内存"></a>栈内存和堆内存</h5><p>程序是需要加载到内存中执行的，我们可以将内存划分为两个区域，栈内存和堆内存</p><p>原始类型占据的空间是在栈内存中分配的</p><p>对象类型占据的空间是在堆内存中分配的</p><h3 id="2、值类型和引用类型"><a href="#2、值类型和引用类型" class="headerlink" title="2、值类型和引用类型"></a>2、值类型和引用类型</h3><p>原始类型的保存方式：在变量中保存的是值本身</p><ul><li>所以原始类型也被称之为值类型</li></ul><p>对象类型的保存方式：在变量中保存的是对象的“引用”</p><ul><li>所以对象类型也被称之为引用类型</li></ul><h3 id="3、函数的-this-指向"><a href="#3、函数的-this-指向" class="headerlink" title="3、函数的 this 指向"></a>3、函数的 this 指向</h3><p>函数中是有一个this的变量，this变量在大多数情况下会指向一个对象</p><p>使用 this 方便在一个方法中，拿到当前对象的一些属性</p><p>情况一：如果普通的函数被默认调用，即全局环境下默认调用一个函数，那么this指向的是window</p><p>情况二：如果函数它是被某一个对象来引用并且调用它，即通过对象调用，那么this对指向这个对象(调用的那个对象)</p><p>this代表的是当前调用对象</p><h3 id="4、工厂方法创建类"><a href="#4、工厂方法创建类" class="headerlink" title="4、工厂方法创建类"></a>4、工厂方法创建类</h3><h5 id="1-类和对象的思维方式"><a href="#1-类和对象的思维方式" class="headerlink" title="1.类和对象的思维方式"></a>1.类和对象的思维方式</h5><p>创建一些列类似的对象，比如学生、游戏英雄，都具有姓名学号，但是具体的值不同</p><p>方法1：手动创建，但是重复代码很多</p><p>方法2：for循环，但是不能修改具体的值</p><p>方法3：工厂函数，一种常见的设计模式，但在js中大可不必这样做</p><p>工厂方法创建对象有一个比较大的问题：我们在打印对象时，对象的类型都是Object类型</p><ul><li>但是从某些角度来说，这些对象应该有一个他们共同的类型</li></ul><h5 id="2-构造函数的方式：使用new关键词（操作符）"><a href="#2-构造函数的方式：使用new关键词（操作符）" class="headerlink" title="2.构造函数的方式：使用new关键词（操作符）"></a>2.构造函数的方式：使用new关键词（操作符）</h5><ul><li>构造函数也被称之为构造器，通常我们在创建对象时会调用的函数</li><li>在其他编程语言，构造函数存在于类中的一个方法，称为构造方法</li><li>但在js中，构造函数扮演了其他语言中类的角色</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">coder</span>(<span class="params">name, age, height</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">height</span> = height</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">running</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;running&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在函数调用的前面加上 new 关键字(操作符)</span></span><br><span class="line"><span class="keyword">var</span> stu1 = <span class="keyword">new</span> <span class="title function_">coder</span>(<span class="string">&quot;why&quot;</span>, <span class="number">21</span>, <span class="number">157</span>)</span><br></pre></td></tr></table></figure><p>也就是在 JavaScript 中，构造函数其实就是类的扮演者：</p><p>比如系统默认给我们提供的 Date 就是一个构造函数，也可以看成是一个类</p><p>在ES5之前，我们都是通过 function 来声明一个构造函数（类）的，之后通过 new 关键字来对其进行调用</p><p>在ES6之后，JavaScript 可以像别的语言一样，通过 class 来声明一个类</p><h3 id="5、构造函数和类"><a href="#5、构造函数和类" class="headerlink" title="5、构造函数和类"></a>5、构造函数和类</h3><h5 id="1-什么是类（构造函数）"><a href="#1-什么是类（构造函数）" class="headerlink" title="1.什么是类（构造函数）"></a>1.什么是类（构造函数）</h5><ul><li><p>现实生活中往往是根据一份描述&#x2F;一个模板来创建一个实体对象的</p></li><li><p>编程语言也是一样, 也必须先有一份描述, 在这份描述中说明将来创建出来的对象有哪些属性(成员变量)和行为(成员方法)</p></li></ul><p>比如现实生活中，我们会如此来描述一些事物：</p><ul><li><p>比如水果fruits是一类事物的统称，苹果、橘子、葡萄等是具体的对象；</p></li><li><p>比如人person是一类事物的统称，而Jim、Lucy、Lily、李雷、韩梅梅是具体的对象；</p></li></ul><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230303155836052.png" alt="image-20230303155836052"></p><p>对象是由类创建出来的，类相当于设计图纸，用于描述对象的内容(属性)</p><p>类在没有调用的情况下是没有在内存中创建的，使用需要new操作符</p><p>JavaScript中类的表示形式就是构造函数。</p><h5 id="2-JavaScript中的构造函数是怎么样的？"><a href="#2-JavaScript中的构造函数是怎么样的？" class="headerlink" title="2.JavaScript中的构造函数是怎么样的？"></a>2.JavaScript中的构造函数是怎么样的？</h5><p>构造函数也是一个普通的函数，从表现形式来说，和千千万万个普通的函数没有任何区别；</p><p>那么如果这么一个普通的函数被使用new操作符来调用了，那么这个函数就称之为是一个构造函数；</p><p>如果一个函数被使用new操作符调用了，那么它会执行如下操作：</p><ol><li><p>在内存中创建一个新的对象（空对象）；</p></li><li><p>这个对象内部的[[prototype]]属性会被赋值为该构造函数的prototype属性；</p></li><li><p>构造函数内部的this，会指向创建出来的新对象；</p></li><li><p>执行函数的内部代码（函数体代码）；</p></li><li><p>如果构造函数没有返回非空对象，则返回创建出来的新对象；</p></li></ol><p>构造函数可以确保我们的对象是有我们定义的类型的（例如：student）</p><h5 id="3-全局对象window了解"><a href="#3-全局对象window了解" class="headerlink" title="3.全局对象window了解"></a>3.全局对象window了解</h5><p>浏览器中存在一个全局对象 Object —&gt; window</p><p>作用1：查找变量时，最终会查到 window 头上</p><p>作用2：将我们一些浏览器全局提供给我们的变量&#x2F;函数&#x2F;对象，放在 window 对象上</p><p>作用3：使用 var 定义的变量会被默认添加到 window 上面(设计缺陷)</p><p>浏览器看到后面添加了<strong>var</strong> message 信息，会对前方 clg.window 进行刷新，所以前方打印的window对象中可以查看到 message定义的信息</p><p>函数也是对象</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义对象类型的变量</span></span><br><span class="line"><span class="comment">// 地址 -&gt; 指针 -&gt; 引用</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125; <span class="comment">// 堆内存</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125; <span class="comment">// 堆内存</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;&#125;  <span class="comment">// 堆内存</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// console.log(typeof obj)  //Object</span></span><br><span class="line"><span class="comment">// console.log(typeof foo)  // function -&gt; object</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Dog</span>(<span class="params"></span>) &#123; &#125;</span><br><span class="line"><span class="comment">// 构造函数上(类上面) 添加的函数，称之为类方法</span></span><br><span class="line"><span class="title class_">Dog</span>.<span class="property">running</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="title class_">Dog</span>.<span class="title function_">running</span>()</span><br></pre></td></tr></table></figure><h2 id="9-JavaScript常见的内置类"><a href="#9-JavaScript常见的内置类" class="headerlink" title="9.JavaScript常见的内置类"></a>9.JavaScript常见的内置类</h2><h3 id="1、认识包装类型"><a href="#1、认识包装类型" class="headerlink" title="1、认识包装类型"></a>1、认识包装类型</h3><p>原始类型的包装类</p><p>js的原始类型并非对象类型，所以理论上，他们是没法获取属性或调用方法的</p><p>那么出现这样的现象，是因为js为了使其可以获取属性和调用方法，对其封装了对应的包装类型</p><p>常见的包装类型：String、Number、Boolean、Symbol、Bigint类型</p><p>包装类型的使用过程，当我们使用原始类型的属性或者方法时</p><ul><li><p>根据原始值，创建一个原始类型对应的包装类型对象</p></li><li><p>调用对应的属性或者方法，返回一个新的值</p></li><li><p>创建的包装类对象被销毁</p></li><li><p>通常JavaScript引擎会进行很多的优化，它可以跳过创建包装类的过程在内部直接完成属性的获取或者方法的调用</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;why&quot;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> num1)  <span class="comment">// object</span></span><br></pre></td></tr></table></figure><p>注意事项：null、undefined 没有任何的方法，也没有对应的 “ 对象包装型 ”</p><h3 id="2、数字类型Number"><a href="#2、数字类型Number" class="headerlink" title="2、数字类型Number"></a>2、数字类型Number</h3><h4 id="1-属性补充："><a href="#1-属性补充：" class="headerlink" title="1.属性补充："></a>1.属性补充：</h4><ul><li>Number.MAX_SAFE_INTEGER：JavaScript 中最大的安全整数 (2^53 - 1) </li><li>Number.MIN_SAFE_INTEGER：JavaScript 中最小的安全整数 -(2^53 - 1)</li></ul><h4 id="2-实例方法补充"><a href="#2-实例方法补充" class="headerlink" title="2.实例方法补充"></a>2.实例方法补充</h4><p> 方法一：toString(base)，将数字转成字符串，并且按照base进制进行转化</p><ul><li><p>base 的范围可以从 2 到 36，默认情况下是 10； </p></li><li><p>注意：如果是直接对一个数字操作，需要使用..运算符；</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num1.<span class="title function_">toString</span>(<span class="number">2</span>))  <span class="comment">// 转成2进制</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1000.</span>.<span class="title function_">toString</span>(<span class="number">2</span>))</span><br></pre></td></tr></table></figure><p>方法二：toFixed(digits)，格式化一个数字，保留digits位的小数，返回值是string类型； </p><ul><li><p>digits的范围是0到20（包含）之间；</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类方法：</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">parseInt</span>()  通过类名调用</span><br><span class="line"><span class="comment">// 实例方法：</span></span><br><span class="line"><span class="number">123.</span>.<span class="title function_">toFixed</span>(<span class="number">2</span>) 通过具体的对象调用</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-类方法补充"><a href="#3-类方法补充" class="headerlink" title="3.类方法补充"></a>3.类方法补充</h4><p>方法一：Number.parseInt(string[, radix])，将字符串解析成整数，也有对应的全局方法parseInt，不会四舍五入</p><p>方法二：Number. parseFloat(string)，将字符串解析成浮点数，也有对应的全局方法parseFloat</p><h3 id="3、数字对象Math"><a href="#3、数字对象Math" class="headerlink" title="3、数字对象Math"></a>3、数字对象Math</h3><p>Math 是一个内置对象（不是一个构造函数），它拥有一些数学常数属性和数学函数方法</p><p>常见的属性</p><ul><li>Math.PI：圆周率</li><li>Math.ceil：向上舍入取整 </li><li>Math.round：四舍五入取整 </li><li>Math.random：生成0~1的随机数（包含0，不包含1）</li><li>Math.pow(x, y)：返回x的y次幂</li></ul><h3 id="4、字符串类型String"><a href="#4、字符串类型String" class="headerlink" title="4、字符串类型String"></a>4、字符串类型String</h3><p>String 类提供了我们对于字符串各种操作的属性和方法</p><h4 id="1-常见的属性"><a href="#1-常见的属性" class="headerlink" title="1.常见的属性"></a>1.常见的属性</h4><ul><li>length：获取字符串的长度</li></ul><p>操作一：访问字符串的字符 </p><p>使用方法一：通过字符串的索引 str[0] </p><p>使用方法二：通过str.charAt(pos)方法 </p><p>它们的区别是索引的方式没有找到会返回undefined，而charAt没有找到会返回空字符串； </p><p>练习：字符串的遍历 </p><p>方式一：普通for循环</p><p>方式二：for..of..遍历</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// for...of...的遍历 -&gt; 迭代器</span></span><br><span class="line"><span class="comment">// 目前的可迭代对象：字符串/数组</span></span><br><span class="line"><span class="comment">// 对象不支持 for  of</span></span><br><span class="line"><span class="comment">// string 对象内部是将字符串变成了一个可迭代对象</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> char <span class="keyword">of</span> message) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(char)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-修改字符串"><a href="#2-修改字符串" class="headerlink" title="2.修改字符串"></a>2.修改字符串</h4><p>字符串的不可变性</p><ul><li>字符串在定义后是不可修改的</li></ul><p>在我们改变很多字符串的操作中，都是生成了一个新的字符串</p><p>比如改变字符串大小的两个方法 </p><ul><li><p>toLowerCase()：将所有的字符转成小写； </p></li><li><p>toUpperCase()：将所有的字符转成大写；</p></li></ul><h4 id="3-查找字符串"><a href="#3-查找字符串" class="headerlink" title="3.查找字符串"></a>3.查找字符串</h4><p>方法1：str.indexOf(searchValue[, fromIndex])</p><ul><li>从fromIndex开始，查找searchValue的索引</li><li>没有找到则返回-1</li><li>类似的方法 lastIndexOf，从最后开始查找（用的较少）</li></ul><p>方法2：是否包含字符串 str.includes(searchString[, position])</p><ul><li>position位置开始查找searchString， 根据情况返回 true 或 false</li><li>这是ES6新增的方法</li></ul><p>方法3：以xxx开头 str.startWith(searchString[, position])</p><ul><li>从position位置开始，判断字符串是否以searchString开头</li><li>这是ES6新增的方法，下面的方法也一样</li></ul><p>方法4：以xxx结尾 str.endWith(searchString[, length])</p><ul><li>length长度内，判断字符串是否以searchString结尾</li></ul><p>方法5：替换字符串 str.replace(regexp|substr,newSubStr|function)</p><ul><li>查找到对应的字符串，并且使用新的字符串进行替代</li><li>也可以传入一个正则表达式来查找，也可以传入一个函数来替换</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> message = <span class="string">&quot;my name is why.&quot;</span></span><br><span class="line">   <span class="keyword">var</span> name = <span class="string">&#x27;why&#x27;</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 判断一个字符串中是否有另外一个字符串</span></span><br><span class="line">   <span class="comment">// 1.indexOf(searchString, fromIndex)</span></span><br><span class="line">   <span class="comment">// 返回的结果是一个索引值</span></span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">     index:</span></span><br><span class="line"><span class="comment">       情况1：搜索到：搜索字符串所在的索引位置</span></span><br><span class="line"><span class="comment">       情况2：没有搜索到，返回-1</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"> <span class="comment">//  var index = message.indexOf(name)</span></span><br><span class="line"> <span class="comment">//  if (message.indexOf(name) !== -1) &#123;</span></span><br><span class="line"> <span class="comment">//   console.log(&quot;message中包含name&quot;)</span></span><br><span class="line"> <span class="comment">//  &#125; else &#123;</span></span><br><span class="line"> <span class="comment">//   console.log(&quot;message中不包含name&quot;)</span></span><br><span class="line"> <span class="comment">//  &#125;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 方法2：es6中新增一个方法，来判断包含关系</span></span><br><span class="line"> <span class="comment">// if (message.includes(name)) &#123;</span></span><br><span class="line"> <span class="comment">//   console.log(&quot;message中包含name&quot;)</span></span><br><span class="line"> <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 3.startWith:是否以xxx开头</span></span><br><span class="line"> <span class="comment">// if (message.startsWith(&quot;my&quot;)) &#123;</span></span><br><span class="line"> <span class="comment">//   console.log(&quot;message以my开头&quot;)</span></span><br><span class="line"> <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 4.endWith:是否以xxx结尾</span></span><br><span class="line"> <span class="comment">// if (message.endsWith(&#x27;why&#x27;)) &#123;</span></span><br><span class="line"> <span class="comment">//   console.log(&quot;message以why结尾&quot;)</span></span><br><span class="line"> <span class="comment">// &#125; else &#123;</span></span><br><span class="line"> <span class="comment">//   console.log(&quot;no&quot;)</span></span><br><span class="line"> <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 5.替换字符串 replace</span></span><br><span class="line"> <span class="comment">// var newMessage = message.replace(&quot;why&quot;, &quot;kobe&quot;)</span></span><br><span class="line"> <span class="comment">// console.log(newMessage)</span></span><br><span class="line"> <span class="keyword">var</span> newName = <span class="string">&quot;kobe&quot;</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">var</span> newMessage = message.<span class="title function_">replace</span>(<span class="string">&quot;why&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> newName.<span class="title function_">toUpperCase</span>()</span><br><span class="line"> &#125;)</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(newMessage)</span><br></pre></td></tr></table></figure><p>获取子字符串</p><table><thead><tr><th>方法</th><th>选择方式</th><th>负值参数</th></tr></thead><tbody><tr><td>slice(start,end)</td><td>从start到end（不含end）</td><td>允许</td></tr><tr><td>substring(start,end)</td><td>从start到end（不含end）</td><td>负值代表0</td></tr><tr><td>substr(start,length)</td><td>从start开始获取长为 length 的字符串</td><td>允许start为负数</td></tr></tbody></table><p>substr 方法可能有的浏览器不支持，推荐slcie，负值：-1表示为最后一位</p><h4 id="4-字符串的拼接"><a href="#4-字符串的拼接" class="headerlink" title="4.字符串的拼接"></a>4.字符串的拼接</h4><p>方法：</p><ul><li><p>运用 + 运算符</p></li><li><p>str1.concat(str2)   括号中的是可变参数，支持链式编程</p></li></ul><p>删除首尾空格：str.trim()</p><h4 id="6-字符串切割与改变连接方式"><a href="#6-字符串切割与改变连接方式" class="headerlink" title="6.字符串切割与改变连接方式"></a>6.字符串切割与改变连接方式</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> message = <span class="string">&quot;223-423-422-122-352&quot;</span></span><br><span class="line">   <span class="keyword">var</span> items = message.<span class="title function_">split</span>(<span class="string">&quot;-&quot;</span>)  <span class="comment">// 返回值是一个string类型的数组</span></span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(items)</span><br><span class="line">   <span class="comment">// 将此数组改为以 * 连接的字符串</span></span><br><span class="line">   <span class="keyword">var</span> newMessage = items.<span class="title function_">join</span>(<span class="string">&quot;*&quot;</span>)</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(newMessage)</span><br></pre></td></tr></table></figure><p>补充 string 方法</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;124&quot;</span></span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">padStart</span>(<span class="number">4</span>, <span class="string">&quot;0&quot;</span>))   <span class="comment">// 0124</span></span><br></pre></td></tr></table></figure><h3 id="5、数组Array使用详解"><a href="#5、数组Array使用详解" class="headerlink" title="5、数组Array使用详解"></a>5、数组Array使用详解</h3><h4 id="1-什么是数组"><a href="#1-什么是数组" class="headerlink" title="1.什么是数组"></a>1.什么是数组</h4><p>是一种有序的组合，里面的元素是按照一定顺序来排列的，可以通过索引查找</p><p>数组和对象都是一种保存多个数据的数据结构</p><p>通过 [ ] 创建</p><ul><li>数组是一种特殊的对象类型</li></ul><p>通过构造函数 Array 创建</p><ul><li>new Array()  &#x2F;&#x2F; () 里面可以传入数据  “ ”  ，但是如果传入一个数字类型，会默认当成我们要创建一个对应长度的数组</li></ul><p>数组元素从0开始索引</p><ul><li>一些编程语言可以通过 arr[-1] 来访问最后一个元素</li><li>js并不支持这种写法，访问最后一个元素：arr[arr.length-1]</li></ul><h4 id="2-数组的基本操作"><a href="#2-数组的基本操作" class="headerlink" title="2.数组的基本操作"></a>2.数组的基本操作</h4><h5 id="1、访问数组中的元素"><a href="#1、访问数组中的元素" class="headerlink" title="1、访问数组中的元素"></a>1、访问数组中的元素</h5><ul><li>arr[index]</li><li>arr.at(index)<ul><li>如果index &gt;&#x3D; 0，则与arr[index] 的情况相同</li><li>对于index为负数的情况，它则从数组的尾部向前数</li></ul></li></ul><h5 id="2、修改数组中的元素"><a href="#2、修改数组中的元素" class="headerlink" title="2、修改数组中的元素"></a>2、修改数组中的元素</h5><p>arr[index] &#x3D; “coderwhy”</p><h5 id="3、删除"><a href="#3、删除" class="headerlink" title="3、删除"></a>3、删除</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">delete</span> names[<span class="number">2</span>] </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(names)  <span class="comment">// 索引为2的位置为empty</span></span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(names[<span class="number">2</span>])  <span class="comment">// 查询结果为undefined</span></span><br></pre></td></tr></table></figure><p>删除和添加元素虽然也可以通过索引来直接操作，但是开发中很少这样操作。</p><p>具体的操作方法</p><ul><li>添加&#x2F;删除尾部<ul><li>push()：在尾部添加元素，为可变参数</li><li>pop()：在尾部删除元素，一次只能删除一个元素</li></ul></li><li>添加&#x2F;删除首部<ul><li>unshift()：在首部添加元素，为可变参数， 在首端添加元素，整个其他数组元素向后移动</li><li>shift()：在首部删除元素，一次只能删除一个元素， 取出队列首端的一个元素，整个数组元素向前前移动</li></ul></li></ul><p>相对来说，push和pop的运行比较快</p><p>删除方法2：</p><ul><li>arr.splice</li></ul><p>语法结构：arr.splice(start, deleteCount, [, item1[, item2[,item3]…]])</p><p>从start位置开始，删除deleteCount（0代表不删除)个元素，后面的则为添加items</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除元素</span></span><br><span class="line">names.<span class="title function_">splice</span>(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(names)</span><br><span class="line"><span class="comment">// 新增元素</span></span><br><span class="line">names.<span class="title function_">splice</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="string">&quot;ssx&quot;</span>, <span class="string">&quot;ccg&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(names)</span><br><span class="line"><span class="comment">// 替换元素</span></span><br><span class="line">names.<span class="title function_">splice</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;vc&quot;</span>, <span class="string">&quot;ccc&quot;</span>, <span class="string">&quot;kobe&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(names)</span><br></pre></td></tr></table></figure><p>这个方法会修改原数组</p><p>length 属性：用于获取数组的长</p><ul><li>当我们修改出租的时候，length 属性会自动更新</li></ul><p>length属性是可写的</p><ul><li>如果我们手动增加一个默认大于length的数值，那么会增加数组的长度</li><li>但是如果我们减少它，数组会被截断</li></ul><p>清空数组的最简单的方法就是：arr.length &#x3D; 0</p><h5 id="4、数组的遍历"><a href="#4、数组的遍历" class="headerlink" title="4、数组的遍历"></a>4、数组的遍历</h5><ul><li>普通的 for 循环</li><li>for..in 遍历：获取到的 index 为索引值，arr[index] 为 value 值</li><li>for..of 遍历：获取不到索引值，能获取到每一个元素</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2.1 普通的for 循环</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; names.<span class="property">length</span>; i++) &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(names[i])</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 2.2 for...in</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">var</span> index <span class="keyword">in</span> names) &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(index, names[index])  <span class="comment">// 索引</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 2.3 for...of</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">var</span> items <span class="keyword">of</span> names) &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(items)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h5 id="5、数组方法"><a href="#5、数组方法" class="headerlink" title="5、数组方法"></a>5、数组方法</h5><ul><li>arr.slice 方法：用于对数组进行截取，不会修改原数组，类似于字符串的slice方法<ul><li>arr.slice(start, end) 截取到的元素包含strat，但不包含end 元素</li></ul></li><li>arr.concat 方法：创建一个新的数组，其中包含来自于其他数组和其他项的值<ul><li>var newArr &#x3D; arr.concat(“ssd”, “ssx”, “ccc”)</li></ul></li><li>arr.join 方法：将一个数组的所有元素连接成一个字符串并返回这个字符串<ul><li>console.log(arr.join(“-“))</li></ul></li></ul><h5 id="6、查找元素"><a href="#6、查找元素" class="headerlink" title="6、查找元素"></a>6、查找元素</h5><ul><li>arr.indexOf(searchElement[, fromIndex]) 方法，查找某个元素的索引<ul><li>从 fromIndex 开始查找，如果找到则返回索引，没找到返回-1</li><li>也有对应的从最后位置开始查找的 lastIndexOf 方法</li><li>对于复杂数据类型的不便于查找，使用 for 循环也可以实现</li></ul></li><li>arr.includes 方法：判断数组是否包含某个元素<ul><li>arr.includes(valueToFind[, fromIndex])</li><li>从索引from开始查找item，找到则返回true，找不到返回false</li></ul></li><li>find 和 findIndex 直接查找元素或者元素的索引（es6之后）</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> findStu = students.<span class="title function_">find</span>(<span class="keyword">function</span>(<span class="params">item</span>)&#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(item)</span><br><span class="line">     <span class="keyword">return</span> item.<span class="property">id</span> = <span class="number">101</span></span><br><span class="line">   &#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(findStu)</span><br></pre></td></tr></table></figure><h5 id="7、排序和反转"><a href="#7、排序和反转" class="headerlink" title="7、排序和反转"></a>7、排序和反转</h5><p>方法1：算法实现排序</p><p>方法2：使用 sort 高级函数，排序之后生成一个新的数组，可用于复杂类型的数组</p><ul><li><p>如果 compareFunction(a, b) 小于 0 ，那么 a 会被排列到 b 前面； </p></li><li><p>如果 compareFunction(a, b) 等于 0 ， a 和 b 的相对位置不变； </p></li><li><p>如果 compareFunction(a, b) 大于 0 ， b 会被排列到 a 前面； </p></li><li><p>也就是说，谁小谁排在前面；</p></li></ul><p> reverse() 方法将数组中元素的位置颠倒，并返回该数组</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">num.<span class="title function_">sort</span>(<span class="keyword">function</span>(<span class="params">item1, item2</span>) &#123;</span><br><span class="line">     <span class="comment">// item1 和 item2 进行比较</span></span><br><span class="line">     <span class="comment">// 返回的是 正数</span></span><br><span class="line">     <span class="comment">// 谁小谁在前</span></span><br><span class="line">     <span class="keyword">return</span> item1 - item2  <span class="comment">//升序</span></span><br><span class="line">     <span class="comment">// return item2 - item1  //降序</span></span><br><span class="line">   &#125;)</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(num)</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(num.<span class="title function_">reverse</span>())  <span class="comment">// 反转</span></span><br></pre></td></tr></table></figure><h5 id="8、数组的其他高阶函数"><a href="#8、数组的其他高阶函数" class="headerlink" title="8、数组的其他高阶函数"></a>8、数组的其他高阶函数</h5><p>arr.forEach  参数（item,index,arr）</p><ul><li>遍历数组，并且让数组中每一个元素都执行一次对应的方法</li></ul><p>arr.map   参数（item,index,arr）</p><ul><li>map() 方法创建一个新数组</li><li>这个新数组由原数组中的每个元素都调用一次提供的函数后的返回值组成</li></ul><p>arr.filter   参数（item,index,arr）</p><ul><li>filter() 方法创建一个新数组</li><li>新数组中只包含每个元素调用函数返回为true的元素</li></ul><p>arr.reduce  参数（preValue, item） preValue 可以传入一个0  作为第一次执行的preValue</p><ul><li>用于计算数组中所有元素的总和</li><li>对数组中的每个元素按序执行一个由您提供的 reducer 函数</li><li>每一次运行 reducer 会将先前元素的计算结果作为参数传入，最后将其结果汇总为单个返回值</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">综合练习：过滤所有的偶数 计算偶数的平方 再求和</span><br><span class="line">    <span class="keyword">var</span> total = num.<span class="title function_">filter</span>(<span class="keyword">function</span>(<span class="params">item</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> item % <span class="number">2</span> === <span class="number">0</span></span><br><span class="line">    &#125;).<span class="title function_">map</span>(<span class="keyword">function</span>(<span class="params">item</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> item * item</span><br><span class="line">    &#125;).<span class="title function_">reduce</span>(<span class="keyword">function</span>(<span class="params">preValue, item</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> preValue + item</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(total)</span><br></pre></td></tr></table></figure><h3 id="6、Date类型的使用"><a href="#6、Date类型的使用" class="headerlink" title="6、Date类型的使用"></a>6、Date类型的使用</h3><h4 id="1-创建Date对象"><a href="#1-创建Date对象" class="headerlink" title="1.创建Date对象"></a>1.创建Date对象</h4><p>在 js 中使用 Date 来表示和处理时间</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Date 构造函数的以下用法</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>()  <span class="comment">// 当前时间</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&quot;2022-08-08&quot;</span>)   <span class="comment">// 传入参数，时间字符串</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">2022</span>, <span class="number">02</span>, <span class="number">03</span>, <span class="number">06</span>, <span class="number">15</span>, <span class="number">06</span>, <span class="number">33</span>) <span class="comment">// 传入具体的年月日时分秒毫秒</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">1000267496623</span>) <span class="comment">// 传入一个Unix时间戳  1s -&gt; 1000ms</span></span><br></pre></td></tr></table></figure><h4 id="2-dateString-时间的表示方式"><a href="#2-dateString-时间的表示方式" class="headerlink" title="2. dateString 时间的表示方式"></a>2. dateString 时间的表示方式</h4><p>日期的表示方式有两种：RFC 2822 标准 或者 ISO 8601 标准</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date)  <span class="comment">//  Wed Mar 08 2023 09:52:44 GMT+0800 (中国标准时间) </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date.<span class="title function_">toDateString</span>())  <span class="comment">// Wed Mar 08 2023</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date.<span class="title function_">toISOString</span>())  <span class="comment">// 2023-03-08T01:52:44.254Z 标准时间 不是北京时间</span></span><br></pre></td></tr></table></figure><p>可以将其转化成ISO 8601标准的：  </p><p>YYYY：年份，0000 ~ 9999</p><p>MM：月份，01 ~ 12</p><p>DD：日，01 ~ 31</p><p>T：分隔日期和时间，没有特殊含义，可以省略</p><p>HH：小时，00 ~ 24 </p><p>mm：分钟，00 ~ 59 </p><p>ss：秒，00 ~ 59</p><p>.sss：毫秒  Z：时区</p><h4 id="3-Date-对象的方法"><a href="#3-Date-对象的方法" class="headerlink" title="3.Date 对象的方法"></a>3.Date 对象的方法</h4><p>我们可以从Date对象中获取各种详细的信息： </p><ul><li><p>getFullYear()：获取年份（4 位数）</p></li><li><p>getMonth()：获取月份，从 0 到 11</p></li><li><p>getDate()：获取当月的具体日期，从 1 到 31（方法名字有点迷）</p></li><li><p>getHours()：获取小时</p></li><li><p>getMinutes()：获取分钟</p></li><li><p>getSeconds()：获取秒钟</p></li><li><p>getMilliseconds()：获取毫秒</p></li><li><p>getDay()：获取一周中的第几天，从 0（星期日）到 6（星期六）</p></li></ul><p>设置信息的方法</p><ul><li>setFullYear(year, [month], [date]) </li><li>setMonth(month, [date]) </li><li>setDate(date) </li><li>setHours(hour, [min], [sec], [ms]) </li><li>setMinutes(min, [sec], [ms]) </li><li>setSeconds(sec, [ms]) </li><li>setMilliseconds(ms) </li><li>setTime(milliseconds)</li></ul><p>设置超范围的数值，它会自动校准</p><h4 id="4-Date-获取-Unix-时间戳"><a href="#4-Date-获取-Unix-时间戳" class="headerlink" title="4.Date 获取 Unix 时间戳"></a>4.Date 获取 Unix 时间戳</h4><p>Unix 时间戳：它是一个整数值，表示自1970年1月1日00:00:00 UTC以来的毫秒数</p><p>前面可知，我们可以通过传入一个时间戳来获取其表示的时间</p><p>获取当前的时间戳：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">方法<span class="number">1</span>：<span class="keyword">var</span> timestamp1 = <span class="title class_">Date</span>.<span class="title function_">now</span>()</span><br><span class="line">方法<span class="number">2</span>：<span class="keyword">var</span> date = <span class="keyword">new</span> <span class="title class_">Date</span>()</span><br><span class="line">  <span class="keyword">var</span> timestamp2 = date.<span class="title function_">getTime</span>()</span><br><span class="line">方法<span class="number">3</span>：<span class="variable language_">console</span>.<span class="title function_">log</span>(+date)  <span class="comment">// +运算符</span></span><br><span class="line">可写为：<span class="keyword">var</span> timestamp5 = +<span class="keyword">new</span> <span class="title class_">Date</span>()</span><br></pre></td></tr></table></figure><p>将一个对象转成时间戳：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> date2 = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&quot;2033-03-03&quot;</span>)</span><br><span class="line">方法<span class="number">1</span>：<span class="keyword">var</span> timestamp3 = date2.<span class="title function_">getTime</span>()</span><br><span class="line">方法<span class="number">2</span>：<span class="keyword">var</span> timestamp4 = date2.<span class="title function_">valueOf</span>()</span><br><span class="line">方法<span class="number">3</span>：<span class="variable language_">console</span>.<span class="title function_">log</span>(+date2)</span><br><span class="line">可写为：<span class="keyword">var</span> timestamp6 = +<span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&quot;2033-03-03&quot;</span>)</span><br></pre></td></tr></table></figure><p>时间戳的作用：例如：计算一个操作花费的时间</p><h4 id="5-Date-parse-方法"><a href="#5-Date-parse-方法" class="headerlink" title="5.Date.parse 方法"></a>5.Date.parse 方法</h4><p> Date.parse(str) 方法可以从一个字符串中读取日期，并且输出对应的Unix时间戳</p><ul><li><p>作用等同于 new Date(dateString).getTime() 操作</p></li><li><p>需要符合 RFC2822 或 ISO 8601 日期格式的字符串</p></li><li><p>其他格式也许也支持，但结果不能保证一定正常</p></li><li><p>如果输入的格式不能被解析，那么会返回NaN</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> timeString = <span class="string">&quot;2033-2-3&quot;</span></span><br><span class="line"><span class="keyword">var</span> timestamp = <span class="title class_">Date</span>.<span class="title function_">parse</span>(timeString)</span><br></pre></td></tr></table></figure><h2 id="10-JavaScript-的-DOM-操作"><a href="#10-JavaScript-的-DOM-操作" class="headerlink" title="10.JavaScript 的 DOM 操作"></a>10.JavaScript 的 DOM 操作</h2><h3 id="1、什么是DOM"><a href="#1、什么是DOM" class="headerlink" title="1、什么是DOM"></a>1、什么是DOM</h3><p>学完以上ECMAScript 语法，我们还需要学习浏览器提供开发者的DOM、BOM相关的API才能对网页、浏览器进行操作</p><p>window 全局对象不仅提供了js语法部分的Object\Arry\Date等，也提供了DOM\BOM部分</p><p>DOM：浏览器考虑到开发者与用户可能需要对网页元素做某些操作，会将网页元素抽象成JS对象</p><ul><li>即将网页所有的元素表示为可以修改的对象</li><li>所以这些对象都可以通过 JS 来对其进行访问，所以可以通过 JS 来操作页面</li><li>这个抽象过程称之为文档对象模型，称之为 Document Object Model</li><li>作为了JS语法与网页元素的桥梁</li></ul><p>BOM：浏览器对象模型</p><ul><li>由浏览器提供的用于处理文档之外的所有的其他对象</li><li>比如 navigator、location、history 等对象</li></ul><h3 id="2、认识DOM-Tree"><a href="#2、认识DOM-Tree" class="headerlink" title="2、认识DOM Tree"></a>2、认识DOM Tree</h3><p>在 html 结构中，所有元素都会形成一个树结构（节点是元素）</p><p>抽象为 DOM 之后也会形成 DOM Tree （节点是抽象的对象）</p><h3 id="3、DOM-的整体结构"><a href="#3、DOM-的整体结构" class="headerlink" title="3、DOM 的整体结构"></a>3、DOM 的整体结构</h3><p>DOM相当于是JavaScript和HTML、CSS之间的桥梁</p><ul><li>通过浏览器提供给我们的DOM API，我们可以对元素以及其中的内容做任何事情；</li></ul><p>DOM的继承关系</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230309102756157.png" alt="image-20230309102756157"></p><p>document 对象</p><p>Document节点表示的整个载入的网页，它的实例是全局的document对象：</p><ul><li><p>对DOM的所有操作都是从 document 对象开始的</p></li><li><p>它是DOM的入口点，可以从document开始去访问任何节点元素</p></li></ul><p>对于最顶层的html、head、body元素，我们可以直接在document对象中获取到：</p><ul><li><p>html元素： &#x3D; document.documentElement</p></li><li><p>body元素： &#x3D; document.body</p></li><li><p>head元素： &#x3D; document.head</p></li><li><p>文档声明： &#x3D; document.doctype</p></li></ul><h3 id="4、节点、元素导航"><a href="#4、节点、元素导航" class="headerlink" title="4、节点、元素导航"></a>4、节点、元素导航</h3><h4 id="1-节点之间导航"><a href="#1-节点之间导航" class="headerlink" title="1.节点之间导航"></a>1.节点之间导航</h4><p>如果我们获取到一个节点（Node）后，可以根据这个节点去获取其他的节点，我们称之为节点之间的导航</p><p>节点之间存在如下的关系：</p><ul><li><p>父节点：parentNode</p></li><li><p>前兄弟节点：previousSibling</p></li><li><p>后兄弟节点：nextSibling</p></li><li><p>子节点：childNodes</p></li><li><p>第一个子节点：firstChild</p></li><li><p>第二个子节点：lastChild</p></li></ul><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230311132712739.png" alt="image-20230311132712739"></p><h4 id="2-元素之间导航"><a href="#2-元素之间导航" class="headerlink" title="2.元素之间导航"></a>2.元素之间导航</h4><p>如果我们获取到一个元素（Element）后，可以根据这个元素去获取其他的元素，我们称之为元素之间的导航。</p><p>节点之间存在如下的关系：</p><ul><li><p>父元素：parentElement</p></li><li><p>前兄弟节点：previousElementSibling</p></li><li><p>后兄弟节点：nextElementSibling</p></li><li><p>子节点：children</p></li><li><p>第一个子节点：firstElementChild</p></li><li><p>第二个子节点：lastElementChild</p></li></ul><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230311132841099.png" alt="image-20230311132841099"></p><h4 id="3-table元素之间的导航"><a href="#3-table元素之间的导航" class="headerlink" title="3.table元素之间的导航"></a>3.table元素之间的导航</h4><p>table 还元素支持以下这些属性：</p><ul><li><p>table.rows —  tr元素的集合</p></li><li><p>table.caption&#x2F;tHead&#x2F;tFoot — 引用元素caption、thead、tfoot </p></li><li><p>table.tBodies — tbody 元素的集合</p></li></ul><p>thead、tfoot、tbody 元素提供了 rows 属性</p><ul><li>tbody.rows — 表格内部 tr 元素的集合</li></ul><p>tr：</p><ul><li><p>tr.cells — 在给定 tr 中的 td 和 th 单元格的集合</p></li><li><p>tr.sectionRowIndex — 给定的 tr 在封闭的 thead&#x2F;tbody&#x2F;tfoot 中的位置（索引）</p></li><li><p>tr.rowIndex — 在整个表格中 tr 的编号（包括表格的所有行）</p></li></ul><p>td 和 th</p><ul><li>td.cellIndex — 在封闭的 tr 中单元格的编号</li></ul><h4 id="4-form元素之间的导航"><a href="#4-form元素之间的导航" class="headerlink" title="4.form元素之间的导航"></a>4.form元素之间的导航</h4><p>获取 form 元素可以通过节点和元素的方法获取，也可以通过forms获取；</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> formEl = <span class="variable language_">document</span>.<span class="property">forms</span>[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>form 元素中的内容可以通过 elements 来获取：form.elements</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> elements = formEl.<span class="property">elements</span></span><br></pre></td></tr></table></figure><p>获取 form 中的子元素还可以通过 name 其属性获取</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> inputEl = formEl.<span class="property">elements</span>.<span class="property">account</span></span><br></pre></td></tr></table></figure><p>作用是有时能够以此来获取 input 表单的 value</p><h3 id="5、获取元素的方法"><a href="#5、获取元素的方法" class="headerlink" title="5、获取元素的方法"></a>5、获取元素的方法</h3><p>DOM 提供的获取元素的方法：</p><table><thead><tr><th>方法名</th><th>搜索方式</th><th>可以在元素上调用？</th><th>实时？</th></tr></thead><tbody><tr><td>querySelector</td><td>css-selector</td><td>√</td><td>-</td></tr><tr><td>querySelectorAll</td><td>css-selector</td><td>√</td><td>-</td></tr><tr><td>getElementById</td><td>id</td><td>-</td><td>-</td></tr><tr><td>getElementByName</td><td>name</td><td>-</td><td>√</td></tr><tr><td>getElementByTagName</td><td>tar or ‘*’</td><td>√</td><td>√</td></tr><tr><td>getElementByClassName</td><td>class</td><td>√</td><td>√</td></tr></tbody></table><p>目前最常用的是querySelector和querySelectAll </p><p>getElementById偶尔也会使用或者在适配一些低版本浏览器时；</p><h3 id="6、Node-节点的属性"><a href="#6、Node-节点的属性" class="headerlink" title="6、Node 节点的属性"></a>6、Node 节点的属性</h3><h4 id="1-nodeType属性："><a href="#1-nodeType属性：" class="headerlink" title="1.nodeType属性："></a>1.nodeType属性：</h4><ul><li><p>nodeType 属性提供了一中获取节点类型的方法</p></li><li><p>它有一个数值型值</p></li></ul><p>常见的节点类型：</p><table><thead><tr><th>常量</th><th>值</th><th>描述</th></tr></thead><tbody><tr><td>Node.ELEMENT_NODE</td><td>1</td><td>一个元素节点，例如p元素和div元素</td></tr><tr><td>Node.TEXT_NODE</td><td>3</td><td>Element 或者 Attr 中实际的 文字</td></tr><tr><td>Node.COMMENT_NODE</td><td>8</td><td>一个 Comment 节点。</td></tr><tr><td>Node.DOCUMENT_NODE</td><td>9</td><td>一个 Document 节点。</td></tr><tr><td>Node.DOCUMENT_TYPE_NODE</td><td>10</td><td>描述文档类型的DocumentType 节点。例如<!DCOTYPE html></td></tr></tbody></table><p>nodeName：获取节点的名字</p><p>tagName：获取元素的名称</p><ul><li><p>tagName 属性仅适用于 Element 节点；</p></li><li><p>nodeName 是为任意 Node 定义的：</p><ul><li>对于元素，它的意义与 tagName 相同，所以使用哪一个都是可以的；</li><li>对于其他节点类型（text，comment 等），它拥有一个对应节点类型的字符串</li></ul></li></ul><p>nodeValue&#x2F;data： 用于获取非元素节点的文本内容</p><p>innerHTML 属性</p><ul><li>将元素中的 HTML 获取为字符串形式； </li><li>设置元素中的内容；</li></ul><p>outerHTML 属性</p><ul><li>包含了元素的完整 HTML</li><li>innerHTML 加上元素本身一样；</li></ul><p>textContent 属性</p><ul><li>仅仅获取元素中的文本内容；</li></ul><p>innerHTML和textContent的区别：</p><ul><li>仅仅设置文本的话作用相同</li></ul><p>内容带标签的话</p><ul><li><p>使用 innerHTML，我们将其“作为 HTML”插入，带有所有 HTML 标签</p></li><li><p>使用 textContent，我们将其“作为文本”插入，所有符号（symbol）均按字面意义处理</p></li></ul><p>全局属性 hidden：可以用于设置元素隐藏</p><p>一个元素除了有开始标签、结束标签、内容之外，还有很多的属性（attribute）</p><p>浏览器在解析HTML元素时，会将对应的attribute也创建出来放到对应的元素对象上。</p><ul><li><p>比如id、class就是全局的attribute，会有对应的id、class属性；</p></li><li><p>比如href属性是针对a元素的，type、value属性是针对input元素的；</p></li></ul><p>Attribute 的分类：</p><p>1.如果是HTML标准制定的Attribute，称之为标准的Attribute</p><p>2.而自定义的Attribute，称之为非标准的Attribute</p><h4 id="2-Attribute-属性的操作："><a href="#2-Attribute-属性的操作：" class="headerlink" title="2.Attribute 属性的操作："></a>2.Attribute 属性的操作：</h4><p>对于所有的（标准的和自定义的）attribute访问都支持如下的方法：</p><ul><li><p>elem.hasAttribute(name) — 检查特性是否存在。</p></li><li><p>elem.getAttribute(name) — 获取这个特性值。（字符串类型）（不存在则返回 null）</p></li><li><p>elem.setAttribute(name, value) — 设置这个特性值。</p></li><li><p>elem.removeAttribute(name) — 移除这个特性。</p></li><li><p>attributes：attr对象的集合，具有name、value属性</p></li></ul><p>attribute具备以下特征：</p><ul><li><p>它们的名字是大小写不敏感的（id 与 ID 相同）。</p></li><li><p>它们的值总是字符串类型的。</p></li></ul><h4 id="3-元素的属性-property"><a href="#3-元素的属性-property" class="headerlink" title="3.元素的属性 property"></a>3.元素的属性 property</h4><p>对于 HTML 元素，在元素中称其属性为 attribute，通过js获取元素对象之后（通过property获取attribute的值），称之为元素的对象模型。</p><p>对于标准的attribute，会在DOM对象上创建与其对应的property属性：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里的id称之为property</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(boxEl.<span class="property">id</span>, boxEl.<span class="property">age</span>, boxEl.<span class="property">height</span>,boxEl.<span class="property">title</span>)</span><br></pre></td></tr></table></figure><p>不是标准的属性的话（自定义）返回值为 undefined</p><p>在大多数情况下，它们是相互作用的</p><ul><li><p>改变property，通过attribute获取的值，会随着改变；</p></li><li><p>通过attribute操作修改，property的值会随着改变；</p><ul><li>但是input的value修改只能通过attribute的方法；</li></ul></li></ul><p>大多数情况下，设置、获取attribute，推荐使用property的方式：这是因为它默认情况下是有类型的；</p><p>*<em>HTML5的data-<em>自定义属性，那么它们也是可以在dataset属性中获取到的</em></em></p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230405193102932.png" alt="image-20230405193102932"></p><h4 id="4-JavaScript中动态修改样式"><a href="#4-JavaScript中动态修改样式" class="headerlink" title="4.JavaScript中动态修改样式"></a>4.JavaScript中动态修改样式</h4><p>有时候我们会通过JavaScript来动态修改样式，这个时候我们有两个选择：</p><ul><li><p>选择一：在CSS中编写好对应的样式，动态的添加class；</p></li><li><p>选择二：动态的修改style属性；</p></li></ul><p>开发中如何选择呢？</p><ul><li><p>在大多数情况下，如果可以动态修改class完成某个功能，更推荐使用动态class；</p></li><li><p>如果对于某些情况，无法通过动态修改class（比如精准修改某个css属性的值），那么就可以修改style属性</p></li></ul><p>元素的 className 和 classList</p><p>元素的class attribute，对应的property并非叫class，而是className：</p><p>这是因为JavaScript早期是不允许使用class这种关键字来作为对象的属性，所以DOM规范使用了className；</p><p>虽然现在JavaScript已经没有这样的限制，但是并不推荐，并且依然在使用className这个名称</p><p>对className进行赋值，<strong>它会替换整个类中的字符串</strong></p><p>如果我们需要添加或者移除单个的class，那么可以使用classList属性。</p><p>elem.classList 是一个特殊的对象：</p><ul><li><p>elem.classList.add (class) ：添加一个类</p></li><li><p>elem.classList.remove(class)：添加&#x2F;移除类。</p></li><li><p>elem.classList.toggle(class) ：如果类不存在就添加类，存在就移除它。</p></li><li><p>elem.classList.contains(class)：检查给定类，返回 true&#x2F;false。</p></li></ul><p>classList是可迭代对象，可以通过for of进行遍历。</p><p>元素的 style 属性</p><p>如果需要单独修改某一个CSS属性，那么可以通过style来操作：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">boxEl.<span class="property">style</span>.<span class="property">fontSize</span> = <span class="string">&quot;30px&quot;</span></span><br></pre></td></tr></table></figure><p>对于多词（multi-word）属性，使用驼峰式（小驼峰） camelCase</p><p>如果我们将值设置为空字符串，那么会使用CSS的默认样式：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">boxEl.<span class="property">style</span>.<span class="property">fontSize</span> = <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>多个样式的写法，我们需要使用cssText属性：</p><p>不推荐这种用法，<strong>因为它会替换整个字符串</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">boxEl.<span class="property">style</span>.<span class="property">cssText</span> = <span class="string">&#x27;font-size: 30px; color: red;&#x27;</span></span><br></pre></td></tr></table></figure><p>元素 style 的读取</p><p> 对于内联样式，是可以通过style.*的方式读取到的；</p><p>对于style、css文件中的样式，是读取不到的</p><p>这个时候，我们可以通过getComputedStyle的全局函数来实现</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getComputedStyle</span>(boxEl).<span class="property">fontSize</span>)</span><br></pre></td></tr></table></figure><h4 id="5-创建元素"><a href="#5-创建元素" class="headerlink" title="5.创建元素"></a>5.创建元素</h4><p>document.write：非常便捷，但是对于复杂的内容、元素关系拼接并不方便</p><h5 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h5><ul><li>步骤一：创建元素：document.createElement(tag)</li><li>步骤二：插入元素到 DOM 的某一个位置</li></ul><p>插入方式：</p><ul><li><p>node.append(…nodes or strings) —— 在 node 末尾插入节点或字符串</p></li><li><p>node.prepend(…nodes or strings) —— 在 node 开头插入节点或字符串</p></li><li><p>node.before(…nodes or strings) —— 在 node 前面插入节点或字符串</p></li><li><p>node.after(…nodes or strings) —— 在 node 后面插入节点或字符串</p></li><li><p>node.replaceWith(…nodes or strings) —— 将 node 替换为给定的节点或字符串</p></li></ul><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230312090927700.png" alt="image-20230312090927700"></p><h5 id="移除和克隆元素"><a href="#移除和克隆元素" class="headerlink" title="移除和克隆元素"></a>移除和克隆元素</h5><p>移除元素我们可以调用元素本身的remove方法：</p><p>想要复制一个现有的元素，可以通过cloneNode方法：</p><ul><li><p>可以传入一个Boolean类型的值，来决定是否是深度克隆；</p></li><li><p>深度克隆会克隆对应元素的子元素，否则不会；</p></li></ul><h5 id="旧方法操作元素（了解）"><a href="#旧方法操作元素（了解）" class="headerlink" title="旧方法操作元素（了解）"></a>旧方法操作元素（了解）</h5><p>parentElem.appendChild(node)： </p><ul><li>在parentElem的父元素最后位置添加一个子元素</li></ul><p>parentElem.insertBefore(node, nextSibling)：</p><ul><li>在parentElem的nextSibling前面插入一个子元素；</li></ul><p>parentElem.replaceChild(node, oldChild)：</p><ul><li>在parentElem中，新元素替换之前的oldChild元素；</li></ul><p>parentElem.removeChild(node)：</p><ul><li>在parentElem中，移除某一个元素；</li></ul><h4 id="6-元素的大小、滚动"><a href="#6-元素的大小、滚动" class="headerlink" title="6.元素的大小、滚动"></a>6.元素的大小、滚动</h4><p>clientWidth：contentWith+padding（不包含滚动条）</p><p>clientHeight：contentHeight+padding</p><p>clientTop：border-top的宽度</p><p>clientLeft：border-left的宽度</p><p>offsetWidth：元素完整的宽度</p><p>offsetHeight：元素完整的高度</p><p>offsetLeft：距离父元素的x</p><p>offsetHeight：距离父元素的y</p><p>scrollHeight：整个可滚动的区域高度</p><p>scrollTop：滚动部分的高度</p><h4 id="7-window的大小、滚动"><a href="#7-window的大小、滚动" class="headerlink" title="7.window的大小、滚动"></a>7.window的大小、滚动</h4><p>window的width和height</p><ul><li><p>innerWidth、innerHeight：获取window窗口的宽度和高度（包含滚动条）</p></li><li><p>outerWidth、outerHeight：获取window窗口的整个宽度和高度（包括调试工具、工具栏）</p></li><li><p>documentElement.clientHeight、documentElement.clientWidth：获取html的宽度和高度（不包含滚动条）</p></li></ul><p>indow的滚动位置：</p><ul><li><p>scrollX：X轴滚动的位置（别名pageXOffset）</p></li><li><p>scrollY：Y轴滚动的位置（别名pageYOffset）</p></li></ul><p>也有提供对应的滚动方法：</p><ul><li><p>方法 scrollBy(x,y) ：将页面滚动至相对于当前位置的 (x, y) 位置；</p></li><li><p>方法 scrollTo(pageX,pageY) 将页面滚动至绝对坐标；</p></li></ul><h2 id="11-JavaScript-中的事件"><a href="#11-JavaScript-中的事件" class="headerlink" title="11.JavaScript 中的事件"></a>11.JavaScript 中的事件</h2><h3 id="1、认识事件"><a href="#1、认识事件" class="headerlink" title="1、认识事件"></a>1、认识事件</h3><p>Web页面需要经常和用户之间进行交互，而交互的过程中我们可能想要捕捉这个交互的过程：</p><p>比如用户点击了某个按钮、用户在输入框里面输入了某个文本、用户鼠标经过了某个位置；</p><p>浏览器需要搭建一条JavaScript代码和事件之间的桥梁；</p><p>当某个事件发生时，让JavaScript可以响应（执行某个函数），所以我们需要针对事件编写处理程序（handler）</p><ul><li><p>事件监听方式一：在script中直接监听（很少使用）；</p></li><li><p>事件监听方式二：DOM属性，通过元素的on来监听事件；</p></li><li><p>事件监听方式三：通过EventTarget中的addEventListener来监听；</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;button onclick=<span class="string">&quot;console.log(&#x27;按钮1发生了点击~&#x27;)&quot;</span>&gt;按钮<span class="number">1</span>&lt;/button&gt;</span><br><span class="line">btn2El.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;按钮2发生了点击&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">btn3El.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;btn3的事件监听1&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="常见的事件列表"><a href="#常见的事件列表" class="headerlink" title="常见的事件列表"></a>常见的事件列表</h4><p>鼠标事件</p><ul><li>click —— 当鼠标点击一个元素时（触摸屏设备会在点击时生成）</li><li>mouseover &#x2F; mouseout —— 当鼠标指针移入&#x2F;离开一个元素时</li><li>mousedown &#x2F; mouseup —— 当在元素上按下&#x2F;释放鼠标按钮时</li><li>mousemove —— 当鼠标移动时</li></ul><p>键盘事件</p><ul><li>keydown 和 keyup —— 当按下和松开一个按键时</li></ul><p>表单（form）元素事件</p><ul><li>submit —— 当访问者提交了一个 form 时</li><li>focus —— 当访问者聚焦于一个元素时，例如聚焦于一个 input</li></ul><p>Document 事件</p><ul><li>DOMContentLoaded —— 当 HTML 的加载和处理均完成，DOM 被完全构建完成时</li></ul><p>CSS 事件</p><ul><li>transitionend —— 当一个 CSS 动画完成时。</li></ul><h3 id="2、认识事件流"><a href="#2、认识事件流" class="headerlink" title="2、认识事件流"></a>2、认识事件流</h3><h4 id="1-产生"><a href="#1-产生" class="headerlink" title="1.产生"></a>1.产生</h4><p>当我们在浏览器上对着一个元素点击时，你点击的不仅仅是这个元素本身；</p><p>这是因为我们的HTML元素是存在父子元素叠加层级的；</p><p>比如一个span元素是放在div元素上的，div元素是放在body元素上的，body元素是放在html元素上的</p><h4 id="2-事件冒泡和事件捕获"><a href="#2-事件冒泡和事件捕获" class="headerlink" title="2.事件冒泡和事件捕获"></a>2.事件冒泡和事件捕获</h4><p>默认情况下事件是从最内层的span向外依次传递的顺序，这个顺序我们称之为事件冒泡（Event Bubble）;</p><p>事实上，还有另外一种监听事件流的方式就是从外层到内层，这种称之为事件捕获（Event Capture）；</p><p>为什么会产生两种不同的处理流呢？</p><ul><li><p>这是因为早期浏览器开发时，不管是IE还是Netscape公司都发现了这个问题;</p></li><li><p>但是他们采用了完全相反的事件流来对事件进行了传递；</p></li><li><p>IE采用了事件冒泡的方式，Netscape采用了事件捕获的方式；</p></li></ul><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230403204855424.png"></p><p>过程：</p><p>如果我们都对其进行监听，则执行顺序：</p><ul><li><p>捕获阶段：事件（从 Window）向下走近元素</p></li><li><p>目标阶段：目标阶段（Target phase）</p></li><li><p>冒泡阶段：冒泡阶段（Bubbling phase）</p></li></ul><p>事实上，我们可以通过event对象来获取当前的阶段：eventPhase</p><p>开发中通常会使用事件冒泡，所以事件捕获了解即可</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230403205036219.png" alt="image-20230403205036219"></p><h3 id="3、事件对象"><a href="#3、事件对象" class="headerlink" title="3、事件对象"></a>3、事件对象</h3><p>当一个事件发生时，就会有和这个事件相关的很多信息：</p><ul><li><p>比如事件的类型是什么，你点击的是哪一个元素，点击的位置是哪里等等相关的信息；</p></li><li><p>这些信息会被封装到一个Event对象中，这个对象由浏览器创建，称之为event对象；</p></li><li><p>该对象给我们提供了想要的一些属性，以及可以通过该对象进行某些操作；</p></li></ul><p>如何获取这个event对象呢？</p><ul><li><p>event对象会在传入的事件处理（event handler）函数回调时，被系统传入；</p></li><li><p>我们可以在回调函数中拿到这个event对象；</p></li></ul><h4 id="event-常见的属性"><a href="#event-常见的属性" class="headerlink" title="event 常见的属性"></a>event 常见的属性</h4><p>type：事件的类型；</p><p><strong>target：当前事件发生的元素；</strong></p><p><strong>currentTarget：当前处理事件的元素；</strong></p><p>eventPhase：事件所处的阶段；</p><p>offsetX、offsetY：事件发生在元素内的位置；</p><p>clientX、clientY：事件发生在客户端内的位置；</p><p>pageX、pageY：事件发生在客户端相对于document的位置；</p><p>screenX、screenY：事件发生相对于屏幕的位置；</p><p>常见的方法：</p><ul><li><p>preventDefault：取消事件的默认行为；</p></li><li><p>stopPropagation：阻止事件的进一步传递（冒泡或者捕获都可以阻止）；</p></li></ul><p>事件处理中的 this</p><p>在函数中，我们也可以通过 this 来获取当前的发生元素</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btnEl = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;button&quot;</span>)</span><br><span class="line"><span class="keyword">var</span> divEl = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;div&quot;</span>)</span><br><span class="line"></span><br><span class="line">divEl.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">currentTarget</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(divEl)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span> === divEl)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是因为在浏览器内部，调用 event handler是绑定到当前的 currentTarget 上的</p><h3 id="4、EventTarget-类"><a href="#4、EventTarget-类" class="headerlink" title="4、EventTarget 类"></a>4、EventTarget 类</h3><p>所有的节点、元素都继承自EventTarget，事实上Window也继承自EventTarget</p><p><strong>EventTarget是一个DOM接口，主要用于添加、删除、派发Event事件；</strong></p><p>EventTarget常见的方法：</p><ul><li><p>addEventListener：注册某个事件类型以及事件处理函数；</p></li><li><p>removeEventListener：移除某个事件类型以及事件处理函数；</p></li><li><p>dispatchEvent：派发某个事件类型到 EventTarget 上；</p></li></ul><h3 id="5、事件委托"><a href="#5、事件委托" class="headerlink" title="5、事件委托"></a>5、事件委托</h3><p>事件冒泡在某种情况下可以帮助我们实现强大的事件处理模式 – 事件委托模式（也是一种设计模式）</p><ul><li><p>当子元素被点击时，父元素可以通过冒泡可以监听到子元素的点击；</p></li><li><p>并且可以通过event.target获取到当前监听的元素；</p></li></ul><p>案例：一个ul中存放多个li，点击某一个li会变成红色</p><ul><li><p>方案一：监听每一个li的点击，并且做出相应</p></li><li><p>方案二：在ul中监听点击，并且通过event.target拿到对应的li进行处理</p><ul><li>因为这种方案并不需要遍历后给每一个li上添加事件监听，所以它更加高效</li></ul></li></ul><h4 id="事件委托的标记"><a href="#事件委托的标记" class="headerlink" title="事件委托的标记"></a>事件委托的标记</h4><p>某些事件委托可能需要对具体的子组件进行区分，这个时候我们可以使用data-*对其进行标记：</p><p>比如多个按钮的点击，区分点击了哪一个按钮</p><h3 id="6、常见的事件"><a href="#6、常见的事件" class="headerlink" title="6、常见的事件"></a>6、常见的事件</h3><h4 id="1-常见的鼠标事件"><a href="#1-常见的鼠标事件" class="headerlink" title="1.常见的鼠标事件"></a>1.常见的鼠标事件</h4><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230404201639786.png" alt="image-20230404201639786"></p><h4 id="2-mouseover和mouseenter的区别"><a href="#2-mouseover和mouseenter的区别" class="headerlink" title="2.mouseover和mouseenter的区别"></a>2.mouseover和mouseenter的区别</h4><p>mouseenter和mouseleave</p><ul><li>不支持冒泡</li><li>进入子元素依然属于在该元素内，没有任何反应</li></ul><p>mouseover和mouseout</p><ul><li>支持冒泡</li><li>进入元素的子元素时<ul><li>先调用父元素的mouseout</li><li>再调用子元素的mouseover</li><li>因为支持冒泡，所以会将mouseover传递到父元素中</li></ul></li></ul><h4 id="3-常见的键盘事件"><a href="#3-常见的键盘事件" class="headerlink" title="3.常见的键盘事件"></a>3.常见的键盘事件</h4><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230404201729813.png" alt="image-20230404201729813"></p><p>事件的执行顺序是 onkeydown、onkeypress、onkeyup</p><ul><li><p>down事件先发生</p></li><li><p>press发生在文本被输入</p></li><li><p>up发生在文本输入完成</p></li></ul><p>通过key和code来区分按下的键：</p><ul><li>code：“按键代码”（”KeyA”，”ArrowLeft” 等），特定于键盘上按键的物理位置</li><li>key：字符（”A”，”a” 等），对于非字符（non-character）的按键，通常具有与 code 相同的值</li></ul><h4 id="4-常见的表单事件"><a href="#4-常见的表单事件" class="headerlink" title="4.常见的表单事件"></a>4.常见的表单事件</h4><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230403205650505.png" alt="image-20230403205650505"></p><h4 id="5-文档加载事件"><a href="#5-文档加载事件" class="headerlink" title="5.文档加载事件"></a>5.文档加载事件</h4><ul><li><p>DOMContentLoaded：浏览器已完全加载 HTML，并构建了 DOM 树，但像和样式表之类的外部资源可能尚未加载 完成</p></li><li><p>load：浏览器不仅加载完成了 HTML，还加载完成了所有外部资源：图片，样式等</p></li></ul><p>事件类型：<a href="https://developer.mozilla.org/zh-CN/docs/Web/Events">https://developer.mozilla.org/zh-CN/docs/Web/Events</a></p><h2 id="12-DOM阶段案例"><a href="#12-DOM阶段案例" class="headerlink" title="12.DOM阶段案例"></a>12.DOM阶段案例</h2><p>定时器</p><p>消息滚动</p><p>关闭弹窗</p><p>侧边栏触控展示</p><p>登录展示</p><p>tab栏切换</p><p>轮播图的实现</p><p>购物车操作</p><h2 id="13-JavaScript中的BOM操作"><a href="#13-JavaScript中的BOM操作" class="headerlink" title="13.JavaScript中的BOM操作"></a>13.JavaScript中的BOM操作</h2><h3 id="1、认识BOM操作"><a href="#1、认识BOM操作" class="headerlink" title="1、认识BOM操作"></a>1、认识BOM操作</h3><p>BOM：浏览器对象模型（Brower Object Model）</p><ul><li><p>简称 BOM，由浏览器提供的用于处理文档（document）之外的所有内容的其他对象</p></li><li><p>比如navigator、location、history等对象</p></li></ul><p>JavaScript有一个非常重要的运行环境就是浏览器</p><ul><li>而且浏览器本身又作为一个应用程序需要对其本身进行操作</li><li>所以通常浏览器会有对应的对象模型（BOM，Browser Object Model）</li><li>我们可以将BOM看成是连接 JavaScript 脚本与浏览器窗口的桥梁</li></ul><p>BOM主要包括一下的对象模型：</p><ul><li>window：包括全局属性、方法，控制浏览器窗口相关的属性、方法</li><li>location：浏览器连接到的对象的位置（URL）</li><li>history：操作浏览器的历史</li><li>navigator：用户代理（浏览器）的状态和标识（很少用到）</li><li>screen：屏幕窗口信息（很少用到）</li></ul><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230403201933683.png" alt="image-20230403201933683"></p><h3 id="2、全局对象window"><a href="#2、全局对象window" class="headerlink" title="2、全局对象window"></a>2、全局对象window</h3><p>window对象在浏览器中可以从两个视角来看待：</p><ul><li><p>视角一：全局对象</p><ul><li>我们知道ECMAScript其实是有一个全局对象的，这个全局对象在Node中是global</li><li>在浏览器中就是window对象</li></ul></li><li><p>视角二：浏览器窗口对象</p><ul><li>作为浏览器窗口时，提供了对浏览器操作的相关的API</li></ul></li></ul><p>这两个视角存在大量重叠的地方，不需要刻意去区分它们：</p><ul><li><p>事实上对于浏览器和Node中全局对象名称不一样的情况，目前已经指定了对应的标准，称之为globalThis，并且大多数现代 浏览器都支持它</p></li><li><p>放在window对象上的所有属性都可以被访问</p></li><li><p>使用var定义的变量会被添加到window对象中</p></li><li><p>window默认给我们提供了全局的函数和类：setTimeout、Math、Date、Object等</p></li></ul><p>事实上window对象上肩负的重担是非常大的：</p><ul><li><p>第一：包含大量的属性，localStorage、console、location、history、screenX、scrollX等</p></li><li><p>第二：包含大量的方法，alert、close、scrollTo、open等等（大概40+个方法）</p></li><li><p>第三：包含大量的事件，focus、blur、load、hashchange等等（大概30+个事件）</p></li><li><p>第四：包含从EventTarget继承过来的方法，addEventListener、removeEventListener、dispatchEvent方法；</p></li></ul><p>属性、方法、事件在MDN文档查看：<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window">https://developer.mozilla.org/zh-CN/docs/Web/API/Window</a></p><p>查看MDN文档时不同的符号的意思：</p><ul><li><p>删除符号：表示这个API已经废弃，不推荐继续使用了</p></li><li><p>点踩符号：表示这个API不属于W3C规范，某些浏览器有实现（所以兼容性的问题）</p></li><li><p>实验符号：该API是实验性特性，以后可能会修改，并且存在兼容性问题</p></li></ul><p>window 常见的属性</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">outerHeight</span>)</span><br></pre></td></tr></table></figure><p>window 常见的方法</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> openBtn = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;.open&quot;</span>)</span><br><span class="line"></span><br><span class="line">    openBtn.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">window</span>.<span class="title function_">open</span>(<span class="string">&quot;./page/new.html&quot;</span>, <span class="string">&quot;_blank&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> closeBtn = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;.close&quot;</span>)</span><br><span class="line"></span><br><span class="line">    closeBtn.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">window</span>.<span class="title function_">close</span>()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>window 常见的事件</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// window.onfocus = function() &#123;</span></span><br><span class="line">    <span class="comment">//   console.log(&quot;窗口获得了焦点&quot;)</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// window.onblur = function() &#123;</span></span><br><span class="line">    <span class="comment">//   console.log(&quot;窗口失去了焦点&quot;)</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="variable language_">window</span>.<span class="property">onhashchange</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hash值发生了改变&quot;</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="3、location对象"><a href="#3、location对象" class="headerlink" title="3、location对象"></a>3、location对象</h3><p>location对象用于表示window上当前链接到的URL信息</p><p>常见的属性：</p><ul><li>href: 当前window对应的超链接URL, 整个URL</li><li>protocol: 当前的协议；  host: 主机地址</li><li>hostname: 主机地址(不带端口)</li><li>port: 端口；  pathname: 路径</li><li>search: 查询字符串</li><li>hash: 哈希值</li><li>username：URL中的username（很多浏览器已经禁用）</li><li>password：URL中的password（很多浏览器已经禁用）</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.完整的url</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(location.<span class="property">href</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2。获取url的信息</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(location.<span class="property">hostname</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(location.<span class="property">host</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(location.<span class="property">protocol</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(location.<span class="property">port</span>)</span><br></pre></td></tr></table></figure><p>location其实是URL的一个抽象实现：</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230403202307394.png" alt="image-20230403202307394"></p><p>location有如下常用的方法：</p><ul><li>assign：赋值一个新的URL，并且跳转到该URL中</li><li>replace：打开一个新的URL，并且跳转到该URL中（不同的是不会在浏览记录中留下之前的记录）</li><li>reload：重新加载页面，可以传入一个Boolean类型</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">btns[<span class="number">0</span>].<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      location.<span class="title function_">assign</span>(<span class="string">&quot;https://www.baidu.com&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    btns[<span class="number">1</span>].<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      location.<span class="title function_">replace</span>(<span class="string">&quot;https://www.baidu.com&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    btns[<span class="number">2</span>].<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      location.<span class="title function_">reload</span>()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="4、URLSearchParams"><a href="#4、URLSearchParams" class="headerlink" title="4、URLSearchParams"></a>4、URLSearchParams</h3><p>URLSearchParams 定义了一些实用的方法来处理 URL 的查询字符串</p><ul><li><p>可以将一个字符串转化成URLSearchParams类型</p></li><li><p>也可以将一个URLSearchParams类型转成字符串</p></li></ul><p>URLSearchParams常见的方法有如下：</p><ul><li><p>get：获取搜索参数的值</p></li><li><p>set：设置一个搜索参数和值</p></li><li><p>append：追加一个搜索参数和值</p></li><li><p>has：判断是否有某个搜索参数</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/URLSearchParams">https://developer.mozilla.org/zh-CN/docs/Web/API/URLSearchParams</a></p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> urlSearchString = <span class="string">&quot;?name=wbh&amp;age=21&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(urlSearchString.<span class="title function_">split</span>(<span class="string">&quot;&amp;&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> searchParams = <span class="keyword">new</span> <span class="title class_">URLSearchParams</span>(urlSearchString)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(searchParams.<span class="title function_">get</span>(<span class="string">&quot;name&quot;</span>))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(searchParams.<span class="title function_">get</span>(<span class="string">&quot;age&quot;</span>))</span><br><span class="line"></span><br><span class="line">searchParams.<span class="title function_">append</span>(<span class="string">&quot;address&quot;</span>, <span class="string">&quot;广州市&quot;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(searchParams.<span class="title function_">get</span>(<span class="string">&quot;address&quot;</span>))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(searchParams.<span class="title function_">toString</span>())</span><br></pre></td></tr></table></figure><p>中文会使用encodeURIComponent和decodeURIComponent进行编码和解码</p><h3 id="5、history对象"><a href="#5、history对象" class="headerlink" title="5、history对象"></a>5、history对象</h3><p>history对象允许我们访问浏览器曾经的会话历史记录</p><p>有两个属性</p><ul><li><p>length：会话中的记录条数</p></li><li><p>state：当前保留的状态值</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(history.<span class="property">length</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(history.<span class="property">state</span>)</span><br></pre></td></tr></table></figure><p>有五个方法</p><ul><li>back()：返回上一页，等价于history.go(-1)</li><li>forward()：前进下一页，等价于history.go(1)</li><li>go()：加载历史中的某一页</li><li>pushState()：打开一个指定的地址</li><li>replaceState()：打开一个新的地址，并且使用replace；</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">btnEl.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// history.pushState(&#123;name:&quot;wd&quot;, age:&quot;23&quot;&#125;, &quot;&quot;, &quot;/why&quot;)</span></span><br><span class="line">      history.<span class="title function_">replaceState</span>(&#123;<span class="attr">name</span>:<span class="string">&quot;wd&quot;</span>, <span class="attr">age</span>:<span class="string">&quot;23&quot;</span>&#125;, <span class="string">&quot;&quot;</span>, <span class="string">&quot;/why&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> backEl = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;.back&quot;</span>)</span><br><span class="line">    backEl.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      history.<span class="title function_">back</span>()</span><br><span class="line">      history.<span class="title function_">forward</span>()</span><br><span class="line">      <span class="comment">// 类似于上面的两个方法，只是可以传入层级</span></span><br><span class="line">      history.<span class="title function_">go</span>(-<span class="number">2</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>history和hash目前是vue、react等框架实现路由的底层原理</p><h3 id="6、navigator、screen（很少用）"><a href="#6、navigator、screen（很少用）" class="headerlink" title="6、navigator、screen（很少用）"></a>6、navigator、screen（很少用）</h3><p>navigator 对象表示用户代理的状态和标识等信息</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230403202821277.png" alt="image-20230403202821277"></p><p>screen主要记录的是浏览器窗口外面的客户端显示器的信息</p><ul><li>比如屏幕的逻辑像素 screen.width、screen.height</li></ul><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230403202842991.png" alt="image-20230403202842991"></p><h3 id="7、JSON、Storage"><a href="#7、JSON、Storage" class="headerlink" title="7、JSON、Storage"></a>7、JSON、Storage</h3><h4 id="1-JSON的简单理解"><a href="#1-JSON的简单理解" class="headerlink" title="1.JSON的简单理解"></a>1.JSON的简单理解</h4><p>在目前的开发中，JSON是一种非常重要的数据格式，它并不是编程语言，而是一种可以在服务器和客户端之间传输的数据格式</p><p>JSON的全称是JavaScript Object Notation（JavaScript对象符号）</p><ul><li>JSON是由Douglas Crockford构想和设计的一种轻量级资料交换格式，算是JavaScript的一个子集</li><li>但是虽然JSON被提出来的时候是主要应用JavaScript中，但是目前已经独立于编程语言，可以在各个编程语言中使用</li><li>很多编程语言都实现了将JSON转成对应模型的方式</li></ul><p>其他的传输格式：</p><ul><li>XML：在早期的网络传输中主要是使用XML来进行数据交换的，但是这种格式在解析、传输等各方面都弱于JSON，所以目前已经很 少在被使用了</li><li>Protobuf：另外一个在网络传输中目前已经越来越多使用的传输格式是protobuf，但是直到2021年的3.x版本才支持JavaScript，所 以目前在前端使用的较少</li></ul><p>目前JSON被使用的场景也越来越多：</p><ul><li>网络数据的传输JSON数据</li><li>项目的某些配置文件</li><li>非关系型数据库（NoSQL）将json作为存储格式</li></ul><h4 id="2-JSON的基本语法"><a href="#2-JSON的基本语法" class="headerlink" title="2.JSON的基本语法"></a>2.JSON的基本语法</h4><p>JSON的顶层支持三种类型的值：</p><ul><li><p>简单值：数字（Number）、字符串（String，不支持单引号）、布尔类型（Boolean）、null类型</p></li><li><p>对象值：由key、value组成，key是字符串类型，并且必须添加双引号，值可以是简单值、对象值、数组值</p></li><li><p>数组值：数组的值可以是简单值、对象值、数组值</p></li></ul><h4 id="3-JSON序列化"><a href="#3-JSON序列化" class="headerlink" title="3.JSON序列化"></a>3.JSON序列化</h4><p>某些情况下我们希望将JavaScript中的复杂类型转化成JSON格式的字符串，这样方便对其进行处理</p><ul><li><p>比如我们希望将一个对象保存到localStorage中</p></li><li><p>但是如果我们直接存放一个对象，这个对象会被转化成 [object Object] 格式的字符串，并不是我们想要的结果；</p></li></ul><p>在ES5中引用了JSON全局对象，该对象有两个常用的方法：</p><ul><li>stringify方法：将JavaScript类型转成对应的JSON字符串</li><li>parse方法：解析JSON字符串，转回对应的JavaScript类型</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;sdw&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">23</span>,</span><br><span class="line">    <span class="attr">friend</span>: &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;dsds&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1.将obj对象进行序列化</span></span><br><span class="line"><span class="keyword">var</span> objJSONString = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(objJSONString)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.存储到浏览器本地 localstorage</span></span><br><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&quot;info&quot;</span>, objJSONString)</span><br><span class="line"><span class="keyword">var</span> item = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&quot;info&quot;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(item, <span class="keyword">typeof</span> item)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.将自付出转回到对象（反序列化）</span></span><br><span class="line"><span class="keyword">var</span> newObj = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(item)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newObj)</span><br></pre></td></tr></table></figure><h4 id="4-Stringfy的补充"><a href="#4-Stringfy的补充" class="headerlink" title="4.Stringfy的补充"></a>4.Stringfy的补充</h4><h5 id="Stringfy-的参数-replacer"><a href="#Stringfy-的参数-replacer" class="headerlink" title="Stringfy 的参数 replacer"></a>Stringfy 的参数 replacer</h5><p>JSON.stringify() 方法将一个 JavaScript 对象或值转换为 JSON 字符串：</p><ul><li><p>如果指定了一个 replacer 函数，则可以选择性地替换值</p></li><li><p>如果指定的 replacer 是数组，则可选择性地仅包含数组指定的属性</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// replacer参数</span></span><br><span class="line"><span class="keyword">var</span> objJSONString = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj, <span class="keyword">function</span>(<span class="params">key, value</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (key === <span class="string">&quot;name&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;coderwhy&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> value</span><br><span class="line">&#125;, <span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure><h5 id="Stringify的参数space"><a href="#Stringify的参数space" class="headerlink" title="Stringify的参数space"></a>Stringify的参数space</h5><p>如果对象本身包含toJSON方法，那么会直接使用toJSON方法的结果：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2.space参数</span></span><br><span class="line"><span class="comment">// var objJSONString = JSON.stringify(obj, null, 4)</span></span><br><span class="line"><span class="comment">// console.log(objJSONString)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.如果对象本身有显示toJSON方法，那么直接调用toJSON方法</span></span><br><span class="line"><span class="keyword">var</span> objJSONString = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(objJSONString)</span><br></pre></td></tr></table></figure><h4 id="5-parse方法"><a href="#5-parse方法" class="headerlink" title="5.parse方法"></a>5.parse方法</h4><p>JSON.parse() 方法用来解析JSON字符串，构造由字符串描述的JavaScript值或对象</p><ul><li>提供可选的 reviver 函数用以在返回之前对所得到的对象执行变换(操作)</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> newObj = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(objJSONString, <span class="keyword">function</span>(<span class="params">key, value</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (key === <span class="string">&quot;age&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> value + <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>JSON的方法可以帮我们实现对象的深拷贝</p><h3 id="8、认识Storage"><a href="#8、认识Storage" class="headerlink" title="8、认识Storage"></a>8、认识Storage</h3><h4 id="1-浏览器本地存储"><a href="#1-浏览器本地存储" class="headerlink" title="1.浏览器本地存储"></a>1.浏览器本地存储</h4><p>WebStorage主要提供了一种机制，可以让浏览器提供一种比cookie更直观的key、value存储方式：</p><ul><li>localStorage：本地存储，提供的是一种永久性的存储方法，在关闭掉网页重新打开时，存储的内容依然保留</li><li>sessionStorage：会话存储，提供的是本次会话的存储，在关闭掉会话时，存储的内容会被清除</li></ul><h4 id="2-localStorage和sessionStorage的区别"><a href="#2-localStorage和sessionStorage的区别" class="headerlink" title="2.localStorage和sessionStorage的区别"></a>2.localStorage和sessionStorage的区别</h4><ul><li>验证一：关闭网页后重新打开，localStorage会保留，而sessionStorage会被删除</li><li>验证二：在页面内实现跳转，localStorage会保留，sessionStorage也会保留</li><li>验证三：在页面外实现跳转（打开新的网页），localStorage会保留，sessionStorage不会被保留</li></ul><h4 id="3-Storage有如下的属性和方法："><a href="#3-Storage有如下的属性和方法：" class="headerlink" title="3.Storage有如下的属性和方法："></a>3.Storage有如下的属性和方法：</h4><p>属性：</p><ul><li>Storage.length：只读属性<ul><li>返回一个整数，表示存储在Storage对象中的数据项数量</li></ul></li></ul><p>方法：</p><ul><li>Storage.key()：该方法接受一个数值n作为参数，返回存储中的第n个key名称</li><li>Storage.getItem()：该方法接受一个key作为参数，并且返回key对应的value</li><li>Storage.setItem()：该方法接受一个key和value，并且将会把key和value添加到存储中<ul><li>如果key存储，则更新其对应的值</li></ul></li><li>Storage.removeItem()：该方法接受一个key作为参数，并把该key从存储中删除</li><li>Storage.clear()：该方法的作用是清空存储中的所有key</li></ul><h2 id="14-阶段案例"><a href="#14-阶段案例" class="headerlink" title="14.阶段案例"></a>14.阶段案例</h2><blockquote><p> 华为商城的搭建</p></blockquote><ol><li>页面搭建</li><li>数据插入，现阶段两种方法：创建每一个元素并插入；&#96;&#96;字符模板插入</li><li>实现列表的动态展示<ul><li>获取需要进行筛选的条件</li><li>动态获取 filters 内容（点击按钮获取textContent，取消按钮移除textContent）</li></ul></li><li>过滤数据</li><li>展示数据</li></ol><blockquote><p> 华为轮播图实现与无限轮播</p></blockquote><p>原理：为图片添加 active，并设置 opacity</p><ol><li>获取数据插入页面</li><li>使用定位，将图片定位在 banner 中</li><li>监听事件（上下页）点击，将图片进行展示（opacity &#x3D; 1，添加动画）</li><li>定时器进行自动轮播</li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IT前端 </tag>
            
            <tag> JavaScript </tag>
            
            <tag> DOM </tag>
            
            <tag> BOM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络知识整理</title>
      <link href="/archives/58e66b84.html"/>
      <url>/archives/58e66b84.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IT </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML/CSS 知识体系（部分）</title>
      <link href="/archives/f99e1de4.html"/>
      <url>/archives/f99e1de4.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前端开发"><a href="#前端开发" class="headerlink" title="前端开发"></a>前端开发</h1><h2 id="1-什么是软件"><a href="#1-什么是软件" class="headerlink" title="1.什么是软件"></a>1.什么是软件</h2><p>一系列按照特定顺序组织的计算机数据和指令，是电脑的非有型部分</p><p>软件开发就是告诉计算机一系列的指令，这些指令也称之为程序</p><h2 id="2-软件开发和应用程序开发有什么区别"><a href="#2-软件开发和应用程序开发有什么区别" class="headerlink" title="2.软件开发和应用程序开发有什么区别"></a>2.软件开发和应用程序开发有什么区别</h2><p> <img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230216143732155.png" alt="image-20230216143732155"></p><h2 id="3-完善的应用系统"><a href="#3-完善的应用系统" class="headerlink" title="3.完善的应用系统"></a>3.完善的应用系统</h2><p>服务器、客户端</p><h2 id="4-前端开发工程师-Front-end"><a href="#4-前端开发工程师-Front-end" class="headerlink" title="4.前端开发工程师-Front-end"></a>4.前端开发工程师-Front-end</h2><p>主要负责：Web（网站、后台管理系统、手机H5）、小程序端</p><p>也可以：移动端（Uniapp、React Native）、桌面端（Electron）、服务器开发（Node.js）</p><p><strong>书籍：</strong>《JavaScript高级程序设计》-nicholas C.Zakas  </p><p>《你不知道的JavaScript》</p><h1 id="Web开发"><a href="#Web开发" class="headerlink" title="Web开发"></a>Web开发</h1><h2 id="1-什么是网页"><a href="#1-什么是网页" class="headerlink" title="1.什么是网页"></a>1.什么是网页</h2><p>web page，打开浏览器查看到的一页，是网络中的一页，包括文字、链接、音乐、视频等</p><h2 id="2-什么是网站"><a href="#2-什么是网站" class="headerlink" title="2.什么是网站"></a>2.什么是网站</h2><p>网站是由多个网页组成；通常是n个网页（n&gt;&#x3D;1）</p><h2 id="3-网页的显示过程"><a href="#3-网页的显示过程" class="headerlink" title="3.网页的显示过程"></a>3.网页的显示过程</h2><p>用户：</p><p>网址-&gt;DNS服务器解析-&gt;ip地址-&gt;服务器-&gt;下载资源到浏览器-&gt;浏览器渲染引擎</p><p>​1.用户在浏览器输入一个网址</p><p>​2.浏览器会找到一个对应的服务器地址，请求静态资源</p><p>​3.服务器返回静态资源给浏览器</p><p>​4.浏览器对静态资源进行解析和展示</p><p>前端工程师：</p><p>​1.开发项目</p><p>​2.打包、部署项目到服务器里面</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230216162009343.png" alt="image-20230216162009343"></p><h2 id="4-服务器是什么"><a href="#4-服务器是什么" class="headerlink" title="4.服务器是什么"></a>4.服务器是什么</h2><p>本质是一台类似电脑的主机；稳定运行不关机；没有显示器；一般装的是Linux操作系统</p><h2 id="5-网页的组成"><a href="#5-网页的组成" class="headerlink" title="5.网页的组成"></a>5.网页的组成</h2><ul><li><p>HTML元素：网页的内容结构</p></li><li><p>CSS样式：网页的视觉体验</p></li><li><p>JavaScript语言：网页的交互处理</p></li></ul><h2 id="6-浏览器的作用"><a href="#6-浏览器的作用" class="headerlink" title="6.浏览器的作用"></a>6.浏览器的作用</h2><p>浏览器最核心的部分是渲染引擎，一般也称之为“浏览器内核”，负责解析网页语法，并渲染（显示）网页</p><h2 id="7-不同浏览器的内核"><a href="#7-不同浏览器的内核" class="headerlink" title="7.不同浏览器的内核"></a>7.不同浏览器的内核</h2><ul><li>Trident（三叉戟）：IE、360安全、搜狗高速、百度、UC</li><li>Gecko（壁虎）：火狐</li><li>Presto（急板乐趣）-&gt;Blink（眨眼）：Opera</li><li>Webkit：Safari、360极速、搜狗高速、移动端浏览器（安卓、ios）</li><li>Webkit-&gt;Blink：谷歌、Edge</li></ul><p>不同的浏览器内核有不同的解析、渲染规则，所以同一个网页在不同内核的浏览器中的渲染效果也可能不同</p><h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><p>Hyper-Text-Markup-Language：超文本标记语言，是一种用于创建网页的标记语言</p><p>HTML是构建网页的基石</p><h2 id="1-什么是标记语言"><a href="#1-什么是标记语言" class="headerlink" title="1.什么是标记语言"></a>1.什么是标记语言</h2><ul><li>由无数个标记组成</li><li>是对某些内容进行特殊的标记，以供其他解释器识别处理</li><li>比如<code>&lt;h2&gt;&lt;/h2&gt;</code>标记的文本会被识别为“标题”进行加粗、文字放大显示</li><li>由标签和内容组成的部分称为元素</li></ul><h2 id="2-什么是超文本"><a href="#2-什么是超文本" class="headerlink" title="2.什么是超文本"></a>2.什么是超文本</h2><ul><li>不仅仅可以插入普通的文本，还可以插入图片、音视频等</li><li>还可以表示超链接，从一个网页跳转到另一个网页</li></ul><h2 id="3-HTML文件的特点-结构"><a href="#3-HTML文件的特点-结构" class="headerlink" title="3.HTML文件的特点-结构"></a>3.HTML文件的特点-结构</h2><h3 id="1、HTML文件的扩展名"><a href="#1、HTML文件的扩展名" class="headerlink" title="1、HTML文件的扩展名"></a>1、HTML文件的扩展名</h3><p>因历史遗留问题，win95&#x2F;98系统的文件扩展名不能超过3位，所以用.htm</p><p>现在统一使用.html</p><h3 id="2、结构"><a href="#2、结构" class="headerlink" title="2、结构"></a>2、结构</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span>元数据（metedata）<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span>内容<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h2 id="4-工具"><a href="#4-工具" class="headerlink" title="4.工具"></a>4.工具</h2><p>vscode安装</p><ul><li><p>安装插件：中文-chinese</p></li><li><p>颜色主题：atom one dark</p></li><li><p>文件夹图标：VScode great Icons</p></li><li><p>在浏览器打开网页：open in browser、Live sever（实时刷新）</p></li><li><p>自动重命名标签：auto rename tag</p></li></ul><p>配置</p><ul><li><p>自动保存</p></li><li><p>自动换行：word wrap</p></li><li><p>空格的渲染方式：render whitespace</p></li><li><p>缩进：tab size</p></li></ul><h2 id="5-认识元素"><a href="#5-认识元素" class="headerlink" title="5.认识元素"></a>5.认识元素</h2><h3 id="1、什么是元素"><a href="#1、什么是元素" class="headerlink" title="1、什么是元素"></a>1、什么是元素</h3><p>元素是网页的一部分</p><p>一个元素可以包含一个数据项，或是一块文本，或是一张照片，亦或是什么都不包含</p><p>那么HTML中都有哪些元素呢？</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element">https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element</a></p><h3 id="2、元素的组成"><a href="#2、元素的组成" class="headerlink" title="2、元素的组成"></a>2、元素的组成</h3><ul><li>开始标签：被左右尖括号所包围</li><li>结束标签：与开始标签相似，只是在其元素名之前包含了一个斜杠，表示元素的结尾</li><li>内容：元素的内容</li><li>元素：前三者相结合便是一个完整的元素</li></ul><h3 id="3、单标签-双标签"><a href="#3、单标签-双标签" class="headerlink" title="3、单标签-双标签"></a>3、单标签-双标签</h3><p>双标签元素</p><p>html、body、head、h2、p、a元素</p><p>单标签元素</p><p>br、img、hr、meta、input</p><p>注意：</p><p>html标签不区分大小写，推荐小写</p><h3 id="4、元素的属性"><a href="#4、元素的属性" class="headerlink" title="4、元素的属性"></a>4、元素的属性</h3><p>元素也是可以拥有属性（Attribute）:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;p <span class="keyword">class</span>=<span class="string">&quot;attr&quot;</span>&gt;wowowo&lt;/p&gt;</span><br></pre></td></tr></table></figure><p>属性包含元素的额外信息，这些信息不会出现在实际的内容中</p><p>一个属性必须包含：</p><ul><li>1.一个空格，在属性和元素名称之间。多个属性用空格隔开</li><li>2.属性名称，后面跟着一个等于符</li><li>3.一个属性值，由一对引号“ ”引起来</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;h1 属性名=<span class="string">&quot;属性值&quot;</span>&gt;我是标题&lt;/h1&gt;</span><br></pre></td></tr></table></figure><p>元素属性的分类</p><p>有些属性是公共的，每一个元素都可以设置</p><ul><li>class、id、title属性</li></ul><p>有些属性是元素特有的，不是每一个元素都可以设置</p><ul><li>meta元素的charset属性、img元素的alt属性等</li></ul><h3 id="5、元素的嵌套关系"><a href="#5、元素的嵌套关系" class="headerlink" title="5、元素的嵌套关系"></a>5、元素的嵌套关系</h3><p>某些元素的内容除了可以是文本外，还可以是其他元素，这样就形成了元素的嵌套</p><p>元素之间的关系：                                                                                                                                                                                            </p><p>父子关系，比如ul和li，li和span之间</p><p>兄弟关系，比如两个div，两个span之间</p><p>注释：ctrl+&#x2F;</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!--  --&gt;</span><br></pre></td></tr></table></figure><h2 id="6-HTML常见的元素"><a href="#6-HTML常见的元素" class="headerlink" title="6.HTML常见的元素"></a>6.HTML常见的元素</h2><h3 id="1、HTML结构分析"><a href="#1、HTML结构分析" class="headerlink" title="1、HTML结构分析"></a>1、HTML结构分析</h3><p>文档声明：HTML最上方的一段文本我们称之为文档类型声明，用于声明类型。不仅声明文件类型，而且声明版本，让浏览器按照相应标准去解析识别内容，必须放在HTML文档的最前面，不可省略，否则会出现兼容性问题</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!<span class="variable constant_">DOCTYPE</span> html&gt;  <span class="comment">// 告诉浏览器是HTML5版本</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;元素表示一个<span class="variable constant_">HTML</span>文档的根（顶级元素），所以它被称之为根元素&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>所有其他元素必须是此元素的后代</p><p>W3C标准建议为html元素增加一个lang属性，作用是</p><ul><li>帮助语言合成工具确定要使用的语言</li><li>帮助翻译工具确定要使用的翻译规则</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt; 表示这个<span class="variable constant_">HTML</span>文档使用的语言是英文</span><br><span class="line">&lt;html lang=<span class="string">&quot;zh-CN&quot;</span>&gt; 表示这个<span class="variable constant_">HTML</span>文档的语言是中文</span><br></pre></td></tr></table></figure><p>HTML中head元素规定文档相关的配置信息（也称为元数据），包括文档的标题，引用的文档样式和脚本等</p><ul><li><p>元数据：描述数据的数据</p></li><li><p>这里我们可以理解成对整个页面的配置</p></li></ul><p>网页的标题：title元素</p><p>网页的编码：meta元素</p><ul><li>可以用于设置网页的字符编码，让浏览器更精准的显示每一个文字，不设置或者设置错误会导致乱码</li><li>一般都使用utf-8编码，涵盖了世界上几乎所有的文字</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br></pre></td></tr></table></figure><p>body元素里面的内容将是你在浏览器窗口中看到的东西，也就是网页的具体内容和结构</p><h3 id="2、常见的元素"><a href="#2、常见的元素" class="headerlink" title="2、常见的元素"></a>2、常见的元素</h3><p><strong>h元素</strong>：作为标题—h1-h6：呈现6个不同的级别的标题</p><p><strong>p元素</strong>：表示段落，段落之间有一定的间距</p><p><strong>img元素</strong>：将一份图像嵌入文档。是一个可替换元素</p><ul><li>src属性：图片文件的路径（必须）</li><li>alt属性：文件加载不成功时候显示这段文本；屏幕阅读器会将这些描述给需要使用阅读器的使用者听，让他们知道图片的含义（不是强制性的）</li></ul><p>图片的路径：</p><ul><li>绝对路径：根盘符开始查找，一直找到这个资源</li><li>相对路径：相对于当前文件的路径；.当前文件夹；..上级文件夹</li></ul><p>对于网页来说，不管是什么操作系统，路径分隔符都是&#x2F;，而不是\</p><p><strong>a元素</strong>：（锚：anchor）超链接，打开新的URL</p><ul><li><p>href（ Hypertext Reference）：指定要打开的URL地址，也可以是一个本地地址</p></li><li><p>target：指定在何处显示链接的资源</p><p>​_self：默认值，在当前窗口打开URL</p><p>​_blank：在新的窗口打开URL</p></li></ul><p>锚点链接：锚点可以实现跳转到网页中的具体位置</p><ul><li>在要跳到的元素上定义一个id属性</li><li>定义a元素，并且a元素的href指向对应的id</li></ul><p>a元素中能使用img元素作为跳转</p><p>a元素指向其他的URL：</p><ul><li>压缩包：</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;a href=<span class="string">&quot;https://github.com/coderwhy/HYMiniMall/archive/master.zip&quot;</span>&gt;下载zip包&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>​会直接下载</p><ul><li>指向其他的协议地址：</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;a href=<span class="string">&quot;mailto:123@qq.com&quot;</span>&gt;发邮箱给123qq.<span class="property">com</span>&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>​能打开电脑邮箱软件对发件邮箱进行填充</p><p><strong>iframe元素</strong>：在一个HTML文档中嵌入其他HTML文档</p><ul><li>frameborder属性：用于规定是否显示边框：1：显示  0：不显示</li></ul><p>a元素target属性的其他值：</p><ul><li>_parent：在父窗口打开URL</li><li>_top：在顶层窗口打开URL</li></ul><p>div元素和span元素都是纯粹的容器，也可以把他们理解为盒子，他们都是用来包裹内容的</p><p>无所用、无所不用：</p><p><strong>div元素</strong>：division，分开、分配的意思</p><p>多个div元素包裹的内容会在不同的行显示</p><ul><li>一般作为其他元素的父容器，把其他元素包住，代表一个整体</li><li>用于将网页分割为多个独立的部分</li></ul><p><strong>span元素</strong>：跨域、涵盖的意思；</p><p>多个span元素包裹的内容会同一行显示</p><ul><li>默认情况下，跟普通文本几乎没有差别</li><li>用于区分特殊文本和普通文本，比如显示一些关键字</li></ul><h3 id="3、不常用元素"><a href="#3、不常用元素" class="headerlink" title="3、不常用元素"></a>3、不常用元素</h3><p><strong>strong元素</strong>：内容加粗，强调</p><ul><li>通常加粗会使用css样式来完成</li><li>开发中偶尔会使用</li></ul><p><strong>i元素</strong>：内容倾斜</p><ul><li>开发中通常使用css设置倾斜</li><li>偶尔使用它来做字体图标（看起来像是icon的缩写）</li></ul><p><strong>code元素</strong>：用来显示代码</p><ul><li>偶尔会使用来显示等宽字体</li></ul><p><strong>br元素</strong>：换行元素</p><ul><li>开发中不再使用</li></ul><h3 id="4、HTML全局属性"><a href="#4、HTML全局属性" class="headerlink" title="4、HTML全局属性"></a>4、HTML全局属性</h3><p>某些属性只能设置在特定的元素中</p><p>但是也有一些属性是所有HTML都可以设置和拥有的，这样的属性称之为全局属性</p><p>常见的全局属性：</p><ul><li>id：定义唯一标识符，该标识符在整个文档中必须是唯一的</li><li>class：一个以空格分隔的元素的类名列表</li><li>style：给元素添加内联样式</li><li>title：包含表示与其属性元素相关信息的文本</li></ul><h2 id="7-额外补充"><a href="#7-额外补充" class="headerlink" title="7.额外补充"></a>7.额外补充</h2><h3 id="1、字符实体"><a href="#1、字符实体" class="headerlink" title="1、字符实体"></a>1、字符实体</h3><p>我们编写的HTML会被浏览器解析，那是怎么解析的呢？</p><ul><li><p>如果使用小于号&lt;，浏览器会将其后面的文本解析为一个标签</p></li><li><p>但是在某些情况下我们确实需要编写一个小于号&lt;</p></li><li><p>这时候就可以使用字符实体</p></li></ul><p>HTML实体是一段以连字号(&amp;)开头、以分号(;)结尾的文本（字符串）</p><ul><li>字符实体常用于显示保留字符（这些字符会被解析为HTML代码）和不可见字符（如“不换行空格”）</li><li>你也可以使用实体来代替其他难以用标准键盘键入的字符</li></ul><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230219140224361.png" alt="image-20230219140224361"></p><h3 id="2、URL地址"><a href="#2、URL地址" class="headerlink" title="2、URL地址"></a>2、URL地址</h3><p><strong>URL</strong> 代表着统一资源定位符（Uniform Resource Locator）</p><p>URL 无非就是一个给定的独特资源在Web上的网址</p><ul><li>理论上说：每一个有效的URL都指向一个唯一的资源</li><li>这个资源可以是一个HTML页面，一个CSS文档，一幅图像，等等</li></ul><p>URL标准格式：</p><ul><li>【协议类型】:&#x2F;&#x2F;[服务器地址]:[端口号]&#x2F;【文件路径】【文件名】？[查询]#[片段ID]</li></ul><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230219142839021.png" alt="image-20230219142839021"></p><p>和URI的区别：</p><p>URI（identifier）：统一资源标志符，用于标识Web技术使用的逻辑或物理资源</p><p>URI在某一个规则下能把一个资源独一无二的识别出来</p><ul><li>URL作为一个网络web资源的地址，可以唯一将一个资源识别出来，所以URL是一个URI</li><li>URL是URI的一个子集</li><li>但是URI并不一定是URL</li></ul><h3 id="3、元素语义化"><a href="#3、元素语义化" class="headerlink" title="3、元素语义化"></a>3、元素语义化</h3><p>用正确的元素做正确的事情</p><p>理论上来说，所有的HTML元素，我们都能实现相同的事情</p><p>标签语义化</p><ul><li>方面代码的维护</li><li>减少开发者之间的沟通成本</li><li>能让语音识别工具正确识别网页的用图，以便做出正确的反应</li><li>有利于SEO</li></ul><h3 id="4、SEO优化"><a href="#4、SEO优化" class="headerlink" title="4、SEO优化"></a>4、SEO优化</h3><p>搜索引擎优化（search engine optimization）是通过了解搜索引擎的运作规则来调整网站，以及提高网站在有关搜索引擎内排名的方式</p><h3 id="5、字符编码"><a href="#5、字符编码" class="headerlink" title="5、字符编码"></a>5、字符编码</h3><p>计算机只认识01二进制数字(底层硬件控制电路的开和闭)，计算机只能直接存储和处理二进制数字</p><p>为了在计算机上也能表示、存储和处理像文字、符号之类的字符，就必须将这些字符转化为二进制数字。而转化的标准就称之为字符编码</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230220161644042.png" alt="image-20230220161644042"></p><h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><h2 id="1-邂逅CSS"><a href="#1-邂逅CSS" class="headerlink" title="1.邂逅CSS"></a>1.邂逅CSS</h2><h3 id="1、认识CSS"><a href="#1、认识CSS" class="headerlink" title="1、认识CSS"></a>1、认识CSS</h3><p>CSS表示层叠样式表（Cascading Style Sheet），是为网页添加样式的代码</p><p>属于计算机语言，他不是真正的编程语言，甚至不是标记语言，是一门样式表语言</p><p>94年开发，96发布css1，97W3C成立CSS工作组，98年5月发布css2，06-09流行div+css</p><p>没有真正的CSS3，之后的发布是模块化发布</p><p>CSS的出现是为了美化HTML的，并且让结构与样式分离</p><ul><li>美化1：添加样式</li><li>美化2：对HTML进行布局</li></ul><h3 id="2、编写CSS样式"><a href="#2、编写CSS样式" class="headerlink" title="2、编写CSS样式"></a>2、编写CSS样式</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">color</span>: red;   <span class="comment">// 属性名： 属性值；</span></span><br></pre></td></tr></table></figure><p>三种方法添加样式：</p><ul><li>内联样式（行内样式）：存于HTML元素的style属性之中，分号隔开多个样式</li><li>内部样式表：将css放在HTML文件<code>&lt;head&gt;</code>元素里的<code>&lt;style&gt;</code>元素之中</li><li>外部样式表：link外部的CSS文件</li></ul><p>CSS注释：ctrl+&#x2F;</p><h3 id="3、常见的CSS属性"><a href="#3、常见的CSS属性" class="headerlink" title="3、常见的CSS属性"></a>3、常见的CSS属性</h3><p>css属性的官方文档：<a href="https://www.w3.org/TR/?tag=css">https://www.w3.org/TR/?tag=css</a></p><p>浏览器支持查询CSS属性的可用性：<a href="https://caniuse.com/">https://caniuse.com</a></p><ul><li>font-size：文字大小</li><li>color：前景色</li><li>background-color：背景色</li><li>width：宽度</li><li>height：高度</li></ul><h3 id="4、额外知识补充2"><a href="#4、额外知识补充2" class="headerlink" title="4、额外知识补充2"></a>4、额外知识补充2</h3><h4 id="1-link元素"><a href="#1-link元素" class="headerlink" title="1.link元素"></a>1.link元素</h4><p>link元素是外部资源链接元素，规范了文档与外部资源的关系</p><ul><li>link元素通常是在head元素中</li><li>最常用的链接是样式表</li><li>也可以使用网站图标（favicon）</li></ul><p>常见属性：</p><ul><li>href：指定被链接资源的URL</li><li>rel：指定链接类型<ul><li>icon：站点图标</li><li>stylesheet：CSS样式</li></ul></li></ul><h4 id="2-计算机进制"><a href="#2-计算机进制" class="headerlink" title="2.计算机进制"></a>2.计算机进制</h4><p>进位制是一种计数方式，亦称进位计数法或位值计数法；当数字达到某个值时，进一位</p><p>十六进制：a(10)，b(11)，c(12)，d(13)，e(14)，f(15)，10(16)</p><p>二进制：0b开头</p><p>八进制：0o开头</p><p>十六进制：0x开头</p><p>编程中还是以十进制为主</p><p>十进制转化其他进制：整除取余数</p><p>其他进制转十进制：二进制1001：9</p><h4 id="3-CSS表示颜色"><a href="#3-CSS表示颜色" class="headerlink" title="3.CSS表示颜色"></a>3.CSS表示颜色</h4><p>表示颜色的方法：</p><ul><li>颜色关键字</li></ul><p>RGB【A】颜色（取值0-255），A是可选的，表示透明度</p><ul><li>使用函数符：rgb[a]:(255,255,255)<ul><li>可以是数字，也可以是百分比</li><li>A处于0-1之间的数字，或者百分比，数字1表示完全不透明(100%)</li></ul></li><li>也可以使用十六进制：#FFFFFF <ul><li>可以使用三位数：#f09&#x3D;#ff0099</li><li>可以使用四位数：#0f38&#x3D;#00ff3388</li></ul></li></ul><h4 id="4-浏览器渲染流程"><a href="#4-浏览器渲染流程" class="headerlink" title="4.浏览器渲染流程"></a>4.浏览器渲染流程</h4><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230226155625725.png" alt="image-20230226155625725"></p><h2 id="2-CSS属性"><a href="#2-CSS属性" class="headerlink" title="2.CSS属性"></a>2.CSS属性</h2><h3 id="1、文本"><a href="#1、文本" class="headerlink" title="1、文本"></a>1、文本</h3><h4 id="1-text-decoration（常用）"><a href="#1-text-decoration（常用）" class="headerlink" title="1.text-decoration（常用）"></a>1.text-decoration（常用）</h4><p>用于设置文本的装饰线</p><p>取值：</p><ul><li>none：无任何装饰<ul><li>可以去除 a 元素的下划线</li></ul></li><li>underline：添加下划线</li><li>overline：上划线</li><li>line-through：中划线（删除线）</li></ul><h4 id="2-text-transform"><a href="#2-text-transform" class="headerlink" title="2.text-transform"></a>2.text-transform</h4><p>用于设置文字的大小写转换</p><p>常见的值：</p><ul><li>capitalize：将每个单词的首字母变成大写</li><li>uppercase：将每个单词的全部字母变成大写</li><li>lowercase：将每个单词的全部字母变成小写</li><li>none：没有任何影响</li></ul><h4 id="3-text-indent"><a href="#3-text-indent" class="headerlink" title="3.text-indent"></a>3.text-indent</h4><p>用于设置第一行内容的缩进</p><p>text-indent：2em；  ：刚好是缩进2个文字</p><h4 id="4-text-align（重要）"><a href="#4-text-align（重要）" class="headerlink" title="4.text-align（重要）"></a>4.text-align（重要）</h4><p>设置<strong>文本</strong>的对齐方式（不准确）</p><p>MDN：定义行内内容（例如文字）如何相对于它的<strong>块父元素</strong>对齐（不准确）</p><p>常用的值</p><ul><li>left：左对齐</li><li>right：右对齐</li><li>center：居中对齐，也可以让图片居中</li><li>justify：两端对齐<ul><li>最有一行与只有一行的情况下不生效，要想生效需要设置：text-align-last：justify</li></ul></li></ul><p>W3C：设置的是行内级元素居中</p><h4 id="5-word-x2F-letter-spacing"><a href="#5-word-x2F-letter-spacing" class="headerlink" title="5.word&#x2F;letter-spacing"></a>5.word&#x2F;letter-spacing</h4><p>分别是改变单词&#x2F;字母之间的间距</p><h3 id="2、字体"><a href="#2、字体" class="headerlink" title="2、字体"></a>2、字体</h3><h4 id="1-font-size"><a href="#1-font-size" class="headerlink" title="1.font-size"></a>1.font-size</h4><p>决定字体的大小</p><p>常用的设置</p><ul><li>具体数值+单位：比如100px，也可以使用em，1em代表100%</li><li>百分比：基于父元素的font-size计算</li></ul><h4 id="2-font-family"><a href="#2-font-family" class="headerlink" title="2.font-family"></a>2.font-family</h4><p>用于设置文字的字体名称</p><p>可以设置一个或多个字体名称</p><p>浏览器会选择列表中第一个该计算机上有安装的字体</p><p>或者是通过 @font-face 指定的可以直接下载的字体</p><h4 id="3-font-weight"><a href="#3-font-weight" class="headerlink" title="3.font-weight"></a>3.font-weight</h4><p>用于设置文字的粗细（重量）</p><p>常见的取值：</p><ul><li>100|200|300|400|500|600|700|800|900：每一个数字表示一个重量</li><li>nomal：等于400</li><li>bold：等于700</li></ul><p> strong、b、h1-h6等标签的font-weight默认值就是bold</p><h4 id="4-font-style"><a href="#4-font-style" class="headerlink" title="4.font-style"></a>4.font-style</h4><p>用来设置文本的常规、斜体显示</p><ul><li>normal：常规显示</li><li>italic（斜体）：用字体的斜体显示（通常会有专门的字体）</li><li>oblique（倾斜）：文本倾斜显示（仅仅是让文字倾斜）</li></ul><p>em、i、cite、address、var、dfn等元素的font-style默认值就是italic</p><h4 id="5-font-variant（了解）"><a href="#5-font-variant（了解）" class="headerlink" title="5.font-variant（了解）"></a>5.font-variant（了解）</h4><p>可以影响小写字母的显示形式</p><p>normal：正常显示</p><p>small-caps：将小写字母替换为缩小过的大写字母（高度不变，小写变为大写）</p><h4 id="6-line-height"><a href="#6-line-height" class="headerlink" title="6.line-height"></a>6.line-height</h4><p>用来设置文本的行高</p><p>简单理解就是一行文字所占据的高度</p><p>为什么需要行高？</p><p>严格定义：两行文字基线之间的间距</p><p>基线：与小写字母 x 最底部对齐的线</p><p>区分：</p><ul><li>height：整个元素的高度</li><li>line-height：元素中每一行文字所占据的高度</li></ul><p>只有一行文字时，设置line-height等于height可以设置文本居中（仅限于文本）</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230303083221666.png" alt="image-20230303083221666"></p><h4 id="7-font缩写属性"><a href="#7-font缩写属性" class="headerlink" title="7.font缩写属性"></a>7.font缩写属性</h4><p>font 是一个缩写属性，可以作为以上属性的缩写</p><p>一般：font-style font-variant font-weight font-size&#x2F;line-height font-family;</p><ul><li>前三个可以省略，顺序可以调换</li><li>&#x2F;line-height 可以省略，如果不省略，必须跟在 font-size后面</li><li>font-size、font-family不可以调换顺序，也不能省略</li></ul><p>line-height 写数字的话表示为font-size 的倍数</p><h3 id="3、选择器"><a href="#3、选择器" class="headerlink" title="3、选择器"></a>3、选择器</h3><p>需要找到特定的网页元素进行设置样式</p><p>选择器就是按照一定的规则选出符合条件的元素，为其添加css样式</p><h4 id="1-通用选择器"><a href="#1-通用选择器" class="headerlink" title="1.通用选择器"></a>1.通用选择器</h4><p>所有的元素都会被选中，一般用来设置所有元素的一些通用属性，比如网页重置</p><p>性能比较低，尽量不使用</p><h4 id="2-简单选择器"><a href="#2-简单选择器" class="headerlink" title="2.简单选择器"></a>2.简单选择器</h4><ul><li>元素选择器：使用元素名称</li><li>类选择器：使用 .类名</li><li>id 选择器：使用 #id</li></ul><p>id 注意事项</p><ul><li>一个HTML文档中的id值是唯一的，不能重复<ul><li>id值如果由多个单词组成，单词之间可以用中划线-、下划线_连接，也可使用驼峰标识</li><li>最好不要使用标签名作为id值（阅读性比较差）</li></ul></li></ul><p>中划线又叫连字符</p><h4 id="3-属性选择器"><a href="#3-属性选择器" class="headerlink" title="3.属性选择器"></a>3.属性选择器</h4><p>拥有某一个属性</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[title] &#123;</span><br><span class="line">      <span class="attr">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置包含title属性的div元素的背景色 */</span></span><br><span class="line">[title=div] &#123;</span><br><span class="line">    background-<span class="attr">color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他：</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230303095554442.png" alt="image-20230303095554442"></p><h4 id="4-后代选择器"><a href="#4-后代选择器" class="headerlink" title="4.后代选择器"></a>4.后代选择器</h4><p>后代选择器1：所有的后代（直接&#x2F;间接后代）</p><p>选择器之间以空格分开</p><p>后代选择器2：直接子代选择器（必须是直接子代）</p><p>选择器之间以 &gt; 分割</p><h4 id="5-兄弟选择器"><a href="#5-兄弟选择器" class="headerlink" title="5.兄弟选择器"></a>5.兄弟选择器</h4><p>兄弟选择器1：相邻兄弟选择器（后面）</p><p>使用符号 + 连接</p><p>兄弟选择器2：普遍兄弟选择器（后面）</p><p>使用符号 ~ 连接</p><h4 id="6-选择器组"><a href="#6-选择器组" class="headerlink" title="6.选择器组"></a>6.选择器组</h4><h5 id="1、交集选择器"><a href="#1、交集选择器" class="headerlink" title="1、交集选择器"></a>1、交集选择器</h5><p>需要同时符合两个选择器条件（两个选择器紧密相连）</p><ul><li>在开发中通常为了精准的选择某一个元素</li></ul><h5 id="2、并集选择器"><a href="#2、并集选择器" class="headerlink" title="2、并集选择器"></a>2、并集选择器</h5><p>符合一个选择器条件即可（两个选择器使用, 分割）</p><ul><li>在开发中通常为了给多个元素设置相同的样式</li></ul><h4 id="7-伪类"><a href="#7-伪类" class="headerlink" title="7.伪类"></a>7.伪类</h4><p>伪类是选择器的一种，它用于选择处于特定状态的元素</p><p> 比如：在鼠标悬浮在元素上时变色</p><h5 id="常见的伪类"><a href="#常见的伪类" class="headerlink" title="常见的伪类"></a>常见的伪类</h5><ul><li>动态伪类<ul><li>:link   :visited  :hover  :active  :focus</li></ul></li><li>目标伪类<ul><li>:target</li></ul></li><li>语言伪类<ul><li>:lang()</li></ul></li><li>元素状态伪类<ul><li>:enabled  :disabled  :checked</li></ul></li><li>结构伪类<ul><li>:nth-child()  nth-last-child()  :nth-of-type()  nth-last-of-type()</li><li>:first- child  :last-child  :first-of-type  :last-of-type</li><li>:root  :only-child  :only-of-type  :empty</li></ul></li><li>否定伪类<ul><li>:not()</li></ul></li></ul><h5 id="使用举例"><a href="#使用举例" class="headerlink" title="使用举例"></a>使用举例</h5><ul><li>a:link 未访问的链接</li><li>a:visited 已访问的链接</li><li>a:hover 鼠标挪动到链接上</li><li>a:active 激活的链接（鼠标在链接上长按未松开）</li></ul><h5 id="使用注意"><a href="#使用注意" class="headerlink" title="使用注意"></a>使用注意</h5><ul><li><p>:hover 必须放在 :link 和 :visited 后面才能完全生效</p></li><li><p>:active 必须放在 : hover后面才能完全生效</p></li><li><p>编程建议：:link、:visited、:hover、:active</p></li></ul><p>除了a元素，:hover、:active 也能用在其他元素上</p><p>:focus指当前拥有输入焦点的元素（能接收键盘输入）（能进行交互交互的元素）</p><ul><li>文本输入框一聚焦后，背景就会变红色</li></ul><p>编写顺序：:link、:visited、:focus、:hover、:active</p><p>直接给a元素设置样式，相当于给a元素的所有动态伪类都设置了</p><h4 id="8-伪元素"><a href="#8-伪元素" class="headerlink" title="8.伪元素"></a>8.伪元素</h4><p>伪元素默认为：行内非替换元素</p><p>常用的伪元素有</p><ul><li>:first-line、::first-line：针对首行文本设置属性</li><li>:first-letter、::first-letter：可以针对首字母设置属性</li><li>:before、::before：在一个元素之前插入其他内容</li><li>:after、::after：在一个元素之后插入其他内容</li></ul><p>使用伪元素的过程中，content不能省略，可以为“”</p><p>为了区分伪元素和伪类，建议伪元素使用2个冒号</p><h2 id="3-CSS属性的特性"><a href="#3-CSS属性的特性" class="headerlink" title="3.CSS属性的特性"></a>3.CSS属性的特性</h2><h3 id="1、css属性的继承"><a href="#1、css属性的继承" class="headerlink" title="1、css属性的继承"></a>1、css属性的继承</h3><p>css的某些属性具有继承性</p><ul><li>如果一个属性具备继承性，那么在该元素上设置后，他的后代元素都可以继承这个属性</li><li>如果后代元素自己有设置属性，那么优先使用后代元素自己的属性（不管继承过来的属性权重多高）</li></ul><p>常见的 fone-size&#x2F;font-family&#x2F;font-weight&#x2F;line-height&#x2F;color&#x2F;text-align都具有继承性</p><p><strong>继承过来的是计算值，而不是设置值</strong></p><p>强制继承：在子元素的style中将需要继承的属性的值设置为 inherit</p><h3 id="2、css属性的层叠"><a href="#2、css属性的层叠" class="headerlink" title="2、css属性的层叠"></a>2、css属性的层叠</h3><p>css：层叠样式表</p><ul><li><p>对于一个元素来说，相同一个属性我们可以通过不同的选择器给它进行多次设置</p></li><li><p>那么属性会被一层层覆盖上去，但是最终只有一个会生效</p></li><li><p>判断哪个样式生效</p></li></ul><p>判断1：选择器的权重, 权重大的生效, 根据权重可以判断出优先级</p><p>判断2：先后顺序, 权重相同时, 后面设置的生效</p><p>选择器的权重</p><p>!important：10000</p><p>内联样式：1000</p><p>id选择器：100</p><p>类选择器、属性选择器、伪类：10</p><p>元素选择器、伪元素：1</p><p>通配符：0</p><h3 id="3、HTML元素的类型"><a href="#3、HTML元素的类型" class="headerlink" title="3、HTML元素的类型"></a>3、HTML元素的类型</h3><p>html考虑一个问题：每个元素在页面中到底需要占据多大的空间</p><ul><li><p>某些元素非常重要；独占一行 -&gt;类型：块级元素（block level）h&#x2F;div&#x2F;p</p></li><li><p>某些元素属于内容的一部分，没不要独占一行，与其他内容在同一行显示，类型 -&gt; (inline level)  span a img</p></li></ul><p>HTML元素的类型</p><p>块级元素：独占父元素的一行</p><p>行内级元素：多个行内级元素可以在父元素的同一行中显示</p><p>img元素：inline - replaced -&gt; 行内替换元素</p><p>行内替换元素</p><ul><li><p>和其他的行内元素在同一行显示</p></li><li><p>可以设置宽高</p></li></ul><h3 id="4、display属性"><a href="#4、display属性" class="headerlink" title="4、display属性"></a>4、display属性</h3><p>css中有一个display属性，能够修改元素的显示类型</p><p>block：让元素显示为块级元素（独占父元素的一行，可以设置宽高，高度默认由内容决定）</p><p>inline：让元素显示为行内级元素（和其他元素在一行显示，不能设置宽高，大小由内容决定）</p><p>inline-block：让元素同时具备行内级、块级元素的特征</p><p>none：隐藏元素</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230319072815754.png" alt="image-20230319072815754"></p><p>编写 HTML 注意事项</p><p>块级元素、inline-block元素</p><ul><li><p>一般情况下，可以包含其他任何元素（比如块级元素、行内级元素、inline-block元素）</p></li><li><p>特殊情况，p元素不能包含其他块级元素</p></li></ul><p>行内级元素（比如a、span、strong等）</p><ul><li>一般情况下，只能包含行内级元素</li></ul><h3 id="5、元素的隐藏"><a href="#5、元素的隐藏" class="headerlink" title="5、元素的隐藏"></a>5、元素的隐藏</h3><p>方法一: display设置为none</p><ul><li>元素不显示出来, 并且也不占据位置, 不占据任何空间(和不存在一样)</li></ul><p>方法二: visibility设置为hidden</p><ul><li><p>设置为hidden, 虽然元素不可见, 但是会占据元素应该占据的空间</p></li><li><p>默认为visible, 元素是可见的</p></li></ul><p>方法三: rgba设置颜色, 将a的值设置为0</p><ul><li>rgba的a设置的是alpha值, 可以设置透明度, 不影响子元素（占据空间）</li></ul><p>方法四: opacity设置透明度, 设置为0</p><ul><li>设置整个元素的透明度, 会影响所有的子元素（占据空间）</li></ul><h4 id="编写的-CSS-样式不生效技巧"><a href="#编写的-CSS-样式不生效技巧" class="headerlink" title="编写的 CSS 样式不生效技巧"></a>编写的 CSS 样式不生效技巧</h4><ul><li>选择器优先级太低</li><li>选择器没选中对应的元素</li><li>CSS属性的使用形式不对<ul><li>元素不支持此CSS属性，比如span不支持设置宽高</li><li>浏览器不支持此CSS属性，比如旧版本的浏览器不支持一些css module3的某些属性</li><li>被同类型的CSS属性覆盖，比如font覆盖font-size</li></ul></li></ul><h3 id="6、overflow-属性"><a href="#6、overflow-属性" class="headerlink" title="6、overflow 属性"></a>6、overflow 属性</h3><p>overflow用于控制内容溢出时的行为</p><ul><li><p>visible：溢出的内容照样可见（默认值）</p></li><li><p>hidden：溢出的内容直接裁剪</p></li><li><p>scroll：溢出的内容被裁剪，但可以通过滚动机制查看</p><ul><li>会一直显示滚动条区域，滚动条区域占用的空间属于width、height</li></ul></li><li><p>auto：自动根据内容是否溢出来决定是否提供滚动机制（常用）</p></li></ul><h2 id="4-CSS的盒子模型"><a href="#4-CSS的盒子模型" class="headerlink" title="4.CSS的盒子模型"></a>4.CSS的盒子模型</h2><h3 id="1、认识盒子模型"><a href="#1、认识盒子模型" class="headerlink" title="1、认识盒子模型"></a>1、认识盒子模型</h3><p>我们可以把HTML每一个元素看出一个个的盒子，以具备这4个属性：</p><p>内容（content） ：元素的内容width&#x2F;height</p><p>内边距（padding）：元素和内容之间的间距</p><p>边框（border）：元素自己的边框</p><p>外边距（margin）：元素和其他元素之间的间距</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230314164800601.png" alt="image-20230314164800601"></p><p>盒子模型的四边</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230314171639045.png" alt="image-20230314171639045"></p><h3 id="2、内容—宽度和高度"><a href="#2、内容—宽度和高度" class="headerlink" title="2、内容—宽度和高度"></a>2、内容—宽度和高度</h3><p>设置内容是通过高度和宽度设置的：</p><p>宽度设置：width，默认值 auto，交给浏览器决定</p><p>高度设置：height</p><p>注意：对于行内级非替换元素来说, 设置宽高是无效的</p><p>其他设置：</p><p>min-width：最小宽度，无论内容多少，宽度都大于或等于min-width</p><p>max-width：最大宽度，无论内容多少，宽度都小于或等于max-width</p><p>移动端适配时, 可以设置最大宽度和最小宽度</p><p>min-height：最小高度，无论内容多少，高度都大于或等于min-height</p><p>max-height：最大高度，无论内容多少，高度都小于或等于max-height</p><h3 id="3、内边距：padding"><a href="#3、内边距：padding" class="headerlink" title="3、内边距：padding"></a>3、内边距：padding</h3><p>padding属性用于设置盒子的内边距, 通常用于设置边框和内容之间的间距</p><p>padding单独编写是一个缩写属性</p><ul><li><p>padding-top、padding-right、padding-bottom、padding-left的简写属性</p></li><li><p>padding缩写属性是从零点钟方向开始, 沿着顺时针转动的, 也就是上右下左</p></li></ul><p>padding并非必须是四个值, 也可以有其他值</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230319081108760.png" alt="image-20230319081108760"></p><h3 id="4、边框"><a href="#4、边框" class="headerlink" title="4、边框"></a>4、边框</h3><p>border用于设置盒子的边框，边框具备宽度width、样式style、颜色color</p><p>边框宽度</p><ul><li><p>border-top-width、border-right-width、border-bottom-width、border-left-width</p></li><li><p>border-width是上面4个属性的简写属性</p></li></ul><p>边框颜色</p><ul><li><p>border-top-color、border-right-color、border-bottom-color、border-left-color</p></li><li><p>border-color是上面4个属性的简写属性</p></li></ul><p>边框样式</p><ul><li><p>border-top-style、border-right-style、border-bottom-style、border-left-style</p></li><li><p>border-style是上面4个属性的简写属性</p></li></ul><p>边框样式的设置值：</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230319230129421.png" alt="image-20230319230129421"></p><p>同时设置的方式</p><p>border-top、border-right、border-bottom、border-left</p><p>border：统一设置4个方向的边框</p><p>边框颜色、宽度、样式的编写顺序任意</p><p>圆角</p><p>border-radius用于设置盒子的圆角</p><p>border-radius常见的值</p><ul><li><p>数值: 通常用来设置小的圆角, 比如6px</p></li><li><p>百分比: 通常用来设置一定的弧度或者圆形</p></li></ul><p>border-radius事实上是一个缩写属性</p><ul><li><p>将这四个属性 border-top-left-radius、border-top-right-radius、border-bottom-right-radius，和 border-bottomleft-radius 简写为一个属性</p></li><li><p>开发中比较少见一个个圆角设置</p></li></ul><p>如果一个元素是正方形，设置border-radius大于或等于50%时，就会变成一个圆</p><h3 id="5、外边距"><a href="#5、外边距" class="headerlink" title="5、外边距"></a>5、外边距</h3><p>margin属性用于设置盒子的外边距, 通常用于元素和元素之间的间距</p><p>margin包括四个方向, 所以有如下的取值</p><ul><li><p>margin-top：上内边距</p></li><li><p>margin-right：右内边距</p></li><li><p>margin-bottom：下内边距</p></li><li><p>margin-left：左内边距</p></li></ul><p>margin单独编写是一个缩写属性：</p><ul><li><p>margin-top、margin-right、margin-bottom、margin-left的简写属性</p></li><li><p>margin缩写属性是从零点钟方向开始, 沿着顺时针转动的, 也就是上右下左</p></li></ul><p>margin也并非必须是四个值, 也可以有其他值</p><p>margin和padding的区别</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">  &lt;style&gt;</span><br><span class="line">    .<span class="property">box</span> &#123;</span><br><span class="line">      <span class="attr">width</span>: 300px;</span><br><span class="line">      <span class="attr">height</span>: 300px;</span><br><span class="line">      background-<span class="attr">color</span>: red;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* padding弊端 会撑大盒子 */</span></span><br><span class="line">      <span class="comment">/* padding-left: 100px;</span></span><br><span class="line"><span class="comment">      box-sizing: border-box; */</span></span><br><span class="line">      <span class="attr">overflow</span>: auto;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .<span class="property">container</span> &#123;</span><br><span class="line">      <span class="attr">width</span>: 100px;</span><br><span class="line">      <span class="attr">height</span>: 100px;</span><br><span class="line">      background-<span class="attr">color</span>: green;</span><br><span class="line">      <span class="comment">/* 不用设置 border-box */</span></span><br><span class="line">      margin-<span class="attr">left</span>: 100px;</span><br><span class="line">      <span class="comment">/* 设置上下会有问题 发生传递  需在父元素设置overflow auto 触发bfc */</span></span><br><span class="line">      margin-<span class="attr">top</span>: 100px;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h4 id="1-上下margin传递"><a href="#1-上下margin传递" class="headerlink" title="1.上下margin传递"></a>1.上下margin传递</h4><p>margin-top传递</p><ul><li>如果块级元素的顶部线和父元素的顶部线重叠，那么这个块级元素的margin-top值会传递给父元素</li></ul><p>margin-bottom传递</p><ul><li>如果块级元素的底部线和父元素的底部线重写，并且父元素的高度是auto，那么这个块级元素的margin-bottom值会传递给父元素</li></ul><p>如何防止出现传递问题</p><ul><li><p>给父元素设置padding-top\padding-bottom</p></li><li><p>给父元素设置border</p></li><li><p>触发BFC: 设置overflow为auto</p></li></ul><p>建议</p><ul><li><p>margin一般是用来设置兄弟元素之间的间距</p></li><li><p>padding一般是用来设置父子元素之间的间距</p></li></ul><h4 id="2-上下margin的折叠"><a href="#2-上下margin的折叠" class="headerlink" title="2.上下margin的折叠"></a>2.上下margin的折叠</h4><p>垂直方向上相邻的2个margin（margin-top、margin-bottom）有可能会合并为1个margin，这种现象叫做collapse（折叠）</p><p>水平方向上的margin（margin-left、margin-right）永远不会collapse</p><p>折叠后最终值的计算规则</p><ul><li>两个值进行比较，取较大的值</li></ul><p>如何防止margin collapse？ </p><ul><li>只设置其中一个元素的margin</li></ul><p>margin 和 padding 的选择</p><p>元素与元素的距离：margin</p><p>子元素与父元素的距离：padding</p><h3 id="6、外轮廓"><a href="#6、外轮廓" class="headerlink" title="6、外轮廓"></a>6、外轮廓</h3><p>outline表示元素的外轮廓</p><ul><li><p>不占用空间</p></li><li><p>默认显示在border的外面</p></li></ul><p>outline相关属性有</p><ul><li><p>outline-width: 外轮廓的宽度</p></li><li><p>outline-style：取值跟border的样式一样，比如solid、dotted等</p></li><li><p>outline-color: 外轮廓的颜色</p></li><li><p>outline：outline-width、outline-style、outline-color的简写属性，跟border用法类似</p></li></ul><p>应用实例</p><ul><li>去除a元素、input元素的focus轮廓效果</li></ul><h3 id="7、盒子阴影"><a href="#7、盒子阴影" class="headerlink" title="7、盒子阴影"></a>7、盒子阴影</h3><p>box-shadow属性可以设置一个或者多个阴影</p><p>每个阴影用表示</p><p>多个阴影之间用逗号,隔开，从前到后叠加</p><p>格式：</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230319222535516.png" alt="image-20230319222535516"></p><p>第1个：offset-x, 水平方向的偏移，正数往右偏移</p><p>第2个：offset-y, 垂直方向的偏移，正数往下偏移</p><p>第3个：blur-radius, 模糊半径</p><p>第4个：spread-radius, 延伸半径</p><p><code>&lt;color&gt;</code>：阴影的颜色，如果没有设置，就跟随color属性的颜色</p><p>inset：外框阴影变成内框阴影</p><p>在线网址：<a href="https://html-css-js.com/css/generator/box-shadow/">https://html-css-js.com/css/generator/box-shadow/</a></p><h3 id="8、文字阴影"><a href="#8、文字阴影" class="headerlink" title="8、文字阴影"></a>8、文字阴影</h3><p>text-shadow用法类似于box-shadow，用于给文字添加阴影效果</p><p>常见格式如下</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230319222559369.png" alt="image-20230319222559369"></p><p>相当于box-shadow, 它没有spread-radius的值</p><h3 id="9、行内非替换元素的注意事项"><a href="#9、行内非替换元素的注意事项" class="headerlink" title="9、行内非替换元素的注意事项"></a>9、行内非替换元素的注意事项</h3><p>设置高宽不生效</p><p>设置padding：左右可以生效，上下能够撑开，但是不占据空间</p><p>设置border：上下会被撑起来，不占据空间</p><p>设置margin：上下不生效</p><p>以下属性对行内级非替换元素不起作用</p><ul><li>width、height、margin-top、margin-bottom</li></ul><p>以下属性对行内级非替换元素的效果比较特殊</p><ul><li>padding-top、padding-bottom、上下方向的border</li></ul><p>1.前景色有没有设置到border下面（有设置）</p><p>2.前景色会在border没有设置颜色的情况下，显示出color的颜色</p><h3 id="10、box-sizing"><a href="#10、box-sizing" class="headerlink" title="10、box-sizing"></a>10、box-sizing</h3><p>box-sizing用来设置盒子模型中宽高的行为</p><ul><li>content-box<ul><li>padding、border都布置在width、height<strong>外边</strong></li><li>元素的实际占用宽度 &#x3D; border + padding + width</li><li>元素的实际占用高度 &#x3D; border + padding + height</li></ul></li><li>border-box<ul><li>padding、border都布置在width、height<strong>里边</strong></li><li>元素的实际占用宽度 &#x3D; width</li><li>元素的实际占用高度 &#x3D; height</li></ul></li></ul><h3 id="11、元素的水平居中方案"><a href="#11、元素的水平居中方案" class="headerlink" title="11、元素的水平居中方案"></a>11、元素的水平居中方案</h3><p>在一些需求中，需要元素在父元素中水平居中显示（父元素一般都是块级元素、inline-block）</p><p>行内级元素(包括inline-block元素) </p><ul><li>水平居中：在父元素中设置text-align: center</li></ul><p>块级元素</p><ul><li>水平居中：margin: 0 auto（在块级元素中对自己设置）</li></ul><h3 id="12、案例练习总结"><a href="#12、案例练习总结" class="headerlink" title="12、案例练习总结"></a>12、案例练习总结</h3><p>文字介绍一行展示溢出显示…</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">white-<span class="attr">space</span>: nowrap;</span><br><span class="line"><span class="attr">overflow</span>: hidden;</span><br><span class="line">text-<span class="attr">overflow</span>: ellipsis;</span><br></pre></td></tr></table></figure><p>文字介绍两行展示溢出显示…</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">overflow</span>: hidden;</span><br><span class="line">text-<span class="attr">overflow</span>: ellipsis;</span><br><span class="line"><span class="attr">display</span>: -webkit-box;</span><br><span class="line">-webkit-line-<span class="attr">clamp</span>: <span class="number">2</span>;  <span class="comment">// 设置几行显示文字</span></span><br><span class="line">-webkit-box-<span class="attr">orient</span>: vertical;</span><br><span class="line"></span><br><span class="line">并且需要保证其父元素有具体的宽度，如果父元素设置了inline-block，可调为block</span><br></pre></td></tr></table></figure><h2 id="5-CSS-的背景设置"><a href="#5-CSS-的背景设置" class="headerlink" title="5.CSS 的背景设置"></a>5.CSS 的背景设置</h2><h3 id="1、background-image"><a href="#1、background-image" class="headerlink" title="1、background-image"></a>1、background-image</h3><p>background-image用于设置元素的背景图片</p><ul><li>会盖在（不是覆盖）background-color 的上面</li></ul><p>如果设置了多张图片</p><ul><li>设置的第一张图片将显示在最上面，其他图片按顺序层叠在下面</li></ul><p>注意：如果设置了背景图片后，元素没有具体的宽高，背景图片是不会显示出来的</p><h3 id="2、background-repeat"><a href="#2、background-repeat" class="headerlink" title="2、background-repeat"></a>2、background-repeat</h3><p>background-repeat用于设置背景图片是否要平铺</p><p>常见的属性值有</p><ul><li><p>repeat：平铺（默认值）</p></li><li><p>no-repeat：不平铺</p></li><li><p>repeat-x：只在水平方向平铺</p></li><li><p>repeat-y：只在垂直平方向平铺</p></li></ul><h3 id="3、background-size"><a href="#3、background-size" class="headerlink" title="3、background-size"></a>3、background-size</h3><p>background-size用于设置背景图片的大小</p><p>auto：默认值, 以背景图本身大小显示</p><p>cover：缩放背景图，以完全覆盖铺满元素,可能背景图片部分看不见</p><p>contain：缩放背景图，宽度或者高度铺满元素，但是图片保持宽高比</p><p><code>&lt;percentage&gt;</code>：百分比，相对于背景区（background positioning area）</p><p>length：具体的大小，比如100px</p><h3 id="4、background-position"><a href="#4、background-position" class="headerlink" title="4、background-position"></a>4、background-position</h3><p>background-position用于设置背景图片在水平、垂直方向上的具体位置</p><ul><li><p>可以设置具体的数值，比如 20px 30px</p></li><li><p>水平方向还可以设值：left、center、right</p></li><li><p>垂直方向还可以设值：top、center、bottom</p></li></ul><p>如果只设置了1个方向，另一个方向默认是center</p><h3 id="5、background-attachment"><a href="#5、background-attachment" class="headerlink" title="5、background-attachment"></a>5、background-attachment</h3><p>background-attachment决定背景图像的位置是在视口内固定，或者随着包含它的区块滚动</p><p>可以设置以下3个值</p><ul><li><p>scroll：此关键属性值表示背景相对于元素本身固定， 而不是随着它的内容滚动</p></li><li><p>local：此关键属性值表示背景相对于元素的内容固定。如果一个元素拥有滚动机制，背景将会随着元素的内容滚动</p></li><li><p>fixed：此关键属性值表示背景相对于视口固定。即使一个元素拥有滚动机制，背景也不会随着元素的内容滚动。</p></li></ul><h3 id="6、background"><a href="#6、background" class="headerlink" title="6、background"></a>6、background</h3><p>background是一系列背景相关属性的简写属性</p><p>background-size可以省略，如果不省略，&#x2F;background-size必须紧跟在background-position的后面</p><p>其他属性也都可以省略，而且顺序任意</p><h4 id="background-image-和-img-对比"><a href="#background-image-和-img-对比" class="headerlink" title="background-image 和 img 对比"></a>background-image 和 img 对比</h4><p>利用background-image和img都能够实现显示图片的需求，在开发中该如何选择？</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230319215927911.png" alt="image-20230319215927911"></p><p>总结</p><ul><li><p>img，作为网页内容的重要组成部分，比如广告图片、LOGO图片、文章配图、产品图片</p></li><li><p>background-image，可有可无。有，能让网页更加美观。无，也不影响用户获取完整的网页内容信息</p></li></ul><h2 id="6-高级元素"><a href="#6-高级元素" class="headerlink" title="6.高级元素"></a>6.高级元素</h2><h3 id="1、列表元素"><a href="#1、列表元素" class="headerlink" title="1、列表元素"></a>1、列表元素</h3><p>列表功能不同的方案实现</p><ul><li><p>方案一: 使用div元素来实现（比如汽车之家, 知乎上的很多列表）</p></li><li><p>方案二: 使用列表元素，使用元素语义化的方式实现</p></li></ul><p>HTML提供了3组常用的用来展示列表的元素</p><ul><li><p>有序列表：ol、li：直接子元素只能是 li</p></li><li><p>无序列表：ul、li：直接子元素只能是 li</p></li><li><p>定义列表：dl、dt、dd：直接子元素只能是 dt、dd</p><ul><li>dt（definition term）term是项的意思, 列表中每一项的项目名</li><li>列表中每一项的具体描述，是对 dt 的描述、解释、补充</li><li>一个dt后面一般紧跟着1个或者多个dd</li></ul></li></ul><h3 id="2、表格元素"><a href="#2、表格元素" class="headerlink" title="2、表格元素"></a>2、表格元素</h3><h4 id="1-常见的元素"><a href="#1-常见的元素" class="headerlink" title="1.常见的元素"></a>1.常见的元素</h4><p>table：表格</p><p>tr：表格中的行</p><p>td：行中的单元格</p><p>border-collapse CSS 属性是用来决定表格的<strong>边框</strong>是分开的还是合并的。 </p><ul><li><p>table { border-collapse: collapse; }</p></li><li><p>合并单元格的边框</p></li></ul><h4 id="2-表格的其他元素"><a href="#2-表格的其他元素" class="headerlink" title="2.表格的其他元素"></a>2.表格的其他元素</h4><p>thead：表格的表头</p><p>tbody：表格的主体</p><p>tfoot：表格的页脚</p><p>caption：表格的标题</p><p>th：表格的表头单元格</p><h4 id="3-单元格合并"><a href="#3-单元格合并" class="headerlink" title="3.单元格合并"></a>3.单元格合并</h4><p>在某些特殊的情况下, 每个单元格占据的大小可能并不是固定的</p><p>一个单元格可能会跨多行或者多列来使用</p><p>单元格合并分成两种情况</p><p>跨列合并: 使用colspan</p><ul><li>在最左边的单元格写上colspan属性，并且省略掉合并的td</li></ul><p>跨行合并: 使用rowspan</p><ul><li>在最上面的单元格协商rowspan属性，并且省略掉后面tr中的td</li></ul><h3 id="3、表单"><a href="#3、表单" class="headerlink" title="3、表单"></a>3、表单</h3><p>表单元素</p><p>form：表单，一般情况下，其他表单相关元素都是它的后代元素</p><p>input：单行文本输入框、单选框、复选框、按钮等元素</p><p>textarea：多行文本框</p><p>select、option：下拉选择框 </p><p>button：按钮</p><p>label：表单元素的标题</p><h4 id="1-input-元素的使用"><a href="#1-input-元素的使用" class="headerlink" title="1.input 元素的使用"></a>1.input 元素的使用</h4><p>常见的属性：</p><p>type：input的类型</p><ul><li><p>text：文本输入框（明文输入）</p></li><li><p>password：文本输入框（密文输入）</p></li><li><p>radio：单选框</p></li><li><p>checkbox：复选框</p></li><li><p>button：按钮</p></li><li><p>reset：重置</p></li><li><p>submit：提交表单数据给服务器</p></li><li><p>file：文件上传</p></li></ul><p>readonly：只读</p><p>disabled：禁用</p><p>checked：默认被选中</p><ul><li>只有当type为radio或checkbox时可用</li></ul><p>autofocus：当页面加载时，自动聚焦</p><p>name：名字</p><ul><li>在提交数据给服务器时，可用于区分数据类型</li></ul><p>value：取值</p><p>布尔属性</p><p>常见的布尔属性有disabled、checked、readonly、multiple、autofocus、selected</p><p>布尔属性可以没有属性值，写上属性名就代表使用这个属性</p><ul><li>如果要给布尔属性设值，值就是属性名本身</li></ul><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230320205600506.png" alt="image-20230320205600506"></p><h4 id="2-表单按钮"><a href="#2-表单按钮" class="headerlink" title="2.表单按钮"></a>2.表单按钮</h4><p>普通按钮（type&#x3D;button）：使用value属性设置按钮文字</p><p>重置按钮（type&#x3D;reset）：重置它所属form的所有表单元素（包括input、textarea、select）</p><p>提交按钮（type&#x3D;submit）：提交它所属form的表单数据给服务器（包括input、textarea、select）</p><h4 id="3-input-和-label-的关系"><a href="#3-input-和-label-的关系" class="headerlink" title="3.input 和 label 的关系"></a>3.input 和 label 的关系</h4><p>label元素一般跟input配合使用，用来表示input的标题</p><p>labe可以跟某个input绑定，点击label就可以激活对应的input变成选中</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;username&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    用户:</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;username&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h4 id="4-单选框—radio"><a href="#4-单选框—radio" class="headerlink" title="4.单选框—radio"></a>4.单选框—radio</h4><p>name值相同的radio才具备单选功能</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- 在类型为radio的input中 如果name一样 那么两个radio会互斥 --&gt;</span><br><span class="line">    &lt;label for=&quot;male&quot;&gt;</span><br><span class="line">      &lt;input type=&quot;radio&quot; name=&quot;sex&quot; id=&quot;male&quot; value=&quot;male&quot;&gt;男</span><br><span class="line">    &lt;/label&gt;</span><br><span class="line">    &lt;label for=&quot;female&quot;&gt;</span><br><span class="line">      &lt;input type=&quot;radio&quot; name=&quot;sex&quot; id=&quot;female&quot; value=&quot;female&quot;&gt;女</span><br><span class="line">    &lt;/label&gt;</span><br></pre></td></tr></table></figure><h4 id="5-多选框—checkbox"><a href="#5-多选框—checkbox" class="headerlink" title="5.多选框—checkbox"></a>5.多选框—checkbox</h4><p>属于同一种类型的checkbox，name值要保持一致</p><p>可以设置 checked 来默认选中其中一项</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;label <span class="keyword">for</span>=<span class="string">&quot;basketball&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;basketball&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span> <span class="attr">value</span>=<span class="string">&quot;basketball&quot;</span> <span class="attr">checked</span>&gt;</span>篮球</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h4 id="6-多行输入—textarea"><a href="#6-多行输入—textarea" class="headerlink" title="6.多行输入—textarea"></a>6.多行输入—textarea</h4><p>textarea的常用属性</p><p>cols：列数</p><p>rows：行数</p><p>缩放的CSS设置</p><ul><li><p>禁止缩放：resize: none</p></li><li><p>水平缩放：resize: horizontal</p></li><li><p>垂直缩放：resize: vertical</p></li><li><p>水平垂直缩放：resize: both</p></li></ul><h4 id="7-选项列表"><a href="#7-选项列表" class="headerlink" title="7.选项列表"></a>7.选项列表</h4><p>option是select的子元素，一个option代表一个选项</p><p>select常用属性</p><ul><li><p>multiple：可以多选</p></li><li><p>size：显示多少项</p></li></ul><p>option常用属性</p><ul><li>selected：默认被选中</li></ul><h4 id="8-form元素"><a href="#8-form元素" class="headerlink" title="8.form元素"></a>8.form元素</h4><p>form通常作为表单元素的父元素</p><ul><li><p>form可以将整个表单作为一个整体来进行操作</p></li><li><p>比如对整个表单进行重置</p></li><li><p>比如对整个表单的数据进行提交</p></li></ul><p>form常见的属性如下</p><ul><li><p>action：用于提交表单数据的请求URL</p></li><li><p>method：请求方法（get和post），默认是get</p></li><li><p>target：在什么地方打开URL（参考a元素的target）</p></li></ul><h2 id="7-emmet语法和结构伪类"><a href="#7-emmet语法和结构伪类" class="headerlink" title="7.emmet语法和结构伪类"></a>7.emmet语法和结构伪类</h2><h3 id="1、emmet语法"><a href="#1、emmet语法" class="headerlink" title="1、emmet语法"></a>1、emmet语法</h3><p>Emmet (前身为 Zen Coding) 是一个能大幅度提高前端开发效率的一个工具</p><p>在前端开发的过程中，一大部分的工作是写 HTML、CSS 代码，如果手动来编写效果会非常低</p><p>VsCode内置了Emmet语法，在后缀为.html&#x2F;.css中输入缩写后按Tab&#x2F;Enter键即会自动生成相应代码</p><p>!和html:5可以快速生成完整结构的html5代码</p><p><code>&gt;</code>：子代    <code>+</code>；兄弟   <code>*</code>：多个   <code>^</code>：上一级（最多到body）  <code>()</code>：分组</p><p> 属性：<code>[]</code>：普通属性  <code>#</code>：id属性  <code>.</code> ：class属性   <code>&#123;&#125;</code>：内容   <code>$</code>：数字  </p><p>隐式标签：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- ul&gt;.<span class="property">item</span>&#123;列表元素$$&#125;*<span class="number">3</span> --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span>列表元素01<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span>列表元素02<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span>列表元素03<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>css emmet：属性的缩写</p><h3 id="2、结构伪类"><a href="#2、结构伪类" class="headerlink" title="2、结构伪类"></a>2、结构伪类</h3><h4 id="1-nth-child-n"><a href="#1-nth-child-n" class="headerlink" title="1.:nth-child(n)"></a>1.:nth-child(n)</h4><p>:nth-child(1)：是父元素中的第1个子元素</p><p>:nth-child(2n)：n代表任意正整数和0</p><ul><li><p>是父元素中的第偶数个子元素（第2、4、6、8……个）</p></li><li><p>跟:nth-child(even)同义</p></li></ul><p>:nth-child(2n + 1)：n代表任意正整数和0</p><ul><li>是父元素中的第奇数个子元素（第1、3、5、7……个）</li><li>跟:nth-child(odd)同义</li></ul><p>nth-child(-n + 2)：代表前2个子元素</p><h4 id="2-nth-last-child-n"><a href="#2-nth-last-child-n" class="headerlink" title="2.:nth-last-child(n)"></a>2.:nth-last-child(n)</h4><p>:nth-last-child()的语法跟:nth-child()类似，不同点是:nth-last-child()从最后一个子元素开始往前计数</p><ul><li><p>:nth-last-child(1)，代表倒数第一个子元素</p></li><li><p>:nth-last-child(-n + 2)，代表最后2个子元素</p></li></ul><p>:nth-of-type()用法跟:nth-child()类似</p><ul><li>不同点是:nth-of-type()计数时只计算同种类型的元素</li></ul><p>:nth-last-of-type()用法跟:nth-of-type()类似</p><ul><li>不同点是:nth-last-of-type()从最后一个这种类型的子元素开始往前计数</li></ul><p>其他常见的伪类(了解)</p><ul><li><p>:first-child，等同于:nth-child(1)</p></li><li><p>:last-child，等同于:nth-last-child(1)</p></li><li><p>:first-of-type，等同于:nth-of-type(1)</p></li><li><p>:last-of-type，等同于:nth-last-of-type(1)</p></li><li><p>:only-child，是父元素中唯一的子元素</p></li><li><p>:only-of-type，是父元素中唯一的这种类型的子元素</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">.<span class="property">box</span> &gt; :first-child &#123;</span><br><span class="line">     <span class="attr">color</span>: red;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>偶尔使用</p><ul><li><p>:root，根元素，就是HTML元素</p></li><li><p>:empty代表里面完全空白的元素</p></li></ul><h4 id="3-否定伪类"><a href="#3-否定伪类" class="headerlink" title="3.否定伪类"></a>3.否定伪类</h4><p>:not()的格式是:not(x)</p><ul><li><p>x是一个简单选择器</p></li><li><p>元素选择器、通用选择器、属性选择器、类选择器、id选择器、伪类（除否定伪类）</p></li></ul><p>:not(x)表示除x以外的元素</p><h2 id="8-额外知识"><a href="#8-额外知识" class="headerlink" title="8.额外知识"></a>8.额外知识</h2><h3 id="1、边框的形状"><a href="#1、边框的形状" class="headerlink" title="1、边框的形状"></a>1、边框的形状</h3><p>border 主要是用来给盒子增加边框的, 但是在开发中我们也可以利用边框的特性来实现一些形状</p><p><a href="https://css-tricks.com/the-shape-of-css/#top-of-site">https://css-tricks.com/the-shape-of-css/#top-of-site</a></p><h3 id="2、认识-web-字体"><a href="#2、认识-web-字体" class="headerlink" title="2、认识 web 字体"></a>2、认识 web 字体</h3><p>在之前设置页面使用的字体: font-family</p><ul><li><p>我们需要提供一个或多个字体种类名称，浏览器会在列表中搜寻，直到找到它所运行的系统上可用的字体</p></li><li><p>这样的方式完全没有问题，但是对于传统的web开发人员来说，字体选择是有限的</p></li><li><p>这就是所谓的 Web-safe 字体</p></li><li><p>并且这种默认可选的字体并不能进行一些定制化的需求</p></li></ul><p>如果我们依然想在网页中使用别的字体，使用Web Fonts即可</p><h4 id="1-web-fonts-的工作原理"><a href="#1-web-fonts-的工作原理" class="headerlink" title="1.web fonts 的工作原理"></a>1.web fonts 的工作原理</h4><p>首先，需要通过一些渠道获取到希望使用的字体(不是开发来做的事情): </p><ul><li><p>对于某些收费的字体，需要获取到对应的授权</p></li><li><p>对于某些公司定制的字体，需要设计人员来设计</p></li><li><p>对于某些免费的字体，需要获取到对应的字体文件</p></li></ul><p>其次, 在我们的CSS代码当中使用该字体(重要)</p><p>最后, 在部署静态资源时，将HTML&#x2F;CSS&#x2F;JavaScript&#x2F;Font一起部署在静态服务器中</p><p>用户的角度</p><ul><li>浏览器一个网页时，因为代码中有引入字体文件, 字体文件会被一起下载下来</li><li>浏览器会根据使用的字体在下载的字体文件中查找、解析、使用对应的字体</li><li>在浏览器中使用对应的字体显示内容</li></ul><p>使用：</p><p>第一步</p><ul><li><p>在字体天下网站下载一个字体   <a href="https://www.fonts.net.cn/">https://www.fonts.net.cn/</a></p></li><li><p>默认下载下来的是ttf文件</p></li></ul><p> 第二步：使用字体</p><p>使用过程如下：</p><ul><li><p>1.将字体放到对应的目录中</p></li><li><p>2.通过@font-face来引入字体, 并且设置格式</p></li><li><p>3.使用字体</p></li></ul><p>注意: @font-face 用于加载一个自定义的字体;</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 字体引入 */</span></span><br><span class="line">    @font-face &#123;</span><br><span class="line">      font-<span class="attr">family</span>: <span class="string">&quot;wbh&quot;</span>;</span><br><span class="line">      <span class="attr">src</span>: <span class="title function_">url</span>(<span class="string">&quot;./fonts/SanJiLiFengTi-2.ttf&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 使用 */</span></span><br><span class="line">    .<span class="property">box</span> &#123;</span><br><span class="line">      font-<span class="attr">family</span>: <span class="string">&quot;wbh&quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="2-网络字体的兼容性"><a href="#2-网络字体的兼容性" class="headerlink" title="2.网络字体的兼容性"></a>2.网络字体的兼容性</h4><p>在开发中某些浏览器可能不支持该字体，为了浏览器的兼容性问题，需要有对应其他格式的字体</p><p>TrueType字体：拓展名是 .ttf </p><ul><li><p>OpenType&#x2F;TrueType字体：拓展名是 .ttf、.otf， 建立在TrueType字体之上</p></li><li><p>Embedded OpenType字体：拓展名是 .eot， OpenType字体的压缩版</p></li><li><p>SVG字体：拓展名是 .svg、 .svgz</p></li><li><p>WOFF表示Web Open Font Format web开放字体： 拓展名是 .woff，建立在TrueType字体之上</p></li></ul><p>生成兼容性字体：<a href="https://font.qqe2.com/">https://font.qqe2.com/</a></p><p>兼容性写法：</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230321122936480.png" alt="image-20230321122936480"></p><p>src用于指定字体资源</p><ul><li><p>url指定资源的路径</p></li><li><p>format用于帮助浏览器快速识别字体的格式</p></li></ul><h3 id="3、字体图标"><a href="#3、字体图标" class="headerlink" title="3、字体图标"></a>3、字体图标</h3><p>字体图标的使用步骤</p><p>第一步: 通过link引入iconfont.css文件</p><p>第二步: 使用字体图标</p><p>使用字体图标常见的有两种方式</p><p>方式一: 通过对应字体图标的 Unicode 来显示代码</p><p>方式二: 利用已经编写好的class，直接使用即可</p><p>即：方式1：同webfonts方式，引入ttf文件，再使用对应的字符实体，打开demo_index.html查看字符实体</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">  &lt;style&gt;</span><br><span class="line">    @font-face &#123;</span><br><span class="line">      font-<span class="attr">family</span>: <span class="string">&quot;iconfont&quot;</span>;</span><br><span class="line">      <span class="attr">src</span>: <span class="title function_">url</span>(<span class="string">&quot;./fonts03/iconfont.ttf&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .<span class="property">iconfont</span> &#123;</span><br><span class="line">      font-<span class="attr">family</span>: <span class="string">&quot;iconfont&quot;</span>;</span><br><span class="line">      font-<span class="attr">size</span>: normal;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;iconfont&quot;</span>&gt;</span><span class="symbol">&amp;#xe738;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>方式2：使用伪元素，::before，在 iconfont.css  查看 content</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">    @font-face &#123;</span><br><span class="line">      font-<span class="attr">family</span>: <span class="string">&quot;iconfont&quot;</span>;</span><br><span class="line">      <span class="attr">src</span>: <span class="title function_">url</span>(<span class="string">&quot;./fonts03/iconfont.ttf&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .<span class="property">iconfont</span> &#123;</span><br><span class="line">      font-<span class="attr">family</span>: <span class="string">&quot;iconfont&quot;</span>;</span><br><span class="line">      font-<span class="attr">size</span>: normal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .<span class="property">music</span>::before &#123;</span><br><span class="line">      <span class="attr">content</span>: <span class="string">&quot;\e61a&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;iconfont music&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>方法3：使用 class 类名，引入iconfont.css文件，需先设置类名 iconfont 再设置对应的图标类名</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">  &lt;link rel=<span class="string">&quot;stylesheet&quot;</span> href=<span class="string">&quot;./fonts03/iconfont.css&quot;</span>&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;iconfont icon-music&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>阿里：<a href="https://www.iconfont.cn/">https://www.iconfont.cn/</a></p><h3 id="4、精灵图"><a href="#4、精灵图" class="headerlink" title="4、精灵图"></a>4、精灵图</h3><p>CSS Sprite：是一种CSS图像合成技术，将各种小图片合并到一张图片上，然后利用CSS的背景定位来显示对应的图片部分</p><p>有人翻译为：CSS雪碧、CSS精灵</p><p>使用CSS Sprite的好处</p><ul><li>减少网页的http请求数量，加快网页响应速度，减轻服务器压力</li><li>减小图片总大小</li><li>解决了图片命名的困扰，只需要针对一张集合的图片命名</li></ul><p>精灵图的制作</p><p>方法1：专业设计人员</p><p>方法2：<a href="https://www.toptal.com/developers/css/sprite-generator">https://www.toptal.com/developers/css/sprite-generator</a></p><p>精灵图的使用</p><p>精灵图的原理是通过只显示图片的很小一部分来展示的</p><p>通常使用背景</p><ul><li>1.设置对应元素的宽度和高度</li><li>2.设置精灵图作为背景图片</li><li>3.调整背景图片的位置来展示</li></ul><p>获取精灵图的位置：<a href="http://www.spritecow.com/">http://www.spritecow.com/</a></p><h3 id="5、cursor"><a href="#5、cursor" class="headerlink" title="5、cursor"></a>5、cursor</h3><p>cursor可以设置鼠标指针（光标）在元素上面时的显示样式</p><p>cursor常见的设值有</p><ul><li><p>auto：浏览器根据上下文决定指针的显示样式，比如根据文本和非文本切换指针样式</p></li><li><p>default：由操作系统决定，一般就是一个小箭头</p></li><li><p>pointer：一只小手，鼠标指针挪动到链接上面默认就是这个样式</p></li><li><p>text：一条竖线，鼠标指针挪动到文本输入框上面默认就是这个样式</p></li><li><p>none：没有任何指针显示在元素上面</p></li></ul><h2 id="9-元素定位"><a href="#9-元素定位" class="headerlink" title="9.元素定位"></a>9.元素定位</h2><h3 id="1、标准流布局"><a href="#1、标准流布局" class="headerlink" title="1、标准流布局"></a>1、标准流布局</h3><p>默认情况下，元素都是按照normal flow（标准流、常规流、正常流、文档流【document flow】）进行排布</p><ul><li><p>从左到右、从上到下按顺序摆放好</p></li><li><p>默认情况下，互相之间不存在层叠现象</p></li></ul><p>在标准流中，可以使用margin、padding对元素进行定位</p><p>其中margin还可以设置负数</p><p>比较明显的缺点是</p><ul><li><p>设置一个元素的margin或者padding，通常会影响到标准流中其他元素的定位效果</p></li><li><p>不便于实现元素层叠的效果</p></li></ul><p>如果我们希望一个元素可以跳出标准流，单独的对某个元素进行定位呢? </p><p>可以通过position属性来进行设置</p><p>定位允许您从正常的文档流布局中取出元素，并使它们具有不同的行为: </p><ul><li><p>例如放在另一个元素的上面;</p></li><li><p>或者始终保持在浏览器视窗内的同一位置</p></li></ul><p>利用position可以对元素进行定位，常用取值有5个</p><ul><li>默认值:  static：默认值, 静态定位</li></ul><p>使用下面的值, 可以让元素变成 定位元素(positioned element)</p><ul><li><p>relative：相对定位</p></li><li><p>absolute：绝对定位</p></li><li><p>fixed：固定定位</p></li><li><p>sticky：粘性定位</p></li></ul><p>position属性的默认值：static</p><ul><li><p>元素按照 normal flow 布局</p></li><li><p>left 、right、top、bottom没有任何作用</p></li></ul><h3 id="2、相对定位"><a href="#2、相对定位" class="headerlink" title="2、相对定位"></a>2、相对定位</h3><p>元素按照normal flow布局</p><p>可以通过left、right、top、bottom进行定位</p><ul><li><strong>定位参照对象是元素自己原来的位置</strong></li></ul><p>left、right、top、bottom用来设置元素的具体位置</p><p>相对定位的应用场景</p><ul><li>在不影响其他元素位置的前提下，对当前元素位置进行微调（相对自己原来的位置）</li></ul><h3 id="3、固定定位"><a href="#3、固定定位" class="headerlink" title="3、固定定位"></a>3、固定定位</h3><p>元素脱离normal flow（脱离标准流、脱标）</p><p>可以通过left、right、top、bottom进行定位</p><p><strong>定位参照对象是视口（viewport）</strong></p><p>当画布滚动时，固定不动</p><p>视口（Viewport）</p><ul><li>文档的可视区域</li></ul><p>画布（Canvas）</p><ul><li><p>用于渲染文档的区域</p></li><li><p>文档内容超出视口范围，可以通过滚动查看</p></li></ul><p>宽高对比</p><ul><li>画布 &gt;&#x3D; 视口 画布 和 视口</li></ul><h3 id="4、绝对定位"><a href="#4、绝对定位" class="headerlink" title="4、绝对定位"></a>4、绝对定位</h3><p>元素脱离normal flow（脱离标准流、脱标）</p><p>可以通过left、right、top、bottom进行定位</p><ul><li><p><strong>定位参照对象是最邻近的定位祖先元素</strong></p></li><li><p><strong>如果找不到这样的祖先元素，参照对象是视口，内容是可以滚动的</strong></p></li></ul><p>定位元素（positioned element）</p><ul><li><p>position值不为static的元素</p></li><li><p>也就是position值为relative、absolute、fixed的元素</p></li></ul><h4 id="子绝父相"><a href="#子绝父相" class="headerlink" title="子绝父相"></a>子绝父相</h4><p>在绝大数情况下，子元素的绝对定位都是相对于父元素进行定位</p><p>如果希望子元素相对于父元素进行定位，又不希望父元素脱标，常用解决方案是：</p><ul><li><p>父元素设置position: relative（让父元素成为定位元素，而且父元素不脱离标准流）</p></li><li><p>子元素设置position: absolute</p></li><li><p>简称为“子绝父相”</p></li></ul><h4 id="绝对-x2F-固定-定位元素的特点"><a href="#绝对-x2F-固定-定位元素的特点" class="headerlink" title="绝对&#x2F;固定-定位元素的特点"></a>绝对&#x2F;固定-定位元素的特点</h4><ol><li>position:fixed    </li><li>position:absolute</li></ol><p>可以随意设置宽高</p><p>宽高默认由内容决定</p><p>不再受标准流的约束</p><ul><li>不再严格按照从上往下、从左到右排布</li><li>不再严格区分块级、行内级、行内块级的很多特征都会消失</li></ul><p>不再给父元素汇报宽高数据</p><p>脱标元素内部还是按照标准流布局</p><p>对于绝对定位元素来说</p><p>定位参照对象的宽度 &#x3D; left + right + margin-left + margin-right + 绝对定位元素的实际占用宽度</p><p>定位参照对象的高度 &#x3D; top + bottom + margin-top + margin-bottom + 绝对定位元素的实际占用高度</p><p>如果希望绝对定位元素的宽高和定位参照对象一样，可以给绝对定位元素设置以下属性</p><ul><li>left: 0、right: 0、top: 0、bottom: 0、margin:0</li></ul><p>如果希望绝对定位元素在定位参照对象中居中显示，可以给绝对定位元素设置以下属性</p><ul><li><p>left: 0、right: 0、top: 0、bottom: 0、margin: auto</p></li><li><p>另外，还得设置具体的宽高值（宽高小于定位参照对象的宽高）</p></li></ul><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230321222022472.png"></p><h3 id="5、粘性定位"><a href="#5、粘性定位" class="headerlink" title="5、粘性定位"></a>5、粘性定位</h3><p>还有一个定位的值是position: sticky，比起其他定位值要新一些</p><ul><li><p>sticky是一个大家期待已久的属性</p></li><li><p>可以看做是相对定位和固定定位的结合体</p></li></ul><p>它允许被定位的元素表现得像相对定位一样，直到它滚动到某个阈值点</p><p>当达到这个阈值点时, 就会变成固定定位</p><p>即需要设置这个阈值才能生效，如 top:0 </p><p>sticky是相对于最近的滚动祖先包含视口的(the nearest ancestor scroll container’s scrollport )</p><h3 id="6、z-index"><a href="#6、z-index" class="headerlink" title="6、z-index"></a>6、z-index</h3><p>z-index属性用来设置<strong>定位元素</strong>的层叠顺序（<strong>仅对定位元素有效</strong>）</p><ul><li>取值可以是正整数、负整数、0</li></ul><p>比较原则</p><ul><li><p>如果是兄弟关系</p><ul><li>z-index越大，层叠在越上面</li><li>z-index相等，写在后面的那个元素层叠在上面</li></ul></li><li><p>如果不是兄弟关系 </p><ul><li>各自从元素自己以及祖先元素中，找出最邻近的2个定位元素进行比较</li><li>而且这2个定位元素必须有设置z-index的具体数值</li></ul></li></ul><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230321224530651.png" alt="image-20230321224530651"></p><h2 id="10-CSS元素浮动"><a href="#10-CSS元素浮动" class="headerlink" title="10.CSS元素浮动"></a>10.CSS元素浮动</h2><h3 id="1、认识浮动"><a href="#1、认识浮动" class="headerlink" title="1、认识浮动"></a>1、认识浮动</h3><p>float 属性可以指定一个元素应沿其容器的左侧或右侧放置，允许文本和内联元素环绕它</p><ul><li><p>float 属性最初只用于在一段文本内浮动图像, 实现文字环绕的效果</p></li><li><p>但是早期的CSS标准中并没有提供好的左右布局方案, 因此在一段时间里面它成为网页多列布局的最常用工具</p></li></ul><p>绝对定位、浮动都会让元素脱离标准流，以达到灵活布局的效果</p><p>可以通过float属性让元素产生浮动效果，float的常用取值</p><ul><li><p>none：不浮动，默认值</p></li><li><p>left：向左浮动</p></li><li><p>right：向右浮动</p></li></ul><h3 id="2、浮动规则"><a href="#2、浮动规则" class="headerlink" title="2、浮动规则"></a>2、浮动规则</h3><h4 id="浮动规则1"><a href="#浮动规则1" class="headerlink" title="浮动规则1"></a>浮动规则1</h4><p>元素一旦浮动后, 脱离标准流</p><p>朝着向左或向右方向移动，直到自己的边界紧贴着包含块（一般是父元素）或者其他浮动元素的边界为止</p><p>定位元素会层叠在浮动元素上面</p><h4 id="浮动规则2"><a href="#浮动规则2" class="headerlink" title="浮动规则2"></a>浮动规则2</h4><p>如果元素是向左（右）浮动，浮动元素的左（右）边界不能超出包含块的左（右）边界</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230322211609799.png" alt="image-20230322211609799"></p><h4 id="浮动规则3"><a href="#浮动规则3" class="headerlink" title="浮动规则3"></a>浮动规则3</h4><p>浮动元素之间不能层叠</p><ul><li><p>如果一个元素浮动，另一个浮动元素已经在那个位置了，后浮动的元素将紧贴着前一个浮动元素（左浮找左浮，右浮找右浮）</p></li><li><p>如果水平方向剩余的空间不够显示浮动元素，浮动元素将向下移动，直到有充足的空间为止</p></li></ul><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230322211713800.png" alt="image-20230322211713800"></p><h4 id="浮动规则4"><a href="#浮动规则4" class="headerlink" title="浮动规则4"></a>浮动规则4</h4><p>浮动元素不能与行内级内容层叠，行内级内容将会被浮动元素推出</p><p>​比如行内级元素、inline-block元素、块级元素的文字内容</p><h4 id="浮动规则5"><a href="#浮动规则5" class="headerlink" title="浮动规则5"></a>浮动规则5</h4><p>行内级元素、inline-block元素浮动后，其顶部将与所在行的顶部对齐</p><h4 id="空隙的解决方案"><a href="#空隙的解决方案" class="headerlink" title="空隙的解决方案"></a>空隙的解决方案</h4><p>将多个行内级元素中间的空格去除</p><p>   1.删除换行符（不推荐）</p><p>   2.将父元素的font-size设置为0  但是需要在子元素设置回来</p><p>   3.浮动（设置子元素统一向一个方向浮动）</p><p>   4.flex 布局 (未学习)</p><h4 id="案例练习总结"><a href="#案例练习总结" class="headerlink" title="案例练习总结"></a>案例练习总结</h4><p>京东布局：</p><p>考虑本行最后一个模块跑第二行的解决办法</p><p>方法1：通过类名设置 margin-right 为0，稍微麻烦，但是无需考虑兼容</p><p>方法2：结构伪类，nth-child(n)，有可能存在兼容问题（好用）</p><p>方法3：margin 负值，无需考虑兼容（掌握）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">需在模块再包裹一个div元素，为其设置 margin 的负值</span><br><span class="line">    .<span class="property">box</span> &#123;</span><br><span class="line">      <span class="comment">/* margin-right: -10px; */</span></span><br><span class="line">      <span class="attr">margin</span>: <span class="number">0</span> -5px;</span><br><span class="line">    &#125;</span><br><span class="line">在item设置对应的外边距</span><br><span class="line">      <span class="attr">margin</span>: <span class="number">0</span> 5px;</span><br><span class="line">      <span class="comment">/* margin-right: 10px; */</span></span><br></pre></td></tr></table></figure><p>考拉边框线布局：需设置每一项为border-box</p><p>方法1：为item的父元素设置边框，再为item设置border-right，清除最后一个item的border-right</p><p>方法2：为每一个item设置边框，再设置item 的margin-right为-1px，再设置其中一个item的宽少一个px</p><h3 id="3、浮动存在的问题"><a href="#3、浮动存在的问题" class="headerlink" title="3、浮动存在的问题"></a>3、浮动存在的问题</h3><p>由于浮动元素脱离了标准流，变成了脱标元素，所以不再向父元素汇报高度</p><p>父元素计算总高度时，就不会计算浮动子元素的高度，导致了高度坍塌的问题</p><p>解决父元素高度坍塌问题的过程，一般叫做清浮动（清理浮动、清除浮动）</p><p>清浮动的目的是</p><ul><li>让父元素计算总高度的时候，把浮动子元素的高度算进去</li></ul><h3 id="4、清除浮动"><a href="#4、清除浮动" class="headerlink" title="4、清除浮动"></a>4、清除浮动</h3><p>clear属性是做什么的呢? </p><p>clear 属性可以指定一个元素是否必须移动（清除浮动后）到在它之前的浮动元素下面</p><p>clear的常用取值</p><ul><li><p>left：要求元素的顶部低于之前生成的所有左浮动元素的底部 </p></li><li><p>right：要求元素的顶部低于之前生成的所有右浮动元素的底部</p></li><li><p>both：要求元素的顶部低于之前生成的所有浮动元素的底部</p></li><li><p>none：默认值，无特殊要求</p></li></ul><p>因为所有的后代item元素都是浮动的，脱了标准流</p><p>不会向父元素汇报高度，所以content压根没有高度</p><p>方法一：给父元素设置固定高度</p><ul><li>扩展性不好（不推荐）</li></ul><p>方法二：在父元素最后增加一个空的块级子元素，并且让它设置clear: both</p><ul><li><p>会增加很多无意义的空标签，维护麻烦</p></li><li><p>违反了结构与样式分离的原则（不推荐）</p></li></ul><p>方法三：给父元素添加一个伪元素 </p><ul><li><p>推荐使用</p></li><li><p>编写好后可以轻松实现清除浮动</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">.<span class="property">clear</span>-<span class="attr">fix</span>::after &#123;</span><br><span class="line">  <span class="attr">content</span>: <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="attr">clear</span>: both;</span><br><span class="line">  <span class="attr">display</span>: block;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 增加兼容性 */</span></span><br><span class="line">  <span class="attr">visibility</span>: hidden;</span><br><span class="line">  <span class="attr">height</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.<span class="property">clear</span>-fix &#123;</span><br><span class="line">  <span class="comment">/* 兼容ie 6 7 */</span></span><br><span class="line">  *<span class="attr">zoom</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法四：双伪元素清除</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">.<span class="property">clearfix</span>::before,</span><br><span class="line">        .<span class="property">clearfix</span>::after &#123;</span><br><span class="line">            <span class="attr">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">            <span class="attr">display</span>: table;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 真正清除浮动的标签 */</span></span><br><span class="line">        </span><br><span class="line">        .<span class="property">clearfix</span>::after &#123;</span><br><span class="line">            <span class="attr">clear</span>: both;</span><br><span class="line">        &#125;</span><br><span class="line">父元素：&lt;div <span class="keyword">class</span>=<span class="string">&quot;top clearfix&quot;</span>&gt;</span><br></pre></td></tr></table></figure><p>方法五：</p><p>操作：直接给父元素设置 overflow : hidden</p><h3 id="5、对比布局方案"><a href="#5、对比布局方案" class="headerlink" title="5、对比布局方案"></a>5、对比布局方案</h3><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230322212037560.png" alt="image-20230322212037560"></p><h2 id="11-flex布局"><a href="#11-flex布局" class="headerlink" title="11.flex布局"></a>11.flex布局</h2><h3 id="1、认识flex布局"><a href="#1、认识flex布局" class="headerlink" title="1、认识flex布局"></a>1、认识flex布局</h3><p>Flexbox翻译为弹性盒子</p><ul><li><p>弹性盒子是一种用于按行或按列布局元素的一维布局方法</p></li><li><p>元素可以膨胀以填充额外的空间, 收缩以适应更小的空间</p></li><li><p>通常我们使用Flexbox来进行布局的方案称之为flex布局(flex layout)</p></li></ul><p>flex布局是目前web开发中使用最多的布局方案</p><ul><li><p>flex 布局（Flexible 布局，弹性布局）</p></li><li><p>目前特别在移动端可以说已经完全普及</p></li><li><p>在PC端也几乎已经完全普及和使用, 只有非常少数的网站依然在用浮动来布局</p></li></ul><p>为什么需要flex布局</p><ul><li><p>长久以来，CSS 布局中唯一可靠且跨浏览器兼容的布局工具只有 floats 和 positioning</p></li><li><p>但是这两种方法本身存在很大的局限性, 并且他们用于布局实在是无奈之举</p></li></ul><p>原先布局存在的痛点</p><ul><li>比如在父内容里面垂直居中一个块内容</li><li>比如使容器的所有子项等分可用宽度&#x2F;高度，而不管有多少宽度&#x2F;高度可用</li><li>比如使多列布局中的所有列采用相同的高度，即使它们包含的内容量不同</li></ul><h3 id="2、flex布局的理解"><a href="#2、flex布局的理解" class="headerlink" title="2、flex布局的理解"></a>2、flex布局的理解</h3><p>两个重要的概念：</p><ul><li><p>开启了 flex 布局的元素叫 flex container</p></li><li><p>flex container 里面的直接子元素叫做 flex item</p></li></ul><p>当flex container中的子元素变成了flex item时, 具备一下特点:</p><ul><li><p>flex item的布局将受flex container属性的设置来进行控制和布局</p></li><li><p>flex item不再严格区分块级元素和行内级元素</p></li><li><p>flex item默认情况下是包裹内容的, 但是可以设置宽度和高度</p></li></ul><p>设置 display 属性为 flex 或者 inline-flex 可以成为 flex container</p><p>flex：flex container 以 block-level 形式存在</p><p>inline-flex：flex container 以 inline-level 形式存在</p><h4 id="flex布局的模型"><a href="#flex布局的模型" class="headerlink" title="flex布局的模型"></a>flex布局的模型</h4><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230322220731649.png" alt="image-20230322220731649"></p><h3 id="3、flex-container属性"><a href="#3、flex-container属性" class="headerlink" title="3、flex-container属性"></a>3、flex-container属性</h3><p>应用在 flex container 上的 CSS 属性</p><p>flex-flow、flex-direction、flex-wrap、flex-flow、justify-content、align-items、align-content</p><h4 id="flex-direction"><a href="#flex-direction" class="headerlink" title="flex-direction"></a>flex-direction</h4><p>flex items 默认都是沿着 main axis（主轴）从 main start 开始往 main end 方向排布</p><p>flex-direction 决定了 main axis 的方向，有 4 个取值</p><p>row（默认值）、row-reverse、column、column-reverse</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 修改主轴的方向 */</span></span><br><span class="line"><span class="comment">/* row-reverse  主轴反转 */</span></span><br><span class="line"><span class="comment">/* flex-direction: row-reverse; */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* column 修改主轴的方向 列变成主轴的方向 */</span></span><br><span class="line"><span class="comment">/* column 反转列作为主轴的方向 */</span></span><br><span class="line"><span class="comment">/* flex-direction: column-reverse; */</span></span><br></pre></td></tr></table></figure><h4 id="flex-wrap"><a href="#flex-wrap" class="headerlink" title="flex-wrap"></a>flex-wrap</h4><p>flex-wrap 决定了 flex container 是单行还是多行</p><ul><li><p>nowrap（默认）：单行</p></li><li><p>wrap：多行</p></li><li><p>wrap-reverse：多行（对比 wrap，cross start 与 cross end 相反）</p></li></ul><h4 id="flex-flow"><a href="#flex-flow" class="headerlink" title="flex-flow"></a>flex-flow</h4><p>flex-flow 属性是 flex-direction 和 flex-wrap 的简写，顺序任何, 并且都可以省略</p><h4 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a>justify-content</h4><p>justify-content 决定了 flex items 在 main axis 上的对齐方式</p><p>flex-start（默认值）：与 main start 对齐</p><p>flex-end：与 main end 对齐</p><p>center：居中对齐</p><p>space-between：</p><ul><li><p>flex items 之间的距离相等</p></li><li><p>与 main start、main end两端对齐</p></li></ul><p>space-around： </p><ul><li><p>flex items 之间的距离相等 </p></li><li><p>flex items 与 main start、main end 之间的距离是 flex items 之间距离的一半</p></li></ul><p>space-evenly： </p><ul><li><p>flex items 之间的距离相等 </p></li><li><p>flex items 与 main start、main end 之间的距离等于 flex items 之间的距离</p></li></ul><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230322221215021.png" alt="image-20230322221215021"></p><h4 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h4><p>align-items 决定了 flex items 在 cross axis 上的对齐方式</p><ul><li><p>normal：在弹性布局中，效果和stretch一样</p></li><li><p>stretch：当 flex items 在 cross axis 方向的 size（height） 为 auto 时，会自动拉伸至填充 flex container</p></li><li><p>flex-start：与 cross start 对齐</p></li><li><p>flex-end：与 cross end 对齐</p></li><li><p>center：居中对齐</p></li><li><p>baseline：与基准线对齐 align-item</p></li></ul><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230322221453595.png" alt="image-20230322221453595"></p><h4 id="align-content"><a href="#align-content" class="headerlink" title="align-content"></a>align-content</h4><p>align-content 决定了多行 flex items 在 cross axis 上的对齐方式，用法与 justify-content 类似</p><p>stretch（默认值）：与 align-items 的 stretch 类似</p><p>flex-start：与 cross start 对齐</p><p>flex-end：与 cross end 对齐</p><p>center：居中对齐</p><p>space-between：flex items 之间的距离相等</p><ul><li>与 cross start、cross end两端对齐</li></ul><p>space-around：flex items 之间的距离相等</p><ul><li>flex items 与 cross start、cross end 之间的距离是 flex items 之间距离的一半</li></ul><p>space-evenly：flex items 之间的距离相等</p><ul><li>flex items 与 cross start、cross end 之间的距离等于 flex items 之间的距离</li></ul><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230322221508510.png" alt="image-20230322221508510"></p><h3 id="4、flex-item属性"><a href="#4、flex-item属性" class="headerlink" title="4、flex-item属性"></a>4、flex-item属性</h3><h4 id="order"><a href="#order" class="headerlink" title="order"></a>order</h4><p>order 决定了 flex items 的排布顺序</p><ul><li><p>可以设置任意整数（正整数、负整数、0），值越小就越排在前面</p></li><li><p>默认值是 0</p></li></ul><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230322222250489.png" alt="image-20230322222250489"></p><h4 id="align-self"><a href="#align-self" class="headerlink" title="align-self"></a>align-self</h4><p>flex items 可以通过 align-self 覆盖 flex container 设置的 align-items</p><ul><li><p>auto（默认值）：遵从 flex container 的 align-items 设置</p></li><li><p>stretch、flex-start、flex-end、center、baseline，效果跟 align-items 一致</p></li></ul><h4 id="flex-grow"><a href="#flex-grow" class="headerlink" title="flex-grow"></a>flex-grow</h4><p>flex-grow 决定了 flex items 如何扩展(拉伸&#x2F;成长) </p><ul><li><p>可以设置任意非负数字（正小数、正整数、0），默认值是 0</p></li><li><p>当 flex container 在 main axis 方向上有剩余 size 时，flex-grow 属性才会有效</p></li></ul><p>如果所有 flex items 的 flex-grow 总和 sum 超过 1，每个 flex item 扩展的 size 为</p><ul><li>flex container 的剩余 size * flex-grow &#x2F; sum</li></ul><p>flex items 扩展后的最终 size 不能超过 max-width\max-height</p><h4 id="flex-shrink"><a href="#flex-shrink" class="headerlink" title="flex-shrink"></a>flex-shrink</h4><p>flex-shrink 决定了 flex items 如何收缩（缩小）</p><ul><li><p>可以设置任意非负数字（正小数、正整数、0），默认值是 1</p></li><li><p>当 flex items 在 main axis 方向上超过了 flex container 的 size，flex-shrink 属性才会有效</p></li></ul><p>如果所有 flex items 的 flex-shrink 总和超过 1，每个 flex item 收缩的 size为</p><ul><li>flex items 超出 flex container 的 size * 收缩比例 &#x2F; 所有 flex items 的收缩比例之和</li></ul><p>flex items 收缩后的最终 size 不能小于 min-width\min-height</p><h4 id="flex-basis"><a href="#flex-basis" class="headerlink" title="flex-basis"></a>flex-basis</h4><p>flex-basis 用来设置 flex items 在 main axis 方向上的 base size</p><ul><li>auto（默认值）、具体的宽度数值（100px）</li></ul><p>唯一用处：和width差不多，但是在显示某些内容（比如一串英文）时会当做一个整体，显示不完是会扩展尺寸来显示完整</p><p>决定 flex items 最终 base size 的因素，从优先级高到低</p><ul><li><p>max-width\max-height\min-width\min-height</p></li><li><p>flex-basis</p></li><li><p>width\height</p></li><li><p>内容本身的 size</p></li></ul><h4 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h4><p>flex 是 flex-grow || flex-shrink || flex-basis 的简写,flex 属性可以指定1个，2个或3个值</p><p>设置为none：0 0 auto</p><p>设置为 auto：1 1 auto</p><p>单值语法: 值必须为以下其中之一</p><ul><li><p>一个无单位数：它会被当作 flex-grow 的值</p></li><li><p>一个有效的宽度值：它会被当作 flex-basis 的值</p></li><li><p>关键字none，auto或initial</p></li></ul><p>双值语法: </p><ul><li><p>第一个值必须为一个无单位数，并且它会被当作 flex-grow 的值。</p></li><li><p>第二个值必须为以下之一：</p><ul><li>一个无单位数：它会被当作 flex-shrink 的值</li><li>一个有效的宽度值: 它会被当作 flex-basis 的值</li></ul></li></ul><p>三值语法:</p><p>第一个值必须为一个无单位数，并且它会被当作 flex-grow 的值</p><p>第二个值必须为一个无单位数，并且它会被当作 flex-shrink 的值</p><p>第三个值必须为一个有效的宽度值， 并且它会被当作 flex-basis 的值。</p><h3 id="5、以下布局解决方案"><a href="#5、以下布局解决方案" class="headerlink" title="5、以下布局解决方案"></a>5、以下布局解决方案</h3><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230322222340960.png" alt="image-20230322222340960"></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">常用：在item元素结尾加上span元素 再为span设置相同的宽度（列数-<span class="number">2</span>）</span><br><span class="line">    &lt;div <span class="keyword">class</span>=<span class="string">&quot;item3 item&quot;</span>&gt;3x&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">    .<span class="property">container</span> &gt; span &#123;</span><br><span class="line">      <span class="attr">width</span>: 120px;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="12-项目练习"><a href="#12-项目练习" class="headerlink" title="12.项目练习"></a>12.项目练习</h2><h3 id="1、布局练习"><a href="#1、布局练习" class="headerlink" title="1、布局练习"></a>1、布局练习</h3><h3 id="2、网易云布局"><a href="#2、网易云布局" class="headerlink" title="2、网易云布局"></a>2、网易云布局</h3><p>1.text-indent对行内非替换元素无效</p><p>2.line-height对行内非替换元素的作用</p><p>3.块级元素中嵌套img，需要设置img的vertical-align才能完整盖住块级元素</p><p>4.box-sizing的应用场景：盒子明确设置了宽度和高度</p><p>5.box-sizing无效：块级盒子嵌套、定位、浮动</p><p>6.在a元素中嵌套div元素</p><h3 id="3、王者荣耀"><a href="#3、王者荣耀" class="headerlink" title="3、王者荣耀"></a>3、王者荣耀</h3><h2 id="13-形变与动画"><a href="#13-形变与动画" class="headerlink" title="13.形变与动画"></a>13.形变与动画</h2><h3 id="1、transform"><a href="#1、transform" class="headerlink" title="1、transform"></a>1、transform</h3><p>CSS transform属性允许对某一个元素进行某些形变, 包括旋转，缩放，倾斜或平移等</p><p>注意事项，并非所有的盒子都可以进行transform的转换（通常行内级元素不能进行形变）</p><p>所以，transform对于行内级非替换元素是无效的</p><ul><li><p>比如对span、a元素等</p></li><li><p>table 相关的也不能形变</p></li></ul><p>常见的函数transform function有</p><ul><li><p>平移：translate(x, y) </p></li><li><p>缩放：scale(x, y) </p></li><li><p>旋转：rotate(deg) </p></li><li><p>倾斜：skew(deg, deg)</p></li></ul><p>通过上面的几个函数，我们可以改变某个元素的形变</p><h4 id="1-位移—translate"><a href="#1-位移—translate" class="headerlink" title="1.位移—translate"></a>1.位移—translate</h4><p>平移：translate(x, y) </p><p>这个CSS 函数用于移动元素在平面上的位置</p><p>translate本身可以表示翻译的意思，在物理上也可以表示平移；</p><p>值个数 </p><ul><li>一个值时，设置x轴上的位移</li><li>二个值时，设置x轴和y轴上的位移</li></ul><p>值类型</p><ul><li><p>数字：100px</p></li><li><p>百分比：参照元素本身（ refer to the size of bounding box ）</p></li></ul><p>translate 是 translateX 和 translateY 函数的简写</p><p>translate 的百分比可以完成一个元素的水平和垂直居中</p><p>translate函数相对于 flex 布局的兼容性会好一点点（可忽略不计）</p><h4 id="2-补充：水平居中和垂直居中的方案"><a href="#2-补充：水平居中和垂直居中的方案" class="headerlink" title="2.补充：水平居中和垂直居中的方案"></a>2.补充：水平居中和垂直居中的方案</h4><p>水平居中<br>1.行内级元素</p><ul><li>设置父元素的 text-align:cente</li></ul><p>2.块级元素</p><ul><li>需要有宽度，设置当前块级元素的 margin:0 auto</li></ul><p>3.绝对定位</p><ul><li>元素有宽度的情况下，left0&#x2F;right0&#x2F;margin:0 auto;</li></ul><p>4.flex</p><pre><code>    * justify-content:center</code></pre><p>垂直居中方法</p><p>1.绝对定位</p><p>元素在有高度的情况下，top0&#x2F;bottom0&#x2F;margin:auto 0</p><p>弊端：</p><ul><li><p>必须使用定位（脱离标准流）</p></li><li><p>必须给元素设置宽度</p></li></ul><p>2.flex布局</p><p>弊端</p><ul><li>当前flex局部中的所有元素都会被垂直居中</li><li>相对来说兼容性差一点点（基本可以忽略）</li></ul><p>3.top&#x2F;translate</p><ul><li><p>1、让元素向下位移父元素的50%</p><ul><li>使用相对定位，不能使用margin-top 它相对于的是父元素的宽度</li></ul></li><li><p>2、让元素向上位移自身的50%</p></li></ul><h4 id="3-缩放"><a href="#3-缩放" class="headerlink" title="3.缩放"></a>3.缩放</h4><p>缩放：scale(x, y) </p><ul><li>scale() CSS 函数可改变元素的大小</li></ul><p>值个数</p><ul><li><p>一个值时，设置 x 轴上的缩放</p></li><li><p>二个值时，设置 x 轴和 y 轴上的缩放</p></li></ul><p>值类型：</p><ul><li><p>数字</p><ul><li>1：保持不变</li><li>2：放大一倍 </li><li>0.5：缩小一半</li></ul></li><li><p>百分比：百分比不常用</p></li></ul><p>scale 函数时 scaleX 和 scaleY 的缩写</p><h4 id="4-旋转"><a href="#4-旋转" class="headerlink" title="4.旋转"></a>4.旋转</h4><p>旋转：rotate(<code>&lt;angle&gt;</code>) </p><p>值个数</p><ul><li>一个值时，表示旋转的角度</li></ul><p>值类型：</p><ul><li><p>常用单位deg：旋转的角度（ degrees ）</p></li><li><p>正数为顺时针</p></li><li><p>负数为逆时针</p></li></ul><p>补充一：rotate函数是rotateZ函数的简写写法</p><p>补充二：rotate的其他单位</p><ul><li>度（degrees）、 百分度（gradians）、弧度（radians）或圈数（turns）；</li></ul><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230325082302662.png" alt="image-20230325082302662"></p><h4 id="5-transform-origin"><a href="#5-transform-origin" class="headerlink" title="5.transform origin"></a>5.transform origin</h4><p>transform-origin：形变的原点</p><p>比如在进行scale缩放或者rotate旋转时，都会有一个原点。</p><p>一个值：设置x轴的原点 </p><p>两个值：设置x轴和y轴的原点</p><p>必须是<code>&lt;length&gt;</code>，<code>&lt;percentage&gt;</code>，或 left, center, right, top, bottom关键字中的一个</p><ul><li><p>left, center, right, top, bottom关键字</p></li><li><p>length：从左上角开始计算</p></li><li><p>百分比：参考元素本身大小</p></li></ul><h4 id="6-倾斜"><a href="#6-倾斜" class="headerlink" title="6.倾斜"></a>6.倾斜</h4><p>倾斜：skew(x, y)</p><ul><li>函数定义了一个元素在二维平面上的倾斜转换</li></ul><p>值个数 </p><ul><li>一个值时，表示x轴上的倾斜 </li><li>二个值时，表示x轴和y轴上的倾斜</li></ul><p>值类型</p><ul><li><p>deg：倾斜的角度 </p></li><li><p>正数为顺时针 </p></li><li><p>负数为逆时针</p></li></ul><p>注意：倾斜的原点受transform-origin的影响</p><h4 id="7-transform-设置多个值"><a href="#7-transform-设置多个值" class="headerlink" title="7.transform 设置多个值"></a>7.transform 设置多个值</h4><p>transform的语法是可以设置多个transform-function的</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230325081501119.png" alt="image-20230325081501119"></p><p>+:一个或者多个，并且之间使用空格分割</p><p>#：一个或者多个 之间使用,进行分割（如box-shadow）</p><h3 id="2、transition动画"><a href="#2、transition动画" class="headerlink" title="2、transition动画"></a>2、transition动画</h3><p>CSS transitions 提供了一种在更改CSS属性时控制动画速度的方法</p><p>可以让CSS属性变化成为一个持续一段时间的过程，而不是立即生效的</p><p>比如将一个元素从一个位置移动到另外一个位置，默认在修改完CSS属性后会立即生效</p><p>但是我们可以通过CSS transition，让这个过程加上一定的动画效果，包括一定的曲线速率变化</p><p>通常将两个状态之间的过渡称为隐式过渡（implicit transitions），因为开始与结束之间的状态由浏览器决定</p><p>CSS transitions 可以决定</p><ul><li><p>哪些属性发生动画效果 (明确地列出这些属性) </p></li><li><p>何时开始 (设置 delay）</p></li><li><p>持续多久 (设置 duration) </p></li><li><p>如何动画 (定义timing function，比如匀速地或先快后慢)</p></li></ul><p>哪些属性可以做动画</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_animated_properties">https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_animated_properties</a></p><p>transition CSS 属性是 transition-property，transition-duration，transition-timing-function 和 transition-delay 的一个简写属性</p><p>transition-property：指定应用过渡属性的名称</p><ul><li><p>all：所有属性都执行动画</p></li><li><p>none：所有属性都不执行动画</p></li><li><p>CSS属性名称：要执行动画的CSS属性名称，比如width、left、transform等</p></li></ul><p>transition-duration：指定过渡动画所需的时间</p><ul><li>单位可以是秒（s）或毫秒（ms）</li></ul><p>transition-timing-function：指定动画的变化曲线</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transition-timing-function">https://developer.mozilla.org/zh-CN/docs/Web/CSS/transition-timing-function</a></li></ul><p>transition-delay：指定过渡动画执行之前的等待时间</p><p>transform是形变</p><ul><li><p>一个CSS属性，该CSS属性用于设置形变</p></li><li><p>后面的值是形变的函数，比如scale、rotate、translate</p></li></ul><p>translate是其中一个transform-function ：用于对元素进行平移</p><p>transition是过渡的意思：它本身也有转变的含义，但是更多表示的是过渡的过程</p><h3 id="3、Animation"><a href="#3、Animation" class="headerlink" title="3、Animation"></a>3、Animation</h3><p>transition来进行过渡动画，但是有如下的缺点：</p><ul><li><p>transition只能定义开始状态和结束状态，不能定义中间状态，也就是说只有两个状态</p></li><li><p>transition不能重复执行，除非一再触发动画</p></li><li><p>transition需要在特定状态下会触发才能执行，比如某个属性被修改了</p></li></ul><p>如果我们希望可以有更多状态的变化，我们可以使用CSS Animation</p><p>CSS Animation的使用分成两个步骤：</p><ul><li><p>步骤一：使用keyframes定义动画序列（每一帧动画如何执行）</p></li><li><p>步骤二：配置动画执行的名称、持续时间、动画曲线、延迟、执行次数、方向等等</p></li></ul><h3 id="4、vertical-align"><a href="#4、vertical-align" class="headerlink" title="4、vertical-align"></a>4、vertical-align</h3><p>给行内级元素设置</p><p>vertical-align会影响行内块级元素在一个行盒中垂直方向的位置</p><p>行盒的作用：包裹所有的内容</p><p>一个div没有设置高度的时候，会不会有高度？</p><ul><li><p>没有内容，没有高度</p></li><li><p>有内容，内容撑起来高度</p></li></ul><p>但是内容撑起来高度的本质是什么呢？</p><ul><li>内容有行高（line-height），撑起来了div的高度</li></ul><p>行高为什么可以撑起div的高度？</p><ul><li><p>这是因为line boxes的存在，并且line-boxes有一个特性，包裹每行的 inline level</p></li><li><p>而其中的文字是有行高的，必须将整个行高包裹进去，才算包裹这个 line-leve</p></li></ul><p>line-boxes一定会想办法包裹住当前行中所有的内容</p><p>为什么对齐方式千奇百怪呢？</p><p>答案就是baseline对齐</p><ul><li>官方vertical-align的默认值：没错，就是baseline</li></ul><p>但是baseline都是谁呢?</p><ul><li><p>文本的baseline是字母x的下方</p></li><li><p>Inline-block默认的baseline是margin-bottom的底部（没有，就是盒子的底部）</p></li><li><p>Inline-block有文本时，baseline是最后一行文本的x的下方</p></li></ul><p>不同的取值</p><ul><li>baseline(默认值)：基线对齐（你得先明白什么是基线</li><li>top：把行内级盒子的顶部跟line boxes顶部对齐</li><li>middle：行内级盒子的中心点与父盒基线加上x-height一半的线对齐 </li><li>bottom：把行内级盒子的底部跟line box底部对齐</li><li><code>&lt;percentage&gt;</code>：把行内级盒子提升或者下降一段距离（距离相对于line-height计算\元素高度）， 0%意味着同baseline一 样</li><li><code>&lt;length&gt;</code>：把行内级盒子提升或者下降一段距离，0cm意味着同baseline一样</li></ul><p>解决图片下边缘的间隙方法</p><ul><li>方法一: 设置成top&#x2F;middle&#x2F;bottom</li><li>方法二: 将图片设置为block元素</li></ul><p>盒子与文本分离：line-height 的继承与 vertical-align 的基线对齐导致，需要重新设置 line-height</p><h2 id="14-额外知识补充"><a href="#14-额外知识补充" class="headerlink" title="14.额外知识补充"></a>14.额外知识补充</h2><h3 id="1-HTML5新增元素"><a href="#1-HTML5新增元素" class="headerlink" title="1.HTML5新增元素"></a>1.HTML5新增元素</h3><h4 id="1、语义化元素"><a href="#1、语义化元素" class="headerlink" title="1、语义化元素"></a>1、语义化元素</h4><p> 在HMTL5之前，我们的网站分布层级通常包括 header、nav、main、footer</p><p>弊端：</p><ul><li><p>我们往往过多的使用div, 通过id或class来区分元素</p></li><li><p>对于浏览器来说这些元素不够语义化</p></li><li><p>对于搜索引擎来说, 不利于SEO的优化</p></li></ul><p> HTML5新增了语义化的元素：</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230327081851504.png" alt="image-20230327081851504"></p><h4 id="2、Video、Audio元素"><a href="#2、Video、Audio元素" class="headerlink" title="2、Video、Audio元素"></a>2、Video、Audio元素</h4><p>在HTML5之前是通过flash或者其他插件实现的, 但是会有很多问题</p><ul><li>比如无法很好的支持HTML&#x2F;CSS特性, 兼容性问题等</li></ul><p>HTML5增加了对媒体类型的支持：</p><ul><li><p>音频：audio</p></li><li><p>视频：video</p></li></ul><p>使用方法有两个：</p><ul><li>直接通过元素使用</li><li>通过 javascript 的 API 对其进行控制</li></ul><p><code> &lt;video&gt;</code> 元素用于在HTML或者XHTML文档中嵌入媒体播放器，用于支持文档内的视频播放</p><p>常见属性：</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230327150507161.png" alt="image-20230327150507161"></p><p>每个视频都会有自己的格式，浏览器的video并非支持所有的视频格式，mp4常用</p><p>video的兼容性写法</p><ul><li><p>内容一：通过元素指定更多视频格式的源</p></li><li><p>内容二：通过p&#x2F;div等元素指定在浏览器不支持video元素的情况，显示的内容</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;video src=<span class="string">&quot;./assets/fcrs.mp4&quot;</span> width=<span class="string">&quot;500&quot;</span> controls&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;./assets/fcrs.ogg&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;./assets/fcrs.webm&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>当前您的浏览器不支持视频的播放，请更换浏览器<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p><code>&lt;audio&gt;</code>元素用于在文档中嵌入音频内容, 和video的用法非常类似</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230327150706535.png" alt="image-20230327150706535"></p><p>每个音频都会有自己的格式, 浏览器的audio并非支持所有的视频格式</p><p>具体的支持的格式可以通过下面的链接查看</p><p><a href="https://developer.mozilla.org/en-US/docs/Web/Media/Formats/Audio_codecs">https://developer.mozilla.org/en-US/docs/Web/Media/Formats/Audio_codecs</a></p><p>兼容性写法（降级处理）：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;audio src=<span class="string">&quot;./assets/yhbk.mp3&quot;</span> controls &gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;./assets/fcrs.mp3&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>你的浏览器不支持<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="2-input、全局属性-data"><a href="#2-input、全局属性-data" class="headerlink" title="2.input、全局属性 data-*"></a>2.input、全局属性 data-*</h3><p>HTML5对input元素也进行了扩展，在之前我们已经学习过的其中几个属性也是HTML5的特性：</p><ul><li><p>placeholder：输入框的占位文字</p></li><li><p>multiple：多个值</p></li><li><p>autofocus：最多输入的内容</p></li></ul><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/Input">https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/Input</a></p><p>在HTML5中, 新增一种全局属性的格式 data-*，用于自定义数据属性</p><ul><li><p>data设置的属性可以在JavaScript的DOM操作中通过dataset轻松获取到</p></li><li><p>通常用于HTML和JavaScript数据之间的传递；</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div <span class="keyword">class</span>=<span class="string">&quot;box&quot;</span> data-name=<span class="string">&quot;dww&quot;</span> data-age=<span class="string">&quot;18&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">const</span> boxEl = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;.box&quot;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="variable language_">console</span>.<span class="title function_">log</span>(boxEl.<span class="property">dataset</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>在小程序中, 就是通过data-来传递数据的, 所以该全局属性必须要掌握</p><h3 id="3-white-space-x2F-text-overflow"><a href="#3-white-space-x2F-text-overflow" class="headerlink" title="3.white-space&#x2F;text-overflow"></a>3.white-space&#x2F;text-overflow</h3><p>white-space用于设置空白处理和换行规则</p><ul><li>normal：合并所有连续的空白，允许单词超屏时自动换行</li><li>nowrap：合并所有连续的空白，不允许单词超屏时自动换行</li><li>pre：阻止合并所有连续的空白，不允许单词超屏时自动换行</li><li>pre-wrap：阻止合并所有连续的空白，允许单词超屏时自动换行</li><li>pre-line：合并所有连续的空白（但保留换行），允许单词超屏时自动换行</li></ul><p>text-overflow</p><p>text-overflow通常用来设置文字溢出时的行为</p><ul><li><p>clip：溢出的内容直接裁剪掉（字符可能会显示不完整）</p></li><li><p>ellipsis：溢出那行的结尾处用省略号表示</p></li></ul><p>text-overflow生效的前提是overflow不为visible </p><p>常见的是将white-space、text-overflow、overflow一起使用：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">overflow</span>: hidden;</span><br><span class="line">white-<span class="attr">space</span>: nowrap;</span><br><span class="line">text-<span class="attr">overflow</span>: ellipsis;</span><br></pre></td></tr></table></figure><h3 id="4-CSS常见的函数扩展"><a href="#4-CSS常见的函数扩展" class="headerlink" title="4.CSS常见的函数扩展"></a>4.CSS常见的函数扩展</h3><p>在前面我们有使用过很多个CSS函数</p><ul><li><p>比如rgb&#x2F;rgba&#x2F;translate&#x2F;rotate&#x2F;scale等</p></li><li><p>CSS函数通常可以帮助我们更加灵活的来编写样式的值</p></li></ul><p>下面再学习几个好用的CSS函数</p><ul><li><p>var: 使用CSS定义的变量</p></li><li><p>calc: 计算CSS值，通常用于计算元素的大小或位置</p></li><li><p>blur: 毛玻璃（高斯模糊）效果</p></li><li><p>gradient：颜色渐变函数</p></li></ul><h4 id="1、var"><a href="#1、var" class="headerlink" title="1、var()"></a>1、var()</h4><p>CSS中可以自定义属性</p><ul><li><p>属性名需要以两个减号（–）开始</p></li><li><p>属性值则可以是任何有效的CSS值</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">:root &#123;</span><br><span class="line">  <span class="comment">/* 定义了一个变量 */</span></span><br><span class="line">  <span class="comment">/* 只有后代元素可以使用 */</span></span><br><span class="line">  --main-<span class="attr">color</span>: #f3c221;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以通过var函数来使用</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">.<span class="property">box</span> &#123;</span><br><span class="line">  <span class="attr">color</span>: <span class="title function_">var</span>(--main-color);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>规则集定义的选择器, 是自定义属性的可见作用域(只在选择器内部有效) </p><ul><li>所以推荐将自定义属性定义在html中，也可以使用 :root 选择器</li></ul><h4 id="2、calc"><a href="#2、calc" class="headerlink" title="2、calc()"></a>2、calc()</h4><p>calc() 函数允许在声明 CSS 属性值时执行一些计算</p><p>计算支持加减乘除的运算</p><ul><li>加和减运算符的两边必须要有空白字符</li></ul><p>通常用来设置一些元素的尺寸或者位置</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">.<span class="property">item1</span> &#123;</span><br><span class="line">    <span class="comment">/* width的百分比相当于包含块 */</span></span><br><span class="line">    <span class="attr">width</span>: <span class="title function_">calc</span>(<span class="number">100</span>% - 100px);</span><br><span class="line">    background-<span class="attr">color</span>: #f00;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、blur"><a href="#3、blur" class="headerlink" title="3、blur()"></a>3、blur()</h4><p>blur() 函数将高斯模糊应用于输出图片或者元素</p><p>blur(radius)</p><p>radius, 模糊的半径, 用于定义高斯函数的偏差值, 偏差值越大, 图片越模糊</p><p>通常会和两个属性一起使用：</p><p>filter: 将模糊或颜色偏移等图形效果应用于元素</p><p>backdrop-filter: 为元素后面的区域添加模糊或者其他效果</p><h4 id="4、gradient"><a href="#4、gradient" class="headerlink" title="4、gradient()"></a>4、gradient()</h4><p>是一种<code>&lt;image&gt;</code>CSS数据类型的子类型，用于表现两种或多种颜色的过渡转变</p><ul><li><p>CSS的<code>&lt;image&gt;</code>数据类型描述的是2D图形</p></li><li><p>比如 background-image、list-style-image、border-image、content 等</p></li><li><p>常见的方式是通过url来引入一个图片资源</p></li><li><p>它也可以通过 CSS 的 gradient() 函数来设置颜色的渐变</p></li></ul><p>常见的函数实现有下面几种：</p><ul><li><p>linear-gradient()：创建一个表示两种或多种颜色线性渐变的图片</p></li><li><p>radial-gradient()：创建了一个图像，该图像是由从原点发出的两种或者多种颜色之间的逐步过渡组成</p></li><li><p>repeating-linear-gradient()：创建一个由重复线性渐变组成的<code>&lt;image&gt;</code></p></li><li><p>repeating-radial-gradient()：创建一个重复的原点触发渐变组成的<code>&lt;image&gt;</code></p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">background-<span class="attr">image</span>: linear-<span class="title function_">gradient</span>( 90deg, red, blue 40px, orange <span class="number">60</span>%, purple <span class="number">100</span>%);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">background-<span class="attr">image</span>: radial-<span class="title function_">gradient</span>(at <span class="number">0</span> <span class="number">50</span>%, red,blue);</span><br></pre></td></tr></table></figure><h3 id="5-浏览器前缀"><a href="#5-浏览器前缀" class="headerlink" title="5.浏览器前缀"></a>5.浏览器前缀</h3><p>有时候可能会看到有些CSS属性名前面带有：-o-、-xv-、-ms-、mso-、-moz-、-webkit-</p><p>官方文档专业术语叫做：vendor-specific extensions（供应商特定扩展）</p><p>为什么需要浏览器前缀了？</p><p>CSS属性刚开始并没有成为标准，浏览器为了防止后续会修改名字给新的属性添加了浏览器前缀</p><p>上述前缀叫做浏览器私有前缀，只有对应的浏览器才能解析使用</p><ul><li>-o-、-xv-：Opera等</li><li>-ms-、mso-：IE等</li><li>-moz-：Firefox等</li><li>-webkit-：Safari、Chrome等</li></ul><p>注意：不需要手动添加，后面学习了模块化打包工具会自动添加浏览器前缀</p><h3 id="6-深入理解BFC"><a href="#6-深入理解BFC" class="headerlink" title="6.深入理解BFC"></a>6.深入理解BFC</h3><h4 id="1、FC的概念"><a href="#1、FC的概念" class="headerlink" title="1、FC的概念"></a>1、FC的概念</h4><p>FC的全称是Formatting Context，元素在标准流里面都是属于一个FC的</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230327151516721.png" alt="image-20230327151516721"></p><p>块级元素的布局属于Block Formatting Context（BFC）</p><p>也就是block level box都是在BFC中布局的</p><ul><li><p>行内级元素的布局属于Inline Formatting Context（IFC） </p></li><li><p>而inline level box都是在IFC中布局的</p></li></ul><h4 id="2、BFC的创建"><a href="#2、BFC的创建" class="headerlink" title="2、BFC的创建"></a>2、BFC的创建</h4><p>MDN上有整理出在哪些具体的情况下会创建BFC：</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230327151542003.png" alt="image-20230327151542003"></p><ul><li><p>根元素（<code>&lt;html&gt;</code>）</p></li><li><p>浮动元素（元素的 float 不是 none）</p></li><li><p>绝对定位元素（元素的 position 为 absolute 或 fixed）</p></li><li><p>行内块元素（元素的 display 为 inline-block）</p></li></ul><ul><li><p>表格单元格（元素的 display 为 table-cell，HTML表格单元格默认为该值），表格标题（元素的 display 为 table-caption，HTML表格标题默认为该值）</p></li><li><p>匿名表格单元格元素（元素的 display 为 table、table-row、 table-row-group、table-header-group、table-footer-group（分别是HTML table、 row、tbody、thead、tfoot 的默认属性）或 inline-table）</p></li><li><p>overflow 计算值(Computed)不为 visible 的块元素</p></li><li><p>弹性元素（display 为 flex 或 inline-flex 元素的直接子元素）</p></li><li><p>网格元素（display 为 grid 或 inline-grid 元素的直接子元素）</p></li><li><p>display 值为 flow-root 的元素</p></li></ul><h4 id="3、BFC的作用"><a href="#3、BFC的作用" class="headerlink" title="3、BFC的作用"></a>3、BFC的作用</h4><p>作用：</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230327151603473.png" alt="image-20230327151603473"></p><p>其作用简单概况如下：</p><ul><li><p>在BFC中，box会在垂直方向上一个挨着一个的排布</p></li><li><p>垂直方向的间距由margin属性决定</p></li><li><p>在同一个BFC中，相邻两个box之间的margin会折叠（collapse）</p></li><li><p>在BFC中，每个元素的左边缘是紧挨着包含块的左边缘的</p></li></ul><p>那么这个东西有什么用呢？</p><ul><li><p>解决margin的折叠问题</p></li><li><p>解决浮动高度塌陷问题</p></li></ul><h5 id="1-解决margin折叠"><a href="#1-解决margin折叠" class="headerlink" title="1.解决margin折叠"></a>1.解决margin折叠</h5><p>在同一个BFC中，相邻两个box之间的margin会折叠（collapse）</p><p>官方文档明确的有说</p><p>The vertical distance between two sibling boxes is determined by the ‘margin’ properties. Vertical margins  between adjacent block-level boxes in a block formatting context collapse.</p><p>那么如果我们让两个box是不同的BFC呢？那么就可以解决折叠问题</p><h5 id="2-解决高度塌陷"><a href="#2-解决高度塌陷" class="headerlink" title="2.解决高度塌陷"></a>2.解决高度塌陷</h5><p>网上有很多说法，BFC可以解决浮动高度塌陷，可以实现清除浮动的效果</p><p>但是从来没有给出过BFC可以解决高度塌陷的原理或者权威的文档说明</p><p>他们也压根没有办法解释，为什么可以解决浮动高度的塌陷问题，但是不能解决绝对定位元素的高度塌陷问题呢？</p><p>事实上，BFC解决高度塌陷需要满足两个条件：</p><ul><li><p>浮动元素的父元素触发BFC，形成独立的块级格式化上下文（Block Formatting Context）</p></li><li><p>浮动元素的父元素的高度是auto的</p></li></ul><p>BFC的高度是auto的情况下，是如下方法计算高度的</p><ul><li><p>1.如果只有inline-level，是行高的顶部和底部的距离</p></li><li><p>2.如果有block-level，是由最底层的块上边缘和最底层 块盒子的下边缘之间的距离</p></li><li><p>3.如果有绝对定位元素，将被忽略</p></li><li><p>4.如果有浮动元素，那么会增加高度以包括这些浮动元素的下边缘</p></li></ul><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230327141545017.png" alt="image-20230327141545017"></p><h3 id="7、媒体查询"><a href="#7、媒体查询" class="headerlink" title="7、媒体查询"></a>7、媒体查询</h3><p>媒体查询是一种提供给开发者针对不同设备需求进行定制化开发的一个接口</p><p>你可以根据设备的类型（比如屏幕设备、打印机设备）或者特定的特性（比如屏幕的宽度）来修改你的页面</p><p>媒体查询的使用方式主要有三种：</p><p>方式一：通过@media和@import使用不同的CSS规则（常用）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式1</span></span><br><span class="line">@<span class="keyword">import</span> <span class="title function_">url</span>(./css/body_bgc.<span class="property">css</span>) (max-<span class="attr">width</span>: 800px);</span><br><span class="line"><span class="comment">// 方式2</span></span><br><span class="line">@media (max-<span class="attr">width</span>: 800px) &#123;</span><br><span class="line">    body &#123;</span><br><span class="line">        background-<span class="attr">color</span>: #0f0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方式二：使用media属性为<code>&lt;style&gt;</code>、<code>&lt;link&gt;</code>、<code>&lt;source</code>和其他HTML元素指定的媒体类型</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方式3</span></span><br><span class="line">&lt;link rel=<span class="string">&quot;stylesheet&quot;</span> media=<span class="string">&quot;(max-width: 800px)&quot;</span> href=<span class="string">&quot;./css/body_bgc.css&quot;</span>&gt;</span><br></pre></td></tr></table></figure><p>方式三：使用Window.matchMedia() 和MediaQueryList.addListener() 方法来测试和监控媒体状态</p><h4 id="1-媒体类型"><a href="#1-媒体类型" class="headerlink" title="1.媒体类型"></a>1.媒体类型</h4><p>在使用媒体查询时，你必须指定要使用的媒体类型</p><ul><li>媒体类型是可选的，并且会（隐式地）应用 all 类型</li></ul><p>常见的媒体类型值如下：</p><ul><li>all：适用于所有设备</li></ul><ul><li><p>print：适用于在打印预览模式下在屏幕上查看的分页材料和文档</p></li><li><p>screen（掌握）：主要用于屏幕</p></li><li><p>speech：主要用于语音合成器</p></li></ul><p>被废弃的媒体类型：</p><ul><li><p>CSS2.1 和 Media Queries 3 定义了一些额外的媒体类型(tty, tv, projection, handheld, braille, embossed, 以及 aural)</p></li><li><p>但是他们在Media Queries 4 中已经被废弃，并且不应该被使用</p></li><li><p>aural类型被替换为具有相似效果的speech</p></li></ul><h4 id="2-媒体特性"><a href="#2-媒体特性" class="headerlink" title="2.媒体特性"></a>2.媒体特性</h4><p>媒体特性（Media features）描述了 浏览器、输出设备，或是预览环境的具体特征</p><ul><li><p>通常会将媒体特性描述为一个表达式</p></li><li><p>每条媒体特性表达式都必须用括号括起来</p></li></ul><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230327144350254.png" alt="image-20230327144350254"></p><h4 id="3-逻辑操作符"><a href="#3-逻辑操作符" class="headerlink" title="3.逻辑操作符"></a>3.逻辑操作符</h4><p>媒体查询的表达式最终会获得一个Boolean值，也就是真（true）或者假（false）</p><p>如果结果为真（true），那么就会生效</p><p>如果结果为假（false），那么就不会生效</p><p>如果有多个条件，我们可以通过逻辑操作符联合复杂的媒体查询： </p><ul><li>and：and 操作符用于将多个媒体查询规则组合成单条媒体查询</li><li>not：not运算符用于否定媒体查询，如果不满足这个条件则返回true，否则返回false</li><li>only：only运算符仅在整个查询匹配时才用于应用样式</li><li>, (逗号)：逗号用于将多个媒体查询合并为一个规则</li></ul><p>常见的移动端设备：</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230327152232222.png" alt="image-20230327152232222"></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">@media (min-<span class="attr">width</span>: 320px) and (max-<span class="attr">width</span>:375px) &#123;</span><br><span class="line">    .<span class="property">box</span> &#123; font-<span class="attr">size</span>: 15px; &#125;</span><br><span class="line">&#125;</span><br><span class="line">@media (min-<span class="attr">width</span>: 375px) and (max-<span class="attr">width</span>:414px) &#123;</span><br><span class="line">    .<span class="property">box</span> &#123; font-<span class="attr">size</span>: 18px; &#125;</span><br><span class="line">&#125;</span><br><span class="line">@media (min-<span class="attr">width</span>: 414px) and (max-<span class="attr">width</span>:480px) &#123;</span><br><span class="line">    .<span class="property">box</span> &#123; font-<span class="attr">size</span>: 21px; &#125;</span><br><span class="line">&#125;</span><br><span class="line">@media (min-<span class="attr">width</span>: 480px) &#123;</span><br><span class="line">    .<span class="property">box</span> &#123; font-<span class="attr">size</span>: 24px; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="15-额外知识补充二"><a href="#15-额外知识补充二" class="headerlink" title="15.额外知识补充二"></a>15.额外知识补充二</h2><h3 id="1、CSS中的单位"><a href="#1、CSS中的单位" class="headerlink" title="1、CSS中的单位"></a>1、CSS中的单位</h3><p>px是一个长度（length）单位，事实上CSS中还有非常多的长度单位</p><p>整体可以分成两类：</p><ul><li><p>绝对长度单位（Absolute length units）</p></li><li><p>相对长度单位（Relative length units）</p></li></ul><h4 id="1-绝对单位"><a href="#1-绝对单位" class="headerlink" title="1.绝对单位"></a>1.绝对单位</h4><p>它们与其他任何东西都没有关系，通常被认为总是相同的大小</p><p>这些值中的大多数在用于打印时比用于屏幕输出时更有用，例如，我们通常不会在屏幕上使用cm</p><p>唯一一个经常使用的值，就是px(像素)</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230327154240579.png" alt="image-20230327154240579"></p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230327154805615.png" alt="image-20230327154805615"></p><h4 id="2-相对单位"><a href="#2-相对单位" class="headerlink" title="2.相对单位"></a>2.相对单位</h4><p>相对长度单位相对于其他一些东西</p><p>比如父元素的字体大小，或者视图端口的大小</p><p>使用相对单位的好处是经过一些仔细的规划，可以使文本或其他元素的大小与页面上的其他内容相对应</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230327154928680.png" alt="image-20230327154928680"></p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230327154942985.png" alt="image-20230327154942985"></p><h3 id="2、深入理解pixel、DPR、PPI"><a href="#2、深入理解pixel、DPR、PPI" class="headerlink" title="2、深入理解pixel、DPR、PPI"></a>2、深入理解pixel、DPR、PPI</h3><h4 id="1-pixel"><a href="#1-pixel" class="headerlink" title="1.pixel"></a>1.pixel</h4><p>前面我们已经一直在使用px单位了，px是pixel单词的缩写，翻译为像素</p><p>像素是影响显示的基本单位。（比如屏幕上看到的画面、一幅图片）</p><p>pix是英语单词picture的常用简写，加上英语单词“元素”element，就得到pixel</p><p>“像素”表示“画像元素”之意，有时亦被称为pel（picture element）</p><p>像素的分类</p><p>但是这个100个pixel到底是多少呢？</p><ul><li><p>我们确实可以在屏幕上看到一个大小，但是这个大小代表的真实含义是什么呢？</p></li><li><p>我们经常说一个电脑的分辨率、手机的分辨率，这个CSS当中的像素又是什么关系呢？</p></li></ul><p>这里我们要深入到不同的像素概念中，来理解CSS中的pixel到底代表什么含义</p><p>像素单位常见的有三种像素名称：</p><ul><li><p>设备像素（也称之为物理像素）</p></li><li><p>设备独立像素（也称之为逻辑像素）</p></li></ul><ul><li>CSS像素</li></ul><p>设备像素，也叫物理像素</p><ul><li><p>设备像素指的是显示器上的真实像素，每个像素的大小是屏幕固有的属性，屏幕出厂以后就不会改变了</p></li><li><p>我们在购买显示器或者手机的时候，提到的设备分辨率就是设备像素的大小</p></li><li><p>比如iPhone X的分辨率 1125x2436，指的就是设备像素</p></li></ul><p>设备独立像素，也叫逻辑像素</p><ul><li>如果面向开发者我们使用设备像素显示一个100px的宽度，那么在不同屏幕上显示效果会是不同的</li></ul><ul><li><p>开发者针对不同的屏幕很难进行较好的适配，编写程序必须了解用户的分辨率来进行开发</p></li><li><p>所以在设备像素之上，操作系统为开发者进行抽象，提供了逻辑像素的概念</p></li><li><p>比如你购买了一台显示器，在操作系统上是以1920x1080设置的显示分辨率，那么无论你购买的是2k、4k的显示器，对于开发者来说，都是 1920x1080的大小</p></li></ul><p>CSS像素</p><ul><li><p>CSS中我们经常使用的单位也是pixel，它在默认情况下等同于设备独立像素（也就是逻辑像素）</p></li><li><p>毕竟逻辑像素才是面向我们开发者的</p></li></ul><p>我们可以通过JavaScript中的 screen.width 和 screen.height 获取到电脑的逻辑分辨率</p><h4 id="2-DPR、PPI"><a href="#2-DPR、PPI" class="headerlink" title="2.DPR、PPI"></a>2.DPR、PPI</h4><p>DPR：device pixel ratio</p><p>2010年，iPhone4问世，不仅仅带来了移动互联网，还带来了Retina屏幕</p><p>Retina屏幕翻译为视网膜显示屏，可以为用户带来更好的显示</p><p>在Retina屏幕中，一个逻辑像素在长度上对应两个物理像素，这个比例称之为设备像素比（device pixel ratio）</p><p>我们可以通过window.devicePixelRatio获取到当前屏幕上的DPR值</p><p>PPI（了解）：每英寸像素（英语：Pixels Per Inch，缩写：PPI）</p><p>通常用来表示一个打印图像或者显示器上像素的密度</p><p>前面我们提过1英寸&#x3D;2.54厘米（大概为96px&#x2F;逻辑像素），在工业领域被广泛应用</p><h3 id="3、预处理器"><a href="#3、预处理器" class="headerlink" title="3、预处理器"></a>3、预处理器</h3><h4 id="1-css编写的痛点"><a href="#1-css编写的痛点" class="headerlink" title="1.css编写的痛点"></a>1.css编写的痛点</h4><p>CSS作为一种样式语言, 本身用来给HTML元素添加样式是没有问题的</p><p>但是目前前端项目已经越来越复杂，不再是简简单单的几行CSS就可以搞定的，我们需要几千行甚至上万行的CSS来完成页面的美化工作</p><p>随着代码量的增加, 必然会造成很多的编写不便：</p><ul><li><p>比如大量的重复代码, 虽然可以用类来勉强管理和抽取, 但是使用起来依然不方便</p></li><li><p>比如无法定义变量（当然目前已经支持）, 如果一个值被修改, 那么需要修改大量代码, 可维护性很差(比如主题颜色)</p></li><li><p>比如没有专门的作用域和嵌套, 需要定义大量的id&#x2F;class来保证选择器的准确性, 避免样式混淆</p></li></ul><p>所以有一种对CSS称呼是 “面向命名编程”</p><p>社区为了解决CSS面临的大量问题, 出现了一系列的CSS预处理器(CSS_preprocessor)</p><ul><li>CSS 预处理器是一个能让你通过预处理器自己独有的语法来生成CSS的程序</li><li>市面上有很多CSS预处理器可供选择，且绝大多数CSS预处理器会增加一些原生CSS不具备的特性</li><li>代码最终会转化为CSS来运行, 因为对于浏览器来说只识别CSS</li></ul><h4 id="2-常见的三种预处理器"><a href="#2-常见的三种预处理器" class="headerlink" title="2.常见的三种预处理器"></a>2.常见的三种预处理器</h4><p>Sass&#x2F;Scss：</p><ul><li>2007年诞生，最早也是最成熟的CSS预处理器，拥有ruby社区的支持，是属于Haml（一种模板系统）的一部分</li><li>目前受LESS影响，已经进化到了全面兼容CSS的SCSS</li></ul><p>Less：</p><ul><li>2009年出现，受SASS的影响较大，但又使用CSS的语法，让大部分开发者更容易上手</li><li>比起SASS来，可编程功能不够，不过优点是使用方式简单、便捷，兼容CSS，并且已经足够使用</li><li>另外反过来也影响了SASS演变到了SCSS的时代</li><li>著名的Twitter Bootstrap就是采用LESS做底层语言的，也包括 React 的 UI 框架 AntDesign</li></ul><p>Stylus：</p><ul><li>2010年产生，来自Node.js社区，主要用来给Node项目进行CSS预处理支持</li><li>语法偏向于Python, 使用率相对于Sass&#x2F;Less少很多</li></ul><h4 id="3-less"><a href="#3-less" class="headerlink" title="3.less"></a>3.less</h4><p>It’s CSS, with just a little more</p><p>Less （Leaner Style Sheets 的缩写） 是一门CSS 扩展语言, 并且兼容CSS</p><ul><li><p>Less增加了很多相比于CSS更好用的特性</p></li><li><p>比如定义变量、混入、嵌套、计算等等</p></li><li><p>Less最终需要被编译成CSS运行于浏览器中（包括部署到服务器中）</p></li></ul><h5 id="1-less-代码的编译"><a href="#1-less-代码的编译" class="headerlink" title="1.less 代码的编译"></a>1.less 代码的编译</h5><p>方式一：下载Node环境，通过npm包管理下载less工具，使用less工具对代码进行编译</p><p>方法二：通过VSCode插件（easy less）来编译成CSS或者在线编译：<a href="https://lesscss.org/less-preview/">https://lesscss.org/less-preview/</a></p><p>方式三：引入CDN的less编译代码，对less进行实时的处理</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;link rel=<span class="string">&quot;stylesheet/less&quot;</span> href=<span class="string">&quot;./less/01-less的基本使用.less&quot;</span>&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/less@4&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>方式四：将less编译的js代码下载到本地，执行js代码对less进行编译</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;link rel=<span class="string">&quot;stylesheet/less&quot;</span> href=<span class="string">&quot;./less/01-less的基本使用.less&quot;</span>&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./js/lessc.js&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h5 id="2-less语法"><a href="#2-less语法" class="headerlink" title="2.less语法"></a>2.less语法</h5><p><strong>Less语法一：兼容</strong></p><p>Less是兼容CSS的</p><ul><li>所以我们可以在Less文件中编写所有的CSS代码</li></ul><ul><li>只是将css的扩展名改成了.less结尾而已</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 兼容 css 代码</span></span><br><span class="line">.<span class="property">box</span> &#123;</span><br><span class="line">   <span class="attr">width</span>: 100px;</span><br><span class="line">   <span class="attr">height</span>: 100px;</span><br><span class="line">   background-<span class="attr">color</span>: orange;</span><br><span class="line">   font-<span class="attr">size</span>: 20px;</span><br><span class="line">   <span class="attr">color</span>: white;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>less语法二：变量</strong></p><p>在一个大型的网页项目中，我们CSS使用到的某几种属性值往往是特定的</p><ul><li>比如我们使用到的主题颜色值，那么每次编写类似于#f3c258格式的语法</li><li>一方面是记忆不太方便，需要重新编写或者拷贝样式</li><li>另一方面如果有一天主题颜色改变，我们需要修改大量的代码</li><li>所以，我们可以将常见的颜色或者字体等定义为变量来使用</li></ul><p>在Less中使用如下的格式来定义变量：</p><p>@变量名: 变量值;</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义变量</span></span><br><span class="line">@<span class="attr">mainColor</span>: #0f0;</span><br><span class="line">@<span class="attr">mainFontSize</span>: 15px;</span><br><span class="line">@<span class="attr">smallFontSize</span>: 12px;</span><br><span class="line">@<span class="attr">bigFontSize</span>: 20px;</span><br><span class="line"></span><br><span class="line">.<span class="property">box</span> .<span class="property">pel</span> &#123;</span><br><span class="line">  background-<span class="attr">color</span>: @mainColor;</span><br><span class="line">  font-<span class="attr">size</span>: @smallFontSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>less语法三：嵌套</strong></p><p>在之前的项目中，当我们需要找到一个内层的元素时，往往需要嵌套很多层的选择器</p><p>Less提供了选择器的嵌套</p><p>特殊符号：&amp; 表示当前选择器的父级</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 选择器的嵌套</span></span><br><span class="line">.<span class="property">box</span> &#123;</span><br><span class="line">  .<span class="property">pel</span> &#123;</span><br><span class="line">    <span class="attr">color</span>: @mainColor;</span><br><span class="line">    font-<span class="attr">size</span>: @mainFontSize;</span><br><span class="line">  &#125;</span><br><span class="line">  h1 &#123;</span><br><span class="line">    .<span class="property">keyword</span> &#123;</span><br><span class="line">      <span class="attr">color</span>: @mainColor;</span><br><span class="line">      font-<span class="attr">size</span>: @bigFontSize;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  p &#123;</span><br><span class="line">    a.<span class="property">link</span> &#123;</span><br><span class="line">      <span class="attr">color</span>: @mainColor;</span><br><span class="line">      font-<span class="attr">size</span>: @smallFontSize;</span><br><span class="line">        </span><br><span class="line">      &amp;:hover &#123;</span><br><span class="line">        <span class="attr">color</span>: blue;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>less语法四：运算</strong></p><p>在Less中，算术运算符 +、-、 * 、&#x2F; 可以对任何数字、颜色或变量进行运算</p><ul><li>算术运算符在加、减或比较之前会进行单位换算，计算的结果以最左侧操作数的单位类型为准</li></ul><ul><li>如果单位换算无效或失去意义，则忽略单位</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">.<span class="property">box</span> &#123;</span><br><span class="line">  font-<span class="attr">size</span>: 20px;</span><br><span class="line">  <span class="attr">width</span>: <span class="number">10</span>% + 50px;  <span class="comment">// 60%</span></span><br><span class="line">  <span class="attr">height</span>: 100px;</span><br><span class="line">  background-<span class="attr">color</span>: #ff0000 + #00ff00;  <span class="comment">//#ffff00</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>less语法五：混入（Mixins）</strong></p><p>在原来的CSS编写过程中，多个选择器中可能会有大量相同的代码</p><ul><li><p>我们希望可以将这些代码进行抽取到一个独立的地方，任何选择器都可以进行复用</p></li><li><p>在less中提供了混入（Mixins）来帮助我们完成这样的操作</p></li></ul><p>混合（Mixin）是一种将一组属性从一个规则集（或混入）到另一个规则集的方法</p><p>注意：混入在没有参数的情况下，小括号可以省略，但是不建议这样使用</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2.1 混入的基本使用</span></span><br><span class="line">.<span class="property">nowrap_ellipsis</span> &#123;</span><br><span class="line">  white-<span class="attr">space</span>: nowrap;</span><br><span class="line">  text-<span class="attr">overflow</span>: ellipsis;</span><br><span class="line">  <span class="attr">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.<span class="property">box1</span> &#123;</span><br><span class="line">  <span class="attr">width</span>: 200px;</span><br><span class="line">  background-<span class="attr">color</span>: orange;</span><br><span class="line"></span><br><span class="line">  .<span class="title function_">nowrap_ellipsis</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>混入也可以传入变量</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2.2混入是可以传递参数（定义变量）的</span></span><br><span class="line">.<span class="title function_">box_border</span>(<span class="params">@borderWidth: 5px, @borderColor: green</span>) &#123;</span><br><span class="line">  <span class="attr">border</span>: @borderWidth solid @borderColor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.<span class="property">box2</span> &#123;</span><br><span class="line">  <span class="attr">width</span>: 150px;</span><br><span class="line">  background-<span class="attr">color</span>: #f00;</span><br><span class="line"></span><br><span class="line">  .<span class="title function_">nowrap_ellipsis</span>();</span><br><span class="line">  .<span class="title function_">box_border</span>(10px, yellow);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>less语法六：映射</strong></p><p>混入和映射结合：混入也可以当做一个自定义函数来使用</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2.3 混入和映射（Map）结合使用</span></span><br><span class="line"><span class="comment">// 作用：弥补less中不能自定义函数的缺陷</span></span><br><span class="line">.<span class="property">box_size</span> &#123;</span><br><span class="line">  <span class="attr">width</span>: 200px;</span><br><span class="line">  <span class="attr">height</span>: 150px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.<span class="property">box1</span> &#123;</span><br><span class="line">  <span class="attr">width</span>: .<span class="title function_">box_size</span>()[width];</span><br><span class="line">  background-<span class="attr">color</span>: orange;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单位转换：</p><p><img src="C:\Users\王邦辉\AppData\Roaming\Typora\typora-user-images\image-20230327211450716.png" alt="image-20230327211450716"></p><p><strong>less语法七：extend继承</strong></p><p>和mixins作用类似，用于复用代码</p><p>和mixins相比，继承代码最终会转化成并集选择器</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.box_border &#123;</span><br><span class="line">  border: 5px solid red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.box &#123;</span><br><span class="line">  width: 100px;</span><br><span class="line">  background-color: orange;</span><br><span class="line"></span><br><span class="line">  // .box_border();</span><br><span class="line">  &amp;:extend(.box_border);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Less语法八：Less内置函数</strong></p><p>Less 内置了多种函数用于转换颜色、处理字符串、算术运算等</p><p>内置函数手册：<a href="https://less.bootcss.com/functions/">https://less.bootcss.com/functions/</a></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">.<span class="property">box</span> &#123;</span><br><span class="line">  <span class="attr">color</span>: <span class="title function_">color</span>(skyblue);  <span class="comment">// 转化为16进制编码</span></span><br><span class="line">  <span class="attr">width</span>: <span class="title function_">convert</span>(100px, <span class="string">&quot;in&quot;</span>);  <span class="comment">// px转化为in</span></span><br><span class="line">  font-<span class="attr">size</span>: <span class="title function_">ceil</span>(<span class="number">18.</span>5px);  <span class="comment">// 向上取整</span></span><br><span class="line">  background-<span class="attr">color</span>: orange;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Less语法九：作用域（Scope）</strong></p><p>在查找一个变量时，首先在本地查找变量和混合（mixins）</p><p>如果找不到，则从“父”级作用域继承</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">@<span class="attr">mainColor</span>:#f00;</span><br><span class="line"></span><br><span class="line">.<span class="property">box_mixin</span> &#123;</span><br><span class="line">  @<span class="attr">mainColor</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line">.<span class="property">box</span> &#123;</span><br><span class="line">  <span class="comment">// @mainColor:#0f0;</span></span><br><span class="line">  .<span class="property">item</span> &#123;</span><br><span class="line">    span &#123;</span><br><span class="line">      <span class="attr">color</span>: @mainColor;  <span class="comment">// yellow</span></span><br><span class="line">      .<span class="title function_">box_mixin</span>()</span><br><span class="line">      <span class="comment">// @mainColor:#00f;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Less语法十：注释（Comments）</strong></p><p>在Less中，块注释和行注释都可以使用</p><p><strong>Less语法十一：导入（Importing）</strong></p><ul><li><p>导入的方式和CSS的用法是一致的</p></li><li><p>导入一个 .less 文件，此文件中的所有变量就可以全部使用了</p></li><li><p>如果导入的文件是 .less 扩展名，则可以将扩展名省略掉</p></li></ul><h3 id="4、认识Sass和Scss"><a href="#4、认识Sass和Scss" class="headerlink" title="4、认识Sass和Scss"></a>4、认识Sass和Scss</h3><p>事实上，最初Sass 是Haml的一部分，Haml 是一种模板系统，由 Ruby 开发者设计和开发</p><p>所以，Sass的语法使用的是类似于Ruby的语法，没有花括号，没有分号，具有严格的缩进</p><p>它的语法和CSS区别很大，后来官方推出了全新的语法SCSS，意思是Sassy CSS，完全兼容CSS的</p><p>SCSS的语法也包括变量、嵌套、混入、函数、操作符、作用域等</p><p>通常也包括更为强大的控制语句、更灵活的函数、插值语法等</p><p><a href="https://sass-lang.com/guide">https://sass-lang.com/guide</a></p><h3 id="5、移动端适配"><a href="#5、移动端适配" class="headerlink" title="5、移动端适配"></a>5、移动端适配</h3><p>移动端开发目前主要包括三类：</p><ul><li><p>原生App开发（iOS、Android、RN、uniapp、Flutter等）</p></li><li><p>小程序开发（原生小程序、uniapp、Taro等）</p></li><li><p>Web页面（移动端的Web页面，可以使用浏览器或者webview浏览）</p></li></ul><p>因为目前移动端设备较多，所以我们需要对其进行一些适配</p><p>这里有两个概念：</p><ul><li><p>自适应：根据不同的设备屏幕大小来自动调整尺寸、大小</p></li><li><p>响应式：会随着屏幕的实时变动而自动调整，是一种自适应</p></li></ul><h4 id="1-视口"><a href="#1-视口" class="headerlink" title="1.视口"></a>1.视口</h4><p>在前面我们已经简单了解过视口的概念了：</p><ul><li><p>在一个浏览器中，我们可以看到的区域就是视口（viewport）</p></li><li><p>fixed就是相对于视口来进行定位的</p></li><li><p>在PC端的页面中，是不需要对视口进行区分，因为我们的布局视口和视觉视口是同一个</p></li></ul><p>但是在移动端不太一样，布局的视口和可见的视口是不太一样的</p><p>这是因为移动端的网页窗口往往比较小，我们可能会希望一个大的网页在移动端可以完整的显示，所以在默认情况下，移动端的布局视口是大于视觉视口的</p><p>在移动端，我们可以将视口划分为三种情况：</p><ul><li><p>布局视口（layout viewport）</p></li><li><p>视觉视口（visual layout）</p></li><li><p>理想视口（ideal layout）</p></li></ul><p>这些概念的区分，来自于ppk：<a href="https://www.quirksmode.org/mobile/viewports2.html">https://www.quirksmode.org/mobile/viewports2.html</a></p><p>布局视口</p><p>默认情况下，一个在PC端的网页在移动端的显示：</p><ul><li><p>第一，它会按照宽度为980px来布局一个页面的盒子和内容</p></li><li><p>第二，为了在移动端可以完整的显示页面，会对整个页面进行缩小</p></li></ul><p>我们相对于980px布局的这个视口，称之为布局视口（layout  viewport）</p><ul><li>布局视口的默认宽度是980px</li></ul><p>视觉视口</p><ul><li><p>如果默认情况下，我们按照980px显示内容，那么右侧有一部分区域就会无法显示，所以手机端浏览器会默认对页面进行缩放以显示到用户的可见区域中</p></li><li><p>那么显示在可见区域的这个视口，就是视觉视口（visual viewport）</p></li></ul><p>如果所有的网页都按照980px在移动端布局，那么最终页面都会被缩放显示</p><p>事实上这种方式是不利于我们进行移动的开发的，我们希望的是设置100px，那么显示的就是100px；</p><p>如何做到这一点呢？通过设置理想视口（ideal viewport）</p><p>理想视口</p><ul><li><p>默认情况下的layout viewport并不适合我们进行布局</p></li><li><p>我们可以对layout viewport进行宽度和缩放的设置，以满足正常在一个移动端窗口的布局</p></li><li><p>这个时候可以设置meta中的viewport</p></li></ul><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230328092425280.png" alt="image-20230328092425280"></p><h4 id="2-移动适配方案"><a href="#2-移动适配方案" class="headerlink" title="2.移动适配方案"></a>2.移动适配方案</h4><p>移动端的屏幕尺寸通常是非常繁多的，很多时候我们希望在不同的屏幕尺寸上显示不同的大小</p><p>比如我们设置一个100x100的盒子</p><ul><li><p>在375px的屏幕上显示是100x100</p></li><li><p>在320px的屏幕上显示是90x90</p></li><li><p>在414px的屏幕上显示是100x100</p></li></ul><p>其他尺寸也是类似，比如padding、margin、border、left，甚至是font-size等</p><p>这个时候，我们可能可以想到一些方案来处理尺寸：</p><ul><li><p>方案一：百分比设置</p><ul><li>因为不同属性的百分比值，相对的可能是不同参照物，所以百分比往往很难统一</li><li>所以百分比在移动端适配中使用是非常少的</li></ul></li><li><p>方案二：rem单位+动态html的font-size</p></li><li><p>方案三：vw单位</p></li><li><p>方案四：flex的弹性布局</p></li></ul><h5 id="方案二："><a href="#方案二：" class="headerlink" title="方案二："></a>方案二：</h5><p>rem单位是相对于html元素的font-size来设置的，那么如果我们需要在不同的屏幕下有不同的尺寸，可以动态的修改html的 font-size尺寸</p><p>比如如下案例：</p><ul><li><p>1.设置一个盒子的宽度是2rem</p></li><li><p>2.设置不同的屏幕上html的font-size不同</p></li></ul><p>这样在开发中，我们只需要考虑两个问题：</p><ul><li>问题一：针对不同的屏幕，设置html不同的font-size</li><li>问题二：将原来要设置的尺寸，转化成rem单位</li></ul><h6 id="动态改变font-size"><a href="#动态改变font-size" class="headerlink" title="动态改变font-size"></a>动态改变font-size</h6><p>方案一：媒体查询</p><ul><li>可以通过媒体查询来设置不同尺寸范围内的屏幕html的font-size尺寸</li><li>缺点：<ul><li>1.我们需要针对不同的屏幕编写大量的媒体查询</li><li>2.如果动态改变尺寸，不会实时的进行更新</li></ul></li></ul><p>方案二：编写js代码</p><ul><li><p>如果希望实时改变屏幕尺寸时，font-size也可以实时更改，可以通过js代码</p></li><li><p>方法：</p><ul><li>1.根据html的宽度计算出font-size的大小，并且设置到html上</li><li>2.监听页面的实时改变，并且重新设置font-size的大小到html上</li></ul></li></ul><p>方案三：lib-flexible库</p><ul><li>事实上，lib-flexible库做的事情是相同的，你也可以直接引入它</li></ul><h6 id="rem计算"><a href="#rem计算" class="headerlink" title="rem计算"></a>rem计算</h6><p>方案一：手动换算</p><p>比如有一个在375px屏幕上，100px宽度和高度的盒子</p><p>我们需要将100px转成对应的rem值</p><p>100&#x2F;37.5&#x3D;2.6667，其他也是相同的方法计算即可</p><p>方案二：less&#x2F;scss函数</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">.<span class="title function_">pxToRem</span>(<span class="params">@px</span>) &#123;</span><br><span class="line">  <span class="attr">result</span>: 1rem * (@px / <span class="number">37.5</span>);</span><br><span class="line">&#125;</span><br><span class="line">.<span class="property">box</span> &#123;</span><br><span class="line">  <span class="attr">width</span>: .<span class="title function_">pxToRem</span>(<span class="number">100</span>)[result];</span><br><span class="line">  <span class="attr">height</span>: .<span class="title function_">pxToRem</span>(<span class="number">100</span>)[result];</span><br><span class="line">  background-<span class="attr">color</span>: orange;</span><br><span class="line">&#125;</span><br><span class="line">p &#123;</span><br><span class="line">  font-<span class="attr">size</span>: .<span class="title function_">pxToRem</span>(<span class="number">14</span>)[result];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方案三：postcss-pxtorem（后续学习）</p><ul><li>目前在前端的工程化开发中，我们可以借助于webpack的工具来完成自动的转化</li></ul><p>方案四：VSCode插件</p><ul><li>px to rem 的插件，在编写时自动转化</li></ul><h5 id="方案三：vw适配"><a href="#方案三：vw适配" class="headerlink" title="方案三：vw适配"></a>方案三：vw适配</h5><p>rem事实上是作为一种过渡的方案，它利用的也是vw的思想</p><p>前面不管是我们自己编写的js，还是flexible的源码</p><p>都是将1rem等同于设计稿的1&#x2F;10，在利用1rem计算相对于整个屏幕的尺寸大小</p><p>1vw刚好等于屏幕的1&#x2F;100</p><p>vw相比于rem的优势：</p><ul><li><p>优势一：不需要去计算html的font-size大小，也不需要给html设置这样一个font-size</p></li><li><p>优势二：不会因为设置html的font-size大小，而必须给body再设置一个font-size，防止继承</p></li><li><p>优势三：因为不依赖font-size的尺寸，所以不用担心某些原因html的font-size尺寸被篡改，页面尺寸混乱</p></li><li><p>优势四：vw相比于rem更加语义化，1vw刚才是1&#x2F;100的viewport的大小</p></li><li><p>优势五：可以具备rem之前所有的优点</p></li></ul><p>vw我们只面临一个问题，将尺寸换算成vw的单位即可</p><p>所以，目前相比于rem，更加推荐使用vw</p><p>vw的单位转换</p><p>方案一：手动换算</p><ul><li><p>比如有一个在375px屏幕上，100px宽度和高度的盒子</p></li><li><p>我们需要将100px转成对应的vw值</p></li><li><p>100&#x2F;3.75&#x3D;26.667，其他也是相同的方法计算即可</p></li></ul><p>方案二：less&#x2F;scss函数</p><p>方案三：postcss-px-to-viewport-8-plugin（后续学习）</p><ul><li>和rem一样，在前端的工程化开发中，可以借助于webpack的工具来完成自动的转化</li></ul><p>方案四：VSCode插件</p><ul><li>px to vw 的插件，在编写时自动转化</li></ul><h3 id="6、认识grid布局"><a href="#6、认识grid布局" class="headerlink" title="6、认识grid布局"></a>6、认识grid布局</h3><p>CSS为了进一步增强自己的布局能力，提供了grid布局</p><ul><li><p>CSS Grid Layout (又名“Grid”或 “CSS Grid”)是一种基于二维的布局系统</p></li><li><p>它更加强大，同时也更加复杂; .</p></li></ul><p>目前公司生产环境的项目基本都是使用flex布局为主，因为它兼容性比flex布局差一 些</p><p>Grid Container</p><ul><li>元素设置display 为grid的盒子</li></ul><p>Grid Item，单元格称之为grid cell</p><ul><li>grid container 的直接子项</li></ul><p>Grid Line</p><ul><li>构成网格结构的分割线</li><li>它们可以是垂直的(“列网格线”)或水平的(”行网格线”)</li></ul><p>Grid Track</p><ul><li>两条相邻网格线之间的空间</li><li>可以看成是网格的行或者列</li></ul><p>Grid Area</p><ul><li>由四条网格线包围的总空间</li><li>一个网格区域可以由任意数量的网格单元组成</li></ul><p><a href="https://css-tricks.com/snippets/css/complete-guide-grid/">https://Css-tricks.com/snippets/css/complete-guide-grid/</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IT前端 </tag>
            
            <tag> HTML </tag>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>站点简介</title>
      <link href="/archives/a8213f80.html"/>
      <url>/archives/a8213f80.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>大家好，欢迎来到我的个人blog，在这里我将会分享一些自己的学习笔记，主要分为前端体系、计算机网络、网络规划与设计、相关工具等，也会分享一些个人好用的网站，白嫖攻略，科学魔法等；如有需要，也欢迎私信进行分享交流~</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>

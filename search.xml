<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>面试题</title>
      <link href="/archives/5205ee75.html"/>
      <url>/archives/5205ee75.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>求职：</p><ul><li>平台：智联、51、</li><li>简历：前端开发（wondercv）</li></ul><h1 id="前端面试题"><a href="#前端面试题" class="headerlink" title="前端面试题"></a>前端面试题</h1><h2 id="HTML-x2F-CSS"><a href="#HTML-x2F-CSS" class="headerlink" title="HTML&#x2F;CSS"></a>HTML&#x2F;CSS</h2><h4 id="1-什么是BFC-如何触发-有何特点-如何解决margin”塌陷”"><a href="#1-什么是BFC-如何触发-有何特点-如何解决margin”塌陷”" class="headerlink" title="1.什么是BFC ?如何触发?有何特点?如何解决margin”塌陷”?"></a>1.什么是BFC ?如何触发?有何特点?如何解决margin”塌陷”?</h4><p>BFC代表”块级格式化上下文”（Block Formatting Context），它是CSS布局的一种概念。BFC是一个独立的渲染区域，其中的元素按照一定规则进行布局和渲染。它的存在可以解决一些常见的布局问题。</p><p>触发BFC的条件：</p><ol><li>根元素（<code>&lt;html&gt;</code>）本身就是一个BFC。</li><li>浮动元素（<code>float</code>属性不为<code>none</code>）。</li><li>绝对定位元素（<code>position</code>属性为<code>absolute</code>或<code>fixed</code>）。</li><li><code>display</code>属性为<code>inline-block</code>、<code>table-cell</code>、<code>table-caption</code>、<code>flex</code>、<code>inline-flex</code>的元素。</li><li><code>overflow</code>属性的值不为<code>visible</code>的元素。</li></ol><p>BFC的特点：</p><ol><li>BFC中的元素在垂直方向上一个接一个地排列。</li><li>BFC中的元素与外部元素相互隔离，内部的浮动元素不会影响到外部元素的布局。</li><li>BFC在计算高度时，会考虑其内部元素的浮动元素，使得容器能够正确包裹内部的浮动内容。</li></ol><p>解决margin塌陷的方法： margin塌陷是指在垂直方向上，两个相邻的块级元素的上下外边距（margin）会合并（塌陷）成一个外边距的问题。这种现象常常发生在嵌套的块级元素之间。</p><p>要解决margin塌陷，可以通过创建一个新的BFC来避免外边距合并的问题。可以通过以下方法来触发新的BFC：</p><ol><li>使用浮动（<code>float: left</code>或<code>float: right</code>）：浮动元素会触发BFC，从而避免与其他块级元素的外边距合并。</li><li>使用绝对定位（<code>position: absolute</code>或<code>position: fixed</code>）：绝对定位元素也会触发BFC。</li><li>设置元素的<code>display</code>属性为<code>inline-block</code>或<code>inline-table</code>：这样元素也会成为一个新的BFC。</li><li>使用CSS3中的弹性盒子布局（<code>display: flex</code>或<code>display: inline-flex</code>）：弹性盒子也会触发BFC，从而避免外边距合并。</li><li>设置元素的<code>overflow</code>属性为一个非<code>visible</code>的值（例如<code>overflow: hidden</code>）：这也会触发BFC，防止外边距合并。</li></ol><p>通过触发BFC，我们可以有效地解决margin塌陷问题，确保元素在垂直方向上的外边距得到正确的渲染。</p><h4 id="2-CSS如何出来溢出-说一下overflow不同值的区别"><a href="#2-CSS如何出来溢出-说一下overflow不同值的区别" class="headerlink" title="2.CSS如何出来溢出?说一下overflow不同值的区别"></a>2.CSS如何出来溢出?说一下overflow不同值的区别</h4><p>在CSS中，通过<code>overflow</code>属性可以控制元素内容的溢出处理方式。<code>overflow</code>属性有以下几个可能的值，每个值都有不同的作用：</p><ol><li><code>overflow: visible</code>（默认值）：内容会溢出元素框，显示在元素外部，不进行裁剪。这意味着元素框不会限制内容的显示。</li><li><code>overflow: hidden</code>：内容会溢出元素框的部分会被隐藏，不显示在元素外部。被裁剪的内容对用户不可见，不占据页面空间。</li><li><code>overflow: scroll</code>：如果内容溢出元素框，则会显示滚动条，用户可以通过滚动条查看被裁剪的内容。</li><li><code>overflow: auto</code>：如果内容溢出元素框，则会自动显示滚动条。当内容不溢出时，不显示滚动条，不占据页面空间。如果内容没有溢出，与<code>visible</code>效果相同。</li><li><code>overflow: clip</code>：内容会溢出元素框，但溢出的内容会被裁剪，不显示在元素外部。与<code>hidden</code>效果相同，但不会创建滚动条。</li></ol><p><code>overflow</code>属性的应用通常在父元素的内容区域限制了子元素的尺寸时非常有用。例如，当一个固定大小的容器内包含了大量内容时，可以使用<code>overflow: scroll</code>或<code>overflow: auto</code>，以便用户可以滚动查看全部内容。</p><p>需要注意的是，<code>overflow</code>属性只对具有指定尺寸（如设置<code>height</code>、<code>width</code>）和<code>overflow: hidden</code>之外的值的块级元素和可替换元素有效。对于<code>inline</code>元素，<code>overflow</code>属性无效。</p><p>另外，<code>overflow</code>属性在处理<code>position: absolute</code>元素时也需要特别注意。绝对定位的元素会相对于其最近的具有<code>position</code>属性值不为<code>static</code>的祖先元素进行定位。因此，如果<code>overflow</code>属性的值为<code>hidden</code>或<code>auto</code>，并且该元素的内容溢出，则被裁剪的内容可能会影响绝对定位元素的显示。这种情况下，可以考虑给绝对定位元素的祖先元素设置<code>overflow: hidden</code>或<code>overflow: auto</code>，以避免溢出内容的影响。</p><h4 id="3-三栏布局有什么实现方式？"><a href="#3-三栏布局有什么实现方式？" class="headerlink" title="3.三栏布局有什么实现方式？"></a>3.三栏布局有什么实现方式？</h4><p>三栏布局是指将页面内容划分为左侧、中间和右侧三个区域，并且这三个区域可以具有不同的宽度。实现三栏布局有多种方式，下面列举了几种常见的方法：</p><ol><li>使用浮动（Float）：<ul><li>将左侧和右侧栏设置为固定宽度的块级元素，并分别使用<code>float: left;</code>和<code>float: right;</code>进行浮动。</li><li>将中间栏设置为<code>width: auto;</code>，并确保其在左侧和右侧栏的外部显示，可以使用<code>margin</code>负值或<code>overflow</code>属性来实现。</li><li>这种方法需要注意清除浮动，可以在父容器上使用<code>clearfix</code>技巧或者使用<code>overflow: hidden;</code>来清除浮动。</li></ul></li><li>使用Flexbox布局：<ul><li>将三栏布局的容器设置为<code>display: flex;</code>，默认情况下，子元素会水平排列。</li><li>设置左侧和右侧栏的宽度，可以使用<code>flex: 0 0 &lt;width&gt;;</code>来固定宽度。</li><li>中间栏会自动占据剩余的可用空间，可以设置<code>flex: 1;</code>或者<code>flex-grow: 1;</code>来实现。</li></ul></li><li>使用Grid布局：<ul><li>将三栏布局的容器设置为<code>display: grid;</code>，并指定网格列的大小。</li><li>使用<code>grid-template-columns</code>属性来设置左侧、中间和右侧栏的宽度，例如<code>grid-template-columns: 200px 1fr 200px;</code>。</li></ul></li><li>使用绝对定位：<ul><li>将三栏布局的容器设置为<code>position: relative;</code>，用于定位绝对定位的子元素。</li><li>分别使用<code>position: absolute;</code>将左侧和右侧栏固定在左右位置，设置相应的宽度。</li><li>中间栏可以设置<code>margin-left</code>和<code>margin-right</code>来留出左右栏的空间。</li></ul></li></ol><h4 id="4-css-calc属性作用是什么-主要用于解决什么问题"><a href="#4-css-calc属性作用是什么-主要用于解决什么问题" class="headerlink" title="4.css calc属性作用是什么?主要用于解决什么问题?"></a>4.css calc属性作用是什么?主要用于解决什么问题?</h4><p>CSS的<code>calc()</code>函数用于执行简单的数学运算，它可以在CSS样式中动态计算属性的值。主要用于解决以下问题：</p><ol><li>动态计算长度值：<code>calc()</code>函数允许在CSS样式中使用数学表达式来计算长度值。例如，可以使用<code>calc(100% - 20px)</code>来动态地将一个元素的宽度设置为父元素宽度减去20像素。</li><li>响应式布局：通过<code>calc()</code>函数，可以根据不同的屏幕尺寸或视口大小来调整元素的大小和位置。这样可以实现更灵活的响应式布局。</li><li>解决复杂布局问题：在某些布局情况下，需要根据多个因素来计算元素的尺寸或位置。<code>calc()</code>函数提供了一种简便的方式来处理这些复杂的计算。</li><li>避免CSS预处理器的使用：在CSS预处理器（如Sass或Less）中，也可以使用类似的数学表达式。但使用<code>calc()</code>函数，我们可以在纯CSS中进行类似的计算，无需依赖额外的工具或预处理器。</li></ol><p>总结来说，<code>calc()</code>函数在CSS样式中的使用可以让我们更方便地进行动态计算，解决复杂的布局问题，并实现更灵活的响应式设计，而无需依赖其他工具或预处理器。</p><h4 id="5-有一个固定长宽div-怎么实现在屏幕上垂直水平居中"><a href="#5-有一个固定长宽div-怎么实现在屏幕上垂直水平居中" class="headerlink" title="5.有一个固定长宽div,怎么实现在屏幕上垂直水平居中"></a>5.有一个固定长宽div,怎么实现在屏幕上垂直水平居中</h4><p>要实现一个固定长宽的<code>div</code>在屏幕上垂直水平居中，可以使用绝对定位和<code>transform</code>属性的组合</p><ol><li>设置<code>body</code>的样式，让它占满整个视口（viewport），这样居中的效果会相对于视口来进行计算。</li><li>使用<code>display: flex;</code>让<code>body</code>变为一个弹性容器，<code>justify-content: center;</code>和<code>align-items: center;</code>分别在水平和垂直方向上将内容居中。</li><li>对于<code>.centered-div</code>，设置固定的宽度和高度，然后使用绝对定位<code>position: absolute;</code>将它从正常文档流中脱离，并使用<code>top: 50%;</code>和<code>left: 50%;</code>将其顶部和左侧位置定位到屏幕的中间。</li><li>最后，通过使用<code>transform: translate(-50%, -50%);</code>，将元素的中心点重新定位回屏幕的中心，实现垂直和水平居中。</li></ol><p>这样，固定长宽的<code>div</code>就能在屏幕上垂直水平居中了。记得根据实际情况调整<code>.centered-div</code>的宽高和其他样式，使其适应你的需求。</p><h4 id="6-描述一下渐进增强-progressive-enhancement-和优雅降级-gracefuldegradation"><a href="#6-描述一下渐进增强-progressive-enhancement-和优雅降级-gracefuldegradation" class="headerlink" title="6.描述一下渐进增强(progressive enhancement)和优雅降级(gracefuldegradation)"></a>6.描述一下渐进增强(progressive enhancement)和优雅降级(gracefuldegradation)</h4><p>渐进增强（Progressive Enhancement）和优雅降级（Graceful Degradation）是两种不同的前端开发方法，都旨在在不同浏览器和设备上提供更好的用户体验。</p><ol><li>渐进增强（Progressive Enhancement）： 渐进增强是一种从基本功能开始，逐步增强网页或应用程序的功能和外观的方法。开发者首先关注的是核心功能，确保在所有现代浏览器和设备上都能正常运行。然后，通过使用新的技术、特性或样式，对支持更高级功能的浏览器进行改进。这样，无论用户使用什么设备或浏览器，他们都能访问基本功能，并获得额外的增强功能，提供更好的用户体验。</li></ol><p>渐进增强的优势在于，确保基本功能的普遍可用性，并逐步提供更好的体验。它强调可访问性和可用性，为所有用户提供核心功能，不依赖于特定的浏览器或设备。</p><ol><li>优雅降级（Graceful Degradation）： 优雅降级是一种从复杂功能开始，逐步向下兼容到较旧或不支持现代特性的浏览器的方法。开发者首先关注的是使用最新的技术和特性来实现复杂的功能，并确保在现代浏览器上运行良好。然后，对不支持这些特性的旧浏览器进行回退处理，以确保它们仍然能够使用基本功能。</li></ol><p>优雅降级的优势在于，它允许开发人员专注于最先进的功能和用户体验，而不需要担心不支持这些功能的浏览器。然后，通过为旧浏览器提供替代的功能或回退方案，确保所有用户都能够访问基本功能。</p><p>综合来说，渐进增强和优雅降级是两种不同的开发方法，但目标都是提供更好的用户体验，无论用户使用的是现代浏览器还是较旧的浏览器。渐进增强着重于从简单到复杂，优雅降级着重于从复杂到简单，但它们的本质都是关注所有用户，并确保他们能够访问核心功能。选择使用哪种方法取决于具体的项目需求和用户群体。</p><h4 id="7-iframe-有哪些优点-哪些缺点-胞来解决过什么问题"><a href="#7-iframe-有哪些优点-哪些缺点-胞来解决过什么问题" class="headerlink" title="7.iframe 有哪些优点?哪些缺点?胞来解决过什么问题?"></a>7.iframe 有哪些优点?哪些缺点?胞来解决过什么问题?</h4><p><code>iframe</code>（内联框架）是HTML中的一个元素，用于在网页中嵌入另一个独立的HTML文档。<code>iframe</code>具有一些优点和缺点，同时也被用来解决特定的问题。</p><p>优点：</p><ol><li>分隔内容：<code>iframe</code>可以将不同的网页内容隔离开来，使得嵌入的网页具有独立的上下文，不会受到外部网页的影响。这有助于避免潜在的样式或脚本冲突。</li><li>代码重用：使用<code>iframe</code>可以在多个页面中重用相同的内容，而无需在每个页面中重复代码。这样可以减少维护成本，提高代码的可复用性。</li><li>嵌入外部内容：<code>iframe</code>可以嵌入其他网站或第三方内容，如地图、视频、广告等。这样可以方便地将其他服务或内容集成到自己的网页中。</li><li>异步加载：<code>iframe</code>可以异步加载，不影响主页面的加载和渲染，从而提高页面的加载速度和性能。</li></ol><p>缺点：</p><ol><li>安全性问题：由于<code>iframe</code>可以加载外部网页，如果不受信任的网页被嵌入到自己的网页中，可能会导致跨站脚本攻击（XSS）和点击劫持等安全问题。</li><li>SEO问题：搜索引擎可能会忽略<code>iframe</code>内的内容，导致搜索引擎优化（SEO）方面的问题。</li><li>页面结构复杂性：过度使用<code>iframe</code>可能导致页面结构复杂，增加了维护和调试的难度。</li><li>可访问性问题：对于一些辅助技术（如屏幕阅读器）来说，<code>iframe</code>的内容可能不可访问，影响网页的可访问性。</li></ol><p>使用<code>iframe</code>可以解决一些特定的问题，例如：</p><ol><li>嵌入地图：将第三方地图服务（如Google Maps）嵌入到网页中，以显示地图信息。</li><li>嵌入视频：将视频嵌入到网页中，以方便播放外部视频内容。</li><li>广告展示：展示来自广告服务提供商的广告内容，以获取收益。</li></ol><p>尽管<code>iframe</code>有其优点和应用场景，但在使用时需要谨慎考虑其安全性和可访问性，并确保适当使用以避免潜在的问题。</p><h4 id="8-Google-Chrome如何支持大小小于12px-的文字"><a href="#8-Google-Chrome如何支持大小小于12px-的文字" class="headerlink" title="8.Google Chrome如何支持大小小于12px 的文字?"></a>8.Google Chrome如何支持大小小于12px 的文字?</h4><p>在过去，Google Chrome曾经不支持以小于12px的字体大小进行渲染，这是因为浏览器默认对小于12px的字体进行了最小字体大小限制。然而，后来的Chrome版本中，为了更好地支持一些特定的设计需求，引入了CSS的属性<code>-webkit-text-size-adjust</code>，该属性可以用于控制文字的大小调整。</p><p>要在Google Chrome中支持小于12px的字体大小，可以使用<code>-webkit-text-size-adjust</code>属性并将其设置为<code>none</code>。这样做会禁用浏览器的默认字体大小调整，从而允许使用小于12px的字体大小。</p><p>需要注意的是，使用小于12px的字体大小可能会导致文字在某些设备上不易阅读，尤其是在高分辨率或小尺寸屏幕上。因此，在使用小字体时，务必要进行充分的测试，以确保文字在各种设备和浏览器中都能正常显示和阅读。</p><p>另外，需要注意的是，<code>-webkit-text-size-adjust</code>是一个WebKit引擎（用于Chrome、Safari等浏览器）的私有属性，其他浏览器不支持。如果需要在其他浏览器中支持小于12px的字体大小，可能需要考虑其他解决方案或使用不同的字体单位（如<code>em</code>或<code>rem</code>）来代替像素单位。</p><h4 id="9-描述一下css盒子模型"><a href="#9-描述一下css盒子模型" class="headerlink" title="9.描述一下css盒子模型"></a>9.描述一下css盒子模型</h4><p>CSS盒子模型是指在网页中的每个元素都被视为一个矩形的盒子，它由四个部分组成：内容（Content）、内边距（Padding）、边框（Border）和外边距（Margin）。这些部分构成了一个元素在页面上所占据的空间。</p><ol><li>内容（Content）：指元素的实际内容区域，例如文本、图片或其他嵌套的子元素。内容的尺寸由元素的<code>width</code>和<code>height</code>属性来确定。</li><li>内边距（Padding）：是围绕在内容周围的空间，它指定了内容与边框之间的距离。内边距的尺寸由元素的<code>padding</code>属性来设置。</li><li>边框（Border）：是内边距和外边距之间的一条线，它包围着元素的内容和内边距。边框的样式、宽度和颜色由元素的<code>border</code>属性来设置。</li><li>外边距（Margin）：是元素与相邻元素之间的空间，它指定了元素与周围元素的距离。外边距的尺寸由元素的<code>margin</code>属性来设置。</li></ol><p>CSS盒子模型遵循以下原则：</p><ol><li>盒子模型中的各个部分在计算元素的总尺寸时是相互紧密联系的。例如，元素的总宽度包括了内容宽度、左右内边距和左右边框的宽度，以及左右外边距的宽度。</li><li>默认情况下，CSS的盒子模型是采用标准盒子模型（Standard Box Model）。在标准盒子模型中，元素的总宽度和高度包括了内容、内边距和边框，但不包括外边距。也就是说，元素的外边距是在元素的总宽度和高度之外的。</li></ol><p>​在CSS3中，引入了另一种盒子模型，称为”border-box”盒子模型，它可以通过设置<code>box-sizing: border-box;</code>来应用。在”border-box”盒子模型中，元素的总宽度和高度包括了内容、内边距和边框，同时也包括了外边距。这样可以更方便地控制元素的尺寸和布局，特别是在响应式设计和布局方面。</p><p>​总结来说，CSS盒子模型是一种用于描述元素尺寸和布局的概念，它由内容、内边距、边框和外边距四个部分组成，这些部分共同构成了一个元素在页面中所占据的空间。</p><h4 id="10-HTML5的特性有哪些"><a href="#10-HTML5的特性有哪些" class="headerlink" title="10.HTML5的特性有哪些?"></a>10.HTML5的特性有哪些?</h4><p>HTML5是HTML（超文本标记语言）的第五个版本，它引入了许多新的特性和改进，旨在提供更强大、更丰富的Web开发体验。以下是HTML5的一些主要特性：</p><ol><li>语义化标签：HTML5引入了许多新的语义化标签，如<code>&lt;header&gt;</code>、<code>&lt;nav&gt;</code>、<code>&lt;main&gt;</code>、<code>&lt;section&gt;</code>、<code>&lt;article&gt;</code>、<code>&lt;footer&gt;</code>等，使得文档结构更加清晰，并为搜索引擎提供更多信息。</li><li>多媒体支持：HTML5提供了原生的多媒体支持，包括<code>&lt;audio&gt;</code>和<code>&lt;video&gt;</code>标签，使得在网页上播放音频和视频更加简单。</li><li>Canvas绘图：HTML5引入了<code>&lt;canvas&gt;</code>标签，允许通过JavaScript动态绘制图形、图像和动画，用于实现游戏、数据可视化等交互效果。</li><li>SVG支持：HTML5对Scalable Vector Graphics（可缩放矢量图形）提供了原生支持，可以通过<code>&lt;svg&gt;</code>标签在网页中绘制矢量图形。</li><li>新的表单控件：HTML5引入了新的表单控件，如日期选择器、邮箱验证、电话号码等，使得表单处理更加便捷和语义化。</li><li>本地存储：HTML5提供了本地存储功能，包括LocalStorage和SessionStorage，用于在客户端存储数据，实现离线应用和减少服务器请求。</li><li>Web Workers：HTML5引入了Web Workers，允许在后台线程中运行JavaScript代码，从而提高页面的性能和响应性。</li><li>Web Sockets：HTML5支持Web Sockets，允许在浏览器和服务器之间建立持久的、双向通信的连接，实现实时通信和推送。</li><li>地理位置定位：HTML5支持Geolocation API，允许网页获取用户的地理位置信息，用于定位服务和个性化内容。</li><li>拖放功能：HTML5引入了拖放API，使得网页元素可以被拖动和放置，用于实现更直观的用户交互。</li></ol><p>这些特性只是HTML5提供的一部分功能，它们使得Web开发更加便捷、功能更加强大，同时提高了网页的性能和用户体验。由于HTML5的广泛支持和优势，它已经成为现代Web开发的标准。</p><h4 id="11-CSS3-的特性有哪些"><a href="#11-CSS3-的特性有哪些" class="headerlink" title="11.CSS3 的特性有哪些?"></a>11.CSS3 的特性有哪些?</h4><p>CSS3是CSS（层叠样式表）的第三个版本，引入了许多新的特性和改进，为网页设计和布局提供了更多的灵活性和交互效果。以下是CSS3的一些主要特性：</p><ol><li>边框和背景：<ul><li>圆角边框（<code>border-radius</code>）：可以为元素的边框添加圆角效果。</li><li>阴影效果（<code>box-shadow</code>）：可以为元素添加阴影效果。</li><li>渐变背景（<code>linear-gradient</code>和<code>radial-gradient</code>）：可以为元素的背景添加渐变效果。</li></ul></li><li>选择器：<ul><li>属性选择器：可以根据元素的属性选择元素。</li><li>伪类选择器：可以选择元素的特定状态，如<code>hover</code>、<code>active</code>等。</li></ul></li><li>文本效果：<ul><li>文本阴影（<code>text-shadow</code>）：可以为文字添加阴影效果。</li><li>文本溢出（<code>text-overflow</code>）：可以控制文字在超出容器时的显示方式。</li><li>文本换行（<code>word-wrap</code>和<code>word-break</code>）：可以控制长单词或长链接的换行方式。</li></ul></li><li>盒子模型：<ul><li>盒子阴影（<code>box-shadow</code>）：可以为元素的盒子模型添加阴影效果。</li><li>盒子尺寸（<code>box-sizing</code>）：可以控制元素盒子模型的尺寸计算方式。</li></ul></li><li>转换和过渡：<ul><li>2D转换（<code>transform</code>）：可以对元素进行平移、缩放、旋转等2D变换。</li><li>过渡效果（<code>transition</code>）：可以为元素的属性添加平滑过渡效果。</li></ul></li><li>动画：<ul><li>动画效果（<code>@keyframes</code>和<code>animation</code>）：可以使用关键帧定义动画，控制元素的动画效果。</li></ul></li><li>Flexbox布局：<ul><li>弹性盒子布局（Flexbox）：可以使用<code>display: flex</code>实现灵活的、响应式的布局。</li></ul></li><li>Grid布局：<ul><li>网格布局（Grid）：可以使用<code>display: grid</code>实现复杂的网格布局。</li></ul></li><li>媒体查询：<ul><li>媒体查询（Media Queries）：可以根据设备的特性和视口尺寸应用不同的样式，实现响应式设计。</li></ul></li></ol><p>这些特性只是CSS3提供的一部分功能，它们使得网页设计和布局更加灵活、美观，同时增加了交互效果和用户体验。由于CSS3的广泛支持和优势，它已经成为现代Web开发中的标准。然而，为了确保在所有浏览器中获得一致的显示效果，开发者仍需考虑到兼容性问题，并在需要时提供适当的回退方案。</p><h4 id="12-如何实现水平居中"><a href="#12-如何实现水平居中" class="headerlink" title="12.如何实现水平居中?"></a>12.如何实现水平居中?</h4><p>行内级元素包括inline-block：在父元素中设置text-align:center</p><p>块级元素：margin: 0 auto</p><p>绝对定位：元素在有宽度的情况下：l0;r0;m0auto</p><p>flex：justify-content:center</p><h4 id="13-如何实现垂直居中"><a href="#13-如何实现垂直居中" class="headerlink" title="13.如何实现垂直居中?"></a>13.如何实现垂直居中?</h4><p>绝对定位：元素在有宽度的情况下：t0;b0;mauto0；弊端：必须使用定位（脱离标准流）； 必须给元素设置宽度</p><p>flex：弊端：flex局部中的所有元素都会被垂直居中；兼容性较差</p><p>top&#x2F;translate：让元素下移父元素的50%（使用相对定位，不能使用mt 它相对于的是父元素的宽度）；让元素上移自身的50%</p><h4 id="14-如何实现双圣杯布局"><a href="#14-如何实现双圣杯布局" class="headerlink" title="14.如何实现双圣杯布局?"></a>14.如何实现双圣杯布局?</h4><p>使用了Flexbox布局来实现双圣杯布局。<code>.container</code>是主容器，设置为<code>display: flex;</code>以创建Flexbox容器。<code>justify-content: space-between;</code>将左侧边栏和右侧边栏推到两侧，让中心内容区域占据剩余的空间。</p><p><code>.main-content</code>是中心内容区域，设置为<code>flex: 1;</code>以占据剩余空间。</p><p><code>.left-sidebar</code>和<code>.right-sidebar</code>是左侧和右侧的侧边栏，都设置为<code>flex: 0 0 200px;</code>以固定宽度为200像素。我们使用<code>order: -1;</code>来调整左侧边栏在DOM中的位置，但在显示上放在左侧。</p><p>这样，我们就成功实现了一个简单的双圣杯布局，可以根据需要自定义内容和样式。这种布局非常适合创建带有固定侧边栏的网站，特别是在响应式设计中非常实用。</p><h4 id="15-CSS中选择器的优先级"><a href="#15-CSS中选择器的优先级" class="headerlink" title="15.CSS中选择器的优先级?"></a>15.CSS中选择器的优先级?</h4><p>在 CSS 中，选择器的优先级用于确定应用在元素上的样式规则的优先顺序。当多个选择器都匹配同一个元素时，浏览器需要决定应该使用哪个样式规则。选择器的优先级是根据其特定的组合方式来计算的，优先级从高到低依次为：</p><ol><li><strong>!important：</strong> <code>!important</code> 是最高优先级的标志，当样式规则被标记为 <code>!important</code> 时，该样式将具有最高优先级，即使其他选择器的优先级更高也会被覆盖。但应尽量避免过度使用 <code>!important</code>，因为它可能导致样式管理困难和维护问题。</li><li><strong>内联样式（Inline Style）：</strong> 在元素的 <code>style</code> 属性中直接设置样式，内联样式优先级较高，可以覆盖外部样式表和页面级样式。</li><li><strong>ID 选择器：</strong> 使用 <code>#</code> 符号定义的 ID 选择器，每个 ID 选择器的优先级比内联样式低。</li><li><strong>类选择器、属性选择器和伪类选择器：</strong> 使用类选择器（如 <code>.class</code>）、属性选择器（如 <code>[attribute]</code>）、伪类选择器（如 <code>:hover</code>）的优先级较低，比 ID 选择器优先级低。</li><li><strong>元素选择器和伪元素选择器：</strong> 使用元素选择器（如 <code>div</code>、<code>p</code> 等）和伪元素选择器（如 <code>::before</code>、<code>::after</code>）的优先级较低，比类选择器、属性选择器和伪类选择器优先级低。</li><li><strong>通用选择器和关系选择器：</strong> 使用通用选择器（<code>*</code>）和关系选择器（如 <code>+</code>、<code>&gt;</code>、<code>~</code>）的优先级较低，比元素选择器和伪元素选择器优先级低。</li><li><strong>继承样式：</strong> 继承样式的优先级最低，如果一个元素没有显式地定义某个属性的样式，将会从其父元素继承该属性的样式。</li></ol><p>当多个选择器的优先级相同时，后面出现的样式规则将覆盖先前出现的样式规则。在实际开发中，了解选择器优先级的计算方式有助于更好地控制样式的应用和覆盖，避免样式冲突和重复定义。</p><h4 id="16-CSS-权重如何计算"><a href="#16-CSS-权重如何计算" class="headerlink" title="16.CSS 权重如何计算?"></a>16.CSS 权重如何计算?</h4><p>CSS 权重（Specificity）用于确定应用在元素上的样式规则的优先级。计算 CSS 权重涉及对选择器的特定组合进行分析，每个选择器都有一个权重值，权重值越高，优先级越高。CSS 权重的计算方式如下：</p><ol><li>对于内联样式（Inline Style），权重值为 1000。</li><li>对于 ID 选择器，权重值为 100。</li><li>对于类选择器、属性选择器和伪类选择器，权重值为 10。</li><li>对于元素选择器和伪元素选择器，权重值为 1。</li><li>通用选择器（<code>*</code>）和关系选择器（如 <code>+</code>、<code>&gt;</code>、<code>~</code>）没有权重值。</li></ol><p>权重计算的规则是将选择器的各个部分的权重值相加，得到最终的权重值。例如，对于选择器 <code>.container .item</code>，其中类选择器的权重为 10，权重值为 20（因为有两个类选择器），而对于选择器 <code>div.item</code>，其中元素选择器和类选择器的权重分别为 1 和 10，权重值为 11。</p><p>如果多个样式规则的权重相同，则后面出现的样式规则将覆盖先前出现的样式规则。如果样式规则都使用了 <code>!important</code> 标志，则该样式规则将具有最高优先级，即使其他样式规则的权重值更高也会被覆盖。</p><p>权重计算的示例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">  /* 内联样式，权重值为 1000 */</span><br><span class="line">  div &#123;</span><br><span class="line">    color: red; /* 权重值为 1 */</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /* ID 选择器，权重值为 100 */</span><br><span class="line">  #container &#123;</span><br><span class="line">    color: blue; /* 权重值为 101 */</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /* 类选择器和元素选择器，权重值为 10 + 1 = 11 */</span><br><span class="line">  .item &#123;</span><br><span class="line">    color: green; /* 权重值为 21 */</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;div id=&quot;container&quot; class=&quot;item&quot; style=&quot;color: purple;&quot;&gt;文本颜色&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>在上述示例中，元素 <code>div</code> 的文本颜色最终为紫色，因为内联样式具有最高优先级。如果没有内联样式，文本颜色将为蓝色，因为 ID 选择器的权重值最高。如果同时存在多个具有相同权重的样式规则，则后面出现的样式规则将覆盖先前出现的样式规则。</p><h4 id="17-HTML5-input元素type属性有哪些"><a href="#17-HTML5-input元素type属性有哪些" class="headerlink" title="17.HTML5 input元素type属性有哪些?"></a>17.HTML5 input元素type属性有哪些?</h4><p>在 HTML5 中，<code>&lt;input&gt;</code> 元素的 <code>type</code> 属性用于定义输入字段的类型。不同的 <code>type</code> 属性会影响输入字段的外观和行为。以下是常见的 <code>&lt;input&gt;</code> 元素的 <code>type</code> 属性取值：</p><ol><li><strong>text：</strong> 默认值，创建一个单行文本输入框。</li><li><strong>password：</strong> 创建一个密码输入框，输入的内容会以圆点或星号隐藏。</li><li><strong>checkbox：</strong> 创建一个复选框，允许用户选择一个或多个选项。</li><li><strong>radio：</strong> 创建一个单选按钮，允许用户在一组选项中选择一个。</li><li><strong>submit：</strong> 创建一个提交按钮，用于提交表单数据。</li><li><strong>reset：</strong> 创建一个重置按钮，用于重置表单数据为初始值。</li><li><strong>button：</strong> 创建一个普通按钮，可通过 JavaScript 进行事件绑定。</li><li><strong>file：</strong> 创建一个文件上传字段，用于上传文件。</li><li><strong>image：</strong> 创建一个图像按钮，用于提交表单，并在按钮上显示图像。</li><li><strong>email：</strong> 创建一个用于输入电子邮件地址的文本输入框。</li><li><strong>number：</strong> 创建一个用于输入数值的文本输入框。</li><li><strong>date：</strong> 创建一个用于输入日期的文本输入框。</li><li><strong>time：</strong> 创建一个用于输入时间的文本输入框。</li><li><strong>url：</strong> 创建一个用于输入 URL 地址的文本输入框。</li><li><strong>tel：</strong> 创建一个用于输入电话号码的文本输入框。</li><li><strong>search：</strong> 创建一个用于搜索的文本输入框。</li></ol><p>使用不同的 <code>type</code> 属性可以定制不同类型的输入字段，使用户输入更加方便和准确。请注意，部分浏览器可能对某些 <code>type</code> 属性的支持存在差异，尤其是在旧版本的浏览器中。</p><h4 id="18-CSS中哪些属性可继承，哪些不可以"><a href="#18-CSS中哪些属性可继承，哪些不可以" class="headerlink" title="18.CSS中哪些属性可继承，哪些不可以"></a>18.CSS中哪些属性可继承，哪些不可以</h4><p>在CSS中，有一些属性是可继承的，这意味着它们的值会自动继承给子元素。而另一些属性是不可继承的，子元素不会继承父元素的这些属性值。下面是一些常见的可继承和不可继承的属性：</p><p>可继承属性（Inherited Properties）：</p><ol><li>字体相关属性：<code>font-family</code>、<code>font-size</code>、<code>font-weight</code>、<code>font-style</code>等。</li><li>文本相关属性：<code>color</code>、<code>text-align</code>、<code>line-height</code>、<code>text-indent</code>等。</li><li>元素可见性：<code>visibility</code>属性。</li><li>元素透明度：<code>opacity</code>属性。</li><li>表格布局相关属性：<code>caption-side</code>、<code>border-collapse</code>、<code>empty-cells</code>等。</li></ol><p>不可继承属性（Non-inherited Properties）：</p><ol><li>盒子模型相关属性：<code>width</code>、<code>height</code>、<code>margin</code>、<code>padding</code>、<code>border</code>等。</li><li>定位和浮动相关属性：<code>position</code>、<code>top</code>、<code>right</code>、<code>bottom</code>、<code>left</code>、<code>float</code>等。</li><li>背景相关属性：<code>background-color</code>、<code>background-image</code>、<code>background-size</code>等。</li><li>文本装饰相关属性：<code>text-decoration</code>、<code>text-transform</code>、<code>text-shadow</code>等。</li><li>元素的显示类型：<code>display</code>属性。</li><li>清除浮动：<code>clear</code>属性。</li><li>弹性盒子（Flexbox）和网格布局（Grid Layout）相关属性：<code>display: flex</code>、<code>display: grid</code>等。</li></ol><p>需要注意的是，并非所有的属性都完全符合可继承或不可继承的规则。有些属性可能部分可继承，部分不可继承。此外，有些属性可以通过特定的值或继承机制进行调整，例如<code>inherit</code>、<code>initial</code>、<code>unset</code>等值可以改变继承性。因此，在具体使用中，最好查阅相关文档或测试以确认属性的继承行为。</p><h4 id="19-CSS单位中px、-em和rem的区别-配合font-size如何计算-移动端适配方案"><a href="#19-CSS单位中px、-em和rem的区别-配合font-size如何计算-移动端适配方案" class="headerlink" title="19.CSS单位中px、 em和rem的区别?配合font-size如何计算? (移动端适配方案)"></a>19.CSS单位中px、 em和rem的区别?配合font-size如何计算? (移动端适配方案)</h4><p>在CSS中，<code>px</code>、<code>em</code>和<code>rem</code>是常见的单位，用于定义元素的尺寸。它们在计算和使用<code>font-size</code>时有一些区别，特别是在移动端适配方案中。</p><ol><li><code>px</code>（像素）：是一个固定单位，表示屏幕上的一个物理像素。它是最常见的单位，它的大小不会随着其他因素的改变而改变，因此在响应式设计中不推荐直接使用<code>px</code>作为尺寸单位，因为在不同设备上可能会导致布局和字体大小失真。</li><li><code>em</code>：相对单位，它是相对于父元素的字体大小计算的。例如，如果父元素的字体大小是16px，那么<code>1em</code>就等于<code>16px</code>，<code>2em</code>就等于<code>32px</code>，依此类推。但是，如果子元素使用了<code>em</code>作为字体大小单位，那么它的计算基准将是父元素的字体大小，这可能会导致字体大小的嵌套效应。</li><li><code>rem</code>（root em）：相对单位，它是相对于根元素（<code>html</code>元素）的字体大小计算的。与<code>em</code>不同，<code>rem</code>不会受到父元素字体大小的影响，它始终是相对于根元素的字体大小。这使得<code>rem</code>在响应式设计和移动端适配中非常实用。</li></ol><p>在移动端适配方案中，通常会使用<code>rem</code>作为字体大小和尺寸的单位，这样可以确保元素的尺寸在不同屏幕尺寸下保持相对一致。为了使用<code>rem</code>作为单位，需要设置根元素的字体大小，并根据设计的需求调整其他元素的尺寸。</p><p>例如，如果要将根元素的字体大小设置为<code>16px</code>，可以在CSS中这样做：</p><p>然后，可以根据设计的需求，在其他元素中使用<code>rem</code>来设置字体大小和尺寸。例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">html &#123;</span><br><span class="line">  font-size: 16px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">body &#123;</span><br><span class="line">  font-size: 1rem; /* 等同于16px */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">h1 &#123;</span><br><span class="line">  font-size: 2rem; /* 等同于32px */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p &#123;</span><br><span class="line">  font-size: 1.2rem; /* 等同于19.2px */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.container &#123;</span><br><span class="line">  width: 20rem; /* 等同于320px */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过使用<code>rem</code>作为单位，可以实现移动端的适配，使得元素的大小和字体在不同设备上都能相对一致地展示。同时，使用<code>rem</code>也使得调整根元素的字体大小成为可能，从而实现整个页面的缩放效果。</p><h4 id="20-如何画一条0-5px的线"><a href="#20-如何画一条0-5px的线" class="headerlink" title="20.如何画一条0.5px的线"></a>20.如何画一条0.5px的线</h4><p>在HTML和CSS中，无法直接绘制0.5像素的线。这是由于绝大多数屏幕的物理像素是一个整数，无法显示出半个像素的线。</p><p>然而，你可以通过一些技巧来模拟绘制0.5像素宽的线。其中一个常用的方法是使用<code>transform</code>属性的<code>scale</code>来缩放元素，从而实现模拟0.5像素线的效果。</p><p>以下是一个示例，在这个示例中，我们将一个水平线条进行缩放，实现近似0.5像素宽的线：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.line &#123;</span><br><span class="line">  width: 100px; /* 线条的宽度 */</span><br><span class="line">  height: 1px; /* 线条的高度 */</span><br><span class="line">  background-color: black; /* 线条的颜色 */</span><br><span class="line">  transform: scaleY(0.5); /* 将线条在垂直方向上缩放为原来的0.5倍 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子中，我们创建了一个高度为1像素的水平线条，然后使用<code>transform: scaleY(0.5);</code>将其在垂直方向上缩放为原来的0.5倍，从而模拟出近似0.5像素宽的线。</p><p>需要注意的是，这种方法在不同屏幕上的显示效果可能会有所差异，而且在某些情况下可能会失去一些锐利度。在实际应用中，如果需要非常细小的线条，最好使用一种更合适的设计方法，或者考虑使用其他技术实现，如SVG或Canvas。</p><h4 id="21-隐藏一个元素有哪些方法-display-none与visibility-hidden与opacity-0之间的区别"><a href="#21-隐藏一个元素有哪些方法-display-none与visibility-hidden与opacity-0之间的区别" class="headerlink" title="21.隐藏一个元素有哪些方法? display: none与visibility: hidden与opacity: 0之间的区别?"></a>21.隐藏一个元素有哪些方法? display: none与visibility: hidden与opacity: 0之间的区别?</h4><p>隐藏一个元素有以下几种方法：</p><ol><li><strong>display: none：</strong> 使用 <code>display: none;</code> 属性可以完全从文档流中移除元素，并且不会在页面上占据空间。元素不会显示在页面上，也不会响应用户的交互事件。隐藏后，元素不会占据任何空间，其他元素会重新排列填充被隐藏元素的位置。</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.hidden-element &#123;</span><br><span class="line">  display: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>visibility: hidden：</strong> 使用 <code>visibility: hidden;</code> 属性可以隐藏元素，但它仍然会在文档流中占据空间。元素在页面上不可见，但仍会保留其原有的大小和位置。隐藏后，元素仍然占据空间，其他元素不会重新排列填充其位置。</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.hidden-element &#123;</span><br><span class="line">  visibility: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>opacity: 0：</strong> 使用 <code>opacity: 0;</code> 属性可以使元素完全透明，但元素仍然保留在文档流中，并占据空间。元素在页面上不可见，但仍然会占用其原有的位置和大小。透明后，元素仍然占据空间，其他元素不会重新排列填充其位置。</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.hidden-element &#123;</span><br><span class="line">  opacity: 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>区别总结：</strong></p><ul><li><code>display: none;</code> 会完全从文档流中移除元素，不占据空间，其他元素会重新排列填充其位置。</li><li><code>visibility: hidden;</code> 会隐藏元素，但仍然保留其占用的空间，其他元素不会重新排列。</li><li><code>opacity: 0;</code> 会使元素完全透明，但仍然保留在文档流中，占据空间。</li></ul><p>选择使用哪种方法取决于具体需求。如果希望元素完全消失且不占据空间，使用 <code>display: none;</code> 是更合适的选择。如果希望元素不可见但仍占据空间，可以使用 <code>visibility: hidden;</code> 或 <code>opacity: 0;</code>。</p><h4 id="22-position-的值有哪些，分别有什么特点"><a href="#22-position-的值有哪些，分别有什么特点" class="headerlink" title="22.position 的值有哪些，分别有什么特点?"></a>22.position 的值有哪些，分别有什么特点?</h4><p>CSS 中的 <code>position</code> 属性用于控制元素的定位方式，有以下几个取值：</p><ol><li><strong>static：</strong> 默认值，元素按照正常的文档流布局。<code>top</code>、<code>right</code>、<code>bottom</code> 和 <code>left</code> 属性不起作用。</li><li><strong>relative：</strong> 设置元素相对于其正常位置进行定位。使用 <code>top</code>、<code>right</code>、<code>bottom</code> 和 <code>left</code> 属性可以对元素进行偏移，但元素仍占据原来的空间。相对定位会影响其他元素的布局，其他元素仍会按照相对定位元素的原始位置进行排列。</li><li><strong>absolute：</strong> 设置元素完全脱离文档流，相对于其最近的已定位（position 不是 <code>static</code>）的父元素进行定位。如果没有已定位的父元素，则相对于文档的初始位置进行定位。绝对定位会完全脱离文档流，不占据空间，其他元素会填充其位置。</li><li><strong>fixed：</strong> 设置元素相对于浏览器窗口进行定位，始终保持在固定的位置，即使页面滚动。固定定位也会脱离文档流，不占据空间。</li><li><strong>sticky：</strong> 元素在跨越特定阈值前表现为 <code>relative</code> 定位，之后表现为 <code>fixed</code> 定位。它在滚动时可以将元素固定在指定位置，类似于 <code>fixed</code>，但在某个阈值时又会恢复到 <code>relative</code> 定位，类似于 <code>relative</code>。这个阈值可以通过 <code>top</code>、<code>right</code>、<code>bottom</code> 或 <code>left</code> 属性来设置。</li></ol><p>需要注意的是，<code>relative</code>、<code>absolute</code>、<code>fixed</code> 和 <code>sticky</code> 属性值会创建一个新的定位上下文（positioned context），这意味着它们会影响子元素的定位。而 <code>static</code> 属性值不会创建新的定位上下文，子元素仍会按照正常的文档流布局。</p><h4 id="23-什么是浮动，浮动会引起什么问题，有何解决方案"><a href="#23-什么是浮动，浮动会引起什么问题，有何解决方案" class="headerlink" title="23.什么是浮动，浮动会引起什么问题，有何解决方案?"></a>23.什么是浮动，浮动会引起什么问题，有何解决方案?</h4><p>浮动（float）是 CSS 中的一种定位方式，用于使元素脱离正常的文档流，让元素在其容器中浮动，并排列在容器的左侧或右侧。浮动常用于实现图文混排、多列布局等效果。</p><p>浮动会引起以下问题：</p><ol><li><strong>父容器高度塌陷（容器高度坍塌）：</strong> 当一个元素浮动后，它会脱离文档流，导致其父容器不再计算该元素的高度，从而导致父容器高度塌陷。这会使父容器无法正确包裹浮动元素，影响页面布局。</li><li><strong>文字环绕布局问题：</strong> 如果一个浮动元素位于文本的左侧或右侧，文本会环绕在浮动元素的周围，这可能导致排版混乱。</li></ol><p>解决方案：</p><ol><li><strong>清除浮动（clearfix）：</strong> 可以在浮动元素后面添加一个空元素，并设置 <code>clear: both;</code> 属性，使父容器正确包裹浮动元素。</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.clearfix::after &#123;</span><br><span class="line">  content: &quot;&quot;;</span><br><span class="line">  display: table;</span><br><span class="line">  clear: both;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;clearfix&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;float-box&quot;&gt;浮动元素&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><ol><li><strong>使用父容器的 overflow 属性：</strong> 将父容器的 <code>overflow</code> 属性设置为 <code>hidden</code> 或 <code>auto</code>，可以触发 BFC（块级格式化上下文），从而包裹浮动元素。</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">  overflow: hidden; /* 或 overflow: auto; */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;float-box&quot;&gt;浮动元素&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><ol><li><strong>使用 Flexbox 布局：</strong> 使用 CSS3 的 Flexbox 布局也可以解决浮动问题，因为 Flexbox 不需要浮动元素。</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">  display: flex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;float-box&quot;&gt;浮动元素&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><ol><li><strong>使用 CSS Grid 布局：</strong> CSS3 中的 Grid 布局也是一种解决浮动问题的方式，它可以轻松实现多列布局。</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">  display: grid;</span><br><span class="line">  grid-template-columns: repeat(3, 1fr); /* 3 列等宽布局 */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;float-box&quot;&gt;浮动元素1&lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;float-box&quot;&gt;浮动元素2&lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;float-box&quot;&gt;浮动元素3&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>以上解决方案中，清除浮动（clearfix）和设置父容器的 <code>overflow</code> 属性是传统的方法，在旧浏览器中支持较好。使用 Flexbox 和 CSS Grid 是现代 Web 开发中更推荐的方法，它们可以更灵活地实现复杂的布局需求。</p><h4 id="24-line-height-和height的区别"><a href="#24-line-height-和height的区别" class="headerlink" title="24.line-height 和height的区别"></a>24.line-height 和height的区别</h4><p><code>line-height</code> 和 <code>height</code> 是两个 CSS 属性，用于控制元素的高度和行高，它们有一些区别：</p><ol><li><strong>height（高度）：</strong><ul><li><code>height</code> 属性用于设置元素的高度。</li><li>它可以接受具体的长度值（像素、百分比等）或者是<code>auto</code>关键字。</li><li>当设置为具体的长度值时，元素的高度会被固定为指定的数值，无论其内容是否超过了这个高度。</li><li>如果设置为<code>auto</code>，元素的高度会自动根据其内容撑开，以适应内容的高度。</li></ul></li><li><strong>line-height（行高）：</strong><ul><li><code>line-height</code> 属性用于设置元素中行框的高度。</li><li>它可以接受具体的长度值（像素、百分比等）或者是无单位的数值。</li><li>当设置为具体的长度值时，行框的高度会被固定为指定的数值，所有的行框都会具有相同的高度。</li><li>如果设置为无单位的数值（如<code>1.5</code>），行框的高度会被设置为字体大小的相对值，例如，如果字体大小为16像素，那么行高将是24像素（16 * 1.5）。</li><li><code>line-height</code> 也可以设置为百分比值，此时行高会相对于元素的字体大小进行计算。</li></ul></li></ol><p><strong>区别：</strong></p><ul><li><code>height</code> 用于设置元素的实际高度，可以固定元素的高度。</li><li><code>line-height</code> 用于设置行框的高度，影响文本在行内的垂直对齐和行间距。</li><li><code>height</code> 设置元素的高度不会影响文本的布局，而 <code>line-height</code> 可以影响文本在行内的垂直居中对齐，或者在多行文本中影响行间距。</li></ul><p>通常，我们使用 <code>line-height</code> 来调整行间距或实现文本的垂直居中，而使用 <code>height</code> 来设置元素的实际高度。</p><h4 id="25-设置一个元素的背景颜色，背景颜色会填充哪些区域"><a href="#25-设置一个元素的背景颜色，背景颜色会填充哪些区域" class="headerlink" title="25.设置一个元素的背景颜色，背景颜色会填充哪些区域?"></a>25.设置一个元素的背景颜色，背景颜色会填充哪些区域?</h4><p>当为一个元素设置背景颜色时，背景颜色会填充以下区域：</p><ol><li><strong>内容区域（Content Area）：</strong> 背景颜色将填充元素的内容区域，也就是元素内部实际包含的文本、图片或其他元素的区域。这是背景色最主要的填充区域。</li><li><strong>内边距区域（Padding Area）：</strong> 如果元素有设置内边距（<code>padding</code>），背景颜色也会延伸到内边距区域。内边距区域是内容区域和边框之间的空白区域。</li><li><strong>边框区域（Border Area）：</strong> 背景颜色会填充元素的边框区域，即元素的边框线所占据的区域。</li><li><strong>外边距区域（Margin Area）：</strong> 背景颜色不会填充元素的外边距区域，外边距区域是元素与其他元素之间的空白区域，背景颜色不会延伸到这个区域。</li></ol><p>综上所述，背景颜色将填充元素的内容区域和内边距区域，并且会延伸到边框区域。若想要控制背景颜色的填充范围，可以通过设置元素的内边距和边框来调整。如果希望让背景颜色填充整个元素，可以将元素的内边距和边框设为0。</p><h4 id="26-inline-block-inline-和block的区别-为什么img是inline还可以设置宽高"><a href="#26-inline-block-inline-和block的区别-为什么img是inline还可以设置宽高" class="headerlink" title="26.inline-block. inline 和block的区别;为什么img是inline还可以设置宽高"></a>26.inline-block. inline 和block的区别;为什么img是inline还可以设置宽高</h4><p><code>inline-block</code>、<code>inline</code> 和 <code>block</code> 都是CSS中元素的显示属性，它们之间有一些区别：</p><p><strong>1. inline（内联元素）：</strong></p><ul><li><code>inline</code> 元素会在一行内显示，并且不会独占一行。它们会根据内容的大小自动调整宽度，不可以设置宽度和高度属性，设置无效。</li><li>典型的 <code>inline</code> 元素有：<code>&lt;span&gt;</code>、<code>&lt;a&gt;</code>、<code>&lt;strong&gt;</code>、<code>&lt;em&gt;</code> 等。</li></ul><p><strong>2. block（块级元素）：</strong></p><ul><li><code>block</code> 元素会独占一行，宽度默认是父元素的宽度，可以设置宽度和高度属性。</li><li>典型的 <code>block</code> 元素有：<code>&lt;div&gt;</code>、<code>&lt;p&gt;</code>、<code>&lt;h1&gt;</code>～<code>&lt;h6&gt;</code>、<code>&lt;ul&gt;</code>、<code>&lt;li&gt;</code> 等。</li></ul><p><strong>3. inline-block（内联块级元素）：</strong></p><ul><li><code>inline-block</code> 元素会在一行内显示，但它可以设置宽度和高度属性，同时不会独占一行。</li><li><code>inline-block</code> 元素可以像 <code>inline</code> 元素一样与其他元素在同一行显示，同时又具备像 <code>block</code> 元素一样可以设置宽度和高度的特性。</li><li>典型的 <code>inline-block</code> 元素有：<code>&lt;img&gt;</code>、<code>&lt;input&gt;</code> 等。</li></ul><p><strong>为什么 <code>&lt;img&gt;</code> 是 <code>inline</code> 元素还可以设置宽高：</strong> <code>&lt;img&gt;</code> 标签默认是 <code>inline</code> 元素，但它有固有的宽度和高度，即图片的实际尺寸。因此，尽管 <code>inline</code> 元素不可设置宽度和高度属性，但 <code>&lt;img&gt;</code> 元素可以显示它的实际宽度和高度。当设置 <code>width</code> 和 <code>height</code> 属性时，<code>&lt;img&gt;</code> 元素会按照指定的宽高进行显示，但仍保持在一行内显示，因为它是 <code>inline</code> 元素。这种特性使得在页面中插入图片时，可以通过设置宽高属性来控制图片的显示大小而不破坏文档流布局。</p><h4 id="27-什么是重绘-什么是回流-如何减少-如何让文档脱离文档流"><a href="#27-什么是重绘-什么是回流-如何减少-如何让文档脱离文档流" class="headerlink" title="27.什么是重绘?什么是回流?如何减少?如何让文档脱离文档流?"></a>27.什么是重绘?什么是回流?如何减少?如何让文档脱离文档流?</h4><p>重绘（Repaint）和回流（Reflow）是浏览器渲染页面时的两个重要过程，它们的触发和执行会影响页面性能和用户体验。</p><p><strong>重绘（Repaint）：</strong></p><ul><li>重绘是指当元素样式发生变化（例如颜色、背景色、字体颜色等）但不影响其布局的情况下，浏览器会重新绘制该元素的外观，使其更新显示新的样式。重绘不会改变元素的大小和位置，只是重新绘制元素的外观。</li></ul><p><strong>回流（Reflow）：</strong></p><ul><li>回流是指当元素的布局发生变化（例如大小、位置、显示或隐藏等）时，浏览器会重新计算并重新构建整个页面的布局树（Layout Tree）。回流会导致页面的重新排列和重绘，是较为消耗性能的操作。</li></ul><p><strong>如何减少回流和重绘：</strong></p><ol><li><strong>使用<code>transform</code>属性：</strong> 由于<code>transform</code>属性在GPU上执行，可以减少回流和重绘的次数，适用于移动、旋转和缩放等动画效果。</li><li><strong>批量修改样式：</strong> 避免多次单独修改元素的样式，尽量通过添加或移除类名一次性修改样式，以减少回流和重绘的次数。</li><li><strong>使用文档片段（DocumentFragment）：</strong> 当需要频繁操作DOM时，可以使用文档片段来进行批量操作，最后再一次性添加到文档中，减少回流。</li><li><strong>避免强制同步布局：</strong> 比如读取元素的样式属性（例如offsetTop、offsetWidth等）会导致浏览器强制同步布局，应该避免频繁使用这些属性。</li></ol><p><strong>如何让文档脱离文档流：</strong></p><ul><li>要让元素脱离文档流，可以使用CSS的<code>position</code>属性来设置元素的定位方式为<code>absolute</code>（绝对定位）或<code>fixed</code>（固定定位）。这样，元素将不再占据原有的空间，不会影响其他元素的布局。但是，脱离文档流后，元素将根据其定位方式相对于最近的已定位（非<code>static</code>）祖先元素进行定位。</li></ul><h4 id="28-box-sizing-的作用，如何使用"><a href="#28-box-sizing-的作用，如何使用" class="headerlink" title="28.box-sizing 的作用，如何使用?"></a>28.box-sizing 的作用，如何使用?</h4><p><code>box-sizing</code> 是一个CSS属性，用于控制元素的盒模型计算方式。默认情况下，元素的宽度和高度只包括内容区域（<code>content</code>），而不包括内边距（<code>padding</code>）和边框（<code>border</code>）。这意味着添加内边距和边框会增加元素的总宽度和高度。</p><p><code>box-sizing</code> 可以改变盒模型的计算方式，使元素的宽度和高度包括内边距和边框，从而更方便地控制元素的尺寸。<code>box-sizing</code> 可以有以下两个值：</p><ol><li><code>content-box</code>（默认值）：元素的宽度和高度只包括内容区域（<code>content</code>），内边距（<code>padding</code>）和边框（<code>border</code>）会增加元素的总宽度和高度。</li><li><code>border-box</code>：元素的宽度和高度包括内容区域、内边距和边框。换句话说，设置元素的宽度和高度时，内边距和边框的大小不会再增加元素的总宽度和高度，而是会从内容区域减去。</li></ol><p><strong>如何使用 <code>box-sizing</code>：</strong> 要使用 <code>box-sizing</code> 属性，可以在元素的样式中设置它的值为 <code>content-box</code> 或 <code>border-box</code>。例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* 将所有元素的盒模型计算方式设置为 border-box */</span><br><span class="line">* &#123;</span><br><span class="line">  box-sizing: border-box;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 将某个特定元素的盒模型计算方式设置为 border-box */</span><br><span class="line">.my-element &#123;</span><br><span class="line">  box-sizing: border-box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在设置为 <code>border-box</code> 的情况下，当修改元素的宽度或高度时，可以更方便地控制元素的尺寸，因为内边距和边框不会再增加元素的总宽度和高度。这样有助于避免盒模型计算带来的布局问题，特别在处理响应式布局时非常有用。</p><h4 id="29-如何实现清除浮动"><a href="#29-如何实现清除浮动" class="headerlink" title="29.如何实现清除浮动"></a>29.如何实现清除浮动</h4><p>在 CSS 中，清除浮动是为了解决由于浮动元素导致的父容器无法正确包裹浮动元素而产生的布局问题。浮动元素会脱离正常的文档流，导致父容器高度塌陷，影响布局。有几种常见的方法可以清除浮动：</p><p><strong>1. 使用空元素添加<code>clear</code>属性：</strong> 在浮动元素后面添加一个空元素，并设置 <code>clear: both;</code> 属性，可以清除浮动。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">htmlCopy code&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;float-box&quot;&gt;浮动元素&lt;/div&gt;</span><br><span class="line">  &lt;div style=&quot;clear: both;&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p><strong>2. 使用 clearfix 类：</strong> 定义一个 clearfix 类，将 <code>::after</code> 伪元素应用于父容器，设置 <code>clear: both;</code> 属性，使其成为一个自清除的伪元素。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">  .clearfix::after &#123;</span><br><span class="line">    content: &quot;&quot;;</span><br><span class="line">    display: table;</span><br><span class="line">    clear: both;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;container clearfix&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;float-box&quot;&gt;浮动元素&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p><strong>3. 使用 overflow 属性：</strong> 设置父容器的 <code>overflow</code> 属性为 <code>hidden</code> 或 <code>auto</code>，可以清除浮动。这会使父容器成为一个 BFC（块级格式化上下文），从而包裹浮动元素。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">htmlCopy code&lt;style&gt;</span><br><span class="line">  .container &#123;</span><br><span class="line">    overflow: hidden; /* 或 overflow: auto; */</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;float-box&quot;&gt;浮动元素&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p><strong>4. 使用 flex 布局：</strong> 使用 CSS3 的 Flexbox 布局也可以解决浮动问题，因为 Flexbox 不需要浮动元素。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">htmlCopy code&lt;style&gt;</span><br><span class="line">  .container &#123;</span><br><span class="line">    display: flex;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;float-box&quot;&gt;浮动元素&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>以上方法都可以清除浮动并使父容器正确包裹浮动元素。选择合适的方法取决于具体的布局需求和兼容性考虑。在现代 Web 开发中，通常使用 <code>clearfix</code> 类或 Flexbox 布局来清除浮动。</p><h4 id="30-CSS-动画如何实现"><a href="#30-CSS-动画如何实现" class="headerlink" title="30.CSS 动画如何实现"></a>30.CSS 动画如何实现</h4><p>CSS 动画可以通过使用 <code>@keyframes</code> 规则和 CSS 的动画属性来实现。以下是实现 CSS 动画的步骤：</p><ol><li><strong>定义关键帧（Keyframes）：</strong> 使用 <code>@keyframes</code> 规则来定义动画的关键帧。关键帧是动画的每个阶段的样式状态。在关键帧中，你可以指定元素在动画开始、中间和结束时的样式。</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@keyframes myAnimation &#123;</span><br><span class="line">  0% &#123; /* 动画开始时的样式 */ &#125;</span><br><span class="line">  50% &#123; /* 动画中间时的样式 */ &#125;</span><br><span class="line">  100% &#123; /* 动画结束时的样式 */ &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>应用动画属性：</strong> 使用 CSS 的动画属性来将定义好的关键帧应用到元素上。</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.element &#123;</span><br><span class="line">  animation-name: myAnimation; /* 指定动画关键帧的名称 */</span><br><span class="line">  animation-duration: 2s; /* 指定动画的持续时间 */</span><br><span class="line">  animation-timing-function: ease; /* 指定动画的时间函数（速度曲线），可选值：ease、linear、ease-in、ease-out、ease-in-out 等 */</span><br><span class="line">  animation-delay: 0s; /* 指定动画延迟开始的时间 */</span><br><span class="line">  animation-iteration-count: infinite; /* 指定动画的循环次数，可以是数字或关键词：infinite（无限循环） */</span><br><span class="line">  animation-direction: normal; /* 指定动画的播放方向，可选值：normal（正向）、reverse（反向）、alternate（交替）等 */</span><br><span class="line">  animation-fill-mode: forwards; /* 指定动画结束时元素的样式状态，可选值：none、forwards、backwards、both */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>触发动画：</strong> 一旦定义了关键帧和应用了动画属性，动画就会在满足触发条件时开始。常见的触发方式有：</li></ol><ul><li>使用 <code>animation</code> 属性的 <code>animation-play-state</code> 设置为 <code>running</code> 或 <code>paused</code> 来控制动画的播放和暂停。</li><li>使用 JavaScript 来动态添加或移除类名，从而触发动画。</li></ul><p>上述步骤可以实现简单的 CSS 动画效果。通过调整关键帧的样式和动画属性的设置，可以实现更复杂和多样化的动画效果。</p><h4 id="31-如何实现在某个容器中居中的"><a href="#31-如何实现在某个容器中居中的" class="headerlink" title="31.如何实现在某个容器中居中的?"></a>31.如何实现在某个容器中居中的?</h4><p>要实现在某个容器中居中元素，可以采用以下几种方法：</p><p><strong>1. 使用 Flexbox 布局：</strong> 使用 CSS Flexbox 布局是一种简单而强大的居中方法。将容器的 <code>display</code> 属性设置为 <code>flex</code>，并添加 <code>align-items: center; justify-content: center;</code>，即可使容器内部的元素在水平和垂直方向上居中。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">  display: flex;</span><br><span class="line">  align-items: center;</span><br><span class="line">  justify-content: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 使用绝对定位：</strong> 通过将要居中的元素设置为绝对定位，并使用 <code>top</code>、<code>bottom</code>、<code>left</code>、<code>right</code> 属性来将元素定位在容器中间。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">  position: relative;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.centered-element &#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">  top: 50%;</span><br><span class="line">  left: 50%;</span><br><span class="line">  transform: translate(-50%, -50%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3. 使用 Grid 布局：</strong> 利用 CSS Grid 布局也可以实现元素居中。将容器的 <code>display</code> 属性设置为 <code>grid</code>，并使用 <code>place-items: center;</code> 属性来将元素居中。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">  display: grid;</span><br><span class="line">  place-items: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4. 使用文本对齐：</strong> 对于内联元素（如文本或行内元素），可以使用 <code>text-align: center;</code> 将文本在容器中水平居中。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">  text-align: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上方法都可以让元素在其容器中居中。根据具体需求和布局情况，选择适合的方法即可。</p><h4 id="32-如何改变一个DOM元素的字体颜色"><a href="#32-如何改变一个DOM元素的字体颜色" class="headerlink" title="32.如何改变一个DOM元素的字体颜色?"></a>32.如何改变一个DOM元素的字体颜色?</h4><p>要改变一个 DOM 元素的字体颜色，可以通过 CSS 或 JavaScript 来实现。以下是两种常用的方法：</p><p><strong>1. 使用 CSS：</strong> 可以使用 CSS 的 <code>color</code> 属性来改变元素的字体颜色。将需要改变字体颜色的元素的 CSS <code>color</code> 属性设置为所需的颜色值即可。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* 在样式表中设置元素字体颜色 */</span><br><span class="line">.element &#123;</span><br><span class="line">  color: red; /* 将元素的字体颜色设置为红色 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 使用 JavaScript：</strong> 如果希望在特定事件触发时改变元素的字体颜色，可以使用 JavaScript 来动态修改元素的样式。例如，使用 JavaScript 的 <code>style</code> 属性来设置元素的 <code>color</code> 属性。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- HTML --&gt;</span><br><span class="line">&lt;div id=&quot;myElement&quot;&gt;这是一个文本&lt;/div&gt;</span><br><span class="line">&lt;button onclick=&quot;changeColor()&quot;&gt;改变颜色&lt;/button&gt;</span><br><span class="line">// JavaScript</span><br><span class="line">function changeColor() &#123;</span><br><span class="line">  var element = document.getElementById(&#x27;myElement&#x27;);</span><br><span class="line">  element.style.color = &#x27;blue&#x27;; // 将元素的字体颜色设置为蓝色</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上两种方法都可以实现改变元素的字体颜色。如果需要实现动态效果，可以使用 JavaScript 在特定事件触发时改变元素样式。如果只是静态改变，直接使用 CSS 的 <code>color</code> 属性即可。</p><h4 id="33-相对布局和绝对布局，position-relative-和obsolute"><a href="#33-相对布局和绝对布局，position-relative-和obsolute" class="headerlink" title="33.相对布局和绝对布局，position:relative 和obsolute"></a>33.相对布局和绝对布局，position:relative 和obsolute</h4><p>相对布局（<code>position: relative</code>）和绝对布局（<code>position: absolute</code>）是 CSS 中两种常见的定位方式，它们用于控制元素在文档流中的位置。</p><p><strong>相对布局（position: relative）：</strong></p><ol><li>相对布局会使元素脱离正常的文档流，但它仍然占据原来的空间，其他元素不会填充其位置。</li><li>设置相对布局后，可以通过 <code>top</code>、<code>right</code>、<code>bottom</code> 和 <code>left</code> 属性来相对于元素原来的位置进行偏移。例如，<code>top: 10px; left: 20px;</code> 表示元素相对于原来位置向下偏移 10 像素，向右偏移 20 像素。</li><li>相对布局影响其他元素的布局，其他元素仍会按照相对布局元素的原始位置进行排列。</li></ol><p><strong>绝对布局（position: absolute）：</strong></p><ol><li>绝对布局会使元素完全脱离文档流，并且不占据任何空间，其他元素会填充其位置。</li><li>设置绝对布局后，元素的位置相对于距离它最近的具有定位（position 不是 <code>static</code>）的父元素，如果没有则相对于文档的初始位置进行偏移。</li><li>可以通过 <code>top</code>、<code>right</code>、<code>bottom</code> 和 <code>left</code> 属性来控制元素的位置。</li></ol><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;relative-box&quot;&gt;相对布局&lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;absolute-box&quot;&gt;绝对布局&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">.container &#123;</span><br><span class="line">  position: relative;</span><br><span class="line">  width: 200px;</span><br><span class="line">  height: 200px;</span><br><span class="line">  border: 1px solid black;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.relative-box &#123;</span><br><span class="line">  position: relative;</span><br><span class="line">  top: 20px;</span><br><span class="line">  left: 30px;</span><br><span class="line">  background-color: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.absolute-box &#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">  top: 50px;</span><br><span class="line">  left: 100px;</span><br><span class="line">  background-color: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述示例中，<code>.relative-box</code> 采用相对布局，并相对于原来位置向下偏移 20 像素、向右偏移 30 像素。<code>.absolute-box</code> 采用绝对布局，并相对于父元素 <code>.container</code> 向下偏移 50 像素、向右偏移 100 像素。可以观察到 <code>.absolute-box</code> 完全脱离了文档流，而 <code>.relative-box</code> 仍然占据了原来的空间。</p><h4 id="34-什么是弹性盒子flex布局"><a href="#34-什么是弹性盒子flex布局" class="headerlink" title="34.什么是弹性盒子flex布局?"></a>34.什么是弹性盒子flex布局?</h4><p>弹性盒子（Flexbox）布局是 CSS3 引入的一种用于页面布局的模型，旨在提供更加灵活和方便的布局方式。Flexbox 可以使元素在容器内部自由地伸缩、对齐和重新排列，从而实现适应不同屏幕尺寸和设备的响应式布局。</p><p>Flexbox 的主要特点包括以下几个方面：</p><ol><li><strong>主轴和交叉轴：</strong> Flexbox 布局使用一个主轴和一个交叉轴。主轴是元素的排列方向，可以是水平方向（水平主轴）或垂直方向（垂直主轴）。交叉轴是与主轴垂直的轴线。</li><li><strong>容器和项目：</strong> Flexbox 的布局模型中，容器（Container）是指应用了 Flexbox 的元素，它的 <code>display</code> 属性设置为 <code>flex</code> 或 <code>inline-flex</code>。容器内部的每个子元素都是项目（Item），也称为弹性项目。</li><li><strong>弹性容器属性：</strong> 容器具有一系列属性，用于控制容器内项目的布局方式。常用的容器属性包括：<code>flex-direction</code>（决定主轴的方向）、<code>justify-content</code>（主轴上项目的对齐方式）、<code>align-items</code>（交叉轴上项目的对齐方式）、<code>flex-wrap</code>（项目换行方式）等。</li><li><strong>弹性项目属性：</strong> 项目也具有一系列属性，用于控制项目自身在容器内的布局。常用的项目属性包括：<code>flex</code>（设置项目的伸缩比例）、<code>flex-basis</code>（项目在主轴上的初始大小）、<code>align-self</code>（设置项目在交叉轴上的对齐方式）等。</li></ol><p>使用 Flexbox 布局可以轻松实现水平和垂直居中、等高列布局、自适应布局等复杂的页面结构，减少了传统布局中需要使用大量浮动和定位的情况，使页面的布局更加直观、简单和灵活。因此，Flexbox 布局在现代 Web 开发中得到了广泛的应用。</p><h4 id="35-什么是rem布局"><a href="#35-什么是rem布局" class="headerlink" title="35.什么是rem布局?"></a>35.什么是rem布局?</h4><p><code>rem</code> 布局是一种相对于根元素（通常指 <code>&lt;html&gt;</code> 元素）字体大小的布局方式。在 <code>rem</code> 布局中，页面中的元素尺寸和间距都使用相对于根元素的字体大小来表示，而不是使用固定的像素值。这样可以实现页面元素的动态缩放，适应不同屏幕尺寸和设备。</p><p>在 <code>rem</code> 布局中，一般会将根元素的字体大小设置为一个相对于屏幕宽度的百分比，通常是使用CSS中的<code>vw</code>（视窗宽度）单位来设置。然后，其他元素的尺寸和间距都使用<code>rem</code> 单位来表示。</p><p>例如，假设我们将根元素的字体大小设置为 <code>1vw</code>，并假设设计稿的宽度为 <code>750px</code>。那么 <code>1rem</code> 就等于 <code>7.5px</code>（即 <code>750px * 1vw</code>）。然后，如果我们希望某个元素的宽度为设计稿中的 <code>150px</code>，可以将其设置为 <code>20rem</code>（即 <code>150px / 7.5px</code>）。</p><p>优点：</p><ul><li><code>rem</code> 布局能够实现页面的动态缩放，适应不同屏幕和设备，提供更好的响应式体验。</li><li>可以方便地在不同设备上调整根元素字体大小来适应不同屏幕尺寸。</li></ul><p>注意：</p><ul><li>使用 <code>rem</code> 布局时，需要合理设置根元素字体大小，避免页面元素过小或过大。</li><li>在某些老旧浏览器中，对 <code>rem</code> 单位的支持可能有限，需做相应兼容处理。</li></ul><p>综上所述，<code>rem</code> 布局是一种相对于根元素字体大小的动态布局方式，可以提供更好的响应式体验。</p><h4 id="36-less和scss有什么区别"><a href="#36-less和scss有什么区别" class="headerlink" title="36.less和scss有什么区别?"></a>36.less和scss有什么区别?</h4><p>LESS（Leaner Style Sheets）和 SCSS（Sassy CSS）都是 CSS 预处理器，它们在功能和语法上有一些区别，但目的都是为了增强 CSS 的功能并提高开发效率。</p><p><strong>LESS：</strong></p><ol><li><strong>语法：</strong> LESS 使用较为简洁的语法，使用大括号 <code>&#123;&#125;</code> 和分号 <code>;</code> 来表示代码块和语句。</li><li><strong>变量：</strong> LESS 使用 <code>@</code> 符号来定义变量，例如 <code>@color: #ff0000;</code>。</li><li><strong>嵌套规则：</strong> 可以在 LESS 中嵌套 CSS 规则，使代码结构更清晰。</li><li><strong>混合（Mixins）：</strong> LESS 支持混合功能，允许将一组样式混合到另一个选择器中。</li><li><strong>运算：</strong> LESS 允许进行简单的数学运算，如加法、减法等。</li><li><strong>导入：</strong> 可以使用 <code>@import</code> 指令引入其他 LESS 文件。</li></ol><p><strong>SCSS：</strong></p><ol><li><strong>语法：</strong> SCSS 使用与 CSS 相似的语法，使用大括号 <code>&#123;&#125;</code> 和分号 <code>;</code> 表示代码块和语句。</li><li><strong>变量：</strong> SCSS 也使用 <code>@</code> 符号来定义变量，与 LESS 类似，例如 <code>$color: #ff0000;</code>。</li><li><strong>嵌套规则：</strong> 与 LESS 类似，SCSS 也支持在选择器中嵌套其他规则。</li><li><strong>混合（Mixins）：</strong> SCSS 支持混合功能，使用 <code>@mixin</code> 和 <code>@include</code> 来定义和调用混合。</li><li><strong>运算：</strong> 与 LESS 类似，SCSS 也允许进行数学运算。</li><li><strong>导入：</strong> 可以使用 <code>@import</code> 指令引入其他 SCSS 文件。</li></ol><p><strong>区别总结：</strong></p><ul><li>LESS 和 SCSS 的语法风格有所不同，LESS 更加简洁，SCSS 更接近于标准的 CSS。</li><li>变量、嵌套规则、混合等功能在两者中都有支持，但语法稍有差异。</li><li>选择使用 LESS 还是 SCSS 取决于个人偏好和项目需求。两者功能基本上相似，选择一种熟悉且适合团队的预处理器即可。</li></ul><h4 id="37-before-和-after中双冒号和单冒号的区别"><a href="#37-before-和-after中双冒号和单冒号的区别" class="headerlink" title="37.::before 和::after中双冒号和单冒号的区别?"></a>37.::before 和::after中双冒号和单冒号的区别?</h4><p>在 CSS 中，<code>::before</code> 和 <code>::after</code> 是伪元素（pseudo-elements），用于在元素的内容前面或后面插入生成的内容。它们的双冒号和单冒号表示方式有一些历史和语法上的区别：</p><ol><li><strong>双冒号（<code>::</code>）：</strong><ul><li><code>::before</code> 和 <code>::after</code> 使用双冒号 <code>::</code> 表示伪元素的写法，这是 CSS3 引入的新语法。</li><li>根据 CSS3 标准，伪元素应该使用双冒号 <code>::</code> 表示。</li></ul></li><li><strong>单冒号（<code>:</code>）：</strong><ul><li>在旧的 CSS2 规范中，伪元素使用单冒号 <code>:</code> 表示，例如 <code>:before</code> 和 <code>:after</code>。</li><li>单冒号的写法在 CSS3 中仍然被广泛支持，用于保持对旧浏览器的兼容性。</li></ul></li></ol><p>所以，使用 <code>::before</code> 和 <code>::after</code> 是更加符合当前 CSS3 标准的写法，但在实际使用中，为了兼容性考虑，可以继续使用 <code>:before</code> 和 <code>:after</code> 这样的单冒号写法。</p><p>例如，创建一个在元素内容前插入文本的伪元素样式：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* 使用双冒号的写法（CSS3标准） */</span><br><span class="line">.element::before &#123;</span><br><span class="line">  content: &quot;前置内容&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 使用单冒号的写法（兼容旧浏览器） */</span><br><span class="line">.element:before &#123;</span><br><span class="line">  content: &quot;前置内容&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无论使用双冒号还是单冒号，它们的功能都是一样的，只是写法上存在细微的差别。建议在项目中根据实际需求和兼容性考虑选择合适的写法。</p><h4 id="38-CSS3新增伪类，以及伪元素"><a href="#38-CSS3新增伪类，以及伪元素" class="headerlink" title="38.CSS3新增伪类，以及伪元素?"></a>38.CSS3新增伪类，以及伪元素?</h4><p>CSS3引入了一些新的伪类和伪元素，让开发者在样式表中更加灵活和精确地选择和样式化HTML元素。以下是CSS3新增的一些伪类和伪元素：</p><p><strong>伪类（Pseudo-classes）：</strong></p><ol><li><code>:nth-child(n)</code>：选择其父元素下的第 n 个子元素。可以用来实现奇偶行效果。</li><li><code>:nth-last-child(n)</code>：选择其父元素下的倒数第 n 个子元素。</li><li><code>:first-child</code>：选择其父元素下的第一个子元素。</li><li><code>:last-child</code>：选择其父元素下的最后一个子元素。</li><li><code>:only-child</code>：选择其父元素下仅有的一个子元素。</li><li><code>:not(selector)</code>：选择不匹配给定选择器的元素。</li><li><code>:checked</code>：选择已选中的表单元素，例如复选框或单选按钮。</li><li><code>:focus</code>：选择当前获取焦点的元素。</li><li><code>:hover</code>：选择鼠标悬停在其上的元素。</li><li><code>:active</code>：选择当前正在被激活（鼠标按下还未释放）的元素。</li></ol><p><strong>伪元素（Pseudo-elements）：</strong></p><ol><li><code>::before</code>：在元素的内容之前插入一个伪元素，通常用于添加装饰或图标。</li><li><code>::after</code>：在元素的内容之后插入一个伪元素，同样用于添加装饰或图标。</li><li><code>::first-line</code>：选择元素的第一行文本。</li><li><code>::first-letter</code>：选择元素的第一个字母或字符。</li></ol><p>请注意，伪类和伪元素的语法不同，伪类使用单冒号（<code>:</code>），而伪元素使用双冒号（<code>::</code>）。但为了向后兼容，可以继续使用单冒号来表示伪元素，例如<code>:before</code>和<code>:after</code>。</p><p>这些伪类和伪元素的引入为开发者提供了更多样式化HTML元素的选项和灵活性，使得可以在不添加多余HTML元素的情况下实现一些复杂的样式效果。</p><h4 id="39-响应式布局实现方案"><a href="#39-响应式布局实现方案" class="headerlink" title="39.响应式布局实现方案?"></a>39.响应式布局实现方案?</h4><p>实现响应式布局是为了使网站或应用能够适应不同屏幕尺寸和设备，提供更好的用户体验。以下是几种常见的响应式布局实现方案：</p><ol><li><p><strong>使用CSS Media Queries：</strong> CSS Media Queries 是一种在CSS中根据不同媒体设备的特性来应用不同样式的机制。通过定义不同的断点（例如：手机、平板、桌面屏幕尺寸），可以针对不同屏幕宽度应用不同的样式，从而实现响应式布局。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* 媒体查询，适用于小屏幕（手机） */</span><br><span class="line">@media screen and (max-width: 768px) &#123;</span><br><span class="line">  /* 在这里定义适合小屏幕的样式 */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 媒体查询，适用于中等屏幕（平板） */</span><br><span class="line">@media screen and (min-width: 769px) and (max-width: 1024px) &#123;</span><br><span class="line">  /* 在这里定义适合中等屏幕的样式 */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 媒体查询，适用于大屏幕（桌面） */</span><br><span class="line">@media screen and (min-width: 1025px) &#123;</span><br><span class="line">  /* 在这里定义适合大屏幕的样式 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>使用CSS Flexbox：</strong> CSS Flexbox 是一种弹性布局模型，可以快速简单地实现响应式布局。通过设置容器的 <code>display: flex</code> 属性，子元素可以根据可用空间自动调整布局。这对于创建适应不同屏幕大小的灵活布局非常有用。</p></li><li><p><strong>使用CSS Grid：</strong> CSS Grid 是一种二维网格布局系统，也是一种强大的响应式布局工具。它允许开发者以网格形式对元素进行定位和对齐，可以在网格的不同单元格中自由地进行布局调整。</p></li><li><p><strong>使用流式布局（Fluid Layout）：</strong> 流式布局是一种基于百分比单位的布局方法，可以让元素的宽度和高度随着屏幕大小的变化而自动调整。使用百分比单位来设置元素的宽度，使其在不同屏幕上具有相对的大小。</p></li><li><p><strong>使用CSS预处理器：</strong> 使用CSS预处理器（如Sass、Less）可以更加方便地管理和组织响应式布局样式。通过定义变量和混合（Mixin），可以简化媒体查询的书写，提高代码的可维护性。</p></li></ol><p>无论采用哪种方案，响应式布局都应该考虑各种屏幕尺寸和设备，并确保在不同分辨率下都能提供良好的用户体验。同时，还可以通过测试和调试来验证响应式布局的效果，并确保在不同设备上显示正常。</p><h4 id="40-link-标签和import标签的区别"><a href="#40-link-标签和import标签的区别" class="headerlink" title="40.link 标签和import标签的区别?"></a>40.link 标签和import标签的区别?</h4><p><code>&lt;link&gt;</code>标签和<code>&lt;import&gt;</code>标签是用于在HTML文档中引入外部资源的两种方式，但它们有一些区别和应用场景：</p><p><strong><code>&lt;link&gt;</code>标签：</strong></p><ul><li><code>&lt;link&gt;</code>标签是HTML中的常规标签，主要用于引入外部资源，比如CSS样式表或图标字体等。</li><li>通过<code>&lt;link&gt;</code>标签引入的资源是并行加载的，即在浏览器解析HTML时，会同时发起多个请求去加载所有引入的资源。</li><li>适用于引入CSS样式表，因为CSS文件的加载不会阻塞DOM的解析，可以并行加载多个CSS文件，从而提高页面加载速度。</li></ul><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;styles.css&quot;&gt;</span><br></pre></td></tr></table></figure><p><strong><code>&lt;import&gt;</code>标签：</strong></p><ul><li><code>&lt;import&gt;</code>标签是HTML的扩展标签，在使用Web Components时才会用到。</li><li><code>&lt;import&gt;</code>标签用于引入外部的HTML模块，这些模块可以包含自定义元素、样式和脚本等，形成一个封闭的组件。</li><li>通过<code>&lt;import&gt;</code>标签引入的HTML模块是串行加载的，即需要等待引入的模块完全加载和解析后才能继续解析后续内容。</li><li>适用于使用Web Components构建复杂组件化的应用。</li></ul><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;import src=&quot;component.html&quot;&gt;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ol><li><code>&lt;import&gt;</code>标签现在已经被废弃，不建议再使用，推荐使用ES6的<code>import</code>语句来引入模块。</li><li>在现代的前端开发中，通常使用<code>&lt;link&gt;</code>标签来引入CSS样式表，使用<code>&lt;script&gt;</code>标签来引入JavaScript脚本，而使用模块化的方式（如ES6的<code>import</code>语句或模块打包工具）来引入JavaScript模块。</li></ol><p>总结起来，<code>&lt;link&gt;</code>标签主要用于引入CSS样式表和外部资源，而<code>&lt;import&gt;</code>标签是HTML的扩展标签，用于引入HTML模块，但在现代开发中已经被废弃，推荐使用其他方式进行模块化的引入。</p><h4 id="41-transition-和animation-的区别"><a href="#41-transition-和animation-的区别" class="headerlink" title="41.transition 和animation 的区别?"></a>41.transition 和animation 的区别?</h4><p><code>transition</code> 和 <code>animation</code> 是两种用于实现元素动画效果的CSS属性，它们有以下区别：</p><p><strong>1. 触发方式：</strong></p><ul><li><code>transition</code>：通常由CSS属性的变化触发，比如当元素的颜色、大小、位置等属性发生变化时，可以使用 <code>transition</code> 属性来平滑地过渡到新的状态。</li><li><code>animation</code>：在<code>animation</code>中，动画的触发可以通过CSS关键帧的定义，或者通过JavaScript动态添加类来触发。</li></ul><p><strong>2. 实现方式：</strong></p><ul><li><code>transition</code>：通过定义元素的起始状态和结束状态，并设置过渡时间和过渡函数（timing function）来实现动画效果。</li><li><code>animation</code>：通过定义关键帧（Keyframes），指定元素在不同阶段的样式状态，以及动画的持续时间、循环次数等来实现动画效果。</li></ul><p><strong>3. 动画的控制：</strong></p><ul><li><code>transition</code>：过渡动画是受元素属性的变化控制的，一旦触发属性变化，过渡就会自动执行。</li><li><code>animation</code>：动画可以通过添加、移除类或者通过JavaScript来控制启动和停止。</li></ul><p><strong>4. 多步动画：</strong></p><ul><li><code>transition</code>：<code>transition</code> 属性通常只能实现简单的单步过渡，从一个状态平滑过渡到另一个状态。</li><li><code>animation</code>：<code>animation</code> 属性可以定义复杂的多步动画，通过关键帧的方式在不同的时间点指定不同的样式状态。</li></ul><p><strong>5. 浏览器支持：</strong></p><ul><li><code>transition</code> 和 <code>animation</code> 属性都得到了广泛支持，但某些旧版本的浏览器可能对一些属性和特性的支持有限。</li></ul><p><strong>总结：</strong></p><ul><li><code>transition</code> 适用于简单的属性过渡，比如颜色、大小、位置等的平滑过渡。</li><li><code>animation</code> 适用于复杂的多步动画，可以定义更多样化的动画效果，同时提供更灵活的控制方式。</li></ul><p>在实际应用中，可以根据动画的复杂程度和控制需求来选择使用 <code>transition</code> 还是 <code>animation</code>，有时也可以结合两者来实现更复杂、更丰富的动画效果。</p><h4 id="42-说一下块元素、行元素、置换元素"><a href="#42-说一下块元素、行元素、置换元素" class="headerlink" title="42.说一下块元素、行元素、置换元素"></a>42.说一下块元素、行元素、置换元素</h4><p>在HTML和CSS中，元素可以分为块元素（Block-level Elements）、行元素（Inline Elements）和置换元素（Replaced Elements）三类，这些类型决定了元素在文档流中的显示方式和行为。</p><p><strong>块元素（Block-level Elements）：</strong></p><ol><li>块元素独占一行，会自动换行，并且默认情况下会撑满其父元素的宽度。</li><li>常见的块元素包括<code>&lt;div&gt;</code>、<code>&lt;p&gt;</code>、<code>&lt;h1&gt;</code>～<code>&lt;h6&gt;</code>、<code>&lt;ul&gt;</code>、<code>&lt;ol&gt;</code>、<code>&lt;li&gt;</code>等。</li><li>块元素可以包含其他块元素和行元素。</li></ol><p><strong>行元素（Inline Elements）：</strong></p><ol><li>行元素不会独占一行，它们会在一行内根据其内容排列，并不会强制换行。</li><li>常见的行元素包括<code>&lt;span&gt;</code>、<code>&lt;a&gt;</code>、<code>&lt;img&gt;</code>、<code>&lt;strong&gt;</code>、<code>&lt;em&gt;</code>等。</li><li>行元素只能包含其他行元素或文本，不能包含块元素。</li></ol><p><strong>置换元素（Replaced Elements）：</strong></p><ol><li>置换元素是一种特殊类型的元素，其内容由外部资源决定，而不是由元素自身的内容决定。</li><li>典型的置换元素包括<code>&lt;img&gt;</code>、<code>&lt;input&gt;</code>、<code>&lt;video&gt;</code>、<code>&lt;audio&gt;</code>等，它们的内容是由其<code>src</code>、<code>type</code>等属性所指定的外部资源。</li><li>置换元素通常具有内在尺寸，比如<code>&lt;img&gt;</code>元素的宽度和高度，但可以通过CSS来调整其显示大小。</li></ol><p>需要注意的是，HTML5中的规范有所更新，增加了一些灵活性。例如，<code>&lt;a&gt;</code>元素在HTML4中是行元素，但在HTML5中可以同时具备行元素和块元素的特性，因此可以在其内部包含块级元素。</p><p>理解块元素、行元素和置换元素的区别对于控制元素的布局和样式非常重要，同时也有助于优化页面结构和样式设计。</p><h4 id="43-多行元素的文本省略号如何实现？"><a href="#43-多行元素的文本省略号如何实现？" class="headerlink" title="43.多行元素的文本省略号如何实现？"></a>43.多行元素的文本省略号如何实现？</h4><p>在CSS中，可以通过使用<code>text-overflow</code>属性和<code>white-space</code>属性来实现多行元素文本的省略号。以下是实现多行文本省略号的步骤：</p><ol><li><strong>设置容器的高度和<code>overflow</code>属性：</strong> 首先，将多行文本的容器设置一个固定的高度，并将<code>overflow</code>属性设置为<code>hidden</code>，这样超出容器高度的文本将被隐藏。</li><li><strong>设置<code>white-space</code>属性：</strong> 将容器的<code>white-space</code>属性设置为<code>nowrap</code>，这样文本将在一行中显示，不会换行。</li><li><strong>设置<code>text-overflow</code>属性：</strong> 使用<code>text-overflow: ellipsis</code>来在文本溢出容器时显示省略号。</li></ol><p>下面是一个示例的CSS样式：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">  height: 60px; /* 设置容器高度 */</span><br><span class="line">  overflow: hidden; /* 隐藏超出容器高度的内容 */</span><br><span class="line">  white-space: nowrap; /* 文本不换行 */</span><br><span class="line">  text-overflow: ellipsis; /* 显示省略号 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，将上述样式应用到包含文本的容器中，这样就能实现多行文本的省略号效果。请注意，这种方法适用于单行文本超出容器高度的情况。</p><p>如果希望实现多行文本的省略号，可以结合使用CSS的<code>display: -webkit-box</code> 和 <code>-webkit-line-clamp</code>属性，但这些属性在一些浏览器中的支持可能不稳定。以下是示例代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">  display: -webkit-box;</span><br><span class="line">  -webkit-line-clamp: 3; /* 设置显示的最大行数 */</span><br><span class="line">  -webkit-box-orient: vertical;</span><br><span class="line">  overflow: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码将文本限制在3行，并在超出时显示省略号。请注意，<code>-webkit-line-clamp</code>属性可能不被所有浏览器支持，而且它是一个非标准的CSS属性。因此，在实际使用时，请谨慎考虑兼容性。</p><h4 id="44-Doctype-作用？严格模式与混杂模式如何区分？它们有何意义？"><a href="#44-Doctype-作用？严格模式与混杂模式如何区分？它们有何意义？" class="headerlink" title="44.Doctype 作用？严格模式与混杂模式如何区分？它们有何意义？"></a>44.Doctype 作用？严格模式与混杂模式如何区分？它们有何意义？</h4><p><code>DOCTYPE</code>（文档类型声明）是HTML文档中的一个特殊标记，用于指示浏览器使用哪种HTML版本解析页面。它的作用是告诉浏览器以何种模式来渲染文档，以确保页面在不同浏览器中的显示一致性。</p><p><strong>严格模式（Strict Mode）：</strong></p><ul><li>在严格模式下，浏览器会按照HTML规范的严格标准解析和渲染页面。</li><li>要进入严格模式，需要在HTML文档的开头添加以下DOCTYPE声明：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br></pre></td></tr></table></figure><p><strong>混杂模式（Quirks Mode）：</strong></p><ul><li>在混杂模式下，浏览器会以一种与HTML规范不完全兼容的方式解析和渲染页面。</li><li>如果HTML文档中没有正确声明DOCTYPE，或者声明了过时的DOCTYPE（比如HTML 4.01的DTD声明），浏览器将进入混杂模式。</li></ul><p><strong>意义：</strong> 正确使用DOCTYPE声明非常重要，它对页面的渲染和布局产生直接影响。主要意义如下：</p><ol><li><strong>确定页面渲染模式：</strong> DOCTYPE声明告诉浏览器应该使用哪种渲染模式，是严格模式还是混杂模式。</li><li><strong>确保跨浏览器兼容性：</strong> 使用正确的DOCTYPE声明可以确保页面在不同浏览器中以相同的方式显示，避免兼容性问题。</li><li><strong>遵循标准规范：</strong> 在严格模式下，浏览器会更严格地按照HTML和CSS规范解析页面，从而避免一些奇怪的行为和布局问题。</li></ol><p>总之，DOCTYPE声明在HTML文档中的重要性不可忽视。始终建议使用<code>&lt;!DOCTYPE html&gt;</code>声明进入严格模式，并编写符合标准规范的HTML代码，以确保最佳的跨浏览器兼容性和一致的页面渲染效果。</p><h4 id="45-css中制作动画为什么人们用translate来改变位置而不是定位？"><a href="#45-css中制作动画为什么人们用translate来改变位置而不是定位？" class="headerlink" title="45.css中制作动画为什么人们用translate来改变位置而不是定位？"></a>45.css中制作动画为什么人们用translate来改变位置而不是定位？</h4><p>1.translate（）是transfrom的一个值。改变transfrom或者opacity不会触发浏览器重新布局（reflow）或重绘（repaint），只会触发复合（compositions）。</p><p>2.改变绝对定位会触发重新布局，进而触发重绘和复合。</p><p>3.transfrom使浏览器为元素创建一个GPU。但改变绝对定位会使用到GPU。因此translate（）更高效，可以缩短平滑动画的绘制时间。</p><p>4.translate改变位置时，元素依旧会占据其原始空间，绝对定位不是。</p><h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><h4 id="1-javascript-的数据类型有哪些"><a href="#1-javascript-的数据类型有哪些" class="headerlink" title="1.javascript 的数据类型有哪些?"></a>1.javascript 的数据类型有哪些?</h4><p>在 JavaScript 中，数据类型主要分为两类：基本数据类型（Primitive Data Types）和引用数据类型（Reference Data Types）。以下是 JavaScript 的数据类型：</p><p><strong>1. 基本数据类型（Primitive Data Types）：</strong></p><ul><li><strong>Number（数字）：</strong> 整数或浮点数，如 <code>1</code>、<code>3.14</code> 等。</li><li><strong>String（字符串）：</strong> 由字符组成的文本，用单引号 <code>&#39;</code> 或双引号 <code>&quot;</code> 括起来，如 <code>&#39;Hello&#39;</code>、<code>&quot;JavaScript&quot;</code> 等。</li><li><strong>Boolean（布尔值）：</strong> 表示真（<code>true</code>）或假（<code>false</code>）。</li><li><strong>Undefined（未定义）：</strong> 表示声明了变量但没有赋值的情况，或访问不存在的属性。</li><li><strong>Null（空值）：</strong> 表示空值或不存在的对象。</li><li><strong>Symbol（符号）：</strong> ES6 中新增的数据类型，表示唯一的、不可变的值，用于对象属性的键。</li></ul><p><strong>2. 引用数据类型（Reference Data Types）：</strong></p><ul><li><strong>Object（对象）：</strong> 复杂数据类型，表示一组键值对的集合，可以是普通对象、数组、函数等。</li><li><strong>Array（数组）：</strong> 特殊类型的对象，以数字为索引，按顺序存储多个值。</li><li><strong>Function（函数）：</strong> 一种特殊的对象，具有可执行的代码块。</li><li><strong>Date（日期）：</strong> 表示日期和时间的对象。</li><li><strong>RegExp（正则表达式）：</strong> 表示正则表达式的对象，用于字符串匹配和替换。</li><li><strong>Map、Set、WeakMap、WeakSet：</strong> ES6 中新增的数据类型，用于更高级的数据存储和操作。</li></ul><p>JavaScript 是一种动态类型的语言，变量的数据类型在运行时可以改变。同时，JavaScript 也是一种弱类型的语言，可以自动进行类型转换。例如，将数字类型的变量与字符串类型的变量相加，JavaScript 会自动将数字转换为字符串并拼接在一起。</p><h4 id="2-javascript-有哪些引用类型"><a href="#2-javascript-有哪些引用类型" class="headerlink" title="2.javascript 有哪些引用类型?"></a>2.javascript 有哪些引用类型?</h4><p>JavaScript 中的引用类型（Reference Data Types）包括以下几种：</p><ol><li><strong>Object（对象）：</strong> 对象是 JavaScript 中最常见的引用类型。它是一种复杂数据类型，表示一组键值对的集合。对象可以包含多个属性，每个属性由键（属性名）和值（属性值）组成。对象可以通过字面量表示法或构造函数创建。</li><li><strong>Array（数组）：</strong> 数组是特殊类型的对象，用于以数字为索引按顺序存储多个值。数组可以包含任意数据类型的元素，长度可以动态调整。</li><li><strong>Function（函数）：</strong> 函数也是一种特殊类型的对象，具有可执行的代码块。函数可以接收参数，并返回一个值。JavaScript 中的函数是一等公民，可以像其他数据类型一样进行赋值、传递和返回。</li><li><strong>Date（日期）：</strong> Date 对象用于表示日期和时间。它允许操作日期、时间和与日期相关的计算。</li><li><strong>RegExp（正则表达式）：</strong> RegExp 对象用于表示正则表达式。它用于在字符串中进行模式匹配和替换。</li><li><strong>Map、Set、WeakMap、WeakSet：</strong> ES6 中新增的数据类型。Map 是一种键值对集合，可以使用任意类型的值作为键；Set 是一种值的集合，不允许重复值；WeakMap 和 WeakSet 是一种弱引用集合，不会阻止其引用对象被垃圾回收。</li></ol><p>除了基本数据类型（Number、String、Boolean、Undefined、Null 和 Symbol），其余的数据类型都属于引用类型。引用类型的值保存在堆内存中，并通过引用的方式访问和操作。在使用引用类型时，需要注意变量存储的是引用地址，而非实际数据本身。因此，引用类型在传递时是按引用传递的，多个变量可能引用同一个对象，修改其中一个变量会影响其他变量的值。</p><h4 id="3-如何判断javascript的数据类型"><a href="#3-如何判断javascript的数据类型" class="headerlink" title="3.如何判断javascript的数据类型?"></a>3.如何判断javascript的数据类型?</h4><p>在 JavaScript 中，可以使用以下方法来判断数据的类型：</p><ol><li><strong>typeof 运算符：</strong> <code>typeof</code> 是一种用于判断数据类型的运算符。它返回一个表示数据类型的字符串。例如：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">codeconsole.log(typeof 42); // &quot;number&quot;</span><br><span class="line">console.log(typeof &quot;Hello&quot;); // &quot;string&quot;</span><br><span class="line">console.log(typeof true); // &quot;boolean&quot;</span><br><span class="line">console.log(typeof undefined); // &quot;undefined&quot;</span><br><span class="line">console.log(typeof null); // &quot;object&quot; （注意：null 被错误地判断为对象类型，这是 JavaScript 的历史遗留问题）</span><br><span class="line">console.log(typeof &#123;&#125;); // &quot;object&quot;</span><br><span class="line">console.log(typeof []); // &quot;object&quot;</span><br><span class="line">console.log(typeof function() &#123;&#125;); // &quot;function&quot;</span><br></pre></td></tr></table></figure><ol><li><strong>instanceof 运算符：</strong> <code>instanceof</code> 是一种用于判断对象类型的运算符。它检查对象是否属于某个特定类型的构造函数的实例。例如：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">codeconst arr = [];</span><br><span class="line">console.log(arr instanceof Array); // true</span><br><span class="line"></span><br><span class="line">function Person() &#123;&#125;</span><br><span class="line">const person = new Person();</span><br><span class="line">console.log(person instanceof Person); // true</span><br></pre></td></tr></table></figure><ol><li><strong>Array.isArray() 方法：</strong> <code>Array.isArray()</code> 是一种专门用于判断是否为数组的方法，返回一个布尔值。例如：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy codeconsole.log(Array.isArray([])); // true</span><br><span class="line">console.log(Array.isArray(&#123;&#125;)); // false</span><br></pre></td></tr></table></figure><ol><li><strong>Object.prototype.toString.call() 方法：</strong> 这是一种通用的方法，可以判断任意数据类型的具体类型。例如：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">codeconsole.log(Object.prototype.toString.call(42)); // &quot;[object Number]&quot;</span><br><span class="line">console.log(Object.prototype.toString.call(&quot;Hello&quot;)); // &quot;[object String]&quot;</span><br><span class="line">console.log(Object.prototype.toString.call(true)); // &quot;[object Boolean]&quot;</span><br><span class="line">console.log(Object.prototype.toString.call(undefined)); // &quot;[object Undefined]&quot;</span><br><span class="line">console.log(Object.prototype.toString.call(null)); // &quot;[object Null]&quot;</span><br><span class="line">console.log(Object.prototype.toString.call(&#123;&#125;)); // &quot;[object Object]&quot;</span><br><span class="line">console.log(Object.prototype.toString.call([])); // &quot;[object Array]&quot;</span><br><span class="line">console.log(Object.prototype.toString.call(function() &#123;&#125;)); // &quot;[object Function]&quot;</span><br></pre></td></tr></table></figure><p>使用这些方法，可以根据不同的需求来判断 JavaScript 中的数据类型，并进行相应的处理</p><h4 id="4-怎么判断两个对象相等-如何判断空对象"><a href="#4-怎么判断两个对象相等-如何判断空对象" class="headerlink" title="4.怎么判断两个对象相等?如何判断空对象?"></a>4.怎么判断两个对象相等?如何判断空对象?</h4><p>在 JavaScript 中，判断两个对象相等有两种常见的方法：</p><ol><li><strong>浅相等（Shallow Equality）：</strong> 使用 <code>===</code> 或 <code>==</code> 运算符来比较两个对象。如果两个对象的引用地址相同，或者两个对象具有相同的属性和属性值，且属性值也相等，则认为两个对象相等。</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">codeconst obj1 = &#123; name: &quot;Alice&quot;, age: 30 &#125;;</span><br><span class="line">const obj2 = &#123; name: &quot;Alice&quot;, age: 30 &#125;;</span><br><span class="line">console.log(obj1 === obj2); // false，因为 obj1 和 obj2 引用地址不同</span><br><span class="line">console.log(obj1 == obj2); // false，因为 obj1 和 obj2 引用地址不同</span><br><span class="line"></span><br><span class="line">const obj3 = obj1;</span><br><span class="line">console.log(obj1 === obj3); // true，因为 obj3 和 obj1 引用地址相同</span><br><span class="line"></span><br><span class="line">const obj4 = &#123; name: &quot;Alice&quot;, age: 30 &#125;;</span><br><span class="line">console.log(obj1 === obj4); // false，因为 obj1 和 obj4 引用地址不同</span><br><span class="line">console.log(obj1 == obj4); // false，因为 obj1 和 obj4 引用地址不同</span><br><span class="line"></span><br><span class="line">console.log(obj1.name === obj4.name); // true，因为 name 属性的值相同</span><br><span class="line">console.log(obj1.age === obj4.age); // true，因为 age 属性的值相同</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>深相等（Deep Equality）：</strong> 使用深度比较的方法来判断两个对象是否相等，即逐层比较对象的所有属性和属性值。这可以使用递归函数或第三方库（如 Lodash 的 <code>isEqual</code> 方法）来实现。深相等比较会更准确地判断两个对象是否相等，但也可能比较复杂，特别是在对象嵌套层级很深时。</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">codeconst obj1 = &#123; name: &quot;Alice&quot;, age: 30, address: &#123; city: &quot;New York&quot;, zip: 10001 &#125; &#125;;</span><br><span class="line">const obj2 = &#123; name: &quot;Alice&quot;, age: 30, address: &#123; city: &quot;New York&quot;, zip: 10001 &#125; &#125;;</span><br><span class="line"></span><br><span class="line">// 使用递归函数实现深相等比较</span><br><span class="line">function deepEqual(obj1, obj2) &#123;</span><br><span class="line">  if (obj1 === obj2) return true;</span><br><span class="line"></span><br><span class="line">  if (typeof obj1 !== &quot;object&quot; || obj1 === null || typeof obj2 !== &quot;object&quot; || obj2 === null) return false;</span><br><span class="line"></span><br><span class="line">  const keys1 = Object.keys(obj1);</span><br><span class="line">  const keys2 = Object.keys(obj2);</span><br><span class="line"></span><br><span class="line">  if (keys1.length !== keys2.length) return false;</span><br><span class="line"></span><br><span class="line">  for (const key of keys1) &#123;</span><br><span class="line">    if (!keys2.includes(key) || !deepEqual(obj1[key], obj2[key])) &#123;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(deepEqual(obj1, obj2)); // true，因为两个对象的属性和属性值相等</span><br></pre></td></tr></table></figure><p>判断空对象的方法是检查对象是否为空，即对象是否没有任何属性。可以使用 <code>Object.keys()</code> 方法来获取对象的所有属性，并检查属性的数量是否为 0。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">codefunction isEmptyObject(obj) &#123;</span><br><span class="line">  return Object.keys(obj).length === 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const obj1 = &#123; name: &quot;Alice&quot;, age: 30 &#125;;</span><br><span class="line">const obj2 = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">console.log(isEmptyObject(obj1)); // false，因为 obj1 不是空对象</span><br><span class="line">console.log(isEmptyObject(obj2)); // true，因为 obj2 是空对象</span><br></pre></td></tr></table></figure><h4 id="5-0-1-0-2为什么不等于0-3-解释原理"><a href="#5-0-1-0-2为什么不等于0-3-解释原理" class="headerlink" title="5.0.1 + 0.2为什么不等于0.3 ? (解释原理)"></a>5.0.1 + 0.2为什么不等于0.3 ? (解释原理)</h4><p>0.1 和 0.2 不等于 0.3 的现象是因为 JavaScript 中的数字都采用双精度浮点数格式（64位浮点数）来表示，这是一种近似表示法，并且无法精确表示所有的十进制小数。</p><p>在双精度浮点数表示法中，数字被存储为二进制数，而在二进制中，有些小数是无限循环的，例如 0.1 和 0.2，它们在二进制中会出现无限循环小数的情况。当这些无限循环的二进制小数转换回十进制时，会产生微小的舍入误差，导致最终计算结果不精确。</p><p>具体来说：</p><ul><li>0.1 在二进制表示为 0.00011001100110011001100110011001100110011001100110011010…</li><li>0.2 在二进制表示为 0.00110011001100110011001100110011001100110011001100110100…</li></ul><p>当将这些二进制数转换回十进制时，会产生舍入误差，所以在计算 <code>0.1 + 0.2</code> 时，得到的结果是一个近似值：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(0.1 + 0.2); // 0.30000000000000004</span><br></pre></td></tr></table></figure><p>因此，对于涉及十进制小数计算的情况，尤其是涉及金融计算等需要高精度的场景，建议使用专门的库或算法来处理，而不是直接使用 JavaScript 中的浮点数进行计算。例如，可以使用 <code>toFixed()</code> 方法对结果进行舍入，或使用 <code>BigInt</code> 类型处理整数运算。</p><h4 id="6-强制类型转换、隐式类型转换分别是什么，列举场景说明。"><a href="#6-强制类型转换、隐式类型转换分别是什么，列举场景说明。" class="headerlink" title="6.强制类型转换、隐式类型转换分别是什么，列举场景说明。"></a>6.强制类型转换、隐式类型转换分别是什么，列举场景说明。</h4><p>强制类型转换和隐式类型转换都是 JavaScript 中用于处理不同数据类型之间转换的机制。它们的区别在于转换过程是否显式地被开发人员指定。</p><ol><li><p><strong>强制类型转换（Explicit Type Conversion）：</strong> 也称为显式类型转换，是指开发人员明确地通过特定的函数或操作符来将一个数据类型转换为另一个数据类型。开发人员可以在代码中显式地指定类型转换的规则，从而实现需要的转换。常见的强制类型转换方式有：</p><ul><li><code>Number()</code> 函数：将一个值转换为数字类型。</li><li><code>String()</code> 函数：将一个值转换为字符串类型。</li><li><code>Boolean()</code> 函数：将一个值转换为布尔类型。</li><li><code>parseInt()</code> 和 <code>parseFloat()</code> 函数：将一个字符串转换为整数或浮点数类型。</li><li>自定义的类型转换函数：开发人员可以根据需求定义自己的类型转换函数。</li></ul><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy code// 强制将字符串转换为数字</span><br><span class="line">const numStr = &quot;123&quot;;</span><br><span class="line">const num = Number(numStr);</span><br><span class="line"></span><br><span class="line">// 强制将数字转换为字符串</span><br><span class="line">const number = 456;</span><br><span class="line">const str = String(number);</span><br><span class="line"></span><br><span class="line">// 强制将非空字符串转换为布尔值</span><br><span class="line">const strValue = &quot;Hello&quot;;</span><br><span class="line">const boolValue = Boolean(strValue);</span><br><span class="line"></span><br><span class="line">// 使用自定义函数进行类型转换</span><br><span class="line">function customToNumber(value) &#123;</span><br><span class="line">  return Number(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const result = customToNumber(&quot;789&quot;);</span><br></pre></td></tr></table></figure></li><li><p><strong>隐式类型转换（Implicit Type Conversion）：</strong> 也称为自动类型转换，是指在表达式中，JavaScript 引擎自动根据操作符的规则进行类型转换，而无需开发人员明确地指定。隐式类型转换发生在运算符操作、比较操作和逻辑操作等场景中。JavaScript 引擎会根据运算符的规则将操作数转换为合适的数据类型，并返回结果。</p><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy code// 隐式将字符串转换为数字，进行加法运算</span><br><span class="line">const num1 = &quot;10&quot;;</span><br><span class="line">const num2 = 5;</span><br><span class="line">const sum = num1 + num2; // 结果为字符串 &quot;105&quot;</span><br><span class="line"></span><br><span class="line">// 隐式将字符串转换为数字，进行比较操作</span><br><span class="line">const num3 = &quot;15&quot;;</span><br><span class="line">if (num3 &gt; 10) &#123;</span><br><span class="line">  console.log(&quot;num3 is greater than 10&quot;); // 此行代码会执行，因为 &quot;15&quot; 被隐式转换为数字 15，15 大于 10</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 隐式将数字转换为布尔值，进行逻辑操作</span><br><span class="line">const num4 = 0;</span><br><span class="line">if (num4) &#123;</span><br><span class="line">  console.log(&quot;num4 is truthy&quot;); // 此行代码不会执行，因为 0 被隐式转换为布尔值 false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>在实际开发中，了解强制类型转换和隐式类型转换的区别非常重要，可以避免出现意外的结果和错误。同时，在进行类型转换时，应该注意数据的边界情况和可能出现的意外情况，确保转换结果符合预期。</p><h4 id="7-创建函数的几种方式"><a href="#7-创建函数的几种方式" class="headerlink" title="7.创建函数的几种方式?"></a>7.创建函数的几种方式?</h4><p>在 JavaScript 中，有多种方式可以创建函数，以下是常见的几种方式：</p><ol><li><strong>函数声明（Function Declaration）：</strong> 使用 <code>function</code> 关键字声明一个函数，并给函数命名。函数声明在代码执行之前进行了提升，可以在声明之前调用。</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function add(a, b) &#123;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>函数表达式（Function Expression）：</strong> 将一个函数赋值给一个变量，形成一个函数表达式。函数表达式在代码执行到达时进行赋值，必须在赋值后才能调用。</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const add = function(a, b) &#123;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li><strong>箭头函数（Arrow Function）：</strong> ES6 引入的箭头函数是一种更简洁的函数表达式形式，适用于需要短小的函数。</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const add = (a, b) =&gt; a + b;</span><br></pre></td></tr></table></figure><ol><li><strong>Function 构造函数：</strong> 使用 <code>Function</code> 构造函数可以动态地创建函数。它接收一系列参数，最后一个参数为函数体字符串。</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const add = new Function(&quot;a&quot;, &quot;b&quot;, &quot;return a + b&quot;);</span><br></pre></td></tr></table></figure><ol><li><strong>Generator 函数：</strong> Generator 函数是 ES6 中引入的一种特殊函数，可以通过 <code>function*</code> 关键字来声明。</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function * generateNumbers() &#123;</span><br><span class="line">  yield 1;</span><br><span class="line">  yield 2;</span><br><span class="line">  yield 3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>异步函数（Async Function）：</strong> 异步函数是 ES8&#x2F;ES2017 中引入的一种特殊函数，可以通过 <code>async</code> 关键字声明。异步函数内部可以使用 <code>await</code> 关键字来等待异步操作完成。</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">async function fetchData() &#123;</span><br><span class="line">  const response = await fetch(&#x27;https://api.example.com/data&#x27;);</span><br><span class="line">  const data = await response.json();</span><br><span class="line">  return data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上是常见的创建函数的几种方式，选择哪种方式取决于项目需求和个人偏好。一般情况下，函数声明和函数表达式是最常用的方式，而箭头函数则适用于简单的函数体，让代码更简洁易读。</p><h4 id="8-javascript-创建对象的几种方式"><a href="#8-javascript-创建对象的几种方式" class="headerlink" title="8.javascript 创建对象的几种方式?"></a>8.javascript 创建对象的几种方式?</h4><p>在 JavaScript 中，有多种方式可以创建对象，以下是常见的几种方式：</p><ol><li><strong>对象字面量（Object Literal）：</strong> 使用花括号 <code>&#123;&#125;</code> 来定义一个对象，并在其中定义属性和属性值。</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const person = &#123;</span><br><span class="line">  name: &quot;Alice&quot;,</span><br><span class="line">  age: 30,</span><br><span class="line">  gender: &quot;female&quot;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li><strong>构造函数（Constructor）：</strong> 使用构造函数创建对象，构造函数是一个普通的函数，用于初始化对象的属性。</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Person(name, age, gender) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.age = age;</span><br><span class="line">  this.gender = gender;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const person1 = new Person(&quot;Alice&quot;, 30, &quot;female&quot;);</span><br><span class="line">const person2 = new Person(&quot;Bob&quot;, 25, &quot;male&quot;);</span><br></pre></td></tr></table></figure><ol><li><strong>Object.create() 方法：</strong> 使用 <code>Object.create()</code> 方法创建一个新对象，并指定该对象的原型对象。</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const personPrototype = &#123;</span><br><span class="line">  greet: function() &#123;</span><br><span class="line">    console.log(&quot;Hello!&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const person = Object.create(personPrototype);</span><br><span class="line">person.name = &quot;Alice&quot;;</span><br><span class="line">person.age = 30;</span><br></pre></td></tr></table></figure><ol><li><strong>类（ES6 中的 Class）：</strong> 使用 <code>class</code> 关键字定义一个类，类中的 <code>constructor</code> 方法用于初始化对象的属性。</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">  constructor(name, age, gender) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">    this.gender = gender;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const person1 = new Person(&quot;Alice&quot;, 30, &quot;female&quot;);</span><br><span class="line">const person2 = new Person(&quot;Bob&quot;, 25, &quot;male&quot;);</span><br></pre></td></tr></table></figure><ol><li><strong>工厂函数（Factory Function）：</strong> 工厂函数是一种返回对象的函数，用于封装对象的创建过程。</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function createPerson(name, age, gender) &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    name: name,</span><br><span class="line">    age: age,</span><br><span class="line">    gender: gender</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const person1 = createPerson(&quot;Alice&quot;, 30, &quot;female&quot;);</span><br><span class="line">const person2 = createPerson(&quot;Bob&quot;, 25, &quot;male&quot;);</span><br></pre></td></tr></table></figure><ol><li><strong>Object() 构造函数：</strong> 使用 <code>Object()</code> 构造函数来创建一个空的对象。</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const person = new Object();</span><br><span class="line">person.name = &quot;Alice&quot;;</span><br><span class="line">person.age = 30;</span><br><span class="line">person.gender = &quot;female&quot;;</span><br></pre></td></tr></table></figure><p>以上是常见的创建对象的几种方式，选择哪种方式取决于项目需求和个人偏好。在 ES6 中，推荐使用类来定义对象，它更加清晰和易读。而在 ES5 及以下的版本中，构造函数和对象字面量是更常见的创建对象的方式。</p><h4 id="9-列举宿主对象、内置对象、原生对象并说明其定义。"><a href="#9-列举宿主对象、内置对象、原生对象并说明其定义。" class="headerlink" title="9.列举宿主对象、内置对象、原生对象并说明其定义。"></a>9.列举宿主对象、内置对象、原生对象并说明其定义。</h4><p>在 JavaScript 中，宿主对象、内置对象和原生对象是三种常见的对象分类：</p><ol><li><p><strong>宿主对象（Host Objects）：</strong> 宿主对象是由宿主环境（比如浏览器或 Node.js 等）提供的对象。它们并非由 JavaScript 语言规范定义，而是由宿主环境自己实现的。在浏览器环境中，常见的宿主对象包括 <code>window</code>、<code>document</code>、<code>XMLHttpRequest</code> 等。在 Node.js 环境中，常见的宿主对象包括 <code>global</code>、<code>process</code> 等。宿主对象的定义和功能取决于具体的宿主环境。</p></li><li><p><strong>内置对象（Built-in Objects）：</strong> 内置对象是 JavaScript 语言本身提供的对象，它们存在于全局作用域中，可以直接使用而无需进行特别的导入或引入。内置对象包括 JavaScript 语言核心的对象，如 <code>Object</code>、<code>Array</code>、<code>Function</code>、<code>Date</code> 等，以及一些附加的功能性对象，如 <code>Math</code> 和 <code>JSON</code> 等。</p><ul><li><code>Object</code>：用于创建一个新的对象。</li><li><code>Array</code>：用于创建一个新的数组。</li><li><code>Function</code>：用于创建一个新的函数。</li><li><code>Date</code>：用于处理日期和时间。</li><li><code>Math</code>：提供数学运算方法和常量。</li><li><code>JSON</code>：用于解析和序列化 JSON 数据。</li></ul><p>内置对象的定义和功能是由 ECMAScript 规范（JavaScript 语言的标准）所定义的，因此在任何支持 JavaScript 的环境中，这些内置对象都应该是一样的。</p></li><li><p><strong>原生对象（Native Objects）：</strong> 原生对象是一种特殊的内置对象，它们是由 JavaScript 引擎使用内建的构造函数实例化得到的对象。例如，通过 <code>new Object()</code>、<code>new Array()</code> 等方式创建的对象就属于原生对象。原生对象与内置对象的区别在于它们的创建方式，内置对象是直接可用的，而原生对象需要通过构造函数实例化后才能使用。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const obj1 = new Object(); // 原生对象</span><br><span class="line">const obj2 = &#123;&#125;; // 内置对象</span><br></pre></td></tr></table></figure></li></ol><p>总结：</p><ul><li>宿主对象：由宿主环境提供的对象，定义和功能取决于宿主环境。</li><li>内置对象：JavaScript 语言本身提供的对象，存在于全局作用域中，由 ECMAScript 规范定义。</li><li>原生对象：由 JavaScript 引擎使用内建的构造函数实例化得到的对象。</li></ul><h4 id="10-x3D-x3D-x3D-和-x3D-x3D-的区别"><a href="#10-x3D-x3D-x3D-和-x3D-x3D-的区别" class="headerlink" title="10.&#x3D;&#x3D;&#x3D;和&#x3D;&#x3D;的区别?"></a>10.&#x3D;&#x3D;&#x3D;和&#x3D;&#x3D;的区别?</h4><p>在 JavaScript 中，<code>===</code> 和 <code>==</code> 是用于比较两个值的运算符，它们有以下区别：</p><ol><li><strong>类型比较：</strong> <code>===</code> 运算符执行严格的相等比较，不仅比较值是否相等，还要比较数据类型是否相同。而 <code>==</code> 运算符执行松散的相等比较，只比较值是否相等，不进行数据类型的转换。</li><li><strong>数据类型转换：</strong> 在执行 <code>==</code> 比较时，如果两个操作数的数据类型不同，JavaScript 会尝试进行数据类型的转换，使它们变得相同，然后再进行比较。这种自动的数据类型转换被称为强制类型转换（Type coercion）。</li><li><strong>相等条件：</strong> 使用 <code>===</code> 运算符，只有在两个操作数的值和数据类型完全相等时，才返回 <code>true</code>。而使用 <code>==</code> 运算符，如果两个操作数的值相等或在强制类型转换后相等，就返回 <code>true</code>。</li></ol><p>在大多数情况下，建议使用 <code>===</code> 运算符进行严格的相等比较，因为它可以避免意外的类型转换，使代码更加可靠和易于理解。只有在特定的需求下，才使用 <code>==</code> 运算符进行松散的相等比较。</p><h4 id="11-null-undefined-的区别"><a href="#11-null-undefined-的区别" class="headerlink" title="11.null, undefined 的区别"></a>11.null, undefined 的区别</h4><p><code>null</code> 和 <code>undefined</code> 都是 JavaScript 中表示无值的特殊值，但它们有一些区别：</p><ol><li><p><strong>null：</strong> <code>null</code> 是一个表示空值的特殊对象。当一个变量被赋值为 <code>null</code>，表示该变量的值为空。<code>null</code> 是一个原始值，不是对象，它是 JavaScript 中的关键字。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const myVariable = null;</span><br><span class="line">console.log(myVariable); // null</span><br><span class="line">console.log(typeof myVariable); // &quot;object&quot;，注意这是历史遗留问题，null 的类型被错误地标记为 &quot;object&quot;，实际上它是一个原始值</span><br></pre></td></tr></table></figure></li><li><p><strong>undefined：</strong> <code>undefined</code> 表示一个变量被声明了但尚未赋值，或者访问对象属性时该属性不存在的情况。在以下情况下，变量的值将是 <code>undefined</code>：</p><ul><li>声明了变量但没有初始化。</li><li>访问对象属性时，属性不存在。</li><li>函数没有返回值，默认返回 <code>undefined</code>。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let myVariable;</span><br><span class="line">console.log(myVariable); // undefined</span><br><span class="line"></span><br><span class="line">const myObject = &#123; name: &quot;Alice&quot; &#125;;</span><br><span class="line">console.log(myObject.age); // undefined，myObject 没有名为 &quot;age&quot; 的属性</span><br><span class="line"></span><br><span class="line">function myFunction() &#123;&#125;</span><br><span class="line">const result = myFunction();</span><br><span class="line">console.log(result); // undefined，函数没有明确的返回值，默认返回 undefined</span><br></pre></td></tr></table></figure></li></ol><p>总结：</p><ul><li><code>null</code> 是一个表示空值的关键字，表示变量被赋值为空。</li><li><code>undefined</code> 表示一个变量被声明但尚未赋值，或者访问对象属性时属性不存在。</li></ul><p>在实际编程中，我们经常使用 <code>null</code> 来明确地表示变量为空，而 <code>undefined</code> 通常是 JavaScript 引擎在处理变量时产生的值，而不是我们主动设置的。</p><h4 id="12-什么情况下会返回undefined值"><a href="#12-什么情况下会返回undefined值" class="headerlink" title="12.什么情况下会返回undefined值?"></a>12.什么情况下会返回undefined值?</h4><p>在 JavaScript 中，有几种情况下会返回 <code>undefined</code> 值：</p><ol><li><p><strong>声明但未初始化的变量：</strong> 当声明一个变量但没有给它赋值时，这个变量的值将是 <code>undefined</code>。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let myVariable;</span><br><span class="line">console.log(myVariable); // undefined</span><br></pre></td></tr></table></figure></li><li><p><strong>访问对象中不存在的属性：</strong> 当访问一个对象中不存在的属性时，返回的值将是 <code>undefined</code>。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const myObject = &#123; name: &quot;Alice&quot; &#125;;</span><br><span class="line">console.log(myObject.age); // undefined，myObject 没有名为 &quot;age&quot; 的属性</span><br></pre></td></tr></table></figure></li><li><p><strong>函数没有返回值或显式返回 <code>undefined</code>：</strong> 如果一个函数没有明确的 <code>return</code> 语句，或者 <code>return</code> 语句后面没有值，那么该函数默认返回 <code>undefined</code>。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function myFunction() &#123;</span><br><span class="line">  // 没有明确的返回值，默认返回 undefined</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function anotherFunction() &#123;</span><br><span class="line">  return;</span><br><span class="line">  // 没有返回值，默认返回 undefined</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(myFunction()); // undefined</span><br><span class="line">console.log(anotherFunction()); // undefined</span><br></pre></td></tr></table></figure></li><li><p><strong>函数参数缺失：</strong> 如果函数期望传入某个参数但未传入，函数中对该参数的引用将返回 <code>undefined</code>。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function greet(name) &#123;</span><br><span class="line">  console.log(&quot;Hello, &quot; + name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">greet(); // 输出 &quot;Hello, undefined&quot;，name 参数未传入，默认为 undefined</span><br></pre></td></tr></table></figure></li><li><p><strong>函数参数没有使用 <code>arguments</code> 对象或剩余参数（rest parameters）：</strong> 当函数没有使用 <code>arguments</code> 对象或剩余参数（rest parameters）获取传入的参数时，未传入的参数在函数内部将是 <code>undefined</code>。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function sum(a, b) &#123;</span><br><span class="line">  console.log(a + b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum(3); // 输出 &quot;NaN&quot;，因为 b 没有传入，a + undefined 结果为 NaN</span><br></pre></td></tr></table></figure></li></ol><p>以上是返回 <code>undefined</code> 值的几种常见情况。在编程中，我们要特别注意处理可能返回 <code>undefined</code> 的情况，以避免出现错误。可以使用条件判断或默认值设定等方式来处理这些情况，保证代码的稳定性和可靠性。</p><h4 id="13-如何区分数组和对象"><a href="#13-如何区分数组和对象" class="headerlink" title="13.如何区分数组和对象?"></a>13.如何区分数组和对象?</h4><p>在 JavaScript 中，可以通过以下几个特征来区分数组和对象：</p><ol><li><p><strong>数据类型：</strong> 数组和对象是两种不同的数据类型。数组是一种特殊的对象，它的键（或索引）是整数，表示元素在数组中的位置，而对象的键可以是字符串或符号，表示属性名。</p></li><li><p><strong>语法：</strong> 数组使用方括号 <code>[]</code> 来表示，而对象使用花括号 <code>&#123;&#125;</code> 来表示。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy codeconst myArray = [1, 2, 3];</span><br><span class="line">const myObject = &#123; name: &quot;Alice&quot;, age: 30 &#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>键（或索引）：</strong> 数组的键是按顺序排列的整数索引，从 0 开始。而对象的键可以是任意字符串或符号。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy codeconst myArray = [1, 2, 3];</span><br><span class="line">console.log(myArray[0]); // 1，使用整数索引访问数组元素</span><br><span class="line"></span><br><span class="line">const myObject = &#123; name: &quot;Alice&quot;, age: 30 &#125;;</span><br><span class="line">console.log(myObject[&quot;name&quot;]); // &quot;Alice&quot;，使用字符串键访问对象属性</span><br></pre></td></tr></table></figure></li><li><p><strong>length 属性：</strong> 数组有一个特殊的 <code>length</code> 属性，用于表示数组中元素的个数。而对象没有 <code>length</code> 属性。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy codeconst myArray = [1, 2, 3];</span><br><span class="line">console.log(myArray.length); // 3，数组有 length 属性</span><br><span class="line"></span><br><span class="line">const myObject = &#123; name: &quot;Alice&quot;, age: 30 &#125;;</span><br><span class="line">console.log(myObject.length); // undefined，对象没有 length 属性</span><br></pre></td></tr></table></figure></li><li><p><strong>操作方法：</strong> 数组具有一些特殊的操作方法，如 <code>push()</code>、<code>pop()</code>、<code>shift()</code>、<code>unshift()</code> 等，用于在数组中添加或删除元素。而对象没有这些特殊的操作方法。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy codeconst myArray = [1, 2, 3];</span><br><span class="line">myArray.push(4); // 在数组末尾添加元素</span><br><span class="line"></span><br><span class="line">const myObject = &#123; name: &quot;Alice&quot;, age: 30 &#125;;</span><br><span class="line">myObject.push(4); // TypeError: myObject.push is not a function，对象没有 push 方法</span><br></pre></td></tr></table></figure></li></ol><p>总结：</p><ul><li>数组是一种特殊的对象，用于有序地存储一组数据，通过整数索引访问元素。</li><li>对象用于存储一组键值对数据，通过键（字符串或符号）访问属性。</li><li>数组有 <code>length</code> 属性和一些特殊的操作方法，而对象没有。</li></ul><h4 id="14-多维数组如何降维"><a href="#14-多维数组如何降维" class="headerlink" title="14.多维数组如何降维?"></a>14.多维数组如何降维?</h4><p>降维是将多维数组转换为一维数组的过程。在 JavaScript 中，可以使用递归或数组方法来实现多维数组的降维。</p><ol><li><strong>递归方法：</strong> 使用递归函数遍历多维数组的每个元素，如果元素是一个子数组，则继续递归遍历子数组，直到将所有元素转换为一维数组。</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function flattenArray(arr) &#123;</span><br><span class="line">  const result = [];</span><br><span class="line">  for (let i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">    if (Array.isArray(arr[i])) &#123;</span><br><span class="line">      result.push(...flattenArray(arr[i])); // 递归遍历子数组</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      result.push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const multiDimensionalArray = [1, [2, 3], [4, [5, 6]]];</span><br><span class="line">const flattenedArray = flattenArray(multiDimensionalArray);</span><br><span class="line">console.log(flattenedArray); // [1, 2, 3, 4, 5, 6]</span><br></pre></td></tr></table></figure><ol><li><strong>数组方法：</strong> 使用数组的 <code>flat()</code> 方法可以快速将多维数组降维为一维数组。<code>flat()</code> 方法可以指定降维的深度，如果没有指定深度，默认为 1。</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const multiDimensionalArray = [1, [2, 3], [4, [5, 6]]];</span><br><span class="line">const flattenedArray = multiDimensionalArray.flat(Infinity);</span><br><span class="line">console.log(flattenedArray); // [1, 2, 3, 4, 5, 6]</span><br></pre></td></tr></table></figure><p>使用递归方法可以处理任意深度的多维数组，但可能会有一定的性能开销。而使用 <code>flat()</code> 方法可以简化代码，并且在已知深度的情况下，可以提供更好的性能。</p><p>注意：在使用 <code>flat()</code> 方法时，需要注意浏览器或 Node.js 环境是否支持该方法，如果不支持，可以使用 polyfill 或其他方式进行降维处理。</p><h4 id="15-怎么获取当前日期-年-月-日-时-分-秒"><a href="#15-怎么获取当前日期-年-月-日-时-分-秒" class="headerlink" title="15.怎么获取当前日期(年-月-日 时:分:秒) ?"></a>15.怎么获取当前日期(年-月-日 时:分:秒) ?</h4><p>在 JavaScript 中，可以使用 <code>Date</code> 对象来获取当前日期和时间。以下是获取当前日期和时间的代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const currentDate = new Date();</span><br><span class="line"></span><br><span class="line">const year = currentDate.getFullYear();</span><br><span class="line">const month = String(currentDate.getMonth() + 1).padStart(2, &quot;0&quot;); // 月份从0开始，需要加1，然后补零</span><br><span class="line">const day = String(currentDate.getDate()).padStart(2, &quot;0&quot;);</span><br><span class="line">const hours = String(currentDate.getHours()).padStart(2, &quot;0&quot;);</span><br><span class="line">const minutes = String(currentDate.getMinutes()).padStart(2, &quot;0&quot;);</span><br><span class="line">const seconds = String(currentDate.getSeconds()).padStart(2, &quot;0&quot;);</span><br><span class="line"></span><br><span class="line">const currentDateTime = `$&#123;year&#125;-$&#123;month&#125;-$&#123;day&#125; $&#123;hours&#125;:$&#123;minutes&#125;:$&#123;seconds&#125;`;</span><br><span class="line">console.log(currentDateTime); // 格式为：年-月-日 时:分:秒</span><br></pre></td></tr></table></figure><p>解释：</p><ol><li>使用 <code>new Date()</code> 创建一个新的 <code>Date</code> 对象，它将包含当前日期和时间。</li><li>通过 <code>Date</code> 对象的方法获取当前年、月、日、时、分、秒。</li><li>使用 <code>padStart()</code> 方法对月、日、时、分、秒进行补零操作，确保它们始终是两位数。</li><li>将获取到的年、月、日、时、分、秒拼接成所需的日期时间格式。</li></ol><p>请注意，JavaScript 中的月份是从 0 开始的，所以需要加 1。同时，<code>padStart()</code> 方法是 ES2017 引入的，如果在旧版本的 JavaScript 环境中使用，可以使用其他方式来实现补零操作。</p><h4 id="16-什么是类数组-伪数组-，-如何将其转化为真实的数组"><a href="#16-什么是类数组-伪数组-，-如何将其转化为真实的数组" class="headerlink" title="16.什么是类数组(伪数组)， 如何将其转化为真实的数组?"></a>16.什么是类数组(伪数组)， 如何将其转化为真实的数组?</h4><p>类数组（也称为伪数组）是一种对象，它具有类似数组的特性，但不具备数组原型上的方法，也没有数组的 length 属性。常见的类数组包括 DOM 元素集合、函数的 arguments 对象等。</p><p>在 JavaScript 中，可以通过以下几种方式将类数组转化为真实的数组：</p><ol><li><strong>Array.from() 方法：</strong> 使用 <code>Array.from()</code> 方法可以将可迭代对象或类数组对象转化为真实的数组。</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const arrayLike = &#123; 0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;, length: 3 &#125;;</span><br><span class="line">const realArray = Array.from(arrayLike);</span><br><span class="line"></span><br><span class="line">console.log(realArray); // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br></pre></td></tr></table></figure><ol><li><strong>Array.prototype.slice.call()：</strong> 可以使用 <code>Array.prototype.slice.call()</code> 方法将类数组对象转化为真实的数组。</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const arrayLike = &#123; 0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;, length: 3 &#125;;</span><br><span class="line">const realArray = Array.prototype.slice.call(arrayLike);</span><br><span class="line"></span><br><span class="line">console.log(realArray); // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br></pre></td></tr></table></figure><ol><li><strong>Spread Operator（展开运算符）：</strong> 使用展开运算符 <code>...</code> 也可以将类数组对象转化为真实的数组。</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const arrayLike = &#123; 0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;, length: 3 &#125;;</span><br><span class="line">const realArray = [...arrayLike];</span><br><span class="line"></span><br><span class="line">console.log(realArray); // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br></pre></td></tr></table></figure><ol><li><strong>for 循环：</strong> 使用 for 循环遍历类数组对象，并将其逐个添加到一个新数组中。</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const arrayLike = &#123; 0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;, length: 3 &#125;;</span><br><span class="line">const realArray = [];</span><br><span class="line"></span><br><span class="line">for (let i = 0; i &lt; arrayLike.length; i++) &#123;</span><br><span class="line">  realArray.push(arrayLike[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(realArray); // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br></pre></td></tr></table></figure><p>以上四种方法都可以将类数组对象转化为真实的数组，可以根据实际情况选择其中一种。注意，在转换过程中，类数组对象的索引会被保留，它们将成为新数组的索引。</p><h4 id="17-如何遍历对象的属性"><a href="#17-如何遍历对象的属性" class="headerlink" title="17.如何遍历对象的属性?"></a>17.如何遍历对象的属性?</h4><p>在 JavaScript 中，可以使用不同的方法来遍历对象的属性：</p><ol><li><strong>for…in 循环：</strong> 使用 <code>for...in</code> 循环可以遍历对象的可枚举属性，包括对象自身的属性以及继承的属性（来自原型链）。需要注意的是，<code>for...in</code> 循环也会遍历对象的原型链，因此可以通过 <code>hasOwnProperty()</code> 方法来过滤只遍历对象自身的属性。</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const person = &#123;</span><br><span class="line">  name: &quot;Alice&quot;,</span><br><span class="line">  age: 30,</span><br><span class="line">  gender: &quot;female&quot;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">for (let key in person) &#123;</span><br><span class="line">  if (person.hasOwnProperty(key)) &#123;</span><br><span class="line">    console.log(key + &quot;: &quot; + person[key]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>Object.keys() 方法：</strong> 使用 <code>Object.keys()</code> 方法可以获取对象自身的所有可枚举属性，并返回一个包含这些属性的数组。然后可以使用数组的 <code>forEach()</code> 方法来遍历这些属性。</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const person = &#123;</span><br><span class="line">  name: &quot;Alice&quot;,</span><br><span class="line">  age: 30,</span><br><span class="line">  gender: &quot;female&quot;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Object.keys(person).forEach((key) =&gt; &#123;</span><br><span class="line">  console.log(key + &quot;: &quot; + person[key]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol><li><strong>Object.values() 方法：</strong> 使用 <code>Object.values()</code> 方法可以获取对象自身的所有可枚举属性的值，并返回一个包含这些值的数组。</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const person = &#123;</span><br><span class="line">  name: &quot;Alice&quot;,</span><br><span class="line">  age: 30,</span><br><span class="line">  gender: &quot;female&quot;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Object.values(person).forEach((value) =&gt; &#123;</span><br><span class="line">  console.log(value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol><li><strong>Object.entries() 方法：</strong> 使用 <code>Object.entries()</code> 方法可以获取对象自身的所有可枚举属性的键值对，并返回一个包含这些键值对的数组。可以通过解构赋值来遍历键和值。</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const person = &#123;</span><br><span class="line">  name: &quot;Alice&quot;,</span><br><span class="line">  age: 30,</span><br><span class="line">  gender: &quot;female&quot;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Object.entries(person).forEach(([key, value]) =&gt; &#123;</span><br><span class="line">  console.log(key + &quot;: &quot; + value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上述方法可以根据实际需求来选择使用，它们都可以遍历对象的属性，根据情况选择最适合的方法。请注意，<code>for...in</code> 循环可能会遍历到继承的属性，因此需要适当使用 <code>hasOwnProperty()</code> 方法进行过滤，以避免意外的结果。</p><h4 id="18-如何给一个按钮绑定两个onclick事件"><a href="#18-如何给一个按钮绑定两个onclick事件" class="headerlink" title="18.如何给一个按钮绑定两个onclick事件?"></a>18.如何给一个按钮绑定两个onclick事件?</h4><p>在 HTML 和 JavaScript 中，给一个按钮绑定两个 <code>onclick</code> 事件可以通过以下几种方式实现：</p><ol><li><strong>使用addEventListener() 方法：</strong> 使用 <code>addEventListener()</code> 方法可以给元素添加多个事件监听器，从而绑定多个点击事件。</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;button id=&quot;myButton&quot;&gt;Click Me&lt;/button&gt;</span><br><span class="line">javascriptCopy codeconst myButton = document.getElementById(&quot;myButton&quot;);</span><br><span class="line"></span><br><span class="line">function handleClick1() &#123;</span><br><span class="line">  console.log(&quot;Event 1&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function handleClick2() &#123;</span><br><span class="line">  console.log(&quot;Event 2&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myButton.addEventListener(&quot;click&quot;, handleClick1);</span><br><span class="line">myButton.addEventListener(&quot;click&quot;, handleClick2);</span><br></pre></td></tr></table></figure><ol><li><strong>直接在 HTML 属性中添加事件处理函数：</strong> 在 HTML 元素的 <code>onclick</code> 属性中，可以直接添加多个事件处理函数，使用分号 <code>;</code> 分隔它们。</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;button id=&quot;myButton&quot; onclick=&quot;handleClick1(); handleClick2();&quot;&gt;Click Me&lt;/button&gt;</span><br></pre></td></tr></table></figure><ol><li><strong>使用onclick属性绑定一个匿名函数：</strong> 可以将一个匿名函数作为点击事件的处理函数，然后在匿名函数中调用两个不同的函数。</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;button id=&quot;myButton&quot; onclick=&quot;handleClick()&quot;&gt;Click Me&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">function handleClick() &#123;</span><br><span class="line">  handleClick1();</span><br><span class="line">  handleClick2();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上三种方法都可以给一个按钮绑定两个 <code>onclick</code> 事件，根据实际情况选择最合适的方式即可。注意，在使用 <code>addEventListener()</code> 方法时，它们的执行顺序将按照绑定的顺序执行。而在直接使用 <code>onclick</code> 属性或匿名函数的方式时，它们的执行顺序将由代码中的顺序决定。</p><h4 id="19-变量提升是什么-与函数提升的区别"><a href="#19-变量提升是什么-与函数提升的区别" class="headerlink" title="19.变量提升是什么?与函数提升的区别?"></a>19.变量提升是什么?与函数提升的区别?</h4><p>变量提升（Hoisting）和函数提升是 JavaScript 中的两个重要概念，它们描述了变量和函数在代码执行之前被声明的行为。但它们之间有一些区别。</p><ol><li><p><strong>变量提升：</strong> 在 JavaScript 中，变量的声明会在代码执行之前进行提升，这意味着可以在变量声明之前访问该变量，并且不会报错，但其值为 <code>undefined</code>。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(myVar); // undefined</span><br><span class="line">var myVar = 10;</span><br><span class="line">console.log(myVar); // 10</span><br></pre></td></tr></table></figure><p>在上面的例子中，变量 <code>myVar</code> 在声明之前被访问，但是不会报错，而是输出 <code>undefined</code>，因为变量声明会在代码执行之前被提升，但是赋值操作会保留在原来的位置。</p></li><li><p><strong>函数提升：</strong> 类似于变量提升，函数的声明也会在代码执行之前被提升。这意味着可以在函数声明之前调用函数，并且不会报错。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sayHello(); // &quot;Hello, there!&quot;</span><br><span class="line"></span><br><span class="line">function sayHello() &#123;</span><br><span class="line">  console.log(&quot;Hello, there!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中，函数 <code>sayHello()</code> 在声明之前被调用，但是不会报错，而是输出 “Hello, there!”。函数声明会在代码执行之前被提升，因此可以在代码的任何位置使用函数。</p></li></ol><p>需要注意的是，虽然变量和函数在代码执行之前被提升，但是它们的赋值和具体实现仍然按照原来的顺序执行。所以，尽管在代码的任何位置都可以访问变量和函数的声明，但如果在声明之前使用变量或函数的值，其值将为 <code>undefined</code>。为了避免这种问题，通常建议在代码的开头声明所有的变量和函数，以便更好地理解代码并避免意外行为。</p><h4 id="20-什么是作用域链-如何延长"><a href="#20-什么是作用域链-如何延长" class="headerlink" title="20.什么是作用域链?如何延长?"></a>20.什么是作用域链?如何延长?</h4><p>作用域链是在 JavaScript 中用于查找变量和函数的一种机制。当代码执行时，JavaScript 引擎会创建一个作用域链，它是一个由多个执行上下文对象组成的链表。每个执行上下文对象都包含了当前作用域的变量和函数，并且持有对其父级作用域的引用。这些引用形成了作用域链，用于在当前作用域无法找到变量或函数时，沿着链条向上查找。</p><p>作用域链的构建方式如下：</p><ol><li>当进入一个函数时，会创建一个新的执行上下文对象，并将其添加到作用域链的顶端。</li><li>每个执行上下文对象都有一个指向其父级执行上下文对象的引用，因此形成了一个链表结构，连接了所有的作用域。</li><li>在当前执行上下文对象中查找变量或函数时，首先在当前作用域中查找，如果找到了就直接使用。</li><li>如果在当前作用域中找不到，就沿着作用域链向上查找，直到找到为止。如果在最顶层的全局作用域中都没有找到，则会报错。</li></ol><p>延长作用域链的情况有两种：</p><ol><li><p><strong>函数的嵌套：</strong> 当一个函数内部包含另一个函数时，内部函数的作用域链会延长到外部函数的作用域，从而可以访问外部函数中的变量。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function outer() &#123;</span><br><span class="line">  const x = 10;</span><br><span class="line"></span><br><span class="line">  function inner() &#123;</span><br><span class="line">    console.log(x); // 可以访问外部函数 outer 中的变量 x</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  inner();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">outer(); // 输出 10</span><br></pre></td></tr></table></figure></li><li><p><strong>try-catch 块：</strong> 在 try-catch 块中，catch 块的作用域链会延长到包含它的外部作用域，以便可以访问外部作用域中的变量。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">  const message = &quot;Hello&quot;;</span><br><span class="line">  throw new Error(&quot;Error occurred&quot;);</span><br><span class="line">&#125; catch (error) &#123;</span><br><span class="line">  console.log(message); // 可以访问包含它的外部作用域中的变量 message</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>在 JavaScript 中，作用域链的正确理解对于理解作用域、变量的查找和作用域的嵌套非常重要。</p><h4 id="21-如何实现数组的随机排序"><a href="#21-如何实现数组的随机排序" class="headerlink" title="21.如何实现数组的随机排序?"></a>21.如何实现数组的随机排序?</h4><p>可以使用 Fisher-Yates (Knuth) Shuffle 算法来实现数组的随机排序。这个算法通过遍历数组，随机交换每个位置上的元素，从而得到一个随机排列的数组。</p><p>以下是使用 JavaScript 实现 Fisher-Yates Shuffle 算法的代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function shuffleArray(arr) &#123;</span><br><span class="line">  for (let i = arr.length - 1; i &gt; 0; i--) &#123;</span><br><span class="line">    const randomIndex = Math.floor(Math.random() * (i + 1));</span><br><span class="line">    // 交换当前位置的元素与随机位置的元素</span><br><span class="line">    [arr[i], arr[randomIndex]] = [arr[randomIndex], arr[i]];</span><br><span class="line">  &#125;</span><br><span class="line">  return arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const myArray = [1, 2, 3, 4, 5];</span><br><span class="line">const shuffledArray = shuffleArray(myArray);</span><br><span class="line">console.log(shuffledArray); // 输出一个随机排序的数组，例如 [3, 5, 2, 1, 4]</span><br></pre></td></tr></table></figure><p>解释：</p><ol><li>使用 <code>for</code> 循环从数组的最后一个元素开始，逐个遍历到第一个元素。</li><li>在每次循环中，生成一个随机的索引 <code>randomIndex</code>，范围是当前元素位置到数组开头之间的随机整数。</li><li>交换当前位置的元素与随机位置 <code>randomIndex</code> 的元素，从而实现随机排序。</li></ol><p>通过 Fisher-Yates Shuffle 算法，每个元素在最终的排列中都有相等的概率出现在任何位置，从而实现了数组的随机排序。</p><h4 id="22-dom节点的Attribute和Property-有何区别"><a href="#22-dom节点的Attribute和Property-有何区别" class="headerlink" title="22.dom节点的Attribute和Property 有何区别?"></a>22.dom节点的Attribute和Property 有何区别?</h4><p>Attribute 和 Property 是用于操作 DOM 节点的两个不同概念，它们在使用和表现上有一些区别。</p><p><strong>Attribute（属性）：</strong></p><ol><li>Attribute 是 HTML 元素在 HTML 标签中定义的属性，它们可以在 HTML 标签中通过属性的方式设置，例如 <code>&lt;div id=&quot;myDiv&quot; class=&quot;myClass&quot;&gt;</code>。</li><li>Attribute 是由 HTML 文档解析而来，属于静态值，一旦设置，通常不会随着 JavaScript 的操作而改变。</li><li>通过 JavaScript 的 <code>getAttribute()</code> 方法可以获取元素的属性值，例如 <code>element.getAttribute(&quot;id&quot;)</code>。</li><li>使用 <code>setAttribute()</code> 方法可以动态地设置元素的属性值，例如 <code>element.setAttribute(&quot;data-custom&quot;, &quot;value&quot;)</code>。</li></ol><p><strong>Property（属性）：</strong></p><ol><li>Property 是 DOM 元素对象的属性，它们是对象的属性，通过 JavaScript 对象的方式进行设置和访问。</li><li>Property 是由浏览器解析 HTML 元素后创建的，属于动态值，可以通过 JavaScript 进行改变。</li><li>通过 JavaScript 的点语法或方括号语法可以获取和设置元素的属性，例如 <code>element.id</code> 或 <code>element[&quot;id&quot;]</code>。</li><li>通过设置 Property 的值，通常可以引起页面的重新渲染或重绘，而 Attribute 的改变不会引起页面重新渲染。</li></ol><p>虽然 Attribute 和 Property 在某些情况下是相互关联的，但它们的操作方式和作用有所不同。在使用 JavaScript 操作 DOM 时，通常更推荐使用 Property，因为 Property 的操作更加灵活，而且能够触发页面重新渲染。对于一些特殊属性（例如 data 属性），通常使用 Attribute 更合适，因为它们是自定义的、不会影响样式或布局的数据属性。</p><h4 id="23-dom结构操作怎样添加、移除、移动、复制、创建和查找节点"><a href="#23-dom结构操作怎样添加、移除、移动、复制、创建和查找节点" class="headerlink" title="23.dom结构操作怎样添加、移除、移动、复制、创建和查找节点?"></a>23.dom结构操作怎样添加、移除、移动、复制、创建和查找节点?</h4><p>在 JavaScript 中，可以使用 DOM 操作来添加、移除、移动、复制、创建和查找节点。下面是一些常用的 DOM 操作方法：</p><p><strong>添加节点：</strong></p><ol><li><code>appendChild()</code>: 将一个已有的节点添加为另一个节点的最后一个子节点。</li><li><code>insertBefore()</code>: 将一个已有的节点插入到指定节点的前面。</li></ol><p><strong>移除节点：</strong></p><ol><li><code>removeChild()</code>: 从父节点中移除指定的子节点。</li><li><code>parentNode.removeChild()</code>: 从父节点中移除当前节点。</li></ol><p><strong>移动节点：</strong></p><ol><li><code>appendChild()</code>: 用于将一个节点从一个位置移动到另一个位置（如果该节点已经在文档中存在，则会被自动移动到新位置）。</li></ol><p><strong>复制节点：</strong></p><ol><li><code>cloneNode()</code>: 创建一个指定节点的副本，可以选择是否深度复制，即是否同时复制子节点。</li></ol><p><strong>创建节点：</strong></p><ol><li><code>document.createElement()</code>: 创建一个新的元素节点。</li><li><code>document.createTextNode()</code>: 创建一个包含指定文本的文本节点。</li><li><code>document.createDocumentFragment()</code>: 创建一个文档片段，用于在内存中操作一组节点，然后一次性添加到文档中。</li></ol><p><strong>查找节点：</strong></p><ol><li><code>getElementById()</code>: 根据元素的 id 属性查找元素节点。</li><li><code>getElementsByClassName()</code>: 根据元素的 class 属性查找元素节点，返回一个 HTMLCollection 集合。</li><li><code>getElementsByTagName()</code>: 根据元素的标签名查找元素节点，返回一个 HTMLCollection 集合。</li><li><code>querySelector()</code>: 根据 CSS 选择器查找第一个匹配的元素节点。</li><li><code>querySelectorAll()</code>: 根据 CSS 选择器查找所有匹配的元素节点，返回一个 NodeList 集合。</li></ol><p>下面是一些示例代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;parent&quot;&gt;</span><br><span class="line">  &lt;p&gt;Existing child node&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">// 添加节点</span><br><span class="line">const parent = document.getElementById(&quot;parent&quot;);</span><br><span class="line">const newChild = document.createElement(&quot;p&quot;);</span><br><span class="line">newChild.textContent = &quot;New child node&quot;;</span><br><span class="line">parent.appendChild(newChild);</span><br><span class="line"></span><br><span class="line">// 移除节点</span><br><span class="line">const existingChild = parent.querySelector(&quot;p&quot;);</span><br><span class="line">parent.removeChild(existingChild);</span><br><span class="line"></span><br><span class="line">// 移动节点</span><br><span class="line">const targetParent = document.getElementById(&quot;targetParent&quot;);</span><br><span class="line">targetParent.appendChild(existingChild);</span><br><span class="line"></span><br><span class="line">// 复制节点</span><br><span class="line">const clonedChild = existingChild.cloneNode(true); // 深度复制子节点</span><br><span class="line">targetParent.appendChild(clonedChild);</span><br><span class="line"></span><br><span class="line">// 创建节点</span><br><span class="line">const textNode = document.createTextNode(&quot;Some text&quot;);</span><br><span class="line">targetParent.appendChild(textNode);</span><br><span class="line"></span><br><span class="line">// 查找节点</span><br><span class="line">const foundElement = document.querySelector(&quot;#parent p&quot;);</span><br><span class="line">console.log(foundElement.textContent); // 输出: &quot;New child node&quot;</span><br></pre></td></tr></table></figure><p>注意，对于查找节点的方法（例如 <code>querySelector()</code> 和 <code>querySelectorAll()</code>），如果没有找到匹配的节点，将返回 <code>null</code> 或空的 NodeList，需要进行合适的判断。</p><h4 id="24-什么是事件冒泡，它是如何工作的-如何阻止事件冒泡"><a href="#24-什么是事件冒泡，它是如何工作的-如何阻止事件冒泡" class="headerlink" title="24.什么是事件冒泡，它是如何工作的?如何阻止事件冒泡?"></a>24.什么是事件冒泡，它是如何工作的?如何阻止事件冒泡?</h4><p>事件冒泡是指在 DOM 结构中，当一个元素触发某个事件时，该事件会从触发元素开始向上层级的父元素依次触发，直到达到文档根节点。这意味着事件会先在触发元素上进行处理，然后在其父元素上处理，再然后在其父元素的父元素上处理，以此类推，直到事件冒泡到文档根节点。</p><p>例如，当你点击一个按钮时，会依次触发按钮本身的点击事件，然后是按钮所在的父元素的点击事件，再然后是父元素的父元素的点击事件，依此类推。</p><p>阻止事件冒泡的方法有两种：</p><ol><li><p><strong>使用 stopPropagation() 方法：</strong> 在事件处理函数中调用 <code>event.stopPropagation()</code> 可以阻止事件继续冒泡，从而停止事件传播到更高层级的元素。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;parent&quot;&gt;</span><br><span class="line">  &lt;button id=&quot;child&quot;&gt;Click Me&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const parent = document.getElementById(&quot;parent&quot;);</span><br><span class="line">const child = document.getElementById(&quot;child&quot;);</span><br><span class="line"></span><br><span class="line">function handleClick(event) &#123;</span><br><span class="line">  console.log(&quot;Button clicked&quot;);</span><br><span class="line">  event.stopPropagation();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">child.addEventListener(&quot;click&quot;, handleClick);</span><br><span class="line">parent.addEventListener(&quot;click&quot;, () =&gt; &#123;</span><br><span class="line">  console.log(&quot;Parent clicked&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在上述例子中，当点击按钮时，会输出 “Button clicked”，而不会触发父元素的点击事件。</p></li><li><p><strong>使用事件处理函数的第三个参数：</strong> 在添加事件监听器时，可以将事件处理函数的第三个参数设置为 <code>true</code>，表示在事件捕获阶段处理事件，此时事件不会冒泡。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const parent = document.getElementById(&quot;parent&quot;);</span><br><span class="line">const child = document.getElementById(&quot;child&quot;);</span><br><span class="line"></span><br><span class="line">function handleClick() &#123;</span><br><span class="line">  console.log(&quot;Button clicked&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">child.addEventListener(&quot;click&quot;, handleClick, true); // 使用捕获阶段处理事件</span><br><span class="line">parent.addEventListener(&quot;click&quot;, () =&gt; &#123;</span><br><span class="line">  console.log(&quot;Parent clicked&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在上述例子中，当点击按钮时，会输出 “Button clicked”，而不会触发父元素的点击事件。</p></li></ol><p>需要注意的是，事件捕获和事件冒泡是事件传播的两个阶段。事件捕获是从文档根节点开始，从外到内依次传播到目标元素，而事件冒泡是从目标元素开始，从内到外依次传播到文档根节点。默认情况下，事件处理函数会在事件冒泡阶段触发。如果想在事件捕获阶段触发事件处理函数，可以将事件监听器的第三个参数设置为 <code>true</code>。</p><h4 id="25-什么是事件捕获，它是如何工作的"><a href="#25-什么是事件捕获，它是如何工作的" class="headerlink" title="25.什么是事件捕获，它是如何工作的?"></a>25.什么是事件捕获，它是如何工作的?</h4><p>事件捕获是 DOM 事件传播的第一个阶段，用于在事件到达目标元素之前从文档根节点向下传播。在事件捕获阶段，事件会从最外层的父元素开始，逐级向下传递，直到到达目标元素。然后，事件进入第二个阶段，即事件冒泡阶段。</p><p>事件捕获的工作方式如下：</p><ol><li>事件捕获开始于文档根节点（<code>document</code>），然后向下传播到触发事件的元素。</li><li>事件从 <code>document</code> 向下传递到目标元素的过程中，会依次触发经过的父元素的事件处理函数，直到达到目标元素。</li><li>如果目标元素的父元素也有添加了事件监听器且在捕获阶段处理事件的情况，它们也会在目标元素之前触发。</li></ol><p>示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;parent&quot;&gt;</span><br><span class="line">  &lt;button id=&quot;child&quot;&gt;Click Me&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">const parent = document.getElementById(&quot;parent&quot;);</span><br><span class="line">const child = document.getElementById(&quot;child&quot;);</span><br><span class="line"></span><br><span class="line">function handleCapture() &#123;</span><br><span class="line">  console.log(&quot;Capture phase - Parent&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function handleClick() &#123;</span><br><span class="line">  console.log(&quot;Bubble phase - Child&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">child.addEventListener(&quot;click&quot;, handleClick);</span><br><span class="line">parent.addEventListener(&quot;click&quot;, handleCapture, true); // 使用捕获阶段处理事件</span><br></pre></td></tr></table></figure><p>在上述例子中，当点击按钮时，会按照如下顺序输出日志：</p><ol><li>“Capture phase - Parent” - 这是事件捕获阶段，从文档根节点开始向下传播到父元素。</li><li>“Bubble phase - Child” - 这是事件冒泡阶段，从目标元素开始向上冒泡到父元素。</li></ol><p>默认情况下，事件处理函数会在事件冒泡阶段触发。如果想在事件捕获阶段触发事件处理函数，可以将事件监听器的第三个参数设置为 <code>true</code>。需要注意的是，虽然大部分情况下我们使用事件冒泡，但在某些特定的场景下，事件捕获也可能会派上用场。</p><h4 id="26-如何让事件先冒泡后捕获"><a href="#26-如何让事件先冒泡后捕获" class="headerlink" title="26.如何让事件先冒泡后捕获?"></a>26.如何让事件先冒泡后捕获?</h4><p>在标准的 DOM 事件流中，事件首先经历捕获阶段，然后再进入冒泡阶段。如果希望在事件捕获阶段之后再触发事件冒泡阶段，可以通过在事件处理函数中手动触发冒泡阶段的事件。</p><p>为了实现这个目标，可以使用 <code>dispatchEvent()</code> 方法在指定的元素上手动触发事件。这个方法接受一个事件对象作为参数，通过创建一个自定义的事件对象，并将 <code>bubbles</code> 属性设置为 <code>true</code> 来模拟冒泡行为。</p><p>以下是一个示例代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;parent&quot;&gt;</span><br><span class="line">  &lt;button id=&quot;child&quot;&gt;Click Me&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">const parent = document.getElementById(&quot;parent&quot;);</span><br><span class="line">const child = document.getElementById(&quot;child&quot;);</span><br><span class="line"></span><br><span class="line">function handleCapture() &#123;</span><br><span class="line">  console.log(&quot;Capture phase - Parent&quot;);</span><br><span class="line">  // 在捕获阶段手动触发冒泡阶段的事件</span><br><span class="line">  const event = new Event(&quot;click&quot;, &#123; bubbles: true &#125;);</span><br><span class="line">  child.dispatchEvent(event);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function handleClick() &#123;</span><br><span class="line">  console.log(&quot;Bubble phase - Child&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">child.addEventListener(&quot;click&quot;, handleClick);</span><br><span class="line">parent.addEventListener(&quot;click&quot;, handleCapture, true); // 使用捕获阶段处理事件</span><br></pre></td></tr></table></figure><p>在上述例子中，当点击按钮时，会按照如下顺序输出日志：</p><ol><li>“Capture phase - Parent” - 这是事件捕获阶段，从文档根节点开始向下传播到父元素。</li><li>“Bubble phase - Child” - 这是手动触发的冒泡阶段事件，从目标元素开始向上冒泡到父元素。</li></ol><p>请注意，在手动触发冒泡阶段事件时，确保不要创建无限循环的事件触发，否则可能会导致浏览器崩溃。这种手动触发冒泡的方式应该谨慎使用，只在特定场景下使用。大部分情况下，使用标准的事件流（先捕获后冒泡）即可满足需求。</p><h4 id="27-JavaScript-动画和CSS3动画有什么区别"><a href="#27-JavaScript-动画和CSS3动画有什么区别" class="headerlink" title="27.JavaScript 动画和CSS3动画有什么区别?"></a>27.JavaScript 动画和CSS3动画有什么区别?</h4><p>JavaScript 动画和 CSS3 动画是实现动画效果的两种不同方式，它们在实现方式和使用场景上有一些区别。</p><p><strong>JavaScript 动画：</strong></p><ol><li>实现方式：使用 JavaScript 编程来操作 DOM 元素的属性，从而实现动画效果。</li><li>控制灵活性：JavaScript 动画可以实现更复杂和高度定制化的动画效果，因为可以通过编程来控制每一帧的状态和样式。</li><li>性能：较复杂的 JavaScript 动画可能会导致性能问题，特别是在移动设备上。</li><li>兼容性：较复杂的 JavaScript 动画可能需要更多的兼容性处理，以确保在不同浏览器和设备上正常运行。</li></ol><p><strong>CSS3 动画：</strong></p><ol><li>实现方式：使用 CSS3 的动画属性（例如 <code>animation</code> 和 <code>transition</code>）来指定动画效果，浏览器会自动处理动画过程。</li><li>控制灵活性：CSS3 动画相对简单，适用于较简单的动画效果。虽然可以使用关键帧动画 (<code>@keyframes</code>) 来实现一些复杂效果，但灵活性相对较低。</li><li>性能：CSS3 动画通常比 JavaScript 动画具有更好的性能，因为浏览器会对动画进行硬件加速，并优化动画过程。</li><li>兼容性：CSS3 动画在现代浏览器中有很好的支持，但在一些旧版本的浏览器上可能需要添加一些兼容性前缀或提供替代方案。</li></ol><p>使用哪种动画方式取决于具体的需求和场景。对于简单的动画效果，尽量使用 CSS3 动画，因为它们性能更好且实现更简单。对于复杂的动画效果，可以考虑使用 JavaScript 动画来实现更高度定制化的效果。在实际开发中，通常会根据动画的复杂性和性能需求来选择合适的动画方式。</p><h4 id="28-dom的事件模型"><a href="#28-dom的事件模型" class="headerlink" title="28.dom的事件模型"></a>28.dom的事件模型</h4><p>DOM 事件模型描述了浏览器中事件是如何被处理和传递的。DOM 事件模型分为三个阶段：捕获阶段、目标阶段和冒泡阶段。当一个事件在一个元素上触发时，会按照以下顺序经历这三个阶段：</p><ol><li><strong>捕获阶段（Capture Phase）：</strong><ul><li>事件从文档根节点开始传播，从最外层的父元素向下传递到目标元素。</li><li>在这个阶段，事件会依次触发所有经过的父元素的捕获阶段事件处理函数。</li></ul></li><li><strong>目标阶段（Target Phase）：</strong><ul><li>事件到达目标元素，即触发事件的元素。</li><li>事件处理函数会在目标元素上触发。</li></ul></li><li><strong>冒泡阶段（Bubble Phase）：</strong><ul><li>事件从目标元素开始向上冒泡，传播回文档根节点。</li><li>在这个阶段，事件会依次触发所有经过的父元素的冒泡阶段事件处理函数。</li></ul></li></ol><p>下图展示了 DOM 事件模型的三个阶段：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">------------------------------------------------</span><br><span class="line">| Capture Phase (从文档根节点向下传播)          |</span><br><span class="line">|  &lt;html&gt;                                      |</span><br><span class="line">|    &lt;body&gt;                                    |</span><br><span class="line">|      &lt;div id=&quot;parent&quot;&gt;                       |</span><br><span class="line">|        &lt;button id=&quot;child&quot;&gt;Click Me&lt;/button&gt;  |</span><br><span class="line">|      &lt;/div&gt;                                 |</span><br><span class="line">|    &lt;/body&gt;                                  |</span><br><span class="line">|  &lt;/html&gt;                                    |</span><br><span class="line">------------------------------------------------</span><br><span class="line">                 ↓</span><br><span class="line">--------------------------------------------</span><br><span class="line">| Target Phase (目标元素阶段)              |</span><br><span class="line">|  &lt;html&gt;                                |</span><br><span class="line">|    &lt;body&gt;                              |</span><br><span class="line">|      &lt;div id=&quot;parent&quot;&gt;                 |</span><br><span class="line">|        &lt;button id=&quot;child&quot;&gt;Click Me&lt;/button&gt; |</span><br><span class="line">|      &lt;/div&gt;                           |</span><br><span class="line">|    &lt;/body&gt;                            |</span><br><span class="line">|  &lt;/html&gt;                              |</span><br><span class="line">--------------------------------------------</span><br><span class="line">                 ↓</span><br><span class="line">----------------------------------------------</span><br><span class="line">| Bubble Phase (从目标元素向上冒泡传播)         |</span><br><span class="line">|  &lt;html&gt;                                   |</span><br><span class="line">|    &lt;body&gt;                                 |</span><br><span class="line">|      &lt;div id=&quot;parent&quot;&gt;                    |</span><br><span class="line">|        &lt;button id=&quot;child&quot;&gt;Click Me&lt;/button&gt; |</span><br><span class="line">|      &lt;/div&gt;                                |</span><br><span class="line">|    &lt;/body&gt;                                 |</span><br><span class="line">|  &lt;/html&gt;                                   |</span><br><span class="line">----------------------------------------------</span><br></pre></td></tr></table></figure><p>在事件传播过程中，可以通过在事件监听器中使用 <code>event.stopPropagation()</code> 来阻止事件的继续传播。如果需要在捕获阶段处理事件，可以将事件监听器的第三个参数设置为 <code>true</code>，例如 <code>element.addEventListener(&quot;click&quot;, handler, true)</code>。默认情况下，事件处理函数会在冒泡阶段触发。</p><p>通过了解 DOM 事件模型，开发者可以更好地理解事件的传播过程，灵活地应用事件处理机制。</p><h4 id="29-事件三要素是什么"><a href="#29-事件三要素是什么" class="headerlink" title="29.事件三要素是什么?"></a>29.事件三要素是什么?</h4><p>事件的三要素是指在处理事件时需要考虑的三个主要方面，分别是事件源、事件类型和事件处理程序。</p><ol><li><strong>事件源（Event Source）：</strong> 事件源指触发事件的元素或对象，也就是事件发生的来源。在 HTML 中，事件源可以是 DOM 元素（如按钮、文本框等），也可以是浏览器窗口、文档或其它对象。</li><li><strong>事件类型（Event Type）：</strong> 事件类型指事件的种类或类型。在 JavaScript 中，常见的事件类型包括点击事件（click）、键盘事件（keyup、keydown）、鼠标移动事件（mousemove）等。每种类型的事件都有对应的触发条件和特定的事件对象。</li><li><strong>事件处理程序（Event Handler）：</strong> 事件处理程序是一段 JavaScript 代码，用于定义事件触发后的响应行为。当事件源上发生指定类型的事件时，会调用对应的事件处理程序来执行相应的操作。可以通过事件监听器（addEventListener）或 HTML 属性（例如 onclick）来指定事件处理程序。</li></ol><p>综合来说，事件的三要素就是：事件源是触发事件的元素或对象，事件类型是事件的种类或类型，事件处理程序是定义在事件发生后要执行的 JavaScript 代码。通过处理这三个要素，可以实现对事件的控制和响应，从而实现交互性和动态性的网页效果。</p><h4 id="30-获取元素位置"><a href="#30-获取元素位置" class="headerlink" title="30.获取元素位置?"></a>30.获取元素位置?</h4><p>要获取元素的位置，可以使用 JavaScript 的 <code>getBoundingClientRect()</code> 方法。这个方法返回一个 DOMRect 对象，包含了元素的位置和尺寸信息，包括元素的左边距、上边距、宽度、高度等。</p><p>示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;myElement&quot; style=&quot;width: 100px; height: 50px; border: 1px solid black; position: absolute; top: 50px; left: 100px;&quot;&gt;</span><br><span class="line">  This is a sample element.</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">const myElement = document.getElementById(&quot;myElement&quot;);</span><br><span class="line">const rect = myElement.getBoundingClientRect();</span><br><span class="line"></span><br><span class="line">console.log(&quot;Left:&quot;, rect.left); // 元素左边距</span><br><span class="line">console.log(&quot;Top:&quot;, rect.top); // 元素上边距</span><br><span class="line">console.log(&quot;Width:&quot;, rect.width); // 元素宽度</span><br><span class="line">console.log(&quot;Height:&quot;, rect.height); // 元素高度</span><br><span class="line">console.log(&quot;Right:&quot;, rect.right); // 元素右边距</span><br><span class="line">console.log(&quot;Bottom:&quot;, rect.bottom); // 元素下边距</span><br></pre></td></tr></table></figure><p>在上述例子中，我们首先通过 <code>getElementById()</code> 方法获取 id 为 “myElement” 的元素，然后使用 <code>getBoundingClientRect()</code> 方法获取该元素的位置和尺寸信息，并打印输出。注意，<code>getBoundingClientRect()</code> 方法返回的位置信息是相对于视口（viewport）的，而不是相对于文档的。如果需要获取相对于文档的位置，可以通过加上 <code>window.scrollX</code> 和 <code>window.scrollY</code> 的值来计算。</p><h4 id="31-如何绑定事件，如何解除事件"><a href="#31-如何绑定事件，如何解除事件" class="headerlink" title="31.如何绑定事件，如何解除事件?"></a>31.如何绑定事件，如何解除事件?</h4><p>在 JavaScript 中，可以使用 <code>addEventListener()</code> 方法来绑定事件，使用 <code>removeEventListener()</code> 方法来解除事件。</p><p><strong>绑定事件：</strong> 使用 <code>addEventListener()</code> 方法可以在指定的元素上绑定一个事件处理程序。这个方法接受两个参数：要监听的事件类型和事件处理函数。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;button id=&quot;myButton&quot;&gt;Click Me&lt;/button&gt;</span><br><span class="line">const myButton = document.getElementById(&quot;myButton&quot;);</span><br><span class="line"></span><br><span class="line">function handleClick() &#123;</span><br><span class="line">  console.log(&quot;Button clicked!&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myButton.addEventListener(&quot;click&quot;, handleClick);</span><br></pre></td></tr></table></figure><p>在上述例子中，我们在按钮上绑定了一个点击事件，并指定了 <code>handleClick</code> 函数作为事件处理程序。当按钮被点击时，会触发 <code>handleClick</code> 函数并输出 “Button clicked!”。</p><p><strong>解除事件：</strong> 使用 <code>removeEventListener()</code> 方法可以解除已绑定的事件处理程序。为了解除事件，必须使用相同的事件类型和事件处理程序，这样才能正确地解除事件。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">myButton.removeEventListener(&quot;click&quot;, handleClick);</span><br></pre></td></tr></table></figure><p>在上述例子中，我们使用 <code>removeEventListener()</code> 方法解除了之前绑定的点击事件处理程序 <code>handleClick</code>。这样，在按钮被点击时就不会再触发 <code>handleClick</code> 函数。</p><p>需要注意的是，在使用 <code>removeEventListener()</code> 解除事件时，要确保传入的事件处理程序是之前绑定的同一个函数，否则事件是无法正确解除的。如果绑定事件时使用了匿名函数，解除事件时也需要使用同样的匿名函数。如果在解除事件时传入了不同的事件处理程序函数，那么解除操作将不起作用，事件仍然会触发。</p><h4 id="32-对事件委托的理解"><a href="#32-对事件委托的理解" class="headerlink" title="32.对事件委托的理解"></a>32.对事件委托的理解</h4><p>事件委托（Event Delegation）是一种常用的前端开发技巧，通过在父元素上监听事件，来代理处理其子元素的事件。具体来说，事件委托利用事件冒泡的特性，将事件的处理交给父元素，而不是直接在每个子元素上添加事件监听器。</p><p>事件委托的原理如下：</p><ol><li>当子元素上的事件触发时，事件会向父元素进行冒泡传播。</li><li>在父元素上添加事件监听器，可以捕获所有子元素触发的事件，包括未来添加的子元素。</li><li>通过判断触发事件的子元素的类型或属性，可以选择性地执行相应的事件处理逻辑。</li></ol><p>使用事件委托的好处有很多：</p><ol><li><strong>减少事件监听器的数量：</strong> 在父元素上添加一个事件监听器，就可以处理所有子元素的事件，无需为每个子元素都添加监听器，从而减少了事件监听器的数量，提高性能和内存效率。</li><li><strong>动态元素支持：</strong> 对于通过动态添加的子元素，事件委托也能够处理它们的事件，无需重新绑定事件。</li><li><strong>简化代码：</strong> 事件委托可以使代码更简洁和易于维护，尤其在大量子元素的情况下。</li></ol><p>示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;ul id=&quot;myList&quot;&gt;</span><br><span class="line">  &lt;li&gt;Item 1&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;Item 2&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;Item 3&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">const myList = document.getElementById(&quot;myList&quot;);</span><br><span class="line"></span><br><span class="line">function handleItemClick(event) &#123;</span><br><span class="line">  const target = event.target;</span><br><span class="line">  if (target.tagName === &quot;LI&quot;) &#123;</span><br><span class="line">    console.log(&quot;Clicked on item:&quot;, target.textContent);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myList.addEventListener(&quot;click&quot;, handleItemClick);</span><br></pre></td></tr></table></figure><p>在上述例子中，我们在父元素 <code>&lt;ul&gt;</code> 上添加了一个点击事件监听器，通过事件委托的方式来处理其子元素 <code>&lt;li&gt;</code> 的点击事件。当点击任何 <code>&lt;li&gt;</code> 元素时，事件会冒泡到父元素 <code>&lt;ul&gt;</code>，然后由事件委托的监听器来处理点击事件，并输出点击的项的内容。这样，无论 <code>&lt;li&gt;</code> 元素的数量如何变化，事件处理都能正常工作。</p><h4 id="33-setTimeout-和setInterval的区别及用法是什么"><a href="#33-setTimeout-和setInterval的区别及用法是什么" class="headerlink" title="33.setTimeout 和setInterval的区别及用法是什么?"></a>33.setTimeout 和setInterval的区别及用法是什么?</h4><p><code>setTimeout</code> 和 <code>setInterval</code> 都是 JavaScript 提供的用于定时执行代码的函数，它们之间的区别和用法如下：</p><p><strong>setTimeout:</strong></p><ul><li><code>setTimeout</code> 用于在指定的时间间隔之后执行一次代码。</li><li>它接受两个参数：要执行的函数（或函数的代码）和延迟的毫秒数。</li><li>代码执行后，<code>setTimeout</code> 不会自动重复执行，只会执行一次。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy codefunction myFunction() &#123;</span><br><span class="line">  console.log(&quot;This is a one-time execution.&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setTimeout(myFunction, 1000); // 1秒后执行 myFunction 函数</span><br></pre></td></tr></table></figure><p><strong>setInterval:</strong></p><ul><li><code>setInterval</code> 用于每隔指定的时间间隔重复执行一次代码。</li><li>它接受两个参数：要执行的函数（或函数的代码）和时间间隔的毫秒数。</li><li>代码会不断重复执行，直到使用 <code>clearInterval</code> 方法停止执行。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy codefunction myFunction() &#123;</span><br><span class="line">  console.log(&quot;This is a repeated execution.&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const intervalId = setInterval(myFunction, 1000); // 每隔1秒执行 myFunction 函数</span><br><span class="line"></span><br><span class="line">// 5秒后停止执行</span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">  clearInterval(intervalId);</span><br><span class="line">&#125;, 5000);</span><br></pre></td></tr></table></figure><p><strong>区别：</strong></p><ol><li><code>setTimeout</code> 在指定的时间间隔之后执行一次代码，而 <code>setInterval</code> 每隔指定的时间间隔重复执行一次代码。</li><li><code>setInterval</code> 会一直重复执行，直到使用 <code>clearInterval</code> 方法停止执行；而 <code>setTimeout</code> 只会执行一次。</li></ol><p>在使用 <code>setInterval</code> 时要注意，如果代码执行的时间超过了时间间隔，可能会导致函数之间的重叠执行。因此，确保函数执行时间不会超过时间间隔，或者在下次执行前使用 <code>clearInterval</code> 停止执行。</p><p>总体来说，<code>setTimeout</code> 用于一次性的延迟执行，而 <code>setInterval</code> 用于重复性的定时执行。根据需求选择适合的方法来实现定时操作。</p><h4 id="34-用setTimeout来实现setInterval"><a href="#34-用setTimeout来实现setInterval" class="headerlink" title="34.用setTimeout来实现setInterval"></a>34.用setTimeout来实现setInterval</h4><p>虽然 <code>setTimeout</code> 和 <code>setInterval</code> 是两个不同的函数，但是可以利用 <code>setTimeout</code> 的递归调用来模拟实现类似 <code>setInterval</code> 的功能。实现的关键是在每次函数执行完成后，再次调用 <code>setTimeout</code> 来触发下一次函数执行，从而实现间隔性的重复执行。</p><p>下面是使用 <code>setTimeout</code> 模拟实现 <code>setInterval</code> 的示例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function myInterval(callback, interval) &#123;</span><br><span class="line">  const wrapper = function() &#123;</span><br><span class="line">    callback();</span><br><span class="line">    setTimeout(wrapper, interval); // 递归调用setTimeout，实现重复执行</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  setTimeout(wrapper, interval); // 第一次触发函数执行</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 测试示例</span><br><span class="line">let count = 0;</span><br><span class="line">function printCount() &#123;</span><br><span class="line">  console.log(&quot;Count:&quot;, count);</span><br><span class="line">  count++;</span><br><span class="line"></span><br><span class="line">  if (count === 5) &#123;</span><br><span class="line">    // 停止执行</span><br><span class="line">    console.log(&quot;Stopped.&quot;);</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用自定义的myInterval函数来模拟setInterval</span><br><span class="line">myInterval(printCount, 1000);</span><br></pre></td></tr></table></figure><p>在上述示例中，我们定义了 <code>myInterval</code> 函数，它接受一个回调函数 <code>callback</code> 和一个时间间隔 <code>interval</code>，并通过递归调用 <code>setTimeout</code> 来模拟 <code>setInterval</code> 的功能。在 <code>myInterval</code> 函数内部，我们使用了一个闭包 <code>wrapper</code> 来包裹回调函数 <code>callback</code>，每次执行完 <code>callback</code> 后再次调用 <code>setTimeout</code> 来触发下一次的执行。</p><p>需要注意的是，这种方式虽然能够模拟 <code>setInterval</code> 的功能，但是和原生的 <code>setInterval</code> 相比，可能存在一些性能和准确性上的差异。在实际开发中，建议优先使用原生的 <code>setInterval</code>，除非有特殊需求需要手动模拟。</p><h4 id="35-document-write-和innerHTML的区别"><a href="#35-document-write-和innerHTML的区别" class="headerlink" title="35.document.write 和innerHTML的区别?"></a>35.document.write 和innerHTML的区别?</h4><p><code>document.write</code> 和 <code>innerHTML</code> 都是用于向网页中插入内容的方法，但它们有一些区别：</p><p><strong>document.write:</strong></p><ul><li><code>document.write</code> 是 JavaScript 中最早的一种向文档中插入内容的方法。</li><li>它可以在页面加载时直接在文档中写入内容，也可以在页面加载后通过脚本动态写入内容。</li><li>当页面已经加载完成后，再使用 <code>document.write</code> 会重写整个文档，导致之前的内容丢失，因此在页面加载完成后使用 <code>document.write</code> 是不推荐的做法。</li><li>由于它在加载和解析文档时直接修改 DOM，可能会导致性能问题，而且在某些情况下会破坏页面的结构。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  document.write(&quot;&lt;h1&gt;Hello, World!&lt;/h1&gt;&quot;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><strong>innerHTML:</strong></p><ul><li><code>innerHTML</code> 是用于获取或设置元素的 HTML 内容的属性。</li><li>通过修改元素的 <code>innerHTML</code> 属性，可以向元素内部插入 HTML 内容，包括文本、标签等。</li><li><code>innerHTML</code> 是一个字符串属性，因此可以通过赋值来设置元素的内容，也可以通过读取它来获取元素的内容。</li><li>与 <code>document.write</code> 不同，<code>innerHTML</code> 只会修改指定元素的内容，而不会影响整个文档结构。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;myDiv&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const myDiv = document.getElementById(&quot;myDiv&quot;);</span><br><span class="line">  myDiv.innerHTML = &quot;&lt;h1&gt;Hello, World!&lt;/h1&gt;&quot;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><strong>区别：</strong></p><ul><li><code>document.write</code> 是直接向文档写入内容，对整个文档结构产生影响，可能导致性能问题，并且不适合在页面加载后使用。</li><li><code>innerHTML</code> 是通过修改元素的属性来插入内容，只对指定元素产生影响，不会重写整个文档，更灵活且性能较好。</li></ul><p>总的来说，推荐使用 <code>innerHTML</code> 来动态插入内容，而避免使用 <code>document.write</code>。如果需要在页面加载后动态插入内容，可以使用 <code>innerHTML</code> 或其他 DOM 操作方法来实现。</p><h4 id="36-元素拖动如何实现，原理是怎样"><a href="#36-元素拖动如何实现，原理是怎样" class="headerlink" title="36.元素拖动如何实现，原理是怎样?"></a>36.元素拖动如何实现，原理是怎样?</h4><p>实现元素拖动的常见方式是使用 JavaScript 监听鼠标事件，并在鼠标移动时更新元素的位置。拖动元素的基本原理如下：</p><ol><li>在鼠标按下事件（mousedown）中，记录鼠标的初始位置和需要拖动的元素的初始位置。</li><li>在鼠标移动事件（mousemove）中，计算鼠标的偏移量（鼠标当前位置减去初始位置），然后将偏移量加上元素的初始位置，从而得到元素的新位置。</li><li>将元素的新位置应用到元素的样式中，实现拖动效果。</li><li>在鼠标抬起事件（mouseup）中，取消事件监听，结束拖动。</li></ol><p>下面是一个简单的实现元素拖动的示例：</p><p>HTML：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;draggableElement&quot; style=&quot;width: 100px; height: 100px; background-color: red; position: absolute; top: 100px; left: 100px;&quot;&gt;</span><br><span class="line">  Drag me!</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>JavaScript：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const draggableElement = document.getElementById(&quot;draggableElement&quot;);</span><br><span class="line"></span><br><span class="line">let isDragging = false;</span><br><span class="line">let initialX;</span><br><span class="line">let initialY;</span><br><span class="line"></span><br><span class="line">draggableElement.addEventListener(&quot;mousedown&quot;, (event) =&gt; &#123;</span><br><span class="line">  isDragging = true;</span><br><span class="line">  initialX = event.clientX - draggableElement.offsetLeft;</span><br><span class="line">  initialY = event.clientY - draggableElement.offsetTop;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">document.addEventListener(&quot;mousemove&quot;, (event) =&gt; &#123;</span><br><span class="line">  if (isDragging) &#123;</span><br><span class="line">    const xOffset = event.clientX - initialX;</span><br><span class="line">    const yOffset = event.clientY - initialY;</span><br><span class="line">    draggableElement.style.left = xOffset + &quot;px&quot;;</span><br><span class="line">    draggableElement.style.top = yOffset + &quot;px&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">document.addEventListener(&quot;mouseup&quot;, () =&gt; &#123;</span><br><span class="line">  isDragging = false;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在上述示例中，我们首先获取需要拖动的元素 <code>draggableElement</code>，然后使用三个变量 <code>isDragging</code>、<code>initialX</code> 和 <code>initialY</code> 来记录拖动状态和初始位置。在鼠标按下事件中，我们记录鼠标的初始位置和元素的初始位置。在鼠标移动事件中，我们计算鼠标的偏移量，并将偏移量应用到元素的样式中，实现拖动效果。在鼠标抬起事件中，我们取消拖动状态，结束拖动。</p><p>这样，当我们点击并拖动元素时，它会随着鼠标移动而改变位置，实现了元素的拖动效果。</p><h4 id="37-什么是重绘-repaint-什么是回流-reflow-如何最小化重绘和回流"><a href="#37-什么是重绘-repaint-什么是回流-reflow-如何最小化重绘和回流" class="headerlink" title="37.什么是重绘(repaint)?什么是回流(reflow)?如何最小化重绘和回流?"></a>37.什么是重绘(repaint)?什么是回流(reflow)?如何最小化重绘和回流?</h4><p>重绘（Repaint）和回流（Reflow）是浏览器渲染页面时的两个重要概念：</p><p><strong>重绘（Repaint）：</strong> 重绘是指当元素样式发生改变，但不影响其布局的情况下，浏览器重新绘制元素的过程。重绘不涉及元素的位置和大小的变化，只是重新绘制元素的外观，例如颜色、背景等。</p><p><strong>回流（Reflow）：</strong> 回流是指当页面布局发生改变，浏览器重新计算元素的大小和位置，并重新渲染页面的过程。回流涉及页面布局的改变，例如元素的大小、位置、隐藏状态等。</p><p><strong>最小化重绘和回流的方法：</strong> 由于重绘和回流可能会引起性能问题，我们应该尽量避免不必要的重绘和回流，以提高页面性能。以下是一些最小化重绘和回流的方法：</p><ol><li><strong>使用 class 替代 style：</strong> 使用 class 来修改元素样式，而不是直接操作 style 属性。这样可以将多个样式的修改合并为一个 class 的修改，减少重绘和回流的次数。</li><li><strong>使用文档片段：</strong> 在插入大量 DOM 元素时，使用文档片段（DocumentFragment）来一次性插入，而不是多次单独插入。这样可以减少回流次数。</li><li><strong>使用 CSS3 动画：</strong> 在需要进行动画效果的元素上，尽量使用 CSS3 动画，而不是 JavaScript 控制样式。CSS3 动画在很多情况下使用了 GPU 加速，效率更高。</li><li><strong>避免强制同步布局：</strong> 如果需要获取元素的位置或尺寸等信息，尽量使用异步的方式，避免强制同步布局，以减少回流。</li><li><strong>使用 transform 替代 top&#x2F;left：</strong> 如果需要移动元素，尽量使用 CSS3 的 transform 属性，而不是直接修改 top 和 left 属性。transform 属性不会引起回流。</li><li><strong>避免 table 布局：</strong> 使用 table 布局会导致回流，尽量使用 CSS 布局代替。</li><li><strong>缓存布局信息：</strong> 当需要多次获取元素的布局信息时，应该缓存这些信息，避免重复触发回流。</li></ol><p>以上方法都有助于减少重绘和回流，提高页面性能和用户体验。在实际开发中，尽量遵循这些最佳实践，以优化页面性能。</p><h4 id="38-延迟加载的方式有哪些"><a href="#38-延迟加载的方式有哪些" class="headerlink" title="38.延迟加载的方式有哪些?"></a>38.延迟加载的方式有哪些?</h4><p>延迟加载（Lazy Loading）是一种优化网页性能的技术，它可以延迟加载页面中的资源（如图片、脚本、样式等），直到这些资源在用户视图中可见或需要使用时再进行加载。这样可以减少页面的初始加载时间，提高网页的加载速度和用户体验。以下是常见的延迟加载方式：</p><ol><li><strong>图片延迟加载：</strong> 将页面上的图片的 <code>src</code> 属性设为占位符（如一张空白的图片），然后使用自定义的属性（如 <code>data-src</code>）保存真实的图片地址。当图片进入用户视图时（如滚动到可见区域），再将真实的图片地址赋值给 <code>src</code> 属性，从而实现图片的延迟加载。</li><li><strong>懒加载脚本：</strong> 将不是页面初始加载必需的脚本标记为异步或延迟加载，可以通过将 <code>async</code> 或 <code>defer</code> 属性添加到 <code>&lt;script&gt;</code> 标签来实现。<code>async</code> 属性会异步加载并立即执行脚本，不会阻塞页面加载；<code>defer</code> 属性会在页面加载完成后顺序执行脚本，但不会阻塞 DOM 的解析。</li><li><strong>懒加载样式：</strong> 对于不是页面初始加载必需的样式（如页面上的一些特定样式或主题样式），可以将其标记为异步加载，或通过 JavaScript 动态插入样式表。</li><li><strong>无限滚动：</strong> 对于包含大量数据的列表或瀑布流布局等，可以使用无限滚动的方式，当用户滚动到列表底部时，再加载更多的数据，以避免一次性加载过多的内容。</li><li><strong>按需加载模块：</strong> 对于模块化的前端代码（如通过 ES6 模块导入的脚本），可以使用动态 <code>import()</code> 方法来按需加载模块，当模块需要使用时再进行加载。</li><li><strong>分片加载：</strong> 将页面中的内容分为多个块（chunks），按需加载块中的内容。这种方式常用于 Webpack 或其他打包工具的代码拆分功能。</li></ol><p>使用延迟加载的方式可以显著提高网页的初始加载速度，特别对于包含大量资源或数据的页面。在实际开发中，根据页面的需求和性能优化目标，选择合适的延迟加载方式，有助于提升网页性能，减少用户等待时间。</p><h4 id="39-垃圾回收机制有哪些-具体怎么如何执行"><a href="#39-垃圾回收机制有哪些-具体怎么如何执行" class="headerlink" title="39.垃圾回收机制有哪些?具体怎么如何执行?"></a>39.垃圾回收机制有哪些?具体怎么如何执行?</h4><p>在计算机科学中，垃圾回收（Garbage Collection）是一种自动管理内存的机制，它负责检测不再使用的内存对象（垃圾），并释放这些内存，以供其他对象使用。常见的垃圾回收机制有以下几种：</p><ol><li><strong>引用计数垃圾回收（Reference Counting Garbage Collection）：</strong> 这是最简单的垃圾回收算法。它通过对每个对象维护一个引用计数器，记录有多少个引用指向该对象。当引用计数为 0 时，表示该对象不再被引用，可以被释放。但是引用计数垃圾回收无法处理循环引用的情况，因为循环引用会导致对象之间的引用计数不为 0。</li><li><strong>标记-清除垃圾回收（Mark and Sweep Garbage Collection）：</strong> 这是一种常用的垃圾回收算法。它通过从根对象开始，标记所有可达的对象（即根对象引用的对象及其引用的对象，依次类推）。标记完成后，未被标记的对象即为垃圾，可以被清除。标记-清除垃圾回收能够处理循环引用的情况，并清除不再使用的对象。</li><li><strong>标记-整理垃圾回收（Mark and Compact Garbage Collection）：</strong> 这是标记-清除算法的改进版。除了标记和清除不再使用的对象外，标记-整理还会将存活的对象紧凑排列在内存中，从而减少内存碎片，提高内存使用效率。</li><li><strong>分代垃圾回收（Generational Garbage Collection）：</strong> 分代垃圾回收将对象按照其生命周期划分为多个代（Generation）。一般情况下，新创建的对象属于新生代，生命周期较短；而存活时间较长的对象属于老生代。分代垃圾回收针对不同代采用不同的回收策略，例如，针对新生代采用较频繁但速度较快的回收策略，针对老生代采用较少但速度较慢的回收策略，以提高回收效率。</li></ol><p>垃圾回收的执行步骤通常包括以下几个阶段：</p><ol><li><strong>标记（Mark）：</strong> 从根对象出发，递归地标记所有可达的对象。</li><li><strong>清除（Sweep）：</strong> 遍历整个堆内存，清除所有未标记的对象，将其内存释放。</li><li><strong>整理（Compact，可选）：</strong> 将存活的对象紧凑排列在内存中，减少内存碎片。</li></ol><p>在实际应用中，不同编程语言和运行环境会采用不同的垃圾回收算法和策略，以适应不同的场景和需求。垃圾回收机制的优化是提高应用性能和资源利用率的重要手段。</p><h4 id="40-什么是内存泄漏"><a href="#40-什么是内存泄漏" class="headerlink" title="40.什么是内存泄漏?"></a>40.什么是内存泄漏?</h4><p>内存泄漏（Memory Leak）是指程序在运行过程中，由于错误的内存管理导致一些不再使用的内存无法被及时释放，从而造成内存的持续占用，最终导致可用内存逐渐减少，直至耗尽系统的内存资源。</p><p>内存泄漏通常是由于程序中存在一些无法访问到的内存对象占用了内存空间，而无法回收这些对象的内存。这些未释放的内存会逐渐累积，导致程序的内存使用量逐渐增加，直至达到系统的内存限制，进而引发程序崩溃、运行缓慢或导致其他系统性能问题。</p><p>内存泄漏可能由以下原因引起：</p><ol><li><strong>未及时释放动态分配的内存：</strong> 当程序动态分配内存（如使用 <code>new</code> 或 <code>malloc</code>）后，应及时使用 <code>delete</code> 或 <code>free</code> 释放内存。如果未释放，这些内存将一直占用，造成内存泄漏。</li><li><strong>循环引用：</strong> 当两个或多个对象之间存在相互引用关系，并且这些对象不再被使用时没有及时解除引用，会导致这些对象无法被垃圾回收，从而引发内存泄漏。</li><li><strong>全局变量：</strong> 全局变量在程序的整个生命周期内都存在，如果不再使用时没有释放或清除这些全局变量的引用，会导致内存泄漏。</li><li><strong>未关闭的资源：</strong> 如果程序打开了文件、网络连接或数据库连接等资源，在不再使用时没有正确关闭这些资源，会造成资源泄漏，最终导致内存泄漏。</li></ol><p>解决内存泄漏的方法包括：</p><ul><li>在使用完动态分配的内存后，及时释放它们。</li><li>避免循环引用，确保对象之间的引用关系能够正确地被垃圾回收。</li><li>尽量避免使用全局变量，使用局部变量或限制作用域来控制变量的生命周期。</li><li>在使用资源（如文件、网络连接等）后，及时关闭或释放这些资源。</li></ul><p>通过合理的内存管理，开发者可以避免内存泄漏问题，确保程序正常运行，并减少资源浪费。</p><h4 id="41-数组遍历的方法有哪些，分别有什么特点，性能如何"><a href="#41-数组遍历的方法有哪些，分别有什么特点，性能如何" class="headerlink" title="41.数组遍历的方法有哪些，分别有什么特点，性能如何?"></a>41.数组遍历的方法有哪些，分别有什么特点，性能如何?</h4><p>数组遍历的方法有多种，下面列举常见的数组遍历方法，以及它们的特点和性能：</p><ol><li><p><strong>for 循环：</strong> 这是最基本的数组遍历方法，通过索引逐个访问数组元素。它的特点是简单直接，适用于所有类型的数组，但写法相对繁琐，需要手动管理索引。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const arr = [1, 2, 3, 4, 5];</span><br><span class="line">for (let i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">  console.log(arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>性能：</strong> for 循环的性能是最好的，因为它直接通过索引访问数组元素，没有额外的函数调用和迭代过程。</p></li><li><p><strong>forEach 方法：</strong> forEach 是数组的内置方法，可以直接对数组进行遍历，对每个元素执行指定的回调函数。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const arr = [1, 2, 3, 4, 5];</span><br><span class="line">arr.forEach((item) =&gt; &#123;</span><br><span class="line">  console.log(item);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>特点：</strong> forEach 方法简化了遍历过程，不需要手动管理索引，直接对数组元素执行操作。</p><p><strong>性能：</strong> forEach 方法的性能较好，但在某些情况下可能比 for 循环略慢，因为它使用了回调函数，可能会涉及函数的创建和执行。</p></li><li><p><strong>for…of 循环：</strong> for…of 循环是 ES6 引入的一种新的遍历方式，它可以遍历可迭代对象，包括数组。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const arr = [1, 2, 3, 4, 5];</span><br><span class="line">for (const item of arr) &#123;</span><br><span class="line">  console.log(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>特点：</strong> for…of 循环简洁易读，遍历过程中无需处理索引，直接访问元素。</p><p><strong>性能：</strong> for…of 循环的性能通常和 forEach 方法相当，也会因使用回调函数而略慢于 for 循环。</p></li><li><p><strong>map 方法：</strong> map 方法是数组的内置方法，用于遍历数组，并返回一个新的数组，新数组的每个元素都是对原数组元素的处理结果。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const arr = [1, 2, 3, 4, 5];</span><br><span class="line">const newArr = arr.map((item) =&gt; item * 2);</span><br><span class="line">console.log(newArr);</span><br></pre></td></tr></table></figure><p><strong>特点：</strong> map 方法在遍历的同时生成一个新的数组，对原数组的元素进行处理并映射到新数组中。</p><p><strong>性能：</strong> map 方法和 forEach 方法类似，性能较好，但会因使用回调函数而略慢于 for 循环。</p></li><li><p><strong>其他方法：</strong> 还有一些其他的数组遍历方法，如 filter、reduce、every、some 等，它们都有不同的用途，适用于不同的场景。</p><ul><li>filter 方法：返回符合条件的元素组成的新数组。</li><li>reduce 方法：累加器，将数组元素按指定规则聚合为一个值。</li><li>every 方法：检查数组中是否所有元素都满足某个条件。</li><li>some 方法：检查数组中是否有至少一个元素满足某个条件。</li></ul><p>这些方法在功能上各有不同，使用时需要根据实际需求选择适当的方法。</p></li></ol><p>总体来说，for 循环在性能上是最好的，但 forEach、for…of 和 map 方法在代码的可读性和简洁性上更好。在大多数情况下，这些方法的性能差异并不明显，可以根据具体场景选择最适合的遍历方法。</p><h4 id="42-ES5-和ES6的区别，ES6新增了什么"><a href="#42-ES5-和ES6的区别，ES6新增了什么" class="headerlink" title="42.ES5 和ES6的区别，ES6新增了什么?"></a>42.ES5 和ES6的区别，ES6新增了什么?</h4><p>ES5（ECMAScript 5）和ES6（ECMAScript 2015，也称为ES6）是 JavaScript 的两个主要版本，它们之间有许多区别。ES6是ES5的升级版本，引入了许多新的特性和语法，以便使 JavaScript 语言更加现代化、灵活和易用。以下是ES5和ES6之间的主要区别以及ES6新增的一些功能：</p><ol><li><strong>let 和 const 声明：</strong> ES6引入了块级作用域的变量声明，使用<code>let</code>声明的变量具有块级作用域，而使用<code>const</code>声明的变量是常量，不可重新赋值。</li><li><strong>箭头函数：</strong> ES6引入了箭头函数语法，使得函数的定义更加简洁，并且箭头函数没有自己的<code>this</code>和<code>arguments</code>，继承了外部作用域的<code>this</code>和<code>arguments</code>。</li><li><strong>模板字面量：</strong> ES6引入了模板字面量，使用反引号（&#96;）包围字符串，可以在字符串中插入变量和表达式，使得字符串的拼接更加简洁和方便。</li><li><strong>解构赋值：</strong> ES6引入了解构赋值语法，可以快速地从数组或对象中提取值，并赋值给变量，以简化代码。</li><li><strong>Promise：</strong> ES6引入了Promise对象，用于处理异步操作，避免了回调地狱，使得异步代码更加可读和易于管理。</li><li><strong>类和继承：</strong> ES6引入了类的概念，使用<code>class</code>关键字声明类，并通过<code>extends</code>关键字实现类的继承。</li><li><strong>模块化：</strong> ES6引入了模块化的语法，使用<code>import</code>和<code>export</code>关键字导入和导出模块，使得代码的组织和管理更加清晰和灵活。</li><li><strong>扩展运算符：</strong> ES6引入了扩展运算符（<code>...</code>），可以将数组或对象展开成逗号分隔的参数序列，方便地传递参数或合并数组、对象。</li><li><strong>Set 和 Map 数据结构：</strong> ES6引入了Set和Map两种新的数据结构，Set是一种无重复元素的集合，Map是一种键值对的映射。</li><li><strong>默认参数：</strong> ES6允许函数的参数设置默认值，当函数调用时没有传递对应的参数时，将使用默认值。</li><li><strong>Rest 参数：</strong> ES6引入了Rest参数，允许将不确定数量的参数表示为一个数组。</li><li><strong>Symbol：</strong> ES6引入了Symbol数据类型，用于创建唯一的、不可变的值，可以用作对象的属性名。</li></ol><p>除了上述功能之外，ES6还增加了许多其他功能和语法改进，如迭代器、生成器、模块的动态导入、Proxy、Reflect等，这些都为JavaScript语言的使用和开发带来了更多便利和可能性。由于ES6的广泛支持，现在越来越多的前端开发者开始使用ES6来编写现代化的JavaScript代码。</p><h4 id="43-ES6的继承和ES5的继承有什么区别"><a href="#43-ES6的继承和ES5的继承有什么区别" class="headerlink" title="43.ES6的继承和ES5的继承有什么区别?"></a>43.ES6的继承和ES5的继承有什么区别?</h4><p>ES6的继承和ES5的继承在实现方式和语法上有较大的区别。主要的区别如下：</p><p><strong>ES6的继承（Class 继承）：</strong></p><ol><li><strong>关键字：</strong> ES6使用<code>class</code>关键字来声明类和继承关系。</li><li><strong>构造函数：</strong> 在ES6的继承中，使用<code>constructor</code>方法来定义类的构造函数，而不是像ES5中使用函数来定义构造函数。</li><li><strong>继承：</strong> 使用<code>extends</code>关键字来实现继承，子类通过<code>extends</code>关键字继承父类的属性和方法。</li><li><strong>super 关键字：</strong> 在子类的构造函数中，使用<code>super</code>关键字来调用父类的构造函数，以便初始化父类的属性。</li><li><strong>方法定义：</strong> 在类的定义中，可以直接通过方法名来定义类的方法，不需要使用<code>prototype</code>关键字。</li><li><strong>静态方法：</strong> ES6引入了静态方法的概念，使用<code>static</code>关键字来定义静态方法，静态方法属于类本身而不是实例。</li></ol><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy codeclass Animal &#123;</span><br><span class="line">  constructor(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  speak() &#123;</span><br><span class="line">    console.log(this.name + &#x27; makes a sound&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dog extends Animal &#123;</span><br><span class="line">  constructor(name, breed) &#123;</span><br><span class="line">    super(name);</span><br><span class="line">    this.breed = breed;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  speak() &#123;</span><br><span class="line">    console.log(this.name + &#x27; barks&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static info() &#123;</span><br><span class="line">    console.log(&#x27;This is a Dog class&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const dog = new Dog(&#x27;Buddy&#x27;, &#x27;Golden Retriever&#x27;);</span><br><span class="line">dog.speak(); // Output: Buddy barks</span><br><span class="line">Dog.info(); // Output: This is a Dog class</span><br></pre></td></tr></table></figure><p><strong>ES5的继承（原型链继承）：</strong></p><ol><li><strong>构造函数：</strong> 在ES5的继承中，通过构造函数创建对象，使用<code>new</code>关键字调用构造函数。</li><li><strong>原型链：</strong> 在原型链继承中，通过将子类的原型对象指向父类的实例来实现继承，子类将继承父类的属性和方法。</li><li><strong>调用父类构造函数：</strong> 在子类的构造函数中，通过<code>Parent.call(this, ...)</code>调用父类的构造函数，以便初始化父类的属性。</li><li><strong>方法定义：</strong> 在构造函数的<code>prototype</code>上定义类的方法。</li></ol><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Animal(name) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Animal.prototype.speak = function() &#123;</span><br><span class="line">  console.log(this.name + &#x27; makes a sound&#x27;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function Dog(name, breed) &#123;</span><br><span class="line">  Animal.call(this, name);</span><br><span class="line">  this.breed = breed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Dog.prototype = Object.create(Animal.prototype);</span><br><span class="line">Dog.prototype.constructor = Dog;</span><br><span class="line"></span><br><span class="line">Dog.prototype.speak = function() &#123;</span><br><span class="line">  console.log(this.name + &#x27; barks&#x27;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var dog = new Dog(&#x27;Buddy&#x27;, &#x27;Golden Retriever&#x27;);</span><br><span class="line">dog.speak(); // Output: Buddy barks</span><br></pre></td></tr></table></figure><p>总的来说，ES6的继承更加简洁、易读，使用<code>class</code>关键字和<code>extends</code>关键字可以更直观地描述类的继承关系，而且引入了静态方法的概念。相比之下，ES5的继承通过原型链和构造函数来实现，语法相对复杂一些。由于ES6的继承更加符合现代JavaScript开发的需求，推荐在新项目中使用ES6的继承方式。</p><h4 id="44-var、-let、-const-之间的区别-暂时性死区如何理解"><a href="#44-var、-let、-const-之间的区别-暂时性死区如何理解" class="headerlink" title="44.var、 let、 const 之间的区别?暂时性死区如何理解?"></a>44.var、 let、 const 之间的区别?暂时性死区如何理解?</h4><p><code>var</code>、<code>let</code>和<code>const</code>是 JavaScript 中用于声明变量的关键字，它们之间有一些重要的区别：</p><ol><li><strong>var：</strong><ul><li>在ES5中引入的关键字，具有函数作用域（function scope）。</li><li>声明的变量会被提升到函数的顶部，这就是所谓的”变量提升”（hoisting），在声明之前就可以访问到变量，但值为<code>undefined</code>。</li><li>可以重复声明同名的变量，后面的声明会覆盖前面的声明。</li><li>不受块级作用域控制，可能会导致意外的变量覆盖或泄漏。</li></ul></li><li><strong>let：</strong><ul><li>在ES6中引入的关键字，具有块级作用域（block scope）。</li><li>声明的变量不会被提升，只有在声明之后才能访问到变量。</li><li>不允许重复声明同名的变量，重复声明会导致错误。</li><li>在块级作用域内有效，避免了变量覆盖和泄漏的问题。</li></ul></li><li><strong>const：</strong><ul><li>也是在ES6中引入的关键字，具有块级作用域。</li><li>声明的是常量，一旦赋值后就不能再改变。</li><li>声明的同时必须进行初始化，否则会导致错误。</li><li>对于基本数据类型，常量的值是不可变的，但对于复杂数据类型（如对象和数组），可以修改其内部的属性或元素。</li></ul></li></ol><p>暂时性死区（Temporal Dead Zone，简称TDZ）是指在块级作用域中，使用<code>let</code>和<code>const</code>声明的变量在声明之前是不可访问的，并且如果尝试访问这些变量会导致运行时错误。这是因为在块级作用域内，变量在声明之前处于一个”暂时性死区”，只有在变量的声明语句执行完成之后，变量才会被创建并可以正常访问。</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(a); // ReferenceError: a is not defined</span><br><span class="line">let a = 10;</span><br></pre></td></tr></table></figure><p>在上面的代码中，变量<code>a</code>虽然已经声明了，但由于处于暂时性死区，尝试访问<code>a</code>会导致运行时错误。</p><p>暂时性死区的引入是为了解决<code>var</code>声明的变量提升问题，使得变量的作用域更加清晰和可控。在编写代码时，应尽量将变量声明放在作用域的顶部，以避免因暂时性死区导致的错误。</p><h4 id="45-Class、-extends-是什么，有什么作用"><a href="#45-Class、-extends-是什么，有什么作用" class="headerlink" title="45.Class、 extends 是什么，有什么作用?"></a>45.Class、 extends 是什么，有什么作用?</h4><p>在 JavaScript 中，<code>class</code>是一个关键字，<code>extends</code>是另一个关键字，它们用于实现面向对象编程中的类和继承。</p><p><strong>Class：</strong> <code>class</code>关键字用于定义一个类，类是一种抽象的数据类型，用于描述具有相同属性和方法的对象的集合。类是面向对象编程的基本概念，它允许我们将数据和行为封装在一起，并通过实例化来创建具体的对象。类提供了一种创建对象的模板，可以用来创建多个具有相同属性和方法的对象。</p><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">  constructor(name, species) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.species = species;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  speak() &#123;</span><br><span class="line">    console.log(this.name + &#x27; makes a sound&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const dog = new Animal(&#x27;Buddy&#x27;, &#x27;Dog&#x27;);</span><br><span class="line">console.log(dog.species); // Output: Dog</span><br><span class="line">dog.speak(); // Output: Buddy makes a sound</span><br></pre></td></tr></table></figure><p><strong>Extends：</strong> <code>extends</code>关键字用于在一个类中创建另一个类的子类，实现继承关系。子类继承了父类的属性和方法，并可以在子类中定义新的属性和方法，或覆盖父类的方法。继承允许我们创建一个类的层次结构，通过共享通用的属性和方法来减少重复代码，并在子类中实现特定的功能。</p><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">  constructor(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  speak() &#123;</span><br><span class="line">    console.log(this.name + &#x27; makes a sound&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dog extends Animal &#123;</span><br><span class="line">  constructor(name, breed) &#123;</span><br><span class="line">    super(name);</span><br><span class="line">    this.breed = breed;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  bark() &#123;</span><br><span class="line">    console.log(this.name + &#x27; barks&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const dog = new Dog(&#x27;Buddy&#x27;, &#x27;Golden Retriever&#x27;);</span><br><span class="line">console.log(dog.breed); // Output: Golden Retriever</span><br><span class="line">dog.speak(); // Output: Buddy makes a sound</span><br><span class="line">dog.bark(); // Output: Buddy barks</span><br></pre></td></tr></table></figure><p>通过继承，<code>Dog</code>类继承了<code>Animal</code>类的<code>name</code>属性和<code>speak</code>方法，并在<code>Dog</code>类中添加了新的<code>breed</code>属性和<code>bark</code>方法。</p><p>总结：<code>class</code>和<code>extends</code>关键字是 JavaScript 中实现面向对象编程的重要特性。<code>class</code>用于定义类，<code>extends</code>用于实现类的继承，它们共同为我们提供了一种简洁、灵活和可扩展的方式来组织和管理代码。</p><h4 id="46-什么是JS包"><a href="#46-什么是JS包" class="headerlink" title="46.什么是JS包"></a>46.什么是JS包</h4><p>在 JavaScript 中，”包”（Package）通常是指一组相关的代码文件和资源，以及一个描述文件，用于将这些文件和资源打包成一个单独的、可重用的单元。包的概念主要用于模块化开发，可以将代码和资源按照功能或业务逻辑进行组织，以便于管理和复用。</p><p>常见的 JavaScript 包管理工具是 npm（Node Package Manager），它是 Node.js 生态系统中的包管理工具，也是最大的开源软件注册表，拥有数以百万计的包供开发者使用。通过 npm，开发者可以轻松地安装、发布、更新和管理 JavaScript 包。</p><p>一个典型的 JavaScript 包通常包含以下内容：</p><ol><li><strong>代码文件：</strong> 包含实现特定功能的 JavaScript 代码文件，可以是单个文件或多个文件的组合。</li><li><strong>资源文件：</strong> 包含其他类型的资源文件，如图片、样式表、配置文件等。</li><li><strong>package.json：</strong> 是包的描述文件，其中包含了关于包的信息，比如名称、版本、作者、依赖项等。</li><li><strong>README：</strong> 包的说明文件，通常包含包的用法、示例代码等。</li><li><strong>LICENSE：</strong> 包的许可证文件，规定了使用该包的许可协议。</li></ol><p>JavaScript 包的优势在于它们可以封装代码和资源，并提供良好的模块化开发体验。通过使用包管理工具，我们可以方便地在项目中引用其他开源包，并且可以将自己的代码和资源打包成包，方便其他开发者使用。这种模块化的开发方式提高了代码的复用性、可维护性和可扩展性，是现代 JavaScript 开发中的重要实践。</p><h4 id="47-说一下类的创建和继承，列举一下你所知道的继承方式"><a href="#47-说一下类的创建和继承，列举一下你所知道的继承方式" class="headerlink" title="47.说一下类的创建和继承，列举一下你所知道的继承方式"></a>47.说一下类的创建和继承，列举一下你所知道的继承方式</h4><p>在 JavaScript 中，类的创建和继承是面向对象编程的重要概念。ES6引入了<code>class</code>关键字用于创建类和继承关系，而继承可以通过<code>extends</code>关键字实现。</p><p><strong>类的创建：</strong> 在ES6中，可以使用<code>class</code>关键字来定义一个类，类是一个模板，描述了一类对象的共同属性和方法。类中使用<code>constructor</code>方法来定义类的构造函数，其他方法则直接定义在类的原型上。</p><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">  constructor(name, species) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.species = species;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  speak() &#123;</span><br><span class="line">    console.log(this.name + &#x27; makes a sound&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const dog = new Animal(&#x27;Buddy&#x27;, &#x27;Dog&#x27;);</span><br><span class="line">dog.speak(); // Output: Buddy makes a sound</span><br></pre></td></tr></table></figure><p><strong>继承：</strong> 继承是一种创建类之间关系的方式，使得一个类可以从另一个类继承属性和方法。在ES6中，可以使用<code>extends</code>关键字来实现继承，子类通过<code>extends</code>关键字继承父类的属性和方法，并可以在子类中添加新的属性和方法，或者覆盖父类的方法。</p><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">  constructor(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  speak() &#123;</span><br><span class="line">    console.log(this.name + &#x27; makes a sound&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dog extends Animal &#123;</span><br><span class="line">  constructor(name, breed) &#123;</span><br><span class="line">    super(name); // 调用父类的构造函数</span><br><span class="line">    this.breed = breed;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  bark() &#123;</span><br><span class="line">    console.log(this.name + &#x27; barks&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const dog = new Dog(&#x27;Buddy&#x27;, &#x27;Golden Retriever&#x27;);</span><br><span class="line">dog.speak(); // Output: Buddy makes a sound</span><br><span class="line">dog.bark(); // Output: Buddy barks</span><br></pre></td></tr></table></figure><p>以上就是使用ES6中的<code>class</code>和<code>extends</code>关键字创建类和实现继承的方式。除此之外，JavaScript还有其他几种继承方式：</p><ol><li><strong>原型链继承：</strong> 使用原型链来实现继承，子类的原型对象指向父类的实例，从而继承父类的属性和方法。</li><li><strong>构造函数继承：</strong> 在子类的构造函数中使用<code>Parent.call(this, ...)</code>调用父类的构造函数，实现继承父类的属性。</li><li><strong>组合继承：</strong> 结合原型链继承和构造函数继承，通过原型链继承父类的方法，通过构造函数继承父类的属性。</li><li><strong>原型式继承：</strong> 利用一个中间对象作为桥梁，将父类的原型对象赋值给子类的原型对象，实现继承。</li><li><strong>寄生式继承：</strong> 在原型式继承的基础上，增强了新的方法或属性，返回一个新的对象。</li><li><strong>寄生组合式继承：</strong> 使用寄生式继承来继承父类的原型对象，并修正子类的构造函数指向。</li></ol><p>其中，ES6的<code>class</code>和<code>extends</code>关键字是最常用和推荐的继承方式，因为它们提供了更简洁、易读的语法来定义类和继承关系。</p><h4 id="48-如何解决异步回调地狱"><a href="#48-如何解决异步回调地狱" class="headerlink" title="48.如何解决异步回调地狱"></a>48.如何解决异步回调地狱</h4><p>异步回调地狱是指在 JavaScript 中，多个异步操作嵌套在彼此之中，导致代码结构混乱、难以理解和维护的情况。为了解决异步回调地狱，可以采用以下几种方法：</p><ol><li><strong>使用 Promise：</strong> Promise 是 JavaScript 中的一种处理异步操作的方式，它可以避免回调地狱，使得异步操作可以更加简洁和可读。通过 Promise，可以链式调用多个异步操作，使用<code>.then()</code>和<code>.catch()</code>方法处理异步操作的结果和错误。</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">asyncFunction1()</span><br><span class="line">  .then(result1 =&gt; &#123;</span><br><span class="line">    // 处理结果</span><br><span class="line">    return asyncFunction2();</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(result2 =&gt; &#123;</span><br><span class="line">    // 处理结果</span><br><span class="line">    return asyncFunction3();</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(result3 =&gt; &#123;</span><br><span class="line">    // 处理结果</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(error =&gt; &#123;</span><br><span class="line">    // 处理错误</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><ol><li><strong>使用 async&#x2F;await：</strong> async&#x2F;await 是 ES2017 中引入的语法糖，用于简化 Promise 的使用，使得异步操作可以更像同步操作一样的写法。通过 async&#x2F;await，可以以同步的方式编写异步代码，避免了回调地狱。</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">async function asyncOperation() &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    const result1 = await asyncFunction1();</span><br><span class="line">    // 处理结果</span><br><span class="line">    const result2 = await asyncFunction2();</span><br><span class="line">    // 处理结果</span><br><span class="line">    const result3 = await asyncFunction3();</span><br><span class="line">    // 处理结果</span><br><span class="line">  &#125; catch (error) &#123;</span><br><span class="line">    // 处理错误</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>使用第三方库或工具：</strong> 有一些第三方库或工具可以帮助简化异步代码的编写，比如 <code>async.js</code>、<code>q</code>、<code>bluebird</code> 等。这些库提供了更多的功能和方法，使得异步操作可以更加灵活和易于管理。</li><li><strong>模块化和拆分：</strong> 将复杂的异步操作拆分成多个独立的函数或模块，使得代码结构更清晰，每个函数只负责一个特定的异步操作，可以减少回调地狱的问题。</li><li><strong>使用 Generator：</strong> Generator 是 ES2015 中引入的一种迭代器，它可以用于控制异步操作的流程，也可以减少回调地狱。不过，使用 Generator 需要更多的学习和理解，相比 Promise 和 async&#x2F;await，使用场景相对较少。</li></ol><p>以上方法都可以有效地解决异步回调地狱的问题，具体使用哪种方式取决于项目的需求和开发团队的技术栈。Promise 和 async&#x2F;await 是目前最常用的解决方案，它们可以显著提高代码的可读性和可维护性，使得异步操作更加优雅和简洁。</p><h4 id="49-说一下图片的懒加载和预加载"><a href="#49-说一下图片的懒加载和预加载" class="headerlink" title="49.说一下图片的懒加载和预加载"></a>49.说一下图片的懒加载和预加载</h4><p>图片的懒加载和预加载是优化网页性能的常用技术，它们都是针对图片加载进行的优化处理。</p><p><strong>图片的懒加载：</strong> 图片的懒加载是指延迟加载图片，只有当图片进入用户的可视区域时才开始加载。通常情况下，网页中的图片都是在页面加载时同时请求加载的，如果页面中有很多图片或图片较大，会导致页面加载速度变慢，影响用户体验。通过图片的懒加载，可以避免一次性加载过多图片，节省带宽和加载时间。</p><p>实现图片懒加载的方式有很多种，常见的方法包括：</p><ol><li>使用 Intersection Observer API：该 API 可以监听元素进入视口或离开视口的状态，当图片进入视口时，再进行图片的加载。</li><li>自定义 JavaScript 实现：可以通过监听滚动事件，判断图片是否进入视口，再进行图片的加载。</li><li>使用第三方库：很多 JavaScript 懒加载的第三方库可以帮助实现图片懒加载，比如 <code>LazyLoad</code>、<code>lozad.js</code> 等。</li></ol><p><strong>图片的预加载：</strong> 图片的预加载是指提前加载图片，在用户需要查看图片时可以更快地呈现图片，提高用户体验。预加载通常用于图片轮播、相册等场景，保证用户在切换图片时不会看到加载的过程。</p><p>实现图片预加载的方式有以下几种：</p><ol><li>使用 JavaScript 的 Image 对象：可以通过创建 Image 对象，并设置图片的 <code>src</code> 属性来实现预加载。</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">econst image = new Image();</span><br><span class="line">image.src = &#x27;image.jpg&#x27;;</span><br><span class="line">image.onload = () =&gt; &#123;</span><br><span class="line">  // 图片加载完成后的操作</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li>在 HTML 中使用 <code>link</code> 元素：可以在页面的 <code>head</code> 部分添加 <code>link</code> 元素，通过设置 <code>rel</code> 属性为 <code>preload</code>，并指定图片的 URL，来实现预加载。</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;link rel=&quot;preload&quot; as=&quot;image&quot; href=&quot;image.jpg&quot;&gt;</span><br><span class="line">&lt;/head&gt;</span><br></pre></td></tr></table></figure><ol><li>使用 CSS 的 <code>background-image</code> 属性：可以使用 CSS 来预加载图片，将图片设置为元素的背景图片，然后隐藏该元素。</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.preload-image &#123;</span><br><span class="line">  background-image: url(&#x27;image.jpg&#x27;);</span><br><span class="line">  width: 0;</span><br><span class="line">  height: 0;</span><br><span class="line">  visibility: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是图片的懒加载和预加载的简要介绍和实现方式。这两种技术可以很好地优化图片加载，提高网页的性能和用户体验。在实际开发中，可以根据项目需求选择适合的方案来实现图片的懒加载和预加载。</p><h4 id="50-mouseover和mouseenter的区别"><a href="#50-mouseover和mouseenter的区别" class="headerlink" title="50.mouseover和mouseenter的区别"></a>50.mouseover和mouseenter的区别</h4><p><code>mouseover</code> 和 <code>mouseenter</code> 是 JavaScript 中常用的鼠标事件，它们在触发时有一些区别。</p><p><strong><code>mouseover</code> 事件：</strong> <code>mouseover</code> 事件在鼠标指针进入元素或元素的子元素时触发。当鼠标指针从一个元素移动到其子元素上时，也会触发 <code>mouseover</code> 事件。这意味着，如果一个元素有嵌套的子元素，当鼠标从父元素进入子元素时，会触发两次 <code>mouseover</code> 事件。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">element.addEventListener(&#x27;mouseover&#x27;, function(event) &#123;</span><br><span class="line">  // 鼠标指针进入元素时触发</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong><code>mouseenter</code> 事件：</strong> <code>mouseenter</code> 事件在鼠标指针进入元素时触发，但不会在进入元素的子元素时触发。它只会在鼠标进入元素的边界时触发一次，而不管鼠标是否进入元素的子元素。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">element.addEventListener(&#x27;mouseenter&#x27;, function(event) &#123;</span><br><span class="line">  // 鼠标指针进入元素时触发，不会在进入子元素时触发</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>综上所述，<code>mouseover</code> 事件会在鼠标进入元素及其子元素时触发，而 <code>mouseenter</code> 事件只会在鼠标进入元素的边界时触发，不会在进入子元素时触发。因此，如果需要在鼠标进入元素时触发一次事件而不受子元素影响，可以使用 <code>mouseenter</code> 事件。如果需要在鼠标进入元素及其子元素时触发事件，可以使用 <code>mouseover</code> 事件。</p><h4 id="51-new操作符做了哪些事情"><a href="#51-new操作符做了哪些事情" class="headerlink" title="51.new操作符做了哪些事情"></a>51.new操作符做了哪些事情</h4><p><code>new</code> 操作符是 JavaScript 中用于创建对象实例的关键字，它做了以下几个主要的事情：</p><ol><li><strong>创建一个空对象：</strong> 在执行 <code>new</code> 操作符时，会创建一个新的空对象，这个对象即将成为实例对象。</li><li><strong>将构造函数的作用域赋给新对象：</strong> 将构造函数中的 <code>this</code> 指向新创建的空对象，使得构造函数中的属性和方法可以在新对象上访问和操作。</li><li><strong>执行构造函数的代码：</strong> 将新对象作为 <code>this</code>，执行构造函数中的代码，初始化实例对象的属性。</li><li><strong>返回新对象：</strong> 如果构造函数中没有返回其他对象，那么 <code>new</code> 操作符会返回新创建的对象作为实例。</li></ol><p>简化的示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Person(name, age) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const person1 = new Person(&#x27;Alice&#x27;, 30);</span><br><span class="line">console.log(person1); // Output: Person &#123; name: &#x27;Alice&#x27;, age: 30 &#125;</span><br></pre></td></tr></table></figure><p>在上述示例中，使用 <code>new</code> 操作符创建了一个 <code>Person</code> 类的实例 <code>person1</code>，<code>new</code> 操作符在后台做了以上的四个步骤：</p><ol><li>创建了一个空对象 <code>person1</code>。</li><li>将 <code>Person</code> 构造函数中的 <code>this</code> 指向 <code>person1</code>，使得 <code>name</code> 和 <code>age</code> 属性可以添加到 <code>person1</code> 对象上。</li><li>执行 <code>Person</code> 构造函数中的代码，设置 <code>person1</code> 的属性。</li><li>返回 <code>person1</code> 作为实例。</li></ol><p>需要注意的是，如果构造函数中有返回其他对象，那么 <code>new</code> 操作符会返回该对象，而不是新创建的实例对象。示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Person(name, age) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.age = age;</span><br><span class="line">  return &#123; greeting: &#x27;Hello&#x27; &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const person1 = new Person(&#x27;Alice&#x27;, 30);</span><br><span class="line">console.log(person1); // Output: &#123; greeting: &#x27;Hello&#x27; &#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，<code>Person</code> 构造函数中返回了一个对象 <code>&#123; greeting: &#39;Hello&#39; &#125;</code>，因此 <code>new</code> 操作符返回了该对象，而不是 <code>Person</code> 类的实例。</p><h4 id="52-改变函数内部this指针的指向函数-bind-apply-call-的区别-，内在分别是如何实现的"><a href="#52-改变函数内部this指针的指向函数-bind-apply-call-的区别-，内在分别是如何实现的" class="headerlink" title="52.改变函数内部this指针的指向函数(bind, apply, call 的区别)，内在分别是如何实现的?"></a>52.改变函数内部this指针的指向函数(bind, apply, call 的区别)，内在分别是如何实现的?</h4><p>在 JavaScript 中，可以使用 <code>bind</code>、<code>apply</code> 和 <code>call</code> 来改变函数内部的 <code>this</code> 指向。它们的作用都是为了在调用函数时明确指定函数内部的 <code>this</code> 的值，并且可以传递参数给函数。</p><p><strong>bind 方法：</strong> <code>bind</code> 方法会创建一个新的函数，并将原函数绑定到指定的对象上，返回一个新函数。新函数的 <code>this</code> 指向会被绑定到指定的对象，而不会被调用的位置决定。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const person = &#123;</span><br><span class="line">  name: &#x27;Alice&#x27;,</span><br><span class="line">  sayHello: function() &#123;</span><br><span class="line">    console.log(`Hello, $&#123;this.name&#125;`);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const greet = person.sayHello.bind(person);</span><br><span class="line">greet(); // Output: Hello, Alice</span><br></pre></td></tr></table></figure><p><strong>apply 和 call 方法：</strong> <code>apply</code> 和 <code>call</code> 方法的作用相似，都是用于改变函数的 <code>this</code> 指向，并立即执行函数。它们的区别在于传递参数的方式：</p><ul><li><code>apply</code> 方法接收两个参数：一个是要绑定的对象，另一个是一个数组或类数组对象，用于作为参数传递给函数。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const person = &#123;</span><br><span class="line">  name: &#x27;Alice&#x27;,</span><br><span class="line">  sayHello: function(greeting) &#123;</span><br><span class="line">    console.log(`$&#123;greeting&#125;, $&#123;this.name&#125;`);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">person.sayHello.apply(person, [&#x27;Hi&#x27;]); // Output: Hi, Alice</span><br></pre></td></tr></table></figure><ul><li><code>call</code> 方法接收的参数和 <code>apply</code> 方法一样，但是是逐个传递而不是数组。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const person = &#123;</span><br><span class="line">  name: &#x27;Alice&#x27;,</span><br><span class="line">  sayHello: function(greeting) &#123;</span><br><span class="line">    console.log(`$&#123;greeting&#125;, $&#123;this.name&#125;`);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">person.sayHello.call(person, &#x27;Hello&#x27;); // Output: Hello, Alice</span><br></pre></td></tr></table></figure><p><strong>内部实现：</strong> 这些方法的实现原理可以通过 JavaScript 的函数原型对象来理解。在每个函数对象上，都有 <code>bind</code>、<code>apply</code> 和 <code>call</code> 这三个方法。这些方法在被调用时，会改变函数内部的 <code>this</code> 指向，并在指定的上下文中执行函数。</p><ul><li><code>bind</code> 方法创建一个新函数，并返回这个新函数。新函数内部会调用原函数，并在其中使用指定的对象作为 <code>this</code> 指向。</li><li><code>apply</code> 方法和 <code>call</code> 方法在被调用时立即执行函数，并在执行函数时指定函数内部的 <code>this</code> 指向。它们通过传递指定的对象来改变函数内部的 <code>this</code> 指向，同时可以传递其他参数给函数。</li></ul><p>实现 <code>bind</code> 方法的简化示例代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Function.prototype.myBind = function(context) &#123;</span><br><span class="line">  const fn = this;</span><br><span class="line">  return function(...args) &#123;</span><br><span class="line">    return fn.apply(context, args);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过以上的自定义 <code>myBind</code> 方法，可以实现类似 <code>bind</code> 的功能。类似地，也可以实现 <code>apply</code> 和 <code>call</code> 方法的自定义版本。但是要注意，在实际开发中，通常直接使用 JavaScript 内置的 <code>bind</code>、<code>apply</code> 和 <code>call</code> 方法就可以满足大多数需求。</p><h4 id="53-JS的各种位置-比如clientHeight-scrollHeight-offsetHeight-以及scrollTop-offsetTop-clientTop的区别"><a href="#53-JS的各种位置-比如clientHeight-scrollHeight-offsetHeight-以及scrollTop-offsetTop-clientTop的区别" class="headerlink" title="53.JS的各种位置,比如clientHeight, scrollHeight, offsetHeight ,以及scrollTop,offsetTop, clientTop的区别?"></a>53.JS的各种位置,比如clientHeight, scrollHeight, offsetHeight ,以及scrollTop,offsetTop, clientTop的区别?</h4><p>这些属性是用于获取和设置元素在页面中的位置和尺寸的相关信息。它们之间的区别如下：</p><ol><li><strong>clientHeight：</strong><ul><li>获取元素可见区域的高度，包括内容区和内边距，但不包括边框和滚动条。</li><li>不包括元素的外边距和边框。</li><li>对于行内元素和空元素，<code>clientHeight</code> 始终为0。</li></ul></li><li><strong>scrollHeight：</strong><ul><li>获取元素内容区的实际高度，包括可见区域和溢出隐藏部分的内容。</li><li>不包括元素的内边距、边框和外边距。</li><li>如果元素的内容没有溢出，<code>scrollHeight</code> 等于 <code>clientHeight</code>。</li></ul></li><li><strong>offsetHeight：</strong><ul><li>获取元素在页面中占据的总高度，包括内容区、内边距、边框和滚动条（如果有）。</li><li>不包括元素的外边距。</li></ul></li><li><strong>scrollTop：</strong><ul><li>获取或设置元素内容区域滚动条的垂直偏移量，表示元素内容向上滚动的距离。</li></ul></li><li><strong>offsetTop：</strong><ul><li>获取元素的上边缘相对于视口顶部的距离，即元素在文档流中的位置。</li></ul></li><li><strong>clientTop：</strong><ul><li>获取元素的上边框宽度。</li></ul></li></ol><p>总结一下：</p><ul><li><code>clientHeight</code>：元素内容区的可见高度，包括内边距，不包括滚动条和边框。</li><li><code>scrollHeight</code>：元素内容区的实际高度，包括内边距和溢出隐藏的内容。</li><li><code>offsetHeight</code>：元素在页面中占据的总高度，包括内容区、内边距、边框和滚动条（如果有）。</li><li><code>scrollTop</code>：元素内容区的垂直滚动偏移量。</li><li><code>offsetTop</code>：元素的上边缘相对于视口顶部的距离。</li><li><code>clientTop</code>：元素上边框的宽度。</li></ul><p>这些属性在测量和操作元素的位置和尺寸时非常有用，在进行布局和滚动等操作时经常会用到。需要注意的是，这些属性的值可能受到元素的样式和父元素的影响，因此在使用时应该谨慎考虑可能的影响。</p><h4 id="54-异步加载JS的方法"><a href="#54-异步加载JS的方法" class="headerlink" title="54.异步加载JS的方法"></a>54.异步加载JS的方法</h4><p>异步加载 JavaScript 是一种优化网页性能的常见方法，它可以在页面加载时并行加载 JavaScript 文件，避免阻塞页面的渲染和交互。以下是几种异步加载 JavaScript 的方法：</p><ol><li><p><strong>使用 async 属性：</strong> 使用 <code>&lt;script&gt;</code> 标签并设置 <code>async</code> 属性，浏览器会异步加载并执行脚本，不会阻塞页面的渲染。当脚本加载完成后，会立即执行，但不会保证执行顺序。适用于独立的、不依赖其他脚本的情况。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script src=&quot;your-script.js&quot; async&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>使用 defer 属性：</strong> 使用 <code>&lt;script&gt;</code> 标签并设置 <code>defer</code> 属性，浏览器会异步加载脚本，但会等到整个文档解析完毕后再执行。多个带有 <code>defer</code> 属性的脚本会按照它们在文档中的顺序依次执行。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script src=&quot;your-script.js&quot; defer&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>动态创建 script 标签：</strong> 使用 JavaScript 动态创建 <code>&lt;script&gt;</code> 标签，并设置其 <code>src</code> 属性，然后将标签插入到页面中。这样脚本会异步加载，不会阻塞页面渲染。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const script = document.createElement(&#x27;script&#x27;);</span><br><span class="line">script.src = &#x27;your-script.js&#x27;;</span><br><span class="line">document.body.appendChild(script);</span><br></pre></td></tr></table></figure></li><li><p><strong>使用模块化加载：</strong> 使用模块化加载工具如 <code>import</code>、<code>require</code>，或使用 ES6 的模块化语法 <code>import</code> 来导入需要的模块。这样可以实现异步加载，并根据需要动态加载模块。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// CommonJS</span><br><span class="line">const module = require(&#x27;./your-module&#x27;);</span><br><span class="line"></span><br><span class="line">// ES6</span><br><span class="line">import module from &#x27;./your-module&#x27;;</span><br></pre></td></tr></table></figure></li><li><p><strong>使用异步加载库：</strong> 可以使用一些异步加载库或模块加载器，如 RequireJS、SystemJS、Webpack 等，来管理和加载 JavaScript 文件，实现按需加载和异步加载的控制。</p></li></ol><p>以上方法中，<code>async</code> 和 <code>defer</code> 属性主要用于在 HTML 中进行异步加载，而动态创建 <code>&lt;script&gt;</code> 标签和模块化加载方法更灵活，可以在 JavaScript 中根据条件和需要进行动态加载。选择适合项目需求和场景的方法可以提高网页性能和用户体验。</p><h4 id="55-Ajax-解决浏览器缓存问题"><a href="#55-Ajax-解决浏览器缓存问题" class="headerlink" title="55.Ajax 解决浏览器缓存问题"></a>55.Ajax 解决浏览器缓存问题</h4><p>在使用 Ajax 请求数据时，有时会遇到浏览器缓存的问题，导致请求返回的数据并不是最新的。为了解决这个问题，可以采取以下几种方法：</p><ol><li><p><strong>添加随机参数：</strong> 在每次发送 Ajax 请求时，可以在请求的 URL 后面添加一个随机参数，确保每次请求都是唯一的，从而避免浏览器缓存。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy code</span><br><span class="line">const url = &#x27;your-api-url?&#x27; + Date.now();</span><br></pre></td></tr></table></figure></li><li><p><strong>使用时间戳：</strong> 类似于添加随机参数，可以将当前时间戳添加到请求的 URL 中，保证每次请求都是不同的。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy code</span><br><span class="line">const url = &#x27;your-api-url?&#x27; + new Date().getTime();</span><br></pre></td></tr></table></figure></li><li><p><strong>禁用缓存：</strong> 在请求的请求头中添加禁用缓存的字段，通常使用 <code>Cache-Control</code> 或 <code>Pragma</code> 来禁用缓存。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy codeconst xhr = new XMLHttpRequest();</span><br><span class="line">xhr.open(&#x27;GET&#x27;, &#x27;your-api-url&#x27;, true);</span><br><span class="line">xhr.setRequestHeader(&#x27;Cache-Control&#x27;, &#x27;no-cache&#x27;);</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure></li><li><p><strong>修改请求方式：</strong> 将原来的 GET 请求改为 POST 请求，或者在 URL 中添加参数，确保每次请求的 URL 不同。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy codeconst xhr = new XMLHttpRequest();</span><br><span class="line">xhr.open(&#x27;POST&#x27;, &#x27;your-api-url&#x27;, true);</span><br><span class="line">xhr.send(&#x27;data=&#x27; + Date.now());</span><br></pre></td></tr></table></figure></li><li><p><strong>使用 Fetch API：</strong> 在使用 Fetch API 进行数据请求时，默认会忽略浏览器缓存，因此可以直接使用 Fetch API 来解决缓存问题。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy codefetch(&#x27;your-api-url&#x27;)</span><br><span class="line">  .then(response =&gt; response.json())</span><br><span class="line">  .then(data =&gt; &#123;</span><br><span class="line">    // 处理返回的数据</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(error =&gt; &#123;</span><br><span class="line">    // 处理错误</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure></li></ol><p>通过以上方法，可以有效地解决浏览器缓存问题，确保每次请求都能得到最新的数据。选择适合项目需求的方法可以提高数据的准确性和用户体验。</p><h4 id="56-节流和防抖"><a href="#56-节流和防抖" class="headerlink" title="56.节流和防抖"></a>56.节流和防抖</h4><p>节流（Throttle）和防抖（Debounce）都是用于控制事件触发频率的技术，常用于优化性能和减少资源消耗。它们的作用是避免某些事件触发过于频繁而导致性能问题。</p><p><strong>节流（Throttle）：</strong> 节流是指在一段时间内只执行一次特定的操作，无论事件触发多少次。在这段时间内，如果事件再次触发，将被忽略，直到该时间段过去。节流可以保证特定操作在指定时间内只执行一次。</p><p>常见场景：用户频繁滚动页面，但我们只需要在用户停止滚动时执行某个操作，而不是在每次滚动时都执行。</p><p><strong>防抖（Debounce）：</strong> 防抖是指在事件触发后等待一段时间后再执行特定的操作。如果在等待时间内再次触发事件，那么计时会重置，等待新的一段时间。防抖可以保证特定操作只在最后一次事件触发后执行。</p><p>常见场景：用户在输入框中输入内容，我们希望在用户停止输入一段时间后再执行搜索操作，而不是在每次输入时都立即执行搜索。</p><p>下面是节流和防抖的实现示例：</p><p><strong>节流（Throttle）的实现：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function throttle(func, delay) &#123;</span><br><span class="line">  let lastTime = 0;</span><br><span class="line">  return function(...args) &#123;</span><br><span class="line">    const now = Date.now();</span><br><span class="line">    if (now - lastTime &gt;= delay) &#123;</span><br><span class="line">      func.apply(this, args);</span><br><span class="line">      lastTime = now;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用示例</span><br><span class="line">const throttledFunction = throttle(() =&gt; &#123;</span><br><span class="line">  console.log(&#x27;Throttle example&#x27;);</span><br><span class="line">&#125;, 1000);</span><br><span class="line"></span><br><span class="line">window.addEventListener(&#x27;scroll&#x27;, throttledFunction);</span><br></pre></td></tr></table></figure><p><strong>防抖（Debounce）的实现：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function debounce(func, delay) &#123;</span><br><span class="line">  let timerId;</span><br><span class="line">  return function(...args) &#123;</span><br><span class="line">    clearTimeout(timerId);</span><br><span class="line">    timerId = setTimeout(() =&gt; &#123;</span><br><span class="line">      func.apply(this, args);</span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用示例</span><br><span class="line">const debouncedFunction = debounce(() =&gt; &#123;</span><br><span class="line">  console.log(&#x27;Debounce example&#x27;);</span><br><span class="line">&#125;, 1000);</span><br><span class="line"></span><br><span class="line">window.addEventListener(&#x27;input&#x27;, debouncedFunction);</span><br></pre></td></tr></table></figure><p>根据实际需求，选择适合的节流或防抖策略可以提高性能和用户体验。</p><h4 id="57-eval-是做什么的"><a href="#57-eval-是做什么的" class="headerlink" title="57.eval 是做什么的"></a>57.eval 是做什么的</h4><p><code>eval()</code> 是 JavaScript 中的一个全局函数，其作用是将传入的字符串作为 JavaScript 代码进行解析和执行。它的语法如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eval(string)</span><br></pre></td></tr></table></figure><p>其中，<code>string</code> 是要执行的 JavaScript 代码的字符串表示。<code>eval()</code> 函数会将传入的字符串作为动态的 JavaScript 代码，在运行时将其解析为实际的 JavaScript 代码并执行。</p><p><strong>注意：</strong> 由于 <code>eval()</code> 可以执行任意传入的代码，包括用户输入的内容，因此在使用 <code>eval()</code> 时要格外小心。不当使用 <code>eval()</code> 可能导致安全漏洞和不可预测的行为，因此不推荐在生产环境中使用 <code>eval()</code>。通常情况下，可以使用其他更安全的方法来实现相同的功能，例如使用 JSON.parse() 解析 JSON 数据，使用 Function 构造函数来动态创建函数等。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 不推荐的使用方式</span><br><span class="line">const x = 10;</span><br><span class="line">const y = 20;</span><br><span class="line">const code = &#x27;console.log(x + y)&#x27;;</span><br><span class="line">eval(code); // Output: 30</span><br><span class="line"></span><br><span class="line">// 推荐使用方式</span><br><span class="line">const x = 10;</span><br><span class="line">const y = 20;</span><br><span class="line">const code = new Function(&#x27;x&#x27;, &#x27;y&#x27;, &#x27;console.log(x + y)&#x27;);</span><br><span class="line">code(x, y); // Output: 30</span><br></pre></td></tr></table></figure><p>总之，<code>eval()</code> 函数是一个功能强大但也非常危险的函数，应该谨慎使用，特别是在处理不可信的数据时要避免使用它。</p><h4 id="58-对象深拷贝的简单实现"><a href="#58-对象深拷贝的简单实现" class="headerlink" title="58.对象深拷贝的简单实现"></a>58.对象深拷贝的简单实现</h4><p>对象的深拷贝是指创建一个新的对象，并且将原始对象中的所有属性和属性值都复制到新对象中，而且如果原始对象的属性值是引用类型（如对象或数组），则还需要对这些引用类型进行递归拷贝，确保新对象与原始对象完全独立，互不影响。以下是一个简单的实现深拷贝的方法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function deepClone(obj) &#123;</span><br><span class="line">  if (obj === null || typeof obj !== &#x27;object&#x27;) &#123;</span><br><span class="line">    return obj;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  let clone = Array.isArray(obj) ? [] : &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  for (let key in obj) &#123;</span><br><span class="line">    if (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">      clone[key] = deepClone(obj[key]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return clone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用该函数进行深拷贝：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const originalObj = &#123;</span><br><span class="line">  name: &#x27;John&#x27;,</span><br><span class="line">  age: 30,</span><br><span class="line">  address: &#123;</span><br><span class="line">    city: &#x27;New York&#x27;,</span><br><span class="line">    country: &#x27;USA&#x27;</span><br><span class="line">  &#125;,</span><br><span class="line">  hobbies: [&#x27;reading&#x27;, &#x27;swimming&#x27;]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const clonedObj = deepClone(originalObj);</span><br><span class="line"></span><br><span class="line">console.log(clonedObj);</span><br></pre></td></tr></table></figure><p>上述代码中的 <code>deepClone</code> 函数通过递归地遍历对象的属性，并将每个属性的值复制到新的对象中，确保了原始对象与克隆对象之间的完全独立性。这样做可以确保在对克隆对象进行修改时不会影响到原始对象。</p><h4 id="59-实现JS中所有对象的深度克隆-包装对象，-Date-对象，正则对象"><a href="#59-实现JS中所有对象的深度克隆-包装对象，-Date-对象，正则对象" class="headerlink" title="59.实现JS中所有对象的深度克隆(包装对象， Date 对象，正则对象)"></a>59.实现JS中所有对象的深度克隆(包装对象， Date 对象，正则对象)</h4><p>要实现 JS 中所有对象的深度克隆，我们需要处理各种不同类型的对象，包括基本数据类型、引用类型、Date 对象、正则对象等。以下是一个能够实现深度克隆所有对象的函数：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function deepClone(obj, hash = new WeakMap()) &#123;</span><br><span class="line">  if (obj === null || typeof obj !== &#x27;object&#x27;) &#123;</span><br><span class="line">    return obj;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (hash.has(obj)) &#123;</span><br><span class="line">    return hash.get(obj);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  let clone;</span><br><span class="line"></span><br><span class="line">  if (obj instanceof Date) &#123;</span><br><span class="line">    clone = new Date(obj.getTime());</span><br><span class="line">  &#125; else if (obj instanceof RegExp) &#123;</span><br><span class="line">    clone = new RegExp(obj);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    clone = Array.isArray(obj) ? [] : &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  hash.set(obj, clone);</span><br><span class="line"></span><br><span class="line">  for (let key in obj) &#123;</span><br><span class="line">    if (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">      clone[key] = deepClone(obj[key], hash);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return clone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用该函数进行深度克隆：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const originalObj = &#123;</span><br><span class="line">  name: &#x27;John&#x27;,</span><br><span class="line">  age: 30,</span><br><span class="line">  date: new Date(),</span><br><span class="line">  regExp: /abc/g,</span><br><span class="line">  address: &#123;</span><br><span class="line">    city: &#x27;New York&#x27;,</span><br><span class="line">    country: &#x27;USA&#x27;</span><br><span class="line">  &#125;,</span><br><span class="line">  hobbies: [&#x27;reading&#x27;, &#x27;swimming&#x27;]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const clonedObj = deepClone(originalObj);</span><br><span class="line"></span><br><span class="line">console.log(clonedObj);</span><br></pre></td></tr></table></figure><p>该函数使用了一个 <code>WeakMap</code> 对象来记录已经克隆过的对象，避免对同一个对象重复进行深度克隆，确保克隆后的对象中不包含循环引用。同时，对于 Date 对象和 RegExp 对象，分别进行了特殊处理，以确保它们的克隆也是正确的。</p><p>请注意，该函数处理了大多数常见的数据类型，但并不是对所有情况都适用。在实际应用中，还需要根据具体的需求进一步优化和扩展。</p><h4 id="60-实现一个once函数，传入函数参数只执行一次"><a href="#60-实现一个once函数，传入函数参数只执行一次" class="headerlink" title="60.实现一个once函数，传入函数参数只执行一次"></a>60.实现一个once函数，传入函数参数只执行一次</h4><p>可以实现一个 <code>once</code> 函数，使得传入的函数参数只执行一次。我们可以通过一个闭包来实现该功能，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function once(fn) &#123;</span><br><span class="line">  let executed = false;</span><br><span class="line">  let result;</span><br><span class="line"></span><br><span class="line">  return function (...args) &#123;</span><br><span class="line">    if (!executed) &#123;</span><br><span class="line">      executed = true;</span><br><span class="line">      result = fn.apply(this, args);</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>once</code> 函数，可以确保传入的函数参数只执行一次：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function showMessage() &#123;</span><br><span class="line">  console.log(&#x27;Hello, this message will only show once!&#x27;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const showOnce = once(showMessage);</span><br><span class="line"></span><br><span class="line">showOnce(); // Output: Hello, this message will only show once!</span><br><span class="line">showOnce(); // No output, the function won&#x27;t execute again</span><br></pre></td></tr></table></figure><p>在上面的示例中，<code>once</code> 函数接受一个函数 <code>fn</code> 作为参数，并返回一个新的函数。每次调用新返回的函数时，它会检查 <code>executed</code> 变量是否为 <code>false</code>，如果是，则执行原始的函数 <code>fn</code> 并将 <code>executed</code> 设置为 <code>true</code>，这样保证了原始函数只会执行一次。如果多次调用新函数，则不会再执行原始的函数，而是直接返回之前执行过的结果。这样就实现了传入函数参数只执行一次的功能。</p><h4 id="61-将原生的ajax封装成promise"><a href="#61-将原生的ajax封装成promise" class="headerlink" title="61.将原生的ajax封装成promise"></a>61.将原生的ajax封装成promise</h4><p>可以将原生的 Ajax 请求封装成 Promise，使得在进行异步请求时更加便捷和符合现代 JavaScript 的异步处理方式。下面是一个简单的封装示例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function ajax(url, method = &#x27;GET&#x27;, data = null) &#123;</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    const xhr = new XMLHttpRequest();</span><br><span class="line"></span><br><span class="line">    xhr.open(method, url);</span><br><span class="line"></span><br><span class="line">    xhr.onload = function () &#123;</span><br><span class="line">      if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) &#123;</span><br><span class="line">        resolve(xhr.responseText);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        reject(new Error(xhr.statusText));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    xhr.onerror = function () &#123;</span><br><span class="line">      reject(new Error(&#x27;Network error&#x27;));</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    xhr.send(data);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用封装后的函数进行 Ajax 请求：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const url = &#x27;https://api.example.com/data&#x27;;</span><br><span class="line"></span><br><span class="line">ajax(url)</span><br><span class="line">  .then(response =&gt; &#123;</span><br><span class="line">    console.log(&#x27;Success:&#x27;, response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(error =&gt; &#123;</span><br><span class="line">    console.error(&#x27;Error:&#x27;, error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>在封装函数中，我们创建了一个新的 Promise，并在 Promise 的 executor 函数中执行原生的 Ajax 请求。当请求成功时，我们调用 <code>resolve</code> 并传递响应数据；当请求失败时，我们调用 <code>reject</code> 并传递错误信息。这样，在调用封装后的函数时，我们可以通过 <code>.then()</code> 处理成功的回调，通过 <code>.catch()</code> 处理错误的回调，实现更加清晰和简洁的异步代码。</p><h4 id="62-JS监听对象属性的改变"><a href="#62-JS监听对象属性的改变" class="headerlink" title="62.JS监听对象属性的改变"></a>62.JS监听对象属性的改变</h4><p>在 JavaScript 中，可以使用对象的 <code>Proxy</code> 来监听对象属性的改变。<code>Proxy</code> 是 ES6 中引入的特性，它可以拦截并自定义对象的各种操作，包括属性的读取、设置、删除等。通过使用 <code>Proxy</code>，我们可以实现对对象属性的监听和响应。</p><p>下面是一个使用 <code>Proxy</code> 监听对象属性改变的示例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const obj = &#123;</span><br><span class="line">  name: &#x27;John&#x27;,</span><br><span class="line">  age: 30</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const handler = &#123;</span><br><span class="line">  set(target, key, value) &#123;</span><br><span class="line">    console.log(`Property $&#123;key&#125; changed from $&#123;target[key]&#125; to $&#123;value&#125;`);</span><br><span class="line">    target[key] = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const proxy = new Proxy(obj, handler);</span><br><span class="line"></span><br><span class="line">proxy.name = &#x27;Jane&#x27;; // Output: Property name changed from John to Jane</span><br><span class="line">proxy.age = 35;      // Output: Property age changed from 30 to 35</span><br></pre></td></tr></table></figure><p>在上面的示例中，我们创建了一个对象 <code>obj</code> 和一个 <code>Proxy</code> 对象 <code>proxy</code>。通过定义一个 <code>handler</code> 对象，并在其中实现 <code>set</code> 方法，我们可以拦截对 <code>proxy</code> 对象的属性赋值操作。当对 <code>proxy</code> 对象的属性进行赋值时，<code>set</code> 方法会被触发，并输出属性改变的信息。</p><p>注意：<code>Proxy</code> 不是所有环境都支持，特别是在一些较老的浏览器中可能不支持。在使用 <code>Proxy</code> 时，最好先进行兼容性检查或使用降级方案。如果不需要考虑兼容性问题，<code>Proxy</code> 是一个强大且方便的特性，可以用于实现很多高级功能，包括对象属性的监听和拦截。</p><h4 id="63-如何实现一个私有变量，用get可以访问，不能直接访问"><a href="#63-如何实现一个私有变量，用get可以访问，不能直接访问" class="headerlink" title="63.如何实现一个私有变量，用get可以访问，不能直接访问"></a>63.如何实现一个私有变量，用get可以访问，不能直接访问</h4><p>在 JavaScript 中，没有真正的私有变量概念，但可以通过闭包和作用域来模拟私有变量。通过使用闭包，在对象的内部创建一个函数作用域，将需要隐藏的变量放在该函数作用域内，外部无法直接访问，但通过使用 <code>get</code> 方法，可以间接地访问这些变量。</p><p>下面是一个示例，演示如何使用闭包实现一个私有变量：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function createObject() &#123;</span><br><span class="line">  let privateVariable = 10; // 私有变量</span><br><span class="line"></span><br><span class="line">  return &#123;</span><br><span class="line">    getPrivateVariable() &#123;</span><br><span class="line">      return privateVariable;</span><br><span class="line">    &#125;,</span><br><span class="line">    setPrivateVariable(value) &#123;</span><br><span class="line">      privateVariable = value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const obj = createObject();</span><br><span class="line"></span><br><span class="line">console.log(obj.getPrivateVariable()); // Output: 10</span><br><span class="line">obj.setPrivateVariable(20);</span><br><span class="line">console.log(obj.getPrivateVariable()); // Output: 20</span><br><span class="line"></span><br><span class="line">// 无法直接访问 privateVariable</span><br><span class="line">console.log(obj.privateVariable); // Output: undefined</span><br></pre></td></tr></table></figure><p>在上面的示例中，我们通过 <code>createObject</code> 函数创建了一个包含私有变量的对象。<code>privateVariable</code> 是一个私有变量，外部无法直接访问，但我们通过在返回的对象中暴露 <code>getPrivateVariable</code> 方法，可以间接地访问和修改 <code>privateVariable</code>。</p><p>请注意，这种方式并不是真正意义上的私有变量，因为 JavaScript 中没有真正的私有性。但通过使用闭包和函数作用域，我们可以模拟私有变量，避免直接暴露在全局作用域中，提高代码的封装性和安全性。</p><h4 id="64-怎么控制一次加载一张图片，加载完后再加载下一张"><a href="#64-怎么控制一次加载一张图片，加载完后再加载下一张" class="headerlink" title="64.怎么控制一次加载一张图片，加载完后再加载下一张"></a>64.怎么控制一次加载一张图片，加载完后再加载下一张</h4><p>要实现一次加载一张图片，并在加载完成后再加载下一张图片，可以通过递归和事件监听来实现。具体步骤如下：</p><ol><li>创建一个包含所有图片 URL 的数组。</li><li>创建一个加载图片的函数，该函数接受一个图片 URL 作为参数，并返回一个 Promise 对象，用于表示图片加载的状态。</li><li>使用递归方式依次加载数组中的每张图片，确保每张图片在上一张图片加载完成后再加载下一张图片。</li><li>在图片加载完成时，触发加载下一张图片的操作。</li></ol><p>以下是示例代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const imageUrls = [</span><br><span class="line">  &#x27;url1.jpg&#x27;,</span><br><span class="line">  &#x27;url2.jpg&#x27;,</span><br><span class="line">  &#x27;url3.jpg&#x27;,</span><br><span class="line">  // Add more image URLs here...</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">function loadImage(url) &#123;</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    const img = new Image();</span><br><span class="line"></span><br><span class="line">    img.onload = function () &#123;</span><br><span class="line">      resolve(img);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    img.onerror = function () &#123;</span><br><span class="line">      reject(new Error(`Failed to load image: $&#123;url&#125;`));</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    img.src = url;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function loadImagesSequentially(urls) &#123;</span><br><span class="line">  const promises = [];</span><br><span class="line"></span><br><span class="line">  function loadNextImage(index) &#123;</span><br><span class="line">    if (index &gt;= urls.length) &#123;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const url = urls[index];</span><br><span class="line">    const promise = loadImage(url);</span><br><span class="line"></span><br><span class="line">    promises.push(promise);</span><br><span class="line"></span><br><span class="line">    promise.then(() =&gt; &#123;</span><br><span class="line">      // Image loaded successfully, load the next one</span><br><span class="line">      loadNextImage(index + 1);</span><br><span class="line">    &#125;).catch(error =&gt; &#123;</span><br><span class="line">      console.error(error);</span><br><span class="line">      // If an error occurs, we can choose to handle it or continue with the next image</span><br><span class="line">      loadNextImage(index + 1);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Start loading the images sequentially</span><br><span class="line">  loadNextImage(0);</span><br><span class="line"></span><br><span class="line">  // Return a promise that resolves when all images are loaded</span><br><span class="line">  return Promise.all(promises);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">loadImagesSequentially(imageUrls)</span><br><span class="line">  .then(() =&gt; &#123;</span><br><span class="line">    console.log(&#x27;All images loaded successfully!&#x27;);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(error =&gt; &#123;</span><br><span class="line">    console.error(&#x27;Failed to load images:&#x27;, error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>在上面的示例中，<code>loadImage</code> 函数负责加载单张图片，并返回一个 Promise 对象。<code>loadImagesSequentially</code> 函数负责递归地依次加载所有图片，并确保在每张图片加载完成后再加载下一张图片。最后，使用 <code>Promise.all()</code> 来等待所有图片加载完成。</p><p>注意：以上代码仅为示例，实际使用时，需要根据具体的场景和需求进行适当的调整和优化。</p><h4 id="65-如何实现sleep的效果-es5-或者es6"><a href="#65-如何实现sleep的效果-es5-或者es6" class="headerlink" title="65.如何实现sleep的效果(es5 或者es6)"></a>65.如何实现sleep的效果(es5 或者es6)</h4><p>在 JavaScript 中实现 <code>sleep</code> 的效果，可以使用 <code>setTimeout</code> 或者 <code>async/await</code> 来模拟等待的效果。下面分别给出 ES5 和 ES6 的实现方式：</p><p>ES5（使用 <code>setTimeout</code>）：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function sleep(ms) &#123;</span><br><span class="line">  return new Promise(resolve =&gt; setTimeout(resolve, ms));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用示例</span><br><span class="line">console.log(&#x27;Start&#x27;);</span><br><span class="line">sleep(2000).then(() =&gt; &#123;</span><br><span class="line">  console.log(&#x27;After 2 seconds&#x27;);</span><br><span class="line">&#125;);</span><br><span class="line">console.log(&#x27;End&#x27;);</span><br></pre></td></tr></table></figure><p>ES6（使用 <code>async/await</code>）：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function sleep(ms) &#123;</span><br><span class="line">  return new Promise(resolve =&gt; setTimeout(resolve, ms));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用示例</span><br><span class="line">async function example() &#123;</span><br><span class="line">  console.log(&#x27;Start&#x27;);</span><br><span class="line">  await sleep(2000);</span><br><span class="line">  console.log(&#x27;After 2 seconds&#x27;);</span><br><span class="line">  console.log(&#x27;End&#x27;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">example();</span><br></pre></td></tr></table></figure><p>在上面的代码中，<code>sleep</code> 函数返回一个 Promise 对象，在指定的时间后通过 <code>resolve</code> 方法来完成 Promise，从而实现等待的效果。在 ES5 中，使用 <code>setTimeout</code> 来延迟执行 <code>resolve</code>，而在 ES6 中，可以通过 <code>async/await</code> 来更简洁地实现等待效果。</p><p>请注意，在使用 <code>async/await</code> 的方式时，<code>await</code> 只能在 <code>async</code> 函数中使用，因此需要将整个等待过程包裹在一个 <code>async</code> 函数中。在调用 <code>await sleep(ms)</code> 时，函数会暂停执行，直到 <code>sleep</code> 函数返回的 Promise 被完成（即等待的时间到达），然后继续执行后面的代码。</p><h4 id="66-Function-proto-getPrototypeOf-是什么"><a href="#66-Function-proto-getPrototypeOf-是什么" class="headerlink" title="66.Function._ proto_ (getPrototypeOf)是什么?"></a>66.Function._ proto_ (getPrototypeOf)是什么?</h4><p>在 JavaScript 中，<code>Function.prototype</code> 是一个内置对象，它是所有函数对象的原型。每个函数在创建时都会自动关联到 <code>Function.prototype</code>，它是一个函数对象，因此它本身也有自己的原型对象，即 <code>Function.prototype.__proto__</code>。</p><p>可以通过 <code>Object.getPrototypeOf(Function)</code> 或 <code>Function.__proto__</code> 来访问 <code>Function.prototype</code> 的原型对象。这个原型对象包含了一些内置的方法和属性，可以被所有函数对象共享。</p><p>一些常见的在 <code>Function.prototype</code> 上定义的方法包括 <code>call</code>、<code>apply</code> 和 <code>bind</code>，这些方法用于改变函数的执行上下文或绑定函数的上下文。另外，<code>Function.prototype</code> 上还有一些用于原型链的方法，比如 <code>toString</code>、<code>valueOf</code> 等。</p><p>实际使用中，我们一般不需要直接访问 <code>Function.prototype.__proto__</code>，而是通过函数对象的原型链来间接使用这些方法和属性。例如，当我们调用 <code>func.toString()</code> 时，实际上是访问了 <code>Function.prototype</code> 上的 <code>toString</code> 方法。</p><p>需要注意的是，尽管可以访问 <code>Function.prototype.__proto__</code>，但修改它可能会导致不稳定的行为和兼容性问题。在正常开发中，应该避免直接修改内置对象的原型链，以免影响其他代码的正确性。</p><h4 id="67-箭头函数中this-指向"><a href="#67-箭头函数中this-指向" class="headerlink" title="67.箭头函数中this 指向"></a>67.箭头函数中this 指向</h4><p>箭头函数中的 <code>this</code> 指向在定义时确定，并且是词法作用域（lexical scope）下的 <code>this</code> 值。这意味着箭头函数没有自己的 <code>this</code> 绑定，而是继承了其所在的外层作用域的 <code>this</code> 值。</p><p>在箭头函数中，<code>this</code> 的指向与其声明位置相关，而不是在函数被调用时确定的。这与普通函数不同，普通函数的 <code>this</code> 值在调用时由调用者决定。</p><p>下面是一个简单的示例，说明箭头函数中的 <code>this</code> 指向：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const person = &#123;</span><br><span class="line">  name: &#x27;John&#x27;,</span><br><span class="line">  sayHello: function () &#123;</span><br><span class="line">    console.log(`Hello, I&#x27;m $&#123;this.name&#125;`);</span><br><span class="line">  &#125;,</span><br><span class="line">  sayHelloArrow: () =&gt; &#123;</span><br><span class="line">    console.log(`Hello, I&#x27;m $&#123;this.name&#125;`);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">person.sayHello();      // Output: Hello, I&#x27;m John</span><br><span class="line">person.sayHelloArrow(); // Output: Hello, I&#x27;m undefined</span><br></pre></td></tr></table></figure><p>在上面的示例中，<code>person</code> 对象包含两个函数：<code>sayHello</code> 和 <code>sayHelloArrow</code>。在 <code>sayHello</code> 函数中，我们使用普通的函数表达式，它的 <code>this</code> 指向由调用者（即 <code>person</code> 对象）决定，因此输出了正确的结果。而在 <code>sayHelloArrow</code> 中，我们使用了箭头函数，它继承了其所在作用域的 <code>this</code>，在这个例子中是全局作用域，因此输出了 <code>undefined</code>，因为全局作用域中并没有定义 <code>name</code>。请注意，这里的 <code>this</code> 不是指向 <code>person</code> 对象。</p><p>需要注意的是，箭头函数不适合作为对象的方法，因为箭头函数的 <code>this</code> 值是固定的，不会根据调用者而变化。通常情况下，箭头函数更适合用于简洁的函数定义，或者在需要保留外层作用域的 <code>this</code> 值时使用。而对于对象的方法，应该优先考虑使用普通的函数表达式，以保证正确的 <code>this</code> 指向。</p><h4 id="68-数组常用方法有哪些"><a href="#68-数组常用方法有哪些" class="headerlink" title="68.数组常用方法有哪些"></a>68.数组常用方法有哪些</h4><p>JavaScript 中数组有很多常用的方法，可以用于添加、删除、修改和查询数组中的元素。以下是一些常见的数组方法：</p><ol><li>添加元素：<ul><li><code>push()</code>: 在数组末尾添加一个或多个元素，并返回新数组的长度。</li><li><code>unshift()</code>: 在数组开头添加一个或多个元素，并返回新数组的长度。</li><li><code>splice(index, 0, element1, element2, ...)</code>: 在指定位置插入一个或多个元素。</li></ul></li><li>删除元素：<ul><li><code>pop()</code>: 移除数组末尾的元素，并返回移除的元素。</li><li><code>shift()</code>: 移除数组开头的元素，并返回移除的元素。</li><li><code>splice(index, count)</code>: 从指定位置开始删除指定数量的元素。</li></ul></li><li>修改元素：<ul><li>直接通过索引对数组元素进行赋值：<code>arr[index] = value</code></li></ul></li><li>查询元素：<ul><li><code>indexOf(element)</code>: 返回指定元素在数组中的第一个匹配项的索引，若不存在则返回 -1。</li><li><code>lastIndexOf(element)</code>: 返回指定元素在数组中的最后一个匹配项的索引，若不存在则返回 -1。</li><li><code>includes(element)</code>: 判断数组是否包含指定元素，返回一个布尔值。</li></ul></li><li>数组转换：<ul><li><code>toString()</code>: 将数组转换成字符串，各元素用逗号分隔。</li><li><code>join(separator)</code>: 将数组元素转换成字符串，使用指定的分隔符连接。</li></ul></li><li>数组拷贝：<ul><li><code>slice(start, end)</code>: 返回指定起始和结束位置的子数组，不包括结束位置的元素。</li><li><code>concat(arr1, arr2, ...)</code>: 将多个数组合并成一个新数组。</li></ul></li><li>数组遍历：<ul><li><code>forEach(callback)</code>: 遍历数组中的每个元素，并执行指定的回调函数。</li><li><code>map(callback)</code>: 创建一个新数组，其中的元素是原数组经过指定的回调函数处理后的结果。</li><li><code>filter(callback)</code>: 创建一个新数组，其中的元素是原数组中符合指定条件的元素。</li><li><code>reduce(callback, initialValue)</code>: 对数组中的元素进行累积操作，返回一个最终的结果。</li></ul></li><li>数组长度：<ul><li><code>length</code>: 获取或设置数组的长度。</li></ul></li></ol><p>以上只是数组方法的一部分，还有许多其他方法，可以根据具体需求选择适合的方法来操作数组。需要注意的是，很多数组方法会改变原数组，而不是返回新的数组。如果需要保持原数组的不变性，可以通过数组拷贝等方式避免修改原数组。</p><h4 id="69-数组去重有哪些方法"><a href="#69-数组去重有哪些方法" class="headerlink" title="69.数组去重有哪些方法?"></a>69.数组去重有哪些方法?</h4><p>数组去重是常见的操作，可以通过多种方法实现。以下是几种常用的数组去重方法：</p><ol><li>使用 Set 数据结构（ES6 特性）：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const arr = [1, 2, 2, 3, 4, 4, 5];</span><br><span class="line">const uniqueArr = [...new Set(arr)];</span><br><span class="line">console.log(uniqueArr); // Output: [1, 2, 3, 4, 5]</span><br></pre></td></tr></table></figure><ol><li>使用 indexOf 方法：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const arr = [1, 2, 2, 3, 4, 4, 5];</span><br><span class="line">const uniqueArr = [];</span><br><span class="line">for (let i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">  if (uniqueArr.indexOf(arr[i]) === -1) &#123;</span><br><span class="line">    uniqueArr.push(arr[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(uniqueArr); // Output: [1, 2, 3, 4, 5]</span><br></pre></td></tr></table></figure><ol><li>使用 includes 方法（ES7 特性）：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const arr = [1, 2, 2, 3, 4, 4, 5];</span><br><span class="line">const uniqueArr = [];</span><br><span class="line">for (let i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">  if (!uniqueArr.includes(arr[i])) &#123;</span><br><span class="line">    uniqueArr.push(arr[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(uniqueArr); // Output: [1, 2, 3, 4, 5]</span><br></pre></td></tr></table></figure><ol><li>使用 reduce 方法：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const arr = [1, 2, 2, 3, 4, 4, 5];</span><br><span class="line">const uniqueArr = arr.reduce((result, current) =&gt; &#123;</span><br><span class="line">  if (!result.includes(current)) &#123;</span><br><span class="line">    result.push(current);</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;, []);</span><br><span class="line">console.log(uniqueArr); // Output: [1, 2, 3, 4, 5]</span><br></pre></td></tr></table></figure><ol><li>使用 filter 方法：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const arr = [1, 2, 2, 3, 4, 4, 5];</span><br><span class="line">const uniqueArr = arr.filter((item, index, self) =&gt; &#123;</span><br><span class="line">  return self.indexOf(item) === index;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(uniqueArr); // Output: [1, 2, 3, 4, 5]</span><br></pre></td></tr></table></figure><p>以上方法都可以实现数组去重，具体使用哪种方法可以根据实际情况和性能需求进行选择。注意，对于复杂的对象数组，使用 Set 方法可能会更高效，因为 Set 使用了哈希表来存储唯一值，查找速度更快。而对于简单的原始值数组，使用 indexOf、includes、reduce 或者 filter 方法也能满足需求。</p><h4 id="70-如何去除字符串首尾空格"><a href="#70-如何去除字符串首尾空格" class="headerlink" title="70.如何去除字符串首尾空格"></a>70.如何去除字符串首尾空格</h4><p>要去除字符串的首尾空格，可以使用 JavaScript 的 <code>trim()</code> 方法。<code>trim()</code> 方法会去除字符串的开头和结尾的所有空格（包括空格、制表符、换行符等），并返回一个新的字符串，原始字符串不会改变。</p><p>以下是示例代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const str = &#x27;  Hello, World!  &#x27;;</span><br><span class="line">const trimmedStr = str.trim();</span><br><span class="line">console.log(trimmedStr); // Output: &quot;Hello, World!&quot;</span><br></pre></td></tr></table></figure><p>在上面的例子中，原始字符串 <code>str</code> 的开头和结尾都有空格，使用 <code>trim()</code> 方法后，返回的 <code>trimmedStr</code> 就是去除了开头和结尾空格的新字符串。</p><p>请注意，<code>trim()</code> 方法只会去除首尾的空格，而不会去除字符串中间的空格。如果需要去除字符串中间的空格，可以使用其他方法，比如 <code>replace()</code> 方法结合正则表达式来实现。例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const str = &#x27;  Hello,   World!  &#x27;;</span><br><span class="line">const trimmedStr = str.replace(/\s+/g, &#x27;&#x27;);</span><br><span class="line">console.log(trimmedStr); // Output: &quot;Hello,World!&quot;</span><br></pre></td></tr></table></figure><p>上述代码中的正则表达式 <code>\s+</code> 会匹配一个或多个连续的空格字符，使用 <code>replace()</code> 方法将其替换为空字符串，从而去除了字符串中间的空格。</p><h4 id="71-说说你所知道的JS语言特性"><a href="#71-说说你所知道的JS语言特性" class="headerlink" title="71.说说你所知道的JS语言特性?"></a>71.说说你所知道的JS语言特性?</h4><p>JavaScript 是一种高级、动态、弱类型的编程语言，它在 Web 开发中扮演着重要的角色。以下是一些 JavaScript 的语言特性：</p><ol><li>动态类型：JavaScript 是一种弱类型语言，变量的数据类型在运行时可以动态改变。同一个变量可以在不同的上下文中保存不同类型的值。</li><li>面向对象：JavaScript 支持面向对象编程，可以使用原型继承和构造函数来创建对象，并通过原型链实现继承。</li><li>原型继承：JavaScript 中的对象可以通过原型链继承其他对象的属性和方法，使得代码可以重用和组织。</li><li>闭包：JavaScript 支持闭包，即函数可以访问其外部作用域中的变量，即使函数在外部作用域之外执行。</li><li>函数作为一等公民：函数在 JavaScript 中是一等公民，可以像其他数据类型一样赋值给变量、作为参数传递和作为返回值返回。</li><li>异步编程：JavaScript 支持异步编程，通过回调函数、Promise、async&#x2F;await 等机制实现非阻塞的异步操作。</li><li>事件驱动：在浏览器环境中，JavaScript 是事件驱动的，通过监听事件来响应用户的交互。</li><li>单线程：JavaScript 是单线程语言，意味着在同一时刻只能执行一个任务。这使得编写并发代码变得复杂，但通过异步编程可以实现非阻塞的并发操作。</li><li>变量提升：JavaScript 中的变量和函数声明会被提升到当前作用域的顶部，在声明之前就可以使用。</li><li>动态创建和修改HTML：JavaScript 可以通过 DOM 操作动态地创建、修改和删除 HTML 元素，实现页面内容的动态更新。</li><li>JSON 格式：JavaScript 对象表示法（JSON）是一种轻量级的数据交换格式，用于在客户端和服务器之间传输数据。</li><li>模块化：ES6 引入了模块化的语法，使得 JavaScript 可以以模块的方式组织代码，提高了代码的可维护性和复用性。</li><li>模板字面量：ES6 中引入了模板字面量（Template Literals），使得字符串拼接更加方便，支持多行字符串和插值表达式。</li><li>箭头函数：ES6 中引入了箭头函数，提供了更简洁的函数定义语法，并且继承外部作用域的 <code>this</code> 值。</li><li>解构赋值：ES6 中引入了解构赋值语法，可以方便地从数组或对象中提取值并赋给变量。</li></ol><p>这些是 JavaScript 的一些重要特性，JavaScript 不断发展，新的语言特性和功能不断加入，使得 JavaScript 在 Web 开发中越来越强大和灵活。</p><h4 id="72-如何判断一个数组"><a href="#72-如何判断一个数组" class="headerlink" title="72.如何判断一个数组?"></a>72.如何判断一个数组?</h4><p>判断一个变量是否为数组，可以使用多种方法。以下是常见的几种方式：</p><ol><li>使用 Array.isArray() 方法（推荐）：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const arr = [1, 2, 3];</span><br><span class="line">if (Array.isArray(arr)) &#123;</span><br><span class="line">  console.log(&#x27;arr 是数组&#x27;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  console.log(&#x27;arr 不是数组&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>使用 instanceof 操作符：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const arr = [1, 2, 3];</span><br><span class="line">if (arr instanceof Array) &#123;</span><br><span class="line">  console.log(&#x27;arr 是数组&#x27;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  console.log(&#x27;arr 不是数组&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>使用 Object.prototype.toString.call() 方法：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const arr = [1, 2, 3];</span><br><span class="line">if (Object.prototype.toString.call(arr) === &#x27;[object Array]&#x27;) &#123;</span><br><span class="line">  console.log(&#x27;arr 是数组&#x27;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  console.log(&#x27;arr 不是数组&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述三种方法中，推荐使用 Array.isArray() 方法来判断数组，因为它是专门用于判断变量是否为数组的标准方法，而且对于多窗口（iframe）环境中的数组也能正确判断。而使用 instanceof 操作符和 Object.prototype.toString.call() 方法也可以判断数组，但有一些限制，例如在多窗口环境下可能会失效。</p><p>需要注意的是，由于 JavaScript 是动态类型语言，所以在判断数组之前最好先确保变量不是 null 或 undefined。例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const arr = [1, 2, 3];</span><br><span class="line">if (arr &amp;&amp; Array.isArray(arr)) &#123;</span><br><span class="line">  console.log(&#x27;arr 是数组&#x27;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  console.log(&#x27;arr 不是数组或为 null/undefined&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用这些方法可以准确地判断一个变量是否为数组，根据实际情况选择最合适的方式进行判断。</p><h4 id="73-JS的全排列"><a href="#73-JS的全排列" class="headerlink" title="73.JS的全排列"></a>73.JS的全排列</h4><p>全排列是一种组合算法，可以将一组元素按照不同的顺序进行排列。在 JavaScript 中，可以通过递归和交换元素的方式来实现全排列。以下是一个实现全排列的 JavaScript 函数：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function permute(nums) &#123;</span><br><span class="line">  const result = [];</span><br><span class="line"></span><br><span class="line">  function backtrack(start) &#123;</span><br><span class="line">    if (start === nums.length - 1) &#123;</span><br><span class="line">      result.push([...nums]);</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (let i = start; i &lt; nums.length; i++) &#123;</span><br><span class="line">      // 交换元素，使得当前元素变为第一个元素</span><br><span class="line">      [nums[start], nums[i]] = [nums[i], nums[start]];</span><br><span class="line">      // 递归进入下一层，继续排列后面的元素</span><br><span class="line">      backtrack(start + 1);</span><br><span class="line">      // 回溯，恢复数组原来的状态</span><br><span class="line">      [nums[start], nums[i]] = [nums[i], nums[start]];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  backtrack(0);</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 示例</span><br><span class="line">const nums = [1, 2, 3];</span><br><span class="line">console.log(permute(nums));</span><br></pre></td></tr></table></figure><p>在上述代码中，<code>permute</code> 函数通过 <code>backtrack</code> 函数进行递归排列。<code>backtrack</code> 函数接收一个参数 <code>start</code>，表示从数组的第 <code>start</code> 个元素开始进行排列。当 <code>start</code> 等于数组的长度减 1 时，表示所有元素都已经排列完毕，将当前排列结果加入 <code>result</code> 数组中。否则，从 <code>start</code> 开始循环遍历数组，并依次将当前元素交换到第一个位置，然后递归进入下一层，继续排列后面的元素。完成递归后，需要回溯，恢复数组原来的状态，以便进行下一轮排列。</p><p>使用该函数可以得到数组 <code>[1, 2, 3]</code> 的全排列：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [1, 2, 3],</span><br><span class="line">  [1, 3, 2],</span><br><span class="line">  [2, 1, 3],</span><br><span class="line">  [2, 3, 1],</span><br><span class="line">  [3, 2, 1],</span><br><span class="line">  [3, 1, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>全排列是一种经典的组合算法，在编程中经常会用到，可以用于解决很多问题，如字符串的所有排列、数组的所有组合等。</p><h4 id="74-谈谈你所理解的跨域，为什么会有这个问题-如何解决"><a href="#74-谈谈你所理解的跨域，为什么会有这个问题-如何解决" class="headerlink" title="74.谈谈你所理解的跨域，为什么会有这个问题?如何解决?"></a>74.谈谈你所理解的跨域，为什么会有这个问题?如何解决?</h4><p>跨域（Cross-Origin）是指在浏览器中，当前网页所在的域（协议 + 域名 + 端口）与请求资源所在的域不同，导致浏览器限制了从当前网页向其他域发送跨域请求的能力。这是由于浏览器的同源策略（Same-Origin Policy）所导致的。</p><p>同源策略是一种安全机制，用于阻止一个网页上的脚本或资源（如 XMLHttpRequest 或 Fetch）与不同域的服务器进行通信。具体来说，同源策略要求请求的协议、域名和端口必须完全一致，否则就会产生跨域问题。</p><p>例如，当一个网页的 URL 是 <code>http://example.com/index.html</code>，如果该页面向 <code>http://api.example.com/data</code> 发送请求，就会触发跨域问题，因为二者的域名不同。</p><p>解决跨域问题有以下几种方法：</p><ol><li>JSONP：利用 <code>&lt;script&gt;</code> 标签的跨域特性，通过动态创建 <code>&lt;script&gt;</code> 元素并设置其 <code>src</code> 属性来请求跨域数据。JSONP 依赖于后端服务器的支持，在服务器端返回一个回调函数调用的包装数据，前端通过回调函数来处理数据。</li><li>CORS（Cross-Origin Resource Sharing）：CORS 是一种现代的跨域解决方案，通过服务器设置响应头来授权特定的域名访问资源。在服务器端设置 <code>Access-Control-Allow-Origin</code> 头部，允许指定的域名进行跨域访问。</li><li>代理：在同域下设置一个代理服务器，将跨域请求转发给目标服务器，并将响应返回给前端。这种方法需要在后端进行配置。</li><li>iframe + postMessage：使用 iframe 加载目标页面，并通过 <code>postMessage</code> 方法进行跨域通信。通过在目标页面中监听消息事件，实现跨域数据的传递。</li><li>WebSocket：WebSocket 协议不受同源策略的限制，可以在客户端与服务器之间建立长连接，实现实时通信。</li><li>Nginx 反向代理：通过在 Nginx 配置中添加反向代理规则，将跨域请求转发给目标服务器，同时在服务器端设置 CORS 头部来允许跨域访问。</li></ol><p>注意：在开发过程中，跨域问题通常不会在本地测试环境中出现，因为浏览器会对本地文件进行放宽限制。跨域问题主要出现在生产环境或真实的网络环境中。解决跨域问题时，需要根据具体情况选择合适的方法，并确保服务器端的安全性和正确配置跨域头部。</p><h4 id="75-null-x3D-x3D-undefined输出什么-null-x3D-x3D-x3D-undefined呢"><a href="#75-null-x3D-x3D-undefined输出什么-null-x3D-x3D-x3D-undefined呢" class="headerlink" title="75.null &#x3D;&#x3D; undefined输出什么? null &#x3D;&#x3D;&#x3D; undefined呢?"></a>75.null &#x3D;&#x3D; undefined输出什么? null &#x3D;&#x3D;&#x3D; undefined呢?</h4><p>在 JavaScript 中，null 和 undefined 是两种特殊的值，它们都代表着”没有值”的含义。但它们的数据类型和内部表示是不同的。</p><ol><li><p>null &#x3D;&#x3D; undefined： 当使用双等号（&#x3D;&#x3D;）进行比较时，JavaScript 会进行类型转换。在比较 null 和 undefined 时，它们会被视为相等，因此结果为 true。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy code</span><br><span class="line">console.log(null == undefined); // 输出: true</span><br></pre></td></tr></table></figure></li><li><p>null &#x3D;&#x3D;&#x3D; undefined： 当使用三等号（&#x3D;&#x3D;&#x3D;）进行比较时，JavaScript 不进行类型转换，只有在数据类型和值都相同的情况下，才会被视为相等。由于 null 和 undefined 的数据类型不同，一个是 object，另一个是 undefined，所以它们不相等，结果为 false。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy code</span><br><span class="line">console.log(null === undefined); // 输出: false</span><br></pre></td></tr></table></figure></li></ol><p>总结：</p><ul><li>双等号（&#x3D;&#x3D;）会进行类型转换，null 和 undefined 会被视为相等，其他数据类型会进行相应的类型转换再进行比较。</li><li>三等号（&#x3D;&#x3D;&#x3D;）不会进行类型转换，只有在数据类型和值都相同的情况下才会被视为相等。对于 null 和 undefined，因为它们的数据类型不同，所以不相等。</li></ul><h4 id="76-什么是按需加载"><a href="#76-什么是按需加载" class="headerlink" title="76.什么是按需加载"></a>76.什么是按需加载</h4><p>按需加载（Lazy Loading），也称为延迟加载，是一种优化前端性能的技术。它的主要目的是将网页的初始加载时间缩短，提高页面的加载速度和用户体验。</p><p>在按需加载中，不是一次性将所有的资源（如 JavaScript、CSS、图片等）都加载到页面中，而是根据页面的实际需求，在需要的时候再进行加载。这样可以减少初始加载时的资源大小，加快页面的显示速度，特别是在移动端网络条件不理想的情况下，效果更为明显。</p><p>常见的按需加载方式有：</p><ol><li>图片懒加载：将页面上的图片的真实地址替换为占位图，当图片进入可视区域时再加载真实图片，提高页面加载速度。</li><li>异步加载 JavaScript：将不必要的 JavaScript 代码通过异步加载的方式延迟加载，当需要使用该代码时再动态加载进来。</li><li>动态加载 CSS：根据页面需要加载特定的 CSS 文件，而不是一次性加载所有样式。</li><li>分包加载：将页面中的不同功能模块或页面组件拆分成独立的模块，按需加载，用户访问不同页面时只加载当前页面所需的模块。</li></ol><p>通过按需加载，可以减少页面的加载时间和资源消耗，提高网站性能和用户体验。</p><h4 id="77-简单介绍一下symbol"><a href="#77-简单介绍一下symbol" class="headerlink" title="77.简单介绍一下symbol"></a>77.简单介绍一下symbol</h4><p>Symbol 是 ES6 引入的一种新的原始数据类型，它表示一个独一无二的值，用于创建唯一的标识符。</p><p>Symbol 的定义方式为 <code>Symbol()</code>，每次调用 <code>Symbol()</code> 都会返回一个新的、不同的 Symbol 值。这意味着 Symbol 是永远不会相等的，即使它们的值相同。</p><p>Symbol 有以下特点：</p><ol><li>独一无二：每个 Symbol 都是独一无二的，不会与其他任何值相等。</li><li>不可变性：Symbol 值一旦被创建，就不能修改其值或属性。</li><li>作为属性名：Symbol 可以用作对象的属性名，由于独一无二的特性，可以防止属性名冲突。</li><li>隐藏性：由于 Symbol 值在外部代码中无法获取到具体值，因此可以用于隐藏对象的私有属性和方法。</li></ol><p>常见用法：</p><ol><li>作为对象属性名：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy codeconst mySymbol = Symbol(&#x27;mySymbol&#x27;);</span><br><span class="line">const obj = &#123;</span><br><span class="line">  [mySymbol]: &#x27;This is a symbol property&#x27;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(obj[mySymbol]); // Output: This is a symbol property</span><br></pre></td></tr></table></figure><ol><li>防止属性名冲突：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy codeconst mySymbol1 = Symbol(&#x27;mySymbol&#x27;);</span><br><span class="line">const mySymbol2 = Symbol(&#x27;mySymbol&#x27;);</span><br><span class="line"></span><br><span class="line">const obj = &#123;</span><br><span class="line">  [mySymbol1]: &#x27;Property 1&#x27;,</span><br><span class="line">  [mySymbol2]: &#x27;Property 2&#x27;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(obj[mySymbol1]); // Output: Property 1</span><br><span class="line">console.log(obj[mySymbol2]); // Output: Property 2</span><br></pre></td></tr></table></figure><ol><li>使用内置 Symbol 值：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy codeconst symToStringTag = Symbol.toStringTag;</span><br><span class="line"></span><br><span class="line">const myObject = &#123;</span><br><span class="line">  [symToStringTag]: &#x27;MyObject&#x27;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(myObject.toString()); // Output: [object MyObject]</span><br></pre></td></tr></table></figure><p>Symbol 是一种非常有用的数据类型，特别适合用于创建唯一的属性名和标识符，同时也有助于增强对象的封装和隐藏性。</p><h4 id="78-介绍下promise-及其底层如何实现"><a href="#78-介绍下promise-及其底层如何实现" class="headerlink" title="78.介绍下promise,及其底层如何实现"></a>78.介绍下promise,及其底层如何实现</h4><p>Promise 是 ES6 中新增的一种处理异步操作的机制，用于解决回调地狱的问题，让异步操作更加易读和可维护。它表示一个异步操作的最终完成或失败，并可以处理其结果。</p><p>Promise 有三种状态：Pending（进行中）、Fulfilled（已完成）和Rejected（已失败）。当一个 Promise 对象处于 Pending 状态时，表示异步操作还在进行中；当操作完成后，会进入 Fulfilled 状态，表示操作成功；如果操作失败，则会进入 Rejected 状态，表示操作失败。</p><p>Promise 的基本用法如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy codeconst promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  // 异步操作</span><br><span class="line">  // 如果操作成功，则调用 resolve() 并传递结果</span><br><span class="line">  // 如果操作失败，则调用 reject() 并传递错误信息</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise</span><br><span class="line">  .then((result) =&gt; &#123;</span><br><span class="line">    // 操作成功的回调函数</span><br><span class="line">    console.log(&#x27;Success:&#x27;, result);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch((error) =&gt; &#123;</span><br><span class="line">    // 操作失败的回调函数</span><br><span class="line">    console.error(&#x27;Error:&#x27;, error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>底层实现原理：</p><p>Promise 的底层实现涉及到了一些异步编程的概念，主要是利用了事件循环机制和回调函数。</p><ol><li>创建一个 Promise 对象时，会立即执行传入的 executor 函数，并传入两个回调函数：resolve 和 reject。</li><li>在 executor 函数中，通常会执行一些异步操作，一旦操作完成，可以调用 resolve 方法传递操作的结果，或者调用 reject 方法传递操作失败的原因。</li><li>当 Promise 进入 Fulfilled 状态时，会触发 then 方法中的成功回调函数；当 Promise 进入 Rejected 状态时，会触发 catch 方法中的失败回调函数。</li><li>如果 Promise 在 executor 函数中出现异常或者调用了 reject 方法，则会直接进入 Rejected 状态，并触发 catch 方法中的失败回调函数。</li><li>Promise 的 then 和 catch 方法返回的是一个新的 Promise 对象，使得可以链式调用。</li></ol><p>实际上，Promise 的底层实现涉及了更复杂的细节，包括状态的变化、回调队列的管理等，但以上是其基本原理的简单描述。Promise 的出现极大地简化了异步编程，并提供了更加优雅和直观的处理方式。</p><h4 id="79-JS原型链，原型链的顶端是什么-Object-的原型是什么-Object的原型的原型是什么"><a href="#79-JS原型链，原型链的顶端是什么-Object-的原型是什么-Object的原型的原型是什么" class="headerlink" title="79.JS原型链，原型链的顶端是什么? Object 的原型是什么? Object的原型的原型是什么?"></a>79.JS原型链，原型链的顶端是什么? Object 的原型是什么? Object的原型的原型是什么?</h4><p>在 JavaScript 中，原型链是一种对象之间通过原型链接起来的继承关系。每个对象都有一个原型（prototype），并且对象可以通过原型链来访问其原型的属性和方法。</p><p>原型链的顶端是 <code>Object.prototype</code>，它是 JavaScript 中所有对象的原型的最终原型。也就是说，所有对象（包括函数、数组、字符串等）都是继承自 <code>Object.prototype</code>。</p><p>具体来说：</p><ol><li>对象的原型是通过 <code>__proto__</code> 属性指向其原型对象的，这个原型对象就是该对象的原型。例如：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy codeconst obj = &#123;&#125;;</span><br><span class="line">console.log(obj.__proto__ === Object.prototype); // true</span><br></pre></td></tr></table></figure><ol><li><code>Object.prototype</code> 的原型是 <code>null</code>，即 <code>Object.prototype.__proto__</code> 为 <code>null</code>。这意味着 <code>Object.prototype</code> 是原型链的顶端。</li><li>当我们访问一个对象的属性时，如果对象本身没有这个属性，JavaScript 就会沿着原型链向上查找该属性。如果在原型链中找到了该属性，就会返回它；如果找不到，则返回 <code>undefined</code>。</li></ol><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy codeconst obj = &#123;&#125;;</span><br><span class="line">console.log(obj.toString()); // Object.prototype 上的 toString 方法被调用</span><br></pre></td></tr></table></figure><ol><li>对于构造函数创建的对象，它们的原型是构造函数的 <code>prototype</code> 属性所指向的对象。构造函数可以通过 <code>prototype</code> 属性定义一些公共的属性和方法，这些属性和方法会被所有通过该构造函数创建的对象继承。</li></ol><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy codefunction Person(name) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.sayHello = function() &#123;</span><br><span class="line">  console.log(`Hello, I&#x27;m $&#123;this.name&#125;.`);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const john = new Person(&#x27;John&#x27;);</span><br><span class="line">john.sayHello(); // Hello, I&#x27;m John.</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>Person.prototype</code> 是 <code>john</code> 对象的原型，因此 <code>john</code> 对象可以调用 <code>sayHello</code> 方法。</p><p>总结：原型链的顶端是 <code>Object.prototype</code>，所有对象都继承自它。对象的原型通过 <code>__proto__</code> 属性指向其原型对象，而原型对象的原型是通过 <code>__proto__</code> 属性指向 <code>Object.prototype</code>，形成了原型链的继承关系。</p><h4 id="80-promise-Generator-Async-的使用"><a href="#80-promise-Generator-Async-的使用" class="headerlink" title="80.promise+Generator+Async 的使用"></a>80.promise+Generator+Async 的使用</h4><p><code>Promise</code>, <code>Generator</code>, 和 <code>Async/Await</code> 都是用于处理异步编程的特性，它们在 JavaScript 中都可以用于优雅地处理异步操作。</p><ol><li>Promise: <code>Promise</code> 是一种用于异步编程的对象，可以在异步操作完成后返回结果或错误。使用 <code>Promise</code> 可以避免回调地狱，并使代码更加清晰和可读。<code>Promise</code> 有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy code// Promise 的基本用法</span><br><span class="line">const myPromise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  // 异步操作</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    const randomNum = Math.random();</span><br><span class="line">    if (randomNum &lt; 0.5) &#123;</span><br><span class="line">      resolve(&#x27;Success&#x27;); // 成功时调用 resolve</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      reject(&#x27;Error&#x27;); // 失败时调用 reject</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">myPromise</span><br><span class="line">  .then((result) =&gt; &#123;</span><br><span class="line">    console.log(&#x27;Resolved:&#x27;, result); // 成功时执行 then 回调</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch((error) =&gt; &#123;</span><br><span class="line">    console.error(&#x27;Rejected:&#x27;, error); // 失败时执行 catch 回调</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><ol><li>Generator: <code>Generator</code> 是一种函数，可以通过 <code>function*</code> 关键字定义。它可以通过 <code>yield</code> 关键字将函数的执行过程暂停，并可以通过 <code>next()</code> 方法恢复执行。<code>Generator</code> 在异步编程中常与 <code>Promise</code> 结合使用，可以实现更灵活的控制流程。</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy code// Generator 的基本用法</span><br><span class="line">function* myGenerator() &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    const value1 = yield Promise.resolve(1);</span><br><span class="line">    console.log(value1); // 1</span><br><span class="line">    const value2 = yield Promise.resolve(2);</span><br><span class="line">    console.log(value2); // 2</span><br><span class="line">    const value3 = yield Promise.resolve(3);</span><br><span class="line">    console.log(value3); // 3</span><br><span class="line">  &#125; catch (error) &#123;</span><br><span class="line">    console.error(&#x27;Error:&#x27;, error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const gen = myGenerator();</span><br><span class="line">gen.next().then((result1) =&gt; &#123;</span><br><span class="line">  gen.next(result1.value).then((result2) =&gt; &#123;</span><br><span class="line">    gen.next(result2.value).then((result3) =&gt; &#123;</span><br><span class="line">      gen.next(result3.value); // 依次输出 1, 2, 3</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol><li>Async&#x2F;Await: <code>Async/Await</code> 是 <code>Promise</code> 的一种更简洁的语法糖，它使得异步代码看起来更像同步代码，使得异步流程更易读和维护。在 <code>Async</code> 函数内部使用 <code>await</code> 关键字可以暂停函数的执行，等待 <code>Promise</code> 的状态变为 <code>fulfilled</code>，然后获取其返回值。</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy code// Async/Await 的基本用法</span><br><span class="line">async function myAsyncFunction() &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    const result1 = await Promise.resolve(1);</span><br><span class="line">    console.log(result1); // 1</span><br><span class="line">    const result2 = await Promise.resolve(2);</span><br><span class="line">    console.log(result2); // 2</span><br><span class="line">    const result3 = await Promise.resolve(3);</span><br><span class="line">    console.log(result3); // 3</span><br><span class="line">  &#125; catch (error) &#123;</span><br><span class="line">    console.error(&#x27;Error:&#x27;, error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myAsyncFunction(); // 依次输出 1, 2, 3</span><br></pre></td></tr></table></figure><p>以上是三种处理异步编程的常用方式，它们都可以有效地处理异步操作，使代码更加简洁和易读。根据具体的场景和需求，可以选择使用其中的一种或多种。</p><h4 id="81-JS中string的startwith和indexof两种方法的区别"><a href="#81-JS中string的startwith和indexof两种方法的区别" class="headerlink" title="81.JS中string的startwith和indexof两种方法的区别"></a>81.JS中string的startwith和indexof两种方法的区别</h4><p><code>startsWith</code> 和 <code>indexOf</code> 都是用于在字符串中查找子字符串的方法，但它们之间有一些区别。</p><ol><li><pre><code>startsWith<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"> 方法:</span><br><span class="line"></span><br><span class="line">- `startsWith` 是 ES6 中新增的字符串方法，用于检查一个字符串是否以指定的子字符串开头。</span><br><span class="line">- 它返回一个布尔值，如果字符串以指定的子字符串开头，则返回 `true`，否则返回 `false`。</span><br><span class="line">- `startsWith` 方法可以接受两个参数：要查找的子字符串和可选的搜索起始位置。</span><br><span class="line">- 该方法不会改变原始字符串，它是一个纯粹的查询操作。</span><br><span class="line"></span><br></pre></td></tr></table></figure>javascriptCopy codeconst str = &#39;Hello, world!&#39;;</code></pre></li></ol><p>console.log(str.startsWith(‘Hello’)); &#x2F;&#x2F; true<br>console.log(str.startsWith(‘hello’)); &#x2F;&#x2F; false (区分大小写)<br>console.log(str.startsWith(‘world’, 7)); &#x2F;&#x2F; true (从索引 7 开始搜索)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">1. ```</span><br><span class="line">   indexOf</span><br></pre></td></tr></table></figure><pre><code>方法:</code></pre><ul><li><code>indexOf</code> 是 JavaScript 中原生的字符串方法，用于查找一个字符串中指定子字符串的位置。</li><li>它返回第一个匹配的子字符串的索引，如果没有找到，则返回 <code>-1</code>。</li><li><code>indexOf</code> 方法可以接受两个参数：要查找的子字符串和可选的搜索起始位置。</li><li>该方法不会改变原始字符串，它也是一个纯粹的查询操作。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy codeconst str = &#x27;Hello, world!&#x27;;</span><br><span class="line"></span><br><span class="line">console.log(str.indexOf(&#x27;Hello&#x27;)); // 0 (从索引 0 开始找到匹配的子字符串)</span><br><span class="line">console.log(str.indexOf(&#x27;hello&#x27;)); // -1 (未找到，区分大小写)</span><br><span class="line">console.log(str.indexOf(&#x27;world&#x27;, 7)); // 7 (从索引 7 开始找到匹配的子字符串)</span><br></pre></td></tr></table></figure><p>总结:</p><ul><li><code>startsWith</code> 适用于判断一个字符串是否以指定的子字符串开头，返回布尔值。</li><li><code>indexOf</code> 适用于查找一个字符串中指定子字符串的位置，返回第一个匹配的子字符串的索引。</li></ul><h4 id="82-JS字符串转数字的方法"><a href="#82-JS字符串转数字的方法" class="headerlink" title="82.JS字符串转数字的方法"></a>82.JS字符串转数字的方法</h4><p>在 JavaScript 中，有几种方法可以将字符串转换为数字：</p><ol><li>使用 <code>parseInt()</code> 函数：<code>parseInt()</code> 函数将字符串转换为整数。它从字符串的开始位置解析整数，并忽略字符串中的非数字字符，直到遇到第一个非数字字符为止。</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy codeconst str = &#x27;123&#x27;;</span><br><span class="line">const number = parseInt(str);</span><br><span class="line">console.log(number); // 123</span><br></pre></td></tr></table></figure><ol><li>使用 <code>parseFloat()</code> 函数：<code>parseFloat()</code> 函数将字符串转换为浮点数。它从字符串的开始位置解析浮点数，并忽略字符串中的非数字字符，直到遇到第一个非数字字符为止。</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy codeconst str = &#x27;3.14&#x27;;</span><br><span class="line">const number = parseFloat(str);</span><br><span class="line">console.log(number); // 3.14</span><br></pre></td></tr></table></figure><ol><li>使用 <code>Number()</code> 函数：<code>Number()</code> 函数可以将字符串转换为数字，包括整数和浮点数。如果字符串中包含非数字字符（除了空格和正负号之外），则转换结果为 <code>NaN</code>（Not a Number）。</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy codeconst str1 = &#x27;42&#x27;;</span><br><span class="line">const str2 = &#x27;3.14&#x27;;</span><br><span class="line">const str3 = &#x27;abc&#x27;;</span><br><span class="line"></span><br><span class="line">const number1 = Number(str1);</span><br><span class="line">const number2 = Number(str2);</span><br><span class="line">const number3 = Number(str3);</span><br><span class="line"></span><br><span class="line">console.log(number1); // 42</span><br><span class="line">console.log(number2); // 3.14</span><br><span class="line">console.log(number3); // NaN</span><br></pre></td></tr></table></figure><ol><li>使用加号 <code>+</code> 运算符：将字符串与空字符串相加，可以将其转换为数字。这种方法适用于只包含数字的字符串，如果字符串中包含非数字字符，结果将是 <code>NaN</code>。</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy codeconst str = &#x27;42&#x27;;</span><br><span class="line">const number = +str;</span><br><span class="line">console.log(number); // 42</span><br></pre></td></tr></table></figure><p>注意：以上方法都可以将合法的数字字符串转换为数字。如果字符串不能表示有效的数字，转换结果将是 <code>NaN</code>。在进行字符串转换为数字的操作时，要注意字符串中是否包含非数字字符以及是否符合合理的数字格式。</p><h4 id="83-平时是怎么调试JS的"><a href="#83-平时是怎么调试JS的" class="headerlink" title="83.平时是怎么调试JS的"></a>83.平时是怎么调试JS的</h4><h4 id="84-怎么获得对象上的属性"><a href="#84-怎么获得对象上的属性" class="headerlink" title="84.怎么获得对象上的属性"></a>84.怎么获得对象上的属性</h4><p>可以通过以下几种方式获得对象上的属性：</p><ol><li>使用点符号（<code>.</code>）：通过对象的属性名来访问属性值。</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy codeconst person = &#123; name: &#x27;John&#x27;, age: 30 &#125;;</span><br><span class="line">console.log(person.name); // &quot;John&quot;</span><br><span class="line">console.log(person.age); // 30</span><br></pre></td></tr></table></figure><ol><li>使用方括号（<code>[]</code>）：通过属性名的字符串形式来访问属性值。适用于属性名包含特殊字符或动态生成的情况。</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy codeconst person = &#123; name: &#x27;John&#x27;, age: 30 &#125;;</span><br><span class="line">console.log(person[&#x27;name&#x27;]); // &quot;John&quot;</span><br><span class="line">console.log(person[&#x27;age&#x27;]); // 30</span><br><span class="line"></span><br><span class="line">const propertyName = &#x27;name&#x27;;</span><br><span class="line">console.log(person[propertyName]); // &quot;John&quot;</span><br></pre></td></tr></table></figure><ol><li>使用变量来获取属性值：当属性名保存在变量中时，可以使用变量来获取属性值。</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy codeconst person = &#123; name: &#x27;John&#x27;, age: 30 &#125;;</span><br><span class="line">const propertyName = &#x27;name&#x27;;</span><br><span class="line">console.log(person[propertyName]); // &quot;John&quot;</span><br></pre></td></tr></table></figure><p>注意：如果对象上不存在指定的属性，使用点符号访问该属性会返回 <code>undefined</code>，使用方括号访问该属性会返回 <code>undefined</code> 或引起 <code>TypeError</code> 错误（如果对象是 <code>null</code> 或 <code>undefined</code>）。在访问属性值之前，最好先检查对象是否包含该属性，可以使用 <code>in</code> 运算符或 <code>hasOwnProperty()</code> 方法来检查。</p><h4 id="85-async和await具体该怎么用"><a href="#85-async和await具体该怎么用" class="headerlink" title="85.async和await具体该怎么用?"></a>85.async和await具体该怎么用?</h4><h4 id="86-知道哪些ES6，ES7-的语法"><a href="#86-知道哪些ES6，ES7-的语法" class="headerlink" title="86.知道哪些ES6，ES7 的语法"></a>86.知道哪些ES6，ES7 的语法</h4><p>ES6和ES7（ES2016）引入了许多新的语法特性，以下是其中一些常见的特性：</p><p>ES6（ECMAScript 2015）的语法特性：</p><ol><li>块级作用域：使用 <code>let</code> 和 <code>const</code> 声明变量，使得变量在块级作用域内有效。</li><li>箭头函数：使用箭头函数定义函数，简化函数的语法。</li><li>解构赋值：从对象或数组中提取值并赋值给变量。</li><li>模板字符串：使用反引号 &#96;&#96; 来创建多行字符串，并可以在字符串中插入变量。</li><li>类和对象：使用 <code>class</code> 关键字定义类，使用 <code>constructor</code> 构造函数创建对象。</li><li>模块化：使用 <code>import</code> 和 <code>export</code> 来进行模块的导入和导出。</li><li>Promise：用于处理异步操作的一种机制，解决了回调地狱的问题。</li><li>箭头函数：一种更简洁的函数写法，自动绑定上下文，不绑定 <code>this</code>。</li></ol><p>ES7（ECMAScript 2016）的语法特性：</p><ol><li>Array.prototype.includes()：用于判断数组是否包含某个元素，返回布尔值。</li><li>指数运算符（Exponentiation Operator）：用于求幂运算。</li></ol><p>还有许多其他的语法特性，在不断的更新迭代中，JavaScript语言会持续发展，提供更多方便和强大的功能。</p><h4 id="87-promise-和await-x2F-async的关系"><a href="#87-promise-和await-x2F-async的关系" class="headerlink" title="87.promise 和await&#x2F;async的关系"></a>87.promise 和await&#x2F;async的关系</h4><p>Promise和async&#x2F;await是两种处理异步操作的方式，它们之间有一定的关系。</p><ol><li>Promise：是一种用于处理异步操作的对象，可以将异步操作封装成一个Promise对象，并通过<code>then</code>和<code>catch</code>方法来处理异步操作的结果或错误。Promise的语法相对较为简单，但在多个异步操作需要串行执行或并行执行时，会出现嵌套的问题，也称为”回调地狱”。</li><li>async&#x2F;await：是ES2017（ES8）中引入的异步编程的新特性，它建立在Promise之上，提供了更简洁和清晰的异步代码写法。使用<code>async</code>关键字来声明一个异步函数，异步函数内部可以使用<code>await</code>关键字来等待一个Promise对象的返回结果，而不需要使用<code>.then</code>来处理。在async函数内部，可以像写同步代码一样编写异步操作，使得代码更易于阅读和维护，避免了回调地狱的问题。</li></ol><p>实际上，async&#x2F;await只是Promise的一种语法糖，它并没有改变异步操作的本质，只是让异步代码看起来更像同步代码。async&#x2F;await的使用依赖于Promise，async函数内部可以返回一个Promise对象，通过<code>await</code>等待该Promise的结果。</p><p>简而言之，async&#x2F;await是Promise的一种更直观、更优雅的写法，让异步代码更易于编写和维护。</p><h4 id="88-JS加载过程阻塞，解决方法。"><a href="#88-JS加载过程阻塞，解决方法。" class="headerlink" title="88.JS加载过程阻塞，解决方法。"></a>88.JS加载过程阻塞，解决方法。</h4><p>JavaScript加载过程阻塞指的是当浏览器遇到<code>&lt;script&gt;</code>标签时，会暂停页面的解析和渲染，先加载和执行JavaScript代码，然后再继续解析和渲染页面，这可能会导致页面加载速度变慢和用户体验下降。</p><p>解决JavaScript加载过程阻塞的方法有以下几种：</p><ol><li>异步加载：将<code>&lt;script&gt;</code>标签的<code>async</code>或<code>defer</code>属性设置为<code>true</code>，使得JavaScript文件在后台异步加载，不会阻塞页面的解析和渲染。<code>async</code>和<code>defer</code>的区别在于<code>async</code>表示异步加载且加载完成后立即执行，<code>defer</code>表示异步加载但会等到页面解析完成后按顺序执行。</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">htmlCopy code&lt;!-- 异步加载 --&gt;</span><br><span class="line">&lt;script async src=&quot;your-script.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 延迟执行 --&gt;</span><br><span class="line">&lt;script defer src=&quot;your-script.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><ol><li>动态加载：使用JavaScript动态创建<code>&lt;script&gt;</code>标签并插入到DOM中，这样可以在需要的时候再加载JavaScript文件，避免阻塞页面加载。</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy codeconst script = document.createElement(&#x27;script&#x27;);</span><br><span class="line">script.src = &#x27;your-script.js&#x27;;</span><br><span class="line">document.body.appendChild(script);</span><br></pre></td></tr></table></figure><ol><li>懒加载：将页面中不需要立即执行的JavaScript代码进行拆分，将其作为独立的模块，当需要时再加载和执行。可以使用<code>import()</code>（动态导入）或使用工具如Webpack进行代码分割。</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy code// 动态导入模块</span><br><span class="line">import(&#x27;./your-module.js&#x27;).then(module =&gt; &#123;</span><br><span class="line">  // 模块加载完成后的处理</span><br><span class="line">&#125;).catch(error =&gt; &#123;</span><br><span class="line">  // 加载出错的处理</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol><li>缓存：使用合适的HTTP缓存策略，让浏览器在第一次加载完JavaScript文件后，能够缓存起来，之后再次访问同一页面时可以直接使用缓存的JavaScript文件，加快加载速度。</li></ol><p>注意，虽然异步加载和懒加载可以减少阻塞，但过度使用也可能导致多个脚本并行加载，产生过多的HTTP请求，因此需要权衡使用场景。</p><h4 id="89-JS对象类型，基本对象类型以及引用对象类型的区别"><a href="#89-JS对象类型，基本对象类型以及引用对象类型的区别" class="headerlink" title="89.JS对象类型，基本对象类型以及引用对象类型的区别"></a>89.JS对象类型，基本对象类型以及引用对象类型的区别</h4><p>在JavaScript中，数据类型可以分为三类：基本数据类型、引用数据类型和特殊数据类型（null和undefined）。</p><ol><li>基本数据类型：<ul><li>字符串（String）：表示文本数据，用单引号或双引号括起来。</li><li>数字（Number）：表示数值，包括整数和浮点数。</li><li>布尔值（Boolean）：表示真或假，只有两个值：true和false。</li><li>null：表示空值，表示一个空对象指针。</li><li>undefined：表示未定义，表示一个未初始化的变量。</li></ul></li><li>引用数据类型：<ul><li>对象（Object）：表示复杂的数据结构，可以包含多个属性和方法。对象可以通过大括号 <code>&#123;&#125;</code> 创建。</li><li>数组（Array）：是一种特殊的对象，用于存储多个值。数组可以通过方括号 <code>[]</code> 创建。</li><li>函数（Function）：是一种特殊的对象，用于执行代码块。函数可以通过关键字 <code>function</code> 创建。</li></ul></li></ol><p>基本数据类型是按值访问的，它们的值直接存储在变量中，变量直接访问值。例如，当你将一个基本数据类型的值赋给另一个变量时，它们是相互独立的，修改一个变量的值不会影响另一个变量。</p><p>引用数据类型是按引用访问的，它们的值存储在内存中，变量中存储的是对象在内存中的地址。当你将一个引用类型的值赋给另一个变量时，它们实际上是共享同一个对象，修改一个变量的值会影响到另一个变量。</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy code// 基本数据类型</span><br><span class="line">let a = 10;</span><br><span class="line">let b = a;</span><br><span class="line">a = 20;</span><br><span class="line">console.log(b); // 输出 10，b的值不受a的影响</span><br><span class="line"></span><br><span class="line">// 引用数据类型</span><br><span class="line">let obj1 = &#123; name: &#x27;John&#x27; &#125;;</span><br><span class="line">let obj2 = obj1;</span><br><span class="line">obj1.name = &#x27;Alice&#x27;;</span><br><span class="line">console.log(obj2.name); // 输出 &#x27;Alice&#x27;，obj2和obj1引用同一个对象</span><br></pre></td></tr></table></figure><p>在理解JavaScript的数据类型时，要注意基本数据类型和引用数据类型的区别，以及它们在内存中的存储方式。</p><h4 id="90-轮播的实现原理-假如一个页面上有两个轮播，你会怎么实现"><a href="#90-轮播的实现原理-假如一个页面上有两个轮播，你会怎么实现" class="headerlink" title="90.轮播的实现原理?假如一个页面上有两个轮播，你会怎么实现?"></a>90.轮播的实现原理?假如一个页面上有两个轮播，你会怎么实现?</h4><p>轮播是一种常见的前端组件，实现原理可以简要描述如下：</p><ol><li>HTML结构：轮播通常由一个容器元素包裹多个轮播项元素（图片或其他内容）组成。</li><li>CSS样式：通过CSS样式设置容器元素的宽度和高度，使轮播项在容器中水平排列，并设置overflow:hidden，隐藏超出容器范围的轮播项。</li><li>JavaScript逻辑：轮播的核心逻辑是实现轮播项的切换。可以通过定时器、事件绑定或者其他交互方式触发切换效果。</li></ol><p>具体实现步骤：</p><ol><li>在HTML中创建轮播容器和轮播项：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">htmlCopy code&lt;div class=&quot;carousel&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;carousel-item&quot;&gt;Item 1&lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;carousel-item&quot;&gt;Item 2&lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;carousel-item&quot;&gt;Item 3&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><ol><li>使用CSS样式设置轮播容器和轮播项的样式：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cssCopy code.carousel &#123;</span><br><span class="line">  width: 300px;</span><br><span class="line">  height: 200px;</span><br><span class="line">  overflow: hidden;</span><br><span class="line">  position: relative;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.carousel-item &#123;</span><br><span class="line">  width: 300px;</span><br><span class="line">  height: 200px;</span><br><span class="line">  float: left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>使用JavaScript实现轮播效果：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy code// 获取轮播容器和轮播项元素</span><br><span class="line">const carousel = document.querySelector(&#x27;.carousel&#x27;);</span><br><span class="line">const carouselItems = document.querySelectorAll(&#x27;.carousel-item&#x27;);</span><br><span class="line"></span><br><span class="line">let currentIndex = 0; // 当前轮播项索引</span><br><span class="line"></span><br><span class="line">function showNextSlide() &#123;</span><br><span class="line">  currentIndex = (currentIndex + 1) % carouselItems.length;</span><br><span class="line">  carousel.style.transform = `translateX(-$&#123;currentIndex * 300&#125;px)`;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setInterval(showNextSlide, 3000); // 每隔3秒切换一次轮播项</span><br></pre></td></tr></table></figure><p>对于页面上有多个轮播的情况，可以根据需求给不同的轮播容器添加不同的类名或id，然后使用相应的选择器进行操作。例如，可以通过类名来选择不同的轮播容器：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">htmlCopy code&lt;div class=&quot;carousel carousel1&quot;&gt;</span><br><span class="line">  &lt;!-- 轮播项内容 --&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;carousel carousel2&quot;&gt;</span><br><span class="line">  &lt;!-- 轮播项内容 --&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">javascriptCopy codeconst carousel1 = document.querySelector(&#x27;.carousel1&#x27;);</span><br><span class="line">const carousel2 = document.querySelector(&#x27;.carousel2&#x27;);</span><br><span class="line"></span><br><span class="line">// 实现不同的轮播逻辑</span><br></pre></td></tr></table></figure><h4 id="91-解释一下JS的事件循环"><a href="#91-解释一下JS的事件循环" class="headerlink" title="91.解释一下JS的事件循环"></a>91.解释一下JS的事件循环</h4><p>JavaScript的事件循环（Event Loop）是一种用于处理异步操作的机制，它是JavaScript实现异步非阻塞的核心原理。在单线程的JavaScript中，事件循环负责管理任务队列（Task Queue）和执行栈（Execution Stack）。</p><p>事件循环的过程如下：</p><ol><li>执行栈（主线程）：首先，JavaScript代码从上到下依次执行，将同步任务压入执行栈中。</li><li>异步任务的注册和执行：当遇到异步任务（例如定时器、网络请求、事件监听等）时，它们不会立即执行，而是将回调函数注册到对应的事件队列中。</li><li>任务队列：事件队列分为宏任务队列（Macro Task Queue）和微任务队列（Micro Task Queue）。在每一轮事件循环中，会优先处理微任务队列中的任务。</li><li>执行栈清空：当执行栈中的同步任务执行完毕后，JavaScript引擎会检查微任务队列中是否有任务，如果有，就依次执行所有微任务直到微任务队列为空。</li><li>宏任务处理：接着，JavaScript引擎会从宏任务队列中选择一个最早进入队列的任务，推入执行栈中执行。这个过程会一直重复，直到所有的任务都被执行完毕。</li><li>回到步骤2：当宏任务执行完毕后，JavaScript引擎会再次查看微任务队列，执行所有的微任务。然后，继续从宏任务队列中选择任务执行。</li></ol><p>在每个宏任务执行完毕后，如果有必要，浏览器会对页面进行重新渲染，然后再开始下一轮事件循环。</p><p>常见的微任务有Promise的<code>then</code>、<code>catch</code>和<code>finally</code>，以及<code>MutationObserver</code>。常见的宏任务有定时器（<code>setTimeout</code>、<code>setInterval</code>）、I&#x2F;O操作、DOM事件等。</p><p>事件循环的特点是：同步任务先于异步任务执行，异步任务按照注册的顺序依次执行，微任务优先级高于宏任务。</p><p>JavaScript的事件循环机制使得我们可以实现非阻塞的异步编程，提高了程序的效率和用户体验。但也需要注意合理使用异步任务，避免出现回调地狱或产生深层嵌套的异步代码。</p><h4 id="92-Localstorage、-sessionStorage、-cookie-的区别"><a href="#92-Localstorage、-sessionStorage、-cookie-的区别" class="headerlink" title="92.Localstorage、 sessionStorage、 cookie 的区别"></a>92.Localstorage、 sessionStorage、 cookie 的区别</h4><p>Localstorage、SessionStorage和Cookie是浏览器提供的三种用于在客户端存储数据的方式，它们之间有一些区别：</p><ol><li>存储时效性：<ul><li>Cookie：可以设置过期时间，在过期时间之前一直有效，即使关闭浏览器也不会失效，除非用户手动删除或过期。</li><li>LocalStorage：数据永久保存在客户端，除非用户主动删除，否则数据会一直存在。</li><li>SessionStorage：数据只在当前会话（当前窗口或标签页）有效，关闭窗口或标签页后数据会被清除。</li></ul></li><li>存储大小：<ul><li>Cookie：最大存储大小为4KB。</li><li>LocalStorage：最大存储大小为5MB或更大，不同浏览器可能会有所不同。</li><li>SessionStorage：最大存储大小也为5MB或更大。</li></ul></li><li>与服务器通信：<ul><li>Cookie：每次请求都会携带Cookie，会增加请求的数据量。</li><li>LocalStorage和SessionStorage：仅在客户端使用，不会携带到服务器。</li></ul></li><li>API调用：<ul><li>Cookie：使用<code>document.cookie</code>进行操作。</li><li>LocalStorage和SessionStorage：使用<code>localStorage</code>和<code>sessionStorage</code>进行操作。</li></ul></li><li>共享性：<ul><li>Cookie：可以设置为跨域共享。</li><li>LocalStorage和SessionStorage：只能在同一域名下共享。</li></ul></li><li>安全性：<ul><li>Cookie：由于携带在请求头中，可能被恶意获取，容易遭受跨站脚本攻击（XSS）。</li><li>LocalStorage和SessionStorage：不会随着请求携带，但也不是完全安全，也可能受到XSS攻击。</li></ul></li></ol><p>基于上述区别，我们可以根据不同的需求选择合适的存储方式：</p><ul><li>如果需要在不同窗口或标签页中共享数据，且数据较小，可以使用LocalStorage。</li><li>如果需要在同一会话中共享数据，可以使用SessionStorage。</li><li>如果需要与服务器通信或设置过期时间，可以使用Cookie。但要注意数据大小和安全性问题。</li></ul><p>一般情况下，LocalStorage和SessionStorage是更常用的客户端存储方式，而Cookie主要用于一些需要与服务器交互的场景。</p><h4 id="93-解释一下HTML5DragAPI"><a href="#93-解释一下HTML5DragAPI" class="headerlink" title="93.解释一下HTML5DragAPI"></a>93.解释一下HTML5DragAPI</h4><p>HTML5 Drag API 是 HTML5 中新增的一组 API，用于实现拖拽和拖放功能。它包含了两个主要事件和一些相关的方法和属性，用于在网页中实现元素的拖拽和拖放操作。</p><p>主要事件：</p><ol><li>dragstart：当开始拖动一个元素时触发，可以在此事件中设置要拖动的数据。</li><li>dragend：当拖动结束时触发，无论是成功拖放到目标区域还是取消拖放，都会触发该事件。</li></ol><p>主要方法和属性：</p><ol><li>setData：在 dragstart 事件中使用，用于设置拖动的数据。</li><li>getData：在 dragover 或 drop 事件中使用，用于获取拖动的数据。</li><li>setDragImage：在 dragstart 事件中使用，用于设置自定义的拖动图像。</li><li>dropEffect：用于设置拖放操作的反馈效果，例如拖动时的鼠标样式。</li></ol><p>使用 HTML5 Drag API 实现拖拽和拖放功能的基本步骤如下：</p><ol><li>给需要拖拽的元素添加 dragstart 事件监听器，设置要拖动的数据。</li><li>给目标区域添加 dragover 事件监听器，阻止默认行为，并在其中设置 dropEffect。</li><li>给目标区域添加 drop 事件监听器，获取拖动的数据并进行相应的处理。</li></ol><p>HTML5 Drag API 提供了一种原生的方式来实现拖拽和拖放功能，比起传统的拖放实现，它更加灵活和强大，并且能够与其他 HTML5 特性很好地结合使用，提供更好的用户体验和交互效果。</p><h4 id="94-解释一下webworker"><a href="#94-解释一下webworker" class="headerlink" title="94.解释一下webworker"></a>94.解释一下webworker</h4><p>Web Worker 是 HTML5 提供的一种在后台运行 JavaScript 的机制，它允许在主线程之外创建一个独立的线程，用于执行耗时的计算或处理大量数据，从而不会阻塞主线程，保持页面的响应性。</p><p>主要特点和用法如下：</p><ol><li>独立线程：Web Worker 在主线程之外运行，拥有自己的全局作用域，不会影响主线程的执行。</li><li>无法访问 DOM：由于 Web Worker 在独立线程中运行，因此它无法访问 DOM、BOM 和主线程的变量，也不能直接操作页面元素。</li><li>通信：Web Worker 与主线程之间通过消息传递来进行通信。主线程可以向 Web Worker 发送消息，Web Worker 处理后再将结果返回给主线程。</li><li>不能同步编程：Web Worker 是异步的，不能像主线程那样通过同步的方式编程，因此不适合处理需要立即响应的用户交互。</li><li>文件加载：Web Worker 需要通过一个独立的 JavaScript 文件创建，并且只能加载同源的脚本文件。</li></ol><p>Web Worker 的创建和使用步骤如下：</p><ol><li>创建 Web Worker：通过创建一个独立的 JavaScript 文件，并在该文件中编写 Web Worker 的代码。</li><li>加载 Web Worker：在主线程中通过调用 <code>new Worker()</code> 方法加载 Web Worker。</li><li>通信：主线程通过 <code>postMessage()</code> 方法向 Web Worker 发送消息，Web Worker 通过监听 <code>onmessage</code> 事件接收主线程发送的消息。</li><li>处理消息：Web Worker 收到消息后，进行相应的处理，并通过 <code>postMessage()</code> 方法将结果返回给主线程。</li></ol><p>Web Worker 在处理一些耗时的计算或大量数据处理的任务时非常有用，可以提高页面的性能和用户体验。但需要注意，由于 Web Worker 不能访问 DOM，它只适合用于处理计算密集型的任务，而不适合用于处理需要直接操作页面元素的任务。</p><h4 id="95-和-的valueOf和toString-的结果是什么"><a href="#95-和-的valueOf和toString-的结果是什么" class="headerlink" title="95.{} 和[]的valueOf和toString 的结果是什么?"></a>95.{} 和[]的valueOf和toString 的结果是什么?</h4><p>在 JavaScript 中，<code>valueOf</code> 和 <code>toString</code> 是对象的两个方法，用于返回对象的原始值。</p><ol><li>对于空对象 <code>&#123;&#125;</code> 和空数组 <code>[]</code>：</li></ol><ul><li><code>valueOf</code> 方法返回的是对象本身。</li><li><code>toString</code> 方法会将对象转换为字符串。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy codeconst emptyObj = &#123;&#125;;</span><br><span class="line">const emptyArr = [];</span><br><span class="line"></span><br><span class="line">console.log(emptyObj.valueOf()); // 输出：&#123;&#125;</span><br><span class="line">console.log(emptyObj.toString()); // 输出：&quot;[object Object]&quot;</span><br><span class="line"></span><br><span class="line">console.log(emptyArr.valueOf()); // 输出：[]</span><br><span class="line">console.log(emptyArr.toString()); // 输出：&quot;&quot;</span><br></pre></td></tr></table></figure><p>在上述代码中，<code>valueOf</code> 方法返回了对象本身，而 <code>toString</code> 方法将对象转换为字符串。对于空数组，<code>toString</code> 方法返回了一个空字符串，因为数组没有任何元素。</p><h4 id="96-三种事件模型是什么"><a href="#96-三种事件模型是什么" class="headerlink" title="96.三种事件模型是什么?"></a>96.三种事件模型是什么?</h4><p>JavaScript 中的事件模型分为三种：</p><ol><li>冒泡事件模型（Bubbling Event Model）：事件从最内层的元素开始触发，然后逐级向上传播，直到根节点。换句话说，事件会沿着 DOM 树从目标元素冒泡到父元素，直到最终到达根节点。</li><li>捕获事件模型（Capturing Event Model）：与冒泡事件模型相反，事件从根节点开始触发，然后逐级向下传播，直到目标元素。换句话说，事件会沿着 DOM 树从根节点捕获到目标元素。</li><li>DOM0 事件模型：这是最早期的事件模型，它使用 <code>element.onclick</code> 这样的方式来绑定事件。在 DOM0 事件模型中，事件只能通过指定特定的事件处理函数来绑定到元素上。</li></ol><p>在现代的 Web 开发中，主要使用冒泡事件模型。大多数情况下，我们通过 <code>addEventListener</code> 方法来绑定事件，该方法默认以冒泡模式注册事件。如果需要使用捕获事件模型，可以通过 <code>addEventListener</code> 的第三个参数设置为 <code>true</code> 来实现。</p><h4 id="97-介绍一下V8隐藏类"><a href="#97-介绍一下V8隐藏类" class="headerlink" title="97.介绍一下V8隐藏类"></a>97.介绍一下V8隐藏类</h4><p>V8 是 JavaScript 的引擎，由 Google 开发，用于执行 JavaScript 代码。V8 引擎在优化 JavaScript 代码的执行速度方面做了很多工作，其中一个重要的优化技术就是隐藏类（Hidden Class）。</p><p>隐藏类是 V8 引擎中用于优化对象访问的一种数据结构。在 JavaScript 中，对象的属性可以动态添加或删除，这就导致了对象的内部结构可能会频繁地变化。为了高效地访问对象的属性，V8 引擎使用隐藏类来跟踪对象的属性结构。</p><p>当 V8 引擎第一次创建一个对象时，会生成一个对应的隐藏类，并根据对象的属性结构来初始化这个隐藏类。当对象的属性结构发生变化时（比如添加或删除属性），V8 会创建一个新的隐藏类来反映这种变化。这样，当访问对象的属性时，V8 引擎就可以根据隐藏类的信息快速定位到属性的位置，而不需要遍历整个对象。</p><p>隐藏类的使用可以大幅提高对象属性访问的性能，因为它避免了频繁地进行属性搜索。但是需要注意的是，如果对象的属性结构变化过于频繁，V8 引擎可能会频繁地创建新的隐藏类，从而导致一些性能损失。</p><p>总结起来，V8 引擎中的隐藏类是一种用于优化对象属性访问的数据结构，它通过跟踪对象的属性结构，帮助 V8 引擎快速定位对象属性，从而提高 JavaScript 代码的执行性能。</p><h4 id="98-AMD和CMD规范的区别-说一下CommonJS、AMD和CMD"><a href="#98-AMD和CMD规范的区别-说一下CommonJS、AMD和CMD" class="headerlink" title="98.AMD和CMD规范的区别?说一下CommonJS、AMD和CMD?"></a>98.AMD和CMD规范的区别?说一下CommonJS、AMD和CMD?</h4><p>CommonJS、AMD 和 CMD 都是用于组织和管理 JavaScript 模块的规范。它们在模块加载和定义方面有不同的特点和用法。</p><ol><li>CommonJS:<ul><li>CommonJS 是一种同步加载模块的规范，适用于服务器端开发。</li><li>在 CommonJS 中，使用 <code>require()</code> 方法同步加载模块，模块中的代码会立即执行，并将 <code>module.exports</code> 对象返回给调用者。</li><li>模块的加载和执行是同步的，适用于在服务器端，因为服务器端通常拥有较快的加载速度。</li><li>在浏览器端使用 CommonJS 规范时，需要使用工具（如 Browserify 或 Webpack）将模块转换为符合浏览器环境的代码。</li></ul></li><li>AMD (Asynchronous Module Definition):<ul><li>AMD 是一种异步加载模块的规范，适用于浏览器端开发。</li><li>在 AMD 中，使用 <code>define()</code> 方法定义模块，使用 <code>require()</code> 方法异步加载模块，模块的加载和执行是异步的，不会阻塞页面加载。</li><li>AMD 规范允许在模块加载完成后再执行模块代码，适用于浏览器端，因为浏览器需要异步加载模块，不会阻塞页面渲染。</li></ul></li><li>CMD (Common Module Definition):<ul><li>CMD 是一种异步加载模块的规范，类似于 AMD，适用于浏览器端开发。</li><li>CMD 和 AMD 的主要区别在于对模块的执行时机有不同的处理方式。</li><li>在 CMD 中，使用 <code>define()</code> 方法定义模块，使用 <code>require()</code> 方法异步加载模块，但在加载模块后并不立即执行模块代码，而是等到调用 <code>require()</code> 方法时再执行模块代码。</li></ul></li></ol><p>综上所述，CommonJS 是一种同步加载模块的规范，适用于服务器端开发；AMD 和 CMD 是一种异步加载模块的规范，适用于浏览器端开发。在浏览器端开发中，AMD 和 CMD 都可以实现模块的异步加载，但它们对于模块的定义和执行时机有所不同。常见的模块加载器如 RequireJS 遵循 AMD 规范，而 SeaJS 遵循 CMD 规范。在实际开发中，根据项目需求和开发习惯选择合适的模块化规范和模块加载器。</p><h4 id="99-谈谈JS的运行机制"><a href="#99-谈谈JS的运行机制" class="headerlink" title="99.谈谈JS的运行机制"></a>99.谈谈JS的运行机制</h4><p>JavaScript 的运行机制主要涉及以下几个方面：</p><ol><li>解析器（Parser）：解析器是 JavaScript 引擎的一部分，它负责将 JavaScript 代码转换为可执行的内部表示（通常是抽象语法树 AST 或字节码）。</li><li>执行上下文（Execution Context）：执行上下文是 JavaScript 运行时的一个抽象概念，用于管理代码的执行。每当 JavaScript 代码执行时，都会创建一个执行上下文，并将其推入执行上下文栈（Execution Context Stack）中。</li><li>作用域（Scope）：作用域是一套规则，用于确定在何处以及如何查找变量。JavaScript 采用词法作用域（Lexical Scope），即变量的作用域由它们在代码中的位置决定。</li><li>闭包（Closure）：当一个函数内部的函数引用了外部函数的变量时，就创建了一个闭包。闭包允许在函数执行后继续访问其作用域中的变量。</li><li>事件循环（Event Loop）：事件循环是 JavaScript 实现异步编程的关键机制。JavaScript 是单线程的，但通过事件循环可以处理异步任务，避免阻塞主线程。</li></ol><p>JavaScript 运行机制可以简单概括为以下步骤：</p><ol><li>解析器解析 JavaScript 代码，创建全局执行上下文，并将全局执行上下文推入执行上下文栈。</li><li>全局执行上下文中的代码开始执行，遇到函数调用时，会创建新的执行上下文，并将其推入执行上下文栈。</li><li>函数内部的代码开始执行，根据词法作用域规则查找变量，并创建闭包（如果有需要）。</li><li>在执行过程中，如果遇到异步任务（例如定时器、事件监听、Ajax 请求等），会将异步任务放入事件队列（Event Queue）中。</li><li>当全局执行上下文和所有函数执行上下文执行完毕后，事件循环开始工作。它会从事件队列中取出异步任务，放入执行栈中执行。</li><li>异步任务执行完毕后，对应的回调函数会被调用，从而继续执行相应的逻辑。</li></ol><p>这样，通过事件循环和回调函数，JavaScript 实现了非阻塞式的异步编程，从而可以处理各种异步任务，提高了程序的响应性和性能。</p><h2 id="Vue生态"><a href="#Vue生态" class="headerlink" title="Vue生态"></a>Vue生态</h2><h4 id="1-说说你对Vue的理解，有何优缺点"><a href="#1-说说你对Vue的理解，有何优缺点" class="headerlink" title="1.说说你对Vue的理解，有何优缺点?"></a>1.说说你对Vue的理解，有何优缺点?</h4><p>Vue是一种流行的JavaScript前端框架，用于构建交互性强、响应式的单页面应用（SPA）和复杂的用户界面。它具有以下优点和缺点：</p><p>优点：</p><ol><li>简单易学：Vue的设计非常简洁，易于学习和上手。它提供了清晰的API和文档，使得开发者可以快速掌握并使用Vue进行开发。</li><li>响应式数据绑定：Vue使用双向数据绑定来保持数据和视图之间的同步。当数据发生变化时，视图会自动更新，大大简化了数据驱动视图的过程。</li><li>组件化开发：Vue采用了组件化的架构，将用户界面划分为多个可重用和独立的组件。这样可以提高代码的可维护性和复用性，使开发过程更加模块化。</li><li>轻量级：Vue的体积相对较小，加载速度快，对于移动端和性能要求较高的应用来说，这是一个优势。</li><li>生态系统丰富：Vue拥有强大的生态系统，包括Vue Router用于管理路由、Vuex用于状态管理、Vue CLI用于快速搭建项目等。这些工具和插件使得Vue更加灵活和强大。</li><li>渐进式框架：Vue被设计为渐进式框架，允许开发者逐步引入Vue的功能，可以与现有项目或其他框架很好地集成。</li></ol><p>缺点：</p><ol><li>小团队：相比于Angular和React，Vue的团队相对较小。尽管社区非常活跃，但由于团队规模有限，可能会导致一些功能更新的延迟。</li><li>生态系统相对较新：虽然Vue的生态系统不断发展，但与React和Angular相比，它的生态系统可能还相对较新和不成熟。</li><li>兼容性问题：由于Vue使用了一些现代的Web技术，可能会导致在一些旧版本的浏览器中出现兼容性问题。但是，这在现代项目中已经不再是主要问题。</li><li>插件质量不一：尽管Vue拥有丰富的插件和库，但有些插件的质量可能不一，需要开发者选择合适的插件。</li></ol><p>总的来说，Vue是一款优秀的前端框架，它的简洁、响应式数据绑定、组件化开发等特性使得开发者可以更高效地构建现代化的Web应用。然而，根据具体的项目需求和团队情况，选择合适的框架是很重要的。</p><h4 id="2-Vue和React有什么不同"><a href="#2-Vue和React有什么不同" class="headerlink" title="2.Vue和React有什么不同?"></a>2.Vue和React有什么不同?</h4><p>Vue 和 React 是两个流行的前端框架，它们有很多相似之处，同时也有一些不同点。以下是 Vue 和 React 的主要不同之处：</p><ol><li><strong>模板语法 vs JSX：</strong><ul><li>Vue 使用模板语法，通过在模板中使用指令（如 v-if、v-for 等）来操作 DOM 和渲染数据。</li><li>React 使用 JSX，将组件的结构和逻辑写在 JavaScript 中，通过类似于 HTML 的语法来描述 UI。</li></ul></li><li><strong>数据绑定和响应式系统：</strong><ul><li>Vue 使用双向数据绑定，通过 v-model 指令实现数据的自动双向同步。</li><li>React 使用单向数据流，数据流动是单向的，通过 props 来向子组件传递数据，通过 state 来管理组件的状态。</li></ul></li><li><strong>组件通信：</strong><ul><li>在 Vue 中，组件之间可以通过 props、自定义事件（$emit）以及 Vuex（状态管理库）进行通信。</li><li>在 React 中，组件之间通常通过 props 进行通信，也可以使用 Context API、Redux（状态管理库）等进行状态共享。</li></ul></li><li><strong>生命周期：</strong><ul><li>Vue 和 React 都有生命周期，但名称和使用方式上有所不同。Vue 的生命周期钩子是一些特定的函数名，例如 created、mounted 等。React 使用 useEffect Hook 来处理副作用，代替了传统的生命周期钩子。</li></ul></li><li><strong>过滤器和插槽：</strong><ul><li>在 Vue 中，可以使用过滤器（filters）来格式化数据，也可以使用插槽（slots）来插入内容到组件中。</li><li>在 React 中，没有直接的过滤器的概念，通常使用纯函数或其他库来处理数据。而 React 的插槽可以通过 props 来实现，称为 render props 或者 children props。</li></ul></li><li><strong>状态管理：</strong><ul><li>在 Vue 中，可以使用 Vuex 进行全局状态管理。</li><li>在 React 中，可以使用 Context API 或 Redux 进行全局状态管理。</li></ul></li><li><strong>学习曲线：</strong><ul><li>Vue 的学习曲线相对较低，容易上手，特别适合初学者。</li><li>React 的学习曲线较陡峭，对于有一定 JavaScript 和编程经验的开发者更容易上手。</li></ul></li></ol><p>总的来说，Vue 和 React 都是优秀的前端框架，选择使用哪个取决于个人喜好、团队经验和项目需求。Vue 更注重简洁和易用，适合快速开发；React 更注重灵活性和组件化，适合复杂的应用场景。</p><h4 id="3-什么是虚拟DOM"><a href="#3-什么是虚拟DOM" class="headerlink" title="3.什么是虚拟DOM?"></a>3.什么是虚拟DOM?</h4><p>虚拟DOM（Virtual DOM）是一种编程概念和技术，用于优化前端框架的性能和更新渲染的效率。它是由React框架首先引入并广泛使用的，后来也被其他框架如Vue等采用。</p><p>在传统的前端开发中，当数据发生变化时，直接操作实际的DOM（Document Object Model）来进行更新和重新渲染。这种操作可能会导致频繁的DOM操作，而DOM操作是相对较慢的，特别是在大型、复杂的应用中，频繁的DOM操作会严重影响性能。</p><p>虚拟DOM的核心思想是：不直接操作实际的DOM，而是先在内存中创建一个虚拟的DOM树，这个虚拟DOM树与实际DOM树一一对应。当数据发生变化时，首先更新虚拟DOM，然后通过算法将新的虚拟DOM与旧的虚拟DOM进行比较，找出变化的部分，最后只更新变化的部分到实际的DOM树上。这样避免了直接操作实际DOM的频繁性，大大提高了更新和渲染的效率。</p><p>虚拟DOM的优势在于：</p><ol><li>提高性能：通过批量更新和局部更新，减少实际DOM操作，提高了渲染性能和响应速度。</li><li>简化开发：开发者不需要手动操作DOM来更新页面，而是通过操作数据和虚拟DOM来实现更新，简化了开发过程。</li><li>跨平台：由于虚拟DOM的中间层，使得框架可以在不同的平台上使用，如浏览器、移动端、服务器等。</li><li>方便调试：虚拟DOM可以提供更好的调试工具和开发者工具，方便追踪更新和渲染过程。</li></ol><p>虚拟DOM虽然带来了很多优势，但也并非没有成本。由于引入了虚拟DOM层，会占用一定的内存和计算资源。但在大多数情况下，虚拟DOM带来的性能提升远远大于其本身的开销，因此被广泛应用于现代的前端框架中。</p><h4 id="4-描述下vue的生命周期有哪些-分别做了什么事情"><a href="#4-描述下vue的生命周期有哪些-分别做了什么事情" class="headerlink" title="4.描述下vue的生命周期有哪些?分别做了什么事情?"></a>4.描述下vue的生命周期有哪些?分别做了什么事情?</h4><p>Vue的生命周期是组件在创建、更新和销毁过程中触发的一系列钩子函数。这些钩子函数允许开发者在不同的生命周期阶段执行自定义逻辑。Vue的生命周期可以分为以下几个阶段：</p><ol><li>创建阶段（Creation）：<ul><li>beforeCreate：在实例刚刚被创建，数据观测和事件还未初始化。此时无法访问组件的数据和方法。</li><li>created：在实例已经完成数据观测和事件初始化，但尚未挂载到DOM上。此时组件的数据和方法已经可以使用。</li><li>beforeMount：在组件挂载到DOM之前被调用。此时模板编译完成，但尚未将组件插入到页面中。</li></ul></li><li>挂载阶段（Mounting）：<ul><li>mounted：在组件挂载到DOM后被调用。此时组件已经被插入到页面中，可以访问到DOM元素。</li></ul></li><li>更新阶段（Updating）：<ul><li>beforeUpdate：在组件数据更新之前被调用。此时数据还未更新，DOM也还未重新渲染。</li><li>updated：在组件数据更新后被调用。此时数据已更新，DOM也已重新渲染。</li></ul></li><li>销毁阶段（Destruction）：<ul><li>beforeDestroy：在组件销毁之前被调用。此时组件仍然可用，可以执行一些清理工作。</li><li>destroyed：在组件销毁后被调用。此时组件已被销毁，事件监听和数据观测都已被移除。</li></ul></li></ol><p>在这些生命周期钩子函数中，beforeCreate和created用于初始化组件的数据和方法，beforeMount和mounted用于处理DOM相关的操作，beforeUpdate和updated用于处理数据更新后的操作，beforeDestroy和destroyed用于清理资源和执行一些清理工作。</p><p>在实际开发中，可以根据需要在不同的生命周期阶段使用这些钩子函数来执行一些逻辑，比如在created阶段发起网络请求，或者在beforeDestroy阶段清除定时器等。了解和使用Vue的生命周期可以帮助我们更好地掌握组件的创建、更新和销毁过程，从而更好地优化和管理Vue应用。</p><h4 id="5-watch-怎么深度监听对象变化"><a href="#5-watch-怎么深度监听对象变化" class="headerlink" title="5.watch 怎么深度监听对象变化"></a>5.watch 怎么深度监听对象变化</h4><p>在Vue中，通过<code>watch</code>选项可以对组件的数据进行监听，当数据变化时触发相应的操作。默认情况下，<code>watch</code>只会对对象的引用进行浅层比较，即只会检测对象的第一层属性变化。如果要深度监听对象的变化，可以通过设置<code>deep</code>选项为<code>true</code>来实现。</p><p>在上述示例中，我们在<code>watch</code>选项中定义了一个对<code>myObject</code>的深度监听。当点击按钮后，<code>myObject</code>的属性a和属性b发生变化时，<code>watch</code>中的<code>handler</code>函数将会被调用，并输出新值和旧值。由于我们设置了<code>deep: true</code>，所以Vue会递归遍历<code>myObject</code>的所有嵌套属性，深度监听对象的变化。</p><p>需要注意的是，深度监听对象的变化会带来一定的性能损耗，因为Vue需要递归遍历对象的所有属性。因此，只有在必要时才使用<code>deep: true</code>。在大多数情况下，浅层监听已经足够满足需求。</p><h4 id="6-删除数组用delete和Vue-delete有什么区别"><a href="#6-删除数组用delete和Vue-delete有什么区别" class="headerlink" title="6.删除数组用delete和Vue.delete有什么区别?"></a>6.删除数组用delete和Vue.delete有什么区别?</h4><p>在JavaScript中，删除数组元素通常有两种方法：使用<code>delete</code>操作符和使用<code>splice</code>方法。而在Vue中，还可以使用<code>Vue.delete</code>方法来删除数组元素。</p><p>1.使用<code>delete</code>操作符：</p><ul><li><code>delete</code>操作符用于删除对象的属性，在数组中删除元素时，并不会改变数组的长度，而是将删除元素的位置设置为<code>undefined</code>。这样可能导致数组出现稀疏（sparse）的情况，即数组中有一些位置的值是<code>undefined</code>，而不是真正的元素。例如：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const arr = [1, 2, 3, 4];</span><br><span class="line">delete arr[1]; // arr变为 [1, undefined, 3, 4]</span><br></pre></td></tr></table></figure><p>2.使用<code>splice</code>方法：</p><ul><li><code>splice</code>方法用于删除数组中的元素，并且会改变数组的长度。它可以接收两个参数，第一个参数是删除元素的起始位置，第二个参数是要删除的元素个数。例如：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy codeconst arr = [1, 2, 3, 4];</span><br><span class="line">arr.splice(1, 1); // arr变为 [1, 3, 4]</span><br></pre></td></tr></table></figure><p>3.使用<code>Vue.delete</code>方法：</p><ul><li>在Vue中，如果要删除数组中的元素，特别是响应式数组（由Vue进行数据劫持），应该使用<code>Vue.delete</code>方法。<code>Vue.delete</code>方法是专门用于在Vue响应式数组中删除元素的。它能够正确地更新视图和响应式数据，确保删除元素后页面正确地更新。例如：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy codeconst vm = new Vue(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    arr: [1, 2, 3, 4],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Vue.delete(vm.arr, 1); // arr变为 [1, 3, 4]</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li><code>delete</code>操作符适用于普通数组，但不会对Vue的响应式数组进行正确处理，可能会导致不符合预期的结果。</li><li><code>splice</code>方法适用于普通数组，并且可以在Vue的响应式数组中使用，但需要手动更新视图和响应式数据。</li><li><code>Vue.delete</code>方法是专门用于Vue响应式数组的删除操作，它会正确处理视图和响应式数据，推荐在Vue中使用。</li></ul><h4 id="7-watch-和computed有什么区别"><a href="#7-watch-和computed有什么区别" class="headerlink" title="7.watch 和computed有什么区别?"></a>7.watch 和computed有什么区别?</h4><p><code>watch</code>和<code>computed</code>是Vue中用于监听数据变化的两种不同的方式，它们有以下区别：</p><ol><li>用途：<ul><li><code>watch</code>：用于监听指定的数据变化，当被监听的数据发生变化时，触发相应的回调函数执行自定义的操作。</li><li><code>computed</code>：用于计算衍生的数据（计算属性），它根据其他响应式数据的值计算而来，并且会将计算结果缓存起来，只有依赖的数据发生变化时才会重新计算。</li></ul></li><li>返回值：<ul><li><code>watch</code>：没有返回值，仅用于监听数据变化，不会返回计算结果。</li><li><code>computed</code>：有返回值，返回计算属性的结果，计算结果会被缓存，多次访问同一计算属性时，不会重新计算。</li></ul></li><li>监听方式：<ul><li><code>watch</code>：可以监听一个或多个数据的变化，也可以通过<code>deep</code>选项深度监听对象或数组的变化。</li><li><code>computed</code>：依赖于其他响应式数据，当被依赖的数据发生变化时，计算属性会自动更新。</li></ul></li><li>使用场景：<ul><li><code>watch</code>：适用于对数据变化做一些复杂或异步处理的场景，例如监听输入框的输入，然后进行实时搜索；监听数组的变化，然后触发网络请求等。</li><li><code>computed</code>：适用于根据已有的响应式数据计算出一个新的值，例如计算商品总价、过滤、排序等。</li></ul></li></ol><p>示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">htmlCopy code&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;input v-model=&quot;name&quot; /&gt;</span><br><span class="line">    &lt;p&gt;计算属性：&#123;&#123; fullName &#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      name: &#x27;&#x27;,</span><br><span class="line">      lastName: &#x27;Doe&#x27;,</span><br><span class="line">      firstName: &#x27;John&#x27;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    name(newVal, oldVal) &#123;</span><br><span class="line">      console.log(&#x27;输入框的值发生变化：&#x27;, newVal, oldVal);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    fullName() &#123;</span><br><span class="line">      return this.firstName + &#x27; &#x27; + this.lastName;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>在上述示例中，<code>watch</code>用于监听输入框的值变化，<code>computed</code>用于计算全名。每次输入框的值发生变化时，<code>watch</code>会触发回调函数输出变化的值，而<code>computed</code>会自动计算新的全名，并且只有在<code>firstName</code>和<code>lastName</code>发生变化时才会重新计算全名。</p><h4 id="8-v-for没有key会发生什么问题"><a href="#8-v-for没有key会发生什么问题" class="headerlink" title="8.v-for没有key会发生什么问题?"></a>8.v-for没有key会发生什么问题?</h4><p>如果在使用<code>v-for</code>指令时没有设置<code>key</code>，Vue会发出一个警告，提示开发者最好为每个<code>v-for</code>循环提供一个唯一的<code>key</code>值。虽然不设置<code>key</code>并不会导致错误，但它可能会引发一些不希望出现的问题：</p><ol><li>重复利用DOM元素：Vue使用<code>key</code>来跟踪虚拟DOM中每个节点的身份，在每次<code>v-for</code>更新时，通过<code>key</code>来判断哪些元素需要更新、删除或新增。如果没有<code>key</code>，Vue无法区分各个元素，可能会出现重复利用DOM元素的情况，导致不正确的渲染结果。</li><li>错误的更新行为：没有设置<code>key</code>时，Vue可能会出现意外的更新行为。例如，某个数据项被删除了，但没有设置<code>key</code>，导致Vue无法正确识别删除的元素，从而可能导致删除操作没有生效或产生错误的渲染结果。</li><li>性能问题：没有设置<code>key</code>可能导致Vue在更新时需要对所有元素进行比较和重新渲染，而不是根据<code>key</code>来识别哪些元素是相同的。这会导致不必要的性能开销，特别是在大型列表中。</li></ol><p>因此，为每个<code>v-for</code>循环提供一个唯一的<code>key</code>是一个良好的实践。通常，推荐使用具有唯一标识符的属性作为<code>key</code>，例如数据中的<code>id</code>属性。这样可以确保每个元素在循环中具有唯一的标识，避免可能出现的问题，并优化Vue的更新性能。示例如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">htmlCopy code&lt;div v-for=&quot;item in items&quot; :key=&quot;item.id&quot;&gt;</span><br><span class="line">  &lt;!-- 循环内容 --&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><h4 id="9-谈谈Vue双向绑定原理"><a href="#9-谈谈Vue双向绑定原理" class="headerlink" title="9.谈谈Vue双向绑定原理"></a>9.谈谈Vue双向绑定原理</h4><p>Vue的双向绑定是其核心特性之一，它使得数据和视图之间保持同步，让开发者能够更便捷地处理用户输入和数据更新。Vue的双向绑定原理主要依赖于以下两个机制：</p><ol><li>数据劫持和观察者模式：<ul><li>当Vue实例化时，会对数据进行劫持（Object.defineProperty或Proxy），通过劫持数据的<code>get</code>和<code>set</code>方法，在数据被访问或修改时触发相应的操作。这样Vue就能够捕获到对数据的访问和修改，并进行响应。</li><li>Vue还实现了观察者模式（Observer），通过定义一个Dep（Dependency）依赖管理器来收集依赖（观察者）和通知变化。每个数据属性都会有一个对应的Watcher观察者对象，当数据发生变化时，观察者会收到通知并更新视图。</li></ul></li><li>模板编译：<ul><li>Vue使用模板编译将模板（template）转换为渲染函数（render function）。渲染函数是一个函数，它接收数据并返回虚拟DOM（Virtual DOM）。</li><li>在模板编译的过程中，会解析模板中的指令（如v-bind、v-on、v-model等），当遇到v-model指令时，会将数据属性和表单元素进行绑定。</li><li>在绑定过程中，对于表单元素，会监听其<code>input</code>事件，当用户输入时触发<code>input</code>事件，然后更新数据属性的值。同时，对于数据属性，也会在<code>set</code>方法中触发更新视图的操作。</li></ul></li></ol><p>综合上述机制，当用户输入表单元素时，会触发<code>input</code>事件，更新绑定的数据属性的值；而数据属性的更新又会触发观察者的通知，通知相关的Watcher进行更新操作，最终更新视图。这样就实现了双向绑定，数据的变化会影响视图的更新，同时视图的变化也会反过来影响数据。</p><p>需要注意的是，Vue的双向绑定是基于数据劫持和观察者模式实现的，而并非真正的双向绑定。真正的双向绑定是在数据变化时，视图会自动更新，同时在视图变化时，数据也会自动更新。而Vue的双向绑定是通过触发事件和更新机制来实现的，并非实时的自动双向同步。</p><h4 id="10-v-model-是什么-有什么用呢"><a href="#10-v-model-是什么-有什么用呢" class="headerlink" title="10.v-model 是什么?有什么用呢?"></a>10.v-model 是什么?有什么用呢?</h4><p><code>v-model</code>是Vue.js提供的一个指令，用于在表单元素和数据之间建立双向数据绑定。它是Vue中实现双向绑定的一种简便方式。</p><p>使用<code>v-model</code>指令，可以将表单元素的值和Vue实例的数据属性绑定在一起。当用户在表单元素上输入数据时，<code>v-model</code>会自动将用户的输入更新到Vue实例的对应数据属性中；同时，当Vue实例的数据属性发生变化时，<code>v-model</code>也会自动将更新的数据反映到表单元素上，保持数据和视图之间的同步。</p><p><code>v-model</code>可以用在常见的表单元素上，如文本输入框、多行文本框、复选框、单选按钮和下拉框等。根据不同的表单元素类型，<code>v-model</code>的使用方式略有不同。</p><p>例如，对于文本输入框，可以这样使用<code>v-model</code>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">htmlCopy code&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; v-model=&quot;message&quot; /&gt;</span><br><span class="line">    &lt;p&gt;输入的内容：&#123;&#123; message &#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      message: &#x27;&#x27;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>在上述示例中，<code>v-model=&quot;message&quot;</code>将文本输入框和Vue实例的<code>message</code>数据属性进行了双向绑定。当用户在文本输入框中输入内容时，<code>message</code>会自动更新为输入的内容，并且在页面上展示出来；反之，当<code>message</code>的值发生变化时，文本输入框的内容也会相应地更新。</p><p><code>v-model</code>使得数据的输入和展示变得简单高效，能够方便地处理用户输入和数据更新，是Vue.js中一个非常实用的特性。</p><h4 id="11-在vue项目中如何引入第三方库-有哪些具体操作方法"><a href="#11-在vue项目中如何引入第三方库-有哪些具体操作方法" class="headerlink" title="11.在vue项目中如何引入第三方库?有哪些具体操作方法?"></a>11.在vue项目中如何引入第三方库?有哪些具体操作方法?</h4><p>在Vue项目中引入第三方库可以通过以下几种具体操作方法：</p><ol><li><p>使用CDN链接：</p><ul><li>对于一些常用的第三方库，可以直接使用CDN链接来引入，将链接添加到项目的HTML文件中。例如，在<code>index.html</code>文件中添加以下代码：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;!-- 引入第三方库的CDN链接 --&gt;</span><br><span class="line">  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br></pre></td></tr></table></figure><p>这样就可以直接在项目中使用Vue库了。</p></li><li><p>使用npm安装并导入：</p><ul><li>对于一些复杂或需要频繁使用的第三方库，可以使用npm进行安装，然后在需要的地方通过<code>import</code>或<code>require</code>语句来导入。例如，使用npm安装axios库：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install axios</span><br></pre></td></tr></table></figure><p>在需要使用axios的地方导入：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 使用ES6的import语法</span><br><span class="line">import axios from &#x27;axios&#x27;;</span><br><span class="line"></span><br><span class="line">// 或者使用CommonJS的require语法</span><br><span class="line">// const axios = require(&#x27;axios&#x27;);</span><br></pre></td></tr></table></figure></li><li><p>使用Vue插件：</p><ul><li>一些第三方库为了在Vue项目中更方便地使用，可能会提供Vue插件的形式。通过引入Vue插件，可以将库集成到Vue实例中，使得在Vue组件中更加方便地使用该库的功能。具体使用方法可以查看第三方库的文档。</li></ul></li><li><p>使用全局变量：</p><ul><li>一些第三方库可能在引入后会在全局环境中暴露一个全局变量，可以直接在Vue组件中使用该全局变量。例如，在<code>index.html</code>中引入第三方库：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">htmlCopy code&lt;head&gt;</span><br><span class="line">  &lt;!-- 引入第三方库 --&gt;</span><br><span class="line">  &lt;script src=&quot;path/to/library.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br></pre></td></tr></table></figure><p>然后在Vue组件中使用：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy codeexport default &#123;</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    // 使用全局变量来调用第三方库的功能</span><br><span class="line">    libraryFunction();</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><p>以上是引入第三方库的几种常见方法，具体使用哪种方法取决于第三方库的提供方式以及项目的需求。在引入第三方库时，建议查阅相应库的文档以了解具体的用法和配置。</p><h4 id="12-Vue3-0-里为什么要用Proxy-API替代defineProperty-API"><a href="#12-Vue3-0-里为什么要用Proxy-API替代defineProperty-API" class="headerlink" title="12.Vue3.0 里为什么要用Proxy API替代defineProperty API?"></a>12.Vue3.0 里为什么要用Proxy API替代defineProperty API?</h4><p>Vue 3.0 使用 Proxy API 替代 defineProperty API 的主要原因是 Proxy API 具有更强大的功能和更好的性能，能够更好地满足 Vue 的响应式系统的需求。</p><ol><li><strong>功能更强大：</strong> Proxy API 相比于 defineProperty API，提供了更丰富的拦截方法。通过 Proxy，可以拦截更多种类的操作，包括对属性的读取、赋值、删除等，还可以拦截函数的调用和构造函数的调用等。这使得 Vue 3.0 的响应式系统更加灵活和全面。</li><li><strong>更直观：</strong> Proxy API 的用法更直观和简洁，不需要像 defineProperty API 那样深入研究属性描述符，只需要定义一个处理器对象，通过拦截方法来定义对目标对象的操作行为。这样使得代码更易于理解和维护。</li><li><strong>性能更好：</strong> Proxy API 拥有更好的性能。在 defineProperty API 中，对于每个属性需要逐个设置 getter 和 setter，对于大量属性的对象，会产生较大的开销。而 Proxy API 只需要创建一个代理对象，通过处理器对象来统一处理所有的操作，避免了逐个设置属性的开销，性能更高。</li><li><strong>嵌套属性处理：</strong> Proxy API 对于深层嵌套的属性具有更好的处理能力。在 defineProperty API 中，对于深层嵌套的属性需要逐层设置 getter 和 setter，而 Proxy API 可以一次性拦截所有层次的属性访问和操作。</li></ol><p>总体而言，Proxy API 提供了更现代和强大的响应式机制，使得 Vue 3.0 的响应式系统更加高效、灵活和易用。通过使用 Proxy API，Vue 3.0 实现了更优雅的响应式数据追踪机制，为开发者提供了更好的开发体验和性能优势。</p><h4 id="13-Vue3-0-编译做了哪些优化"><a href="#13-Vue3-0-编译做了哪些优化" class="headerlink" title="13.Vue3.0 编译做了哪些优化?"></a>13.Vue3.0 编译做了哪些优化?</h4><p>Vue 3.0 在编译方面进行了一系列优化，旨在提高编译性能和减少生成的代码量。以下是 Vue 3.0 在编译方面做的一些优化：</p><ol><li><strong>静态标记（Static Markup）：</strong> Vue 3.0 使用了静态标记来标记那些静态节点和属性，这些静态节点和属性在每次重新渲染时都不会发生变化。通过静态标记，Vue 3.0 在每次渲染时可以跳过这些静态节点和属性的比对过程，减少了渲染的时间和开销。</li><li><strong>hoist 静态节点（静态提升）：</strong> Vue 3.0 在编译过程中会将一些静态节点提升到 render 函数的外部，这样可以避免在每次渲染时重新创建这些静态节点，从而减少了生成的代码量和渲染的开销。</li><li><strong>Patch Flag（补丁标记）：</strong> Vue 3.0 使用 Patch Flag 来标记那些需要进行比对的节点类型和属性。通过 Patch Flag，Vue 3.0 可以在进行 DOM 操作时跳过对不需要比对的节点的处理，减少了比对的时间和开销。</li><li><strong>Block Tree（块级树）：</strong> Vue 3.0 使用 Block Tree 来表示模板中的块级元素，例如 v-for 和 v-if。Block Tree 可以更精确地表示模板的结构，减少了不必要的操作和生成的代码量。</li><li><strong>静态提升（静态节点编译）：</strong> Vue 3.0 通过静态提升将静态节点从模板中剥离出来，使得每次渲染只需要处理动态节点，减少了渲染的开销。</li><li><strong>源码优化：</strong> Vue 3.0 在编译器的源码上进行了优化和重构，使得编译器更加高效和灵活。</li></ol><p>总体而言，Vue 3.0 在编译方面进行了多方面的优化，从静态标记、hoist 静态节点到 Patch Flag 和 Block Tree，都使得编译过程更高效，生成的代码更精简，减少了运行时的开销，提高了应用的性能。这些编译优化使得 Vue 3.0 成为一个更加高效和现代的前端框架，为开发者提供更好的开发体验和用户体验。</p><h4 id="14-Vue3-0-新特性一-Composition-API与React-js中Hooks的异同点"><a href="#14-Vue3-0-新特性一-Composition-API与React-js中Hooks的异同点" class="headerlink" title="14.Vue3.0 新特性一-Composition API与React.js中Hooks的异同点"></a>14.Vue3.0 新特性一-Composition API与React.js中Hooks的异同点</h4><p>Vue 3.0 的 Composition API 与 React.js 中的 Hooks 具有一些相似之处，同时也有一些不同点。下面是它们的异同点：</p><p><strong>相似点：</strong></p><ol><li><strong>逻辑复用：</strong> 两者都可以通过抽取逻辑到自定义函数中，实现逻辑的复用。在 Vue 3.0 中，Composition API 允许开发者将组件的逻辑划分为多个功能性模块，从而更好地组织和重用代码。而 React.js 的 Hooks 也提供了各种 Hook 函数（如 useState、useEffect 等）来实现逻辑的复用。</li><li><strong>无需嵌套：</strong> 在 Vue 3.0 的 Composition API 和 React.js 的 Hooks 中，可以在函数组件中直接使用这些功能，无需嵌套。</li><li><strong>可读性：</strong> 两者都可以使代码更具可读性，因为相关逻辑被分组到自定义函数中，从而使组件更加简洁。</li></ol><p><strong>不同点：</strong></p><ol><li><strong>API 名称：</strong> Vue 3.0 使用的是 Composition API，而 React.js 使用的是 Hooks。虽然名称不同，但实质上都是实现了逻辑复用的功能。</li><li><strong>状态管理：</strong> 在 Vue 3.0 的 Composition API 中，可以使用 reactive 和 ref 来处理组件的响应式状态。而 React.js 的 Hooks 则使用 useState 来处理状态。React.js 的 useContext 和 useReducer 等 Hook 也提供了更灵活的状态管理方式。</li><li><strong>生命周期：</strong> 在 Vue 3.0 的 Composition API 中，可以通过 onMounted、onUpdated、onUnmounted 等函数来代替 Vue 2.x 中的生命周期钩子。React.js 的 useEffect Hook 可以用来处理组件的副作用，相当于 Vue 2.x 中的生命周期钩子的合并。</li><li><strong>跨组件状态共享：</strong> 在 Vue 3.0 的 Composition API 中，可以使用 provide 和 inject 来实现组件之间的状态共享。而 React.js 通过 useContext 来实现类似的跨组件状态共享。</li></ol><p>总的来说，Vue 3.0 的 Composition API 和 React.js 的 Hooks 都提供了逻辑复用的能力，并且让组件代码更具可读性。它们在某些方面有一些不同的实现，但都是为了让开发者能够更好地组织和重用组件逻辑。</p><h4 id="15-Vue3-0-如何变得更快的-dom-diff-算法有何优化"><a href="#15-Vue3-0-如何变得更快的-dom-diff-算法有何优化" class="headerlink" title="15.Vue3.0 如何变得更快的? dom diff 算法有何优化?"></a>15.Vue3.0 如何变得更快的? dom diff 算法有何优化?</h4><p>Vue 3.0 通过一系列优化来提高性能，其中 DOM Diff 算法也得到了优化。以下是 Vue 3.0 在提高性能方面的一些措施和 DOM Diff 算法的优化：</p><ol><li><strong>虚拟 DOM 的优化：</strong> Vue 3.0 使用了更高效的虚拟 DOM 实现，通过静态标记、hoist 静态节点和优化的 Patch 策略，减少了虚拟 DOM 的创建和比对的成本，提高了渲染性能。</li><li><strong>编译器优化：</strong> Vue 3.0 中的编译器进行了改进，生成更优化的渲染函数代码，减少了生成的代码量，提高了编译性能。</li><li><strong>响应式系统优化：</strong> Vue 3.0 中的响应式系统进行了重写，使用 Proxy 代替 Object.defineProperty，使得响应式数据的追踪更加高效和精确，减少了响应式系统的开销。</li><li><strong>Tree-shaking 支持：</strong> Vue 3.0 支持 Tree-shaking，通过标记组件、指令和编译器的来源，使得打包时只包含使用到的代码，减少了打包体积，提高了性能。</li><li><strong>Fragment 支持：</strong> Vue 3.0 支持使用 Fragment（片段）渲染多个根节点，减少了不必要的 DOM 包裹，提高了渲染性能。</li><li><strong>合并事件监听器优化：</strong> Vue 3.0 在合并事件监听器时进行了优化，避免了不必要的监听器合并，减少了事件处理的开销。</li><li><strong>缓存事件处理器：</strong> Vue 3.0 对事件处理器进行了缓存，减少了重复创建和销毁事件处理器的开销。</li><li><strong>事件侦听器优化：</strong> Vue 3.0 对事件侦听器进行了优化，减少了事件侦听器的数量，提高了性能。</li><li><strong>更新算法优化：</strong> Vue 3.0 在组件更新算法上进行了优化，减少了不必要的更新操作，提高了更新性能。</li></ol><p>总体而言，Vue 3.0 在性能方面进行了全面的优化和改进，从虚拟 DOM 到响应式系统，再到编译器和打包支持，都使得应用的性能得到显著提升。这些优化使得 Vue 3.0 成为一个更加高效、快速和现代的前端框架，带来更好的用户体验和开发体验。</p><h4 id="16-vue-要做权限管理该怎么做-如果控制到按钮级别的权限怎么做"><a href="#16-vue-要做权限管理该怎么做-如果控制到按钮级别的权限怎么做" class="headerlink" title="16.vue 要做权限管理该怎么做?如果控制到按钮级别的权限怎么做?"></a>16.vue 要做权限管理该怎么做?如果控制到按钮级别的权限怎么做?</h4><p>在 Vue 中进行权限管理，通常可以采用以下几种方法：</p><ol><li><strong>路由权限管理：</strong> 在路由定义时，根据用户的角色或权限信息来动态生成可访问的路由，只加载用户有权限的路由组件。这样可以在页面级别进行权限控制，用户无权限的页面将无法访问。</li><li><strong>组件级别权限控制：</strong> 在组件内部根据用户的角色或权限信息来动态显示或隐藏组件中的某些内容。这可以通过 v-if 或 v-show 指令来实现。</li><li><strong>按钮级别权限控制：</strong> 对于按钮级别的权限控制，可以在组件内部根据用户的角色或权限信息，动态决定是否显示或禁用按钮。这可以通过 v-if 或 v-show 指令来实现，或者通过绑定 disabled 属性来禁用按钮。</li><li><strong>权限指令：</strong> 自定义一个权限指令，通过传入用户的角色或权限信息和目标权限，判断用户是否有权限操作某个元素。如果用户没有权限，可以隐藏或禁用元素。例如，在指令中使用 Vue.directive 钩子来进行权限控制。</li><li><strong>权限管理插件：</strong> 使用现有的权限管理插件，例如 vue-router、v-permission 等，来实现权限管理。这些插件通常提供了方便的配置和管理权限的方式。</li></ol><p>在以上方法中，路由权限管理是最常见且较为常用的方法，它能够有效地控制页面级别的权限，保护用户不应该访问的页面。组件级别和按钮级别权限控制则可以更细粒度地控制页面内的操作权限。无论选择哪种方法，都需要在前端和后端进行配合，前端控制显示和操作的权限，后端进行数据和接口的访问权限控制，以保障整体系统的安全性。</p><h4 id="17-vue-在created和mounted这两个生命周期中请求数据有什么区别呢"><a href="#17-vue-在created和mounted这两个生命周期中请求数据有什么区别呢" class="headerlink" title="17.vue 在created和mounted这两个生命周期中请求数据有什么区别呢?"></a>17.vue 在created和mounted这两个生命周期中请求数据有什么区别呢?</h4><p>在 Vue 组件的生命周期中，<code>created</code>和<code>mounted</code>是两个常用的生命周期钩子函数，它们分别在组件实例创建和组件挂载到页面上时触发。在这两个生命周期中请求数据的主要区别如下：</p><ol><li><strong>触发时机：</strong><ul><li><code>created</code>生命周期在组件实例创建后立即触发，此时组件的实例已经创建，但尚未挂载到页面上，DOM 还没有生成。</li><li><code>mounted</code>生命周期在组件挂载到页面后触发，此时组件已经被添加到页面中，DOM 元素已经生成，可以进行DOM相关的操作。</li></ul></li><li><strong>适用场景：</strong><ul><li><code>created</code>适用于在组件实例创建后，进行一些初始化的操作，例如设置默认数据、创建定时器、绑定事件监听器等。此时还不能进行依赖于DOM的操作，因为DOM还没有生成。</li><li><code>mounted</code>适用于在组件已经挂载到页面后，进行DOM相关的操作，例如获取DOM元素、操作DOM元素、请求数据等。因为在<code>mounted</code>生命周期中，DOM已经生成，可以安全地进行DOM操作。</li></ul></li><li><strong>数据请求：</strong><ul><li>在<code>created</code>生命周期中，可以发起数据请求，但需要注意异步请求的处理。因为<code>created</code>生命周期中的异步请求是在组件创建期间进行的，如果数据请求耗时较长，可能会导致组件在挂载前还未完成，页面上无法显示请求的数据。</li><li>在<code>mounted</code>生命周期中，可以安全地发起数据请求，并对请求结果进行处理。此时，组件已经挂载到页面上，可以确保请求的数据能够正确显示在页面中。</li></ul></li></ol><p>总结：在<code>created</code>生命周期中可以进行一些初始化操作，但需要注意异步请求的处理；在<code>mounted</code>生命周期中，可以进行DOM相关的操作和数据请求，因为此时组件已经挂载到页面上，可以安全地进行DOM操作和显示数据。根据需求的不同，选择适合的生命周期钩子来请求数据和进行其他操作，可以使组件的逻辑更加清晰和合理。</p><h4 id="18-说说你对Proxy的理解。"><a href="#18-说说你对Proxy的理解。" class="headerlink" title="18.说说你对Proxy的理解。"></a>18.说说你对Proxy的理解。</h4><p>Proxy是JavaScript的一个高级特性，它是ES6引入的一个内置对象，用于创建一个代理对象，可以拦截对目标对象的访问和操作。通过Proxy，我们可以在目标对象上定义自定义的行为，实现对对象的拦截、过滤、监听等操作，从而实现更加灵活和高级的编程模式。</p><p>Proxy 对象的创建需要两个参数：目标对象（target）和一个处理器对象（handler）。处理器对象是一个包含各种拦截方法的对象，用于定义对目标对象的各种操作的自定义行为。</p><p>Proxy 支持的拦截方法包括：</p><ol><li><code>get(target, property, receiver)</code>: 拦截对目标对象属性的读取操作。</li><li><code>set(target, property, value, receiver)</code>: 拦截对目标对象属性的赋值操作。</li><li><code>has(target, property)</code>: 拦截对in操作符的操作。</li><li><code>deleteProperty(target, property)</code>: 拦截对delete操作符的操作。</li><li><code>apply(target, thisArg, argumentsList)</code>: 拦截函数的调用操作。</li><li><code>construct(target, argumentsList, newTarget)</code>: 拦截对构造函数的调用操作。</li><li>等等…</li></ol><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jsCopy codeconst target = &#123;</span><br><span class="line">  name: &#x27;John&#x27;,</span><br><span class="line">  age: 30,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const handler = &#123;</span><br><span class="line">  get(target, property) &#123;</span><br><span class="line">    console.log(`读取属性：$&#123;property&#125;`);</span><br><span class="line">    return target[property];</span><br><span class="line">  &#125;,</span><br><span class="line">  set(target, property, value) &#123;</span><br><span class="line">    console.log(`设置属性：$&#123;property&#125;，值：$&#123;value&#125;`);</span><br><span class="line">    target[property] = value;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const proxy = new Proxy(target, handler);</span><br><span class="line"></span><br><span class="line">console.log(proxy.name); // 读取属性：name，输出：John</span><br><span class="line">proxy.age = 31; // 设置属性：age，值：31</span><br><span class="line">console.log(proxy.age); // 读取属性：age，输出：31</span><br></pre></td></tr></table></figure><p>在上述示例中，我们使用Proxy创建了一个代理对象proxy，并定义了一个处理器对象handler来拦截对target对象的读取和设置属性操作。通过Proxy，我们可以在控制台输出读取和设置属性的信息。</p><p>Proxy 在前端开发中广泛应用于数据劫持、数据监听、表单校验、数据代理等场景。它提供了一种强大的机制，使得开发者可以对目标对象的访问和操作进行自定义处理，从而实现更加灵活和强大的编程功能。</p><h4 id="19-Vue3-0性能提升主要是体现在哪些方面"><a href="#19-Vue3-0性能提升主要是体现在哪些方面" class="headerlink" title="19.Vue3.0性能提升主要是体现在哪些方面?"></a>19.Vue3.0性能提升主要是体现在哪些方面?</h4><p>Vue 3.0 在性能方面主要体现在以下几个方面：</p><ol><li><strong>虚拟 DOM 优化：</strong> Vue 3.0 在虚拟 DOM 层面进行了优化，通过使用静态标记和hoist静态节点等技术，减少了虚拟 DOM 的创建和比对的成本，提高了渲染性能。</li><li><strong>编译器优化：</strong> Vue 3.0 中的编译器进行了改进，生成更优化的渲染函数代码，减少了生成的代码量，提高了编译性能。</li><li><strong>响应式系统优化：</strong> Vue 3.0 中的响应式系统进行了重写，使用 Proxy 代替 Object.defineProperty，使得响应式数据的追踪更加高效和精确，减少了响应式系统的开销。</li><li><strong>Tree-shaking 支持：</strong> Vue 3.0 支持 Tree-shaking，通过标记组件、指令和编译器的来源，使得打包时只包含使用到的代码，减少了打包体积，提高了性能。</li><li><strong>组件初始化优化：</strong> Vue 3.0 在组件初始化阶段进行了优化，通过标记组件内部的静态节点，减少了组件的初始化时间，提高了渲染性能。</li><li><strong>合并事件监听器：</strong> Vue 3.0 在合并事件监听器时进行了优化，避免了不必要的监听器合并，减少了事件处理的开销。</li><li><strong>Fragment 支持：</strong> Vue 3.0 支持使用 Fragment（片段）渲染多个根节点，减少了不必要的 DOM 包裹，提高了渲染性能。</li><li><strong>新的异步组件：</strong> Vue 3.0 中支持 Suspense（占位符）和异步组件，使得异步加载组件更加高效和灵活。</li></ol><p>总体而言，Vue 3.0 在性能方面进行了全面的优化和改进，从虚拟 DOM 到响应式系统，再到编译器和打包支持，都使得应用的性能得到显著提升。这些优化使得 Vue 3.0 成为一个更加高效、快速和现代的前端框架，带来更好的用户体验和开发体验。</p><h4 id="20-vue3有哪些新的组件"><a href="#20-vue3有哪些新的组件" class="headerlink" title="20.vue3有哪些新的组件?"></a>20.vue3有哪些新的组件?</h4><p>在 Vue 3 中，并没有新增特定的组件，因为 Vue 3 的主要改进集中在性能优化、Composition API、Tree-shaking 支持以及一些语法上的变化。Vue 3 主要聚焦于整体框架的改进和优化，而没有新增大量的特定组件。</p><p>然而，Vue 3 引入了一些新的特性和语法，让组件的编写更加灵活和方便。例如：</p><ol><li><strong>Fragment（片段）：</strong> Vue 3 中支持使用<code>&lt;template&gt;</code>标签作为片段，允许在不需要额外包裹 DOM 元素的情况下渲染多个根节点。</li><li><strong>Teleport（传送门）：</strong> Vue 3 中引入了 Teleport 特性，允许开发者在组件外部渲染内容，例如弹出窗口等。</li><li><strong>Suspense（占位符）：</strong> Vue 3 中支持使用<code>&lt;suspense&gt;</code>标签来处理异步组件的占位符和错误处理。</li><li><strong>v-model 改进：</strong> Vue 3 中的 v-model 支持自定义组件中的多个值绑定，通过<code>v-model:value</code>和<code>v-model:xxx</code>进行绑定。</li><li><strong>新的事件 API：</strong> Vue 3 中引入了新的事件 API，使用<code>emits</code>选项来替代 Vue 2 中的<code>$listeners</code>和<code>$emit</code>。</li><li><strong>全局 API 修改：</strong> Vue 3 中修改了全局 API 的名称，例如<code>Vue.directive</code>变为<code>app.directive</code>，<code>Vue.mixin</code>变为<code>app.mixin</code>。</li></ol><p>需要注意的是，虽然 Vue 3 没有新增大量特定的组件，但是它在整体性能和开发体验方面带来了许多改进，使得开发者能够更轻松地构建高性能、灵活和可维护的应用程序。同时，Vue 3 也提供了更多新特性和优化，让开发者能够更好地利用 Vue.js 的功能。</p><h4 id="21-Vue2-0-和Vue3-0有什么区别"><a href="#21-Vue2-0-和Vue3-0有什么区别" class="headerlink" title="21.Vue2.0 和Vue3.0有什么区别?"></a>21.Vue2.0 和Vue3.0有什么区别?</h4><p>Vue 3.0 是 Vue.js 框架的一个重大升级版本，带来了一系列的改进和新增功能。以下是 Vue 2.0 和 Vue 3.0 的主要区别：</p><ol><li><strong>性能优化：</strong> Vue 3.0 通过优化虚拟 DOM 和编译器，提高了渲染性能，包括更高效的响应式系统和更少的内存使用。</li><li><strong>Composition API：</strong> Vue 3.0 引入了 Composition API，允许开发者将组件的逻辑划分为多个功能性模块，更好地组织和重用代码，取代了 Vue 2.0 中的 Options API。</li><li><strong>Tree-shaking 支持：</strong> Vue 3.0 使得项目更容易进行 Tree-shaking，减少了项目的体积，提高了性能。</li><li><strong>Fragments：</strong> Vue 3.0 支持 Fragments（片段），可以在不需要额外包裹 DOM 元素的情况下渲染多个根节点。</li><li><strong>Teleport（传送门）：</strong> Vue 3.0 引入了 Teleport，允许开发者在组件外部渲染内容，例如弹出窗口等。</li><li><strong>全局 API 修改：</strong> Vue 3.0 修改了全局 API 的名称，例如<code>Vue.directive</code>变为<code>app.directive</code>，<code>Vue.mixin</code>变为<code>app.mixin</code>。</li><li><strong>v-model 的改进：</strong> Vue 3.0 中的 v-model 支持自定义组件中的多个值绑定，通过<code>v-model:value</code>和<code>v-model:xxx</code>进行绑定。</li><li><strong>Fragment 标签变更：</strong> Vue 3.0 中 Fragment 使用的标签变更为<code>&lt;template&gt;</code>，而不再是 Vue 2.0 中的特殊标签<code>&lt;fragment&gt;</code>。</li><li><strong>新增事件 API：</strong> Vue 3.0 引入了新的事件 API，使用<code>emits</code>选项来替代 Vue 2.0 中的<code>$listeners</code>和<code>$emit</code>。</li><li><strong>全局API Tree-shaking：</strong> Vue 3.0 支持全局API的按需导入，减少了打包体积。</li></ol><p>需要注意的是，虽然 Vue 3.0 带来了很多改进，但与 Vue 2.0 相比，它在某些方面可能不兼容，因此在升级到 Vue 3.0 时，需要仔细阅读官方的升级指南和文档，确保代码能够平稳迁移到新版本。</p><h4 id="22-Composition-Api与Options-Api有什么不同"><a href="#22-Composition-Api与Options-Api有什么不同" class="headerlink" title="22.Composition Api与Options Api有什么不同?"></a>22.Composition Api与Options Api有什么不同?</h4><p>Composition API 和 Options API 是 Vue.js 中两种不同的组件编写风格。</p><p>Options API 是 Vue.js 2.x 默认使用的组件编写方式，它通过一个选项对象来定义组件的数据、方法、生命周期钩子等。</p><p>示例（Options API）：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">htmlCopy code&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;button @click=&quot;increment&quot;&gt;Increment&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      message: &#x27;Hello&#x27;,</span><br><span class="line">      count: 0,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    increment() &#123;</span><br><span class="line">      this.count++;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>Composition API 是 Vue.js 3.x 引入的一种新的组件编写方式，它将组件的逻辑划分为多个功能性的模块，使得逻辑复用更加灵活和方便。</p><p>示例（Composition API）：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">htmlCopy code&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;button @click=&quot;increment&quot;&gt;Increment&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; reactive, ref &#125; from &#x27;vue&#x27;;</span><br><span class="line"></span><br><span class="line">const state = reactive(&#123;</span><br><span class="line">  message: &#x27;Hello&#x27;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">const count = ref(0);</span><br><span class="line"></span><br><span class="line">function increment() &#123;</span><br><span class="line">  count.value++;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>主要的不同点有：</p><ol><li>组织代码方式：<ul><li>Options API 将组件的选项（data、methods、computed等）放在一个对象中，组织代码较为传统，但随着组件逻辑的复杂化，可能导致代码臃肿。</li><li>Composition API 将组件的逻辑拆分为功能性的模块，使得代码更具可读性和维护性，特别适用于大型复杂组件。</li></ul></li><li>响应式数据：<ul><li>Options API 使用 <code>data</code> 函数来定义组件的响应式数据，需要通过 <code>this</code> 来访问。</li><li>Composition API 使用 <code>reactive</code> 或 <code>ref</code> 来定义响应式数据，使得响应式定义更加灵活和直观。</li></ul></li><li>生命周期钩子：<ul><li>Options API 使用生命周期钩子函数来处理组件的生命周期事件，代码较为分散。</li><li>Composition API 使用 <code>setup</code> 函数来处理组件的生命周期，使得逻辑集中在一个地方，更易于理解和管理。</li></ul></li><li>逻辑复用：<ul><li>Options API 使用 mixins 来实现逻辑复用，但可能导致命名冲突和难以追踪问题。</li><li>Composition API 通过函数模块化的方式实现逻辑复用，更加灵活和可控，没有命名冲突的问题。</li></ul></li></ol><p>总体而言，Composition API 提供了更灵活、组织更清晰的组件编写方式，特别适合大型复杂组件或希望更好地组织代码的场景。而 Options API 仍然是合法的，对于一些简单组件或者遗留项目，Options API 仍然可以继续使用。</p><h4 id="23-对Vue项目你做过哪些性能优化"><a href="#23-对Vue项目你做过哪些性能优化" class="headerlink" title="23.对Vue项目你做过哪些性能优化?"></a>23.对Vue项目你做过哪些性能优化?</h4><p>作为AI语言模型，我没有直接参与实际的Vue项目，无法进行具体的性能优化。但是，我可以提供一些常见的Vue项目性能优化策略，供你参考：</p><ol><li>使用Vue的异步组件：将页面按需加载，减少首次加载的资源量，提高页面加载速度。</li><li>使用路由懒加载：将路由页面拆分为多个异步加载的模块，只在需要时加载，避免一次性加载过多的页面代码。</li><li>合理使用v-if和v-show：v-if在条件满足时才会渲染元素，v-show通过CSS控制元素的显示与隐藏。根据场景选择合适的指令来优化渲染性能。</li><li>避免不必要的响应式数据：只将必要的数据声明为响应式，避免过多的数据监听和响应，提高性能。</li><li>使用Object.freeze()：对于静态数据对象，使用Object.freeze()冻结对象，避免响应式系统对其进行深度监听，提高性能。</li><li>合理使用v-for：避免在v-for中使用复杂的表达式，尽量避免频繁地操作DOM。</li><li>使用key属性：在v-for循环中使用key属性，帮助Vue跟踪每个节点的身份，优化列表渲染性能。</li><li>避免不必要的计算属性和监听器：只在必要时使用计算属性和监听器，避免无谓的计算开销。</li><li>使用Vue Devtools：使用Vue Devtools工具来分析组件的性能瓶颈和调试问题。</li><li>使用缓存：对于重复的计算或API请求，使用缓存来避免重复计算和请求，减少服务器负担。</li><li>图片优化：对图片进行压缩和懒加载，减少页面加载时间。</li><li>服务端渲染（SSR）：对于SEO要求较高的项目，可以考虑使用服务端渲染，提高首屏渲染速度。</li></ol><p>这些优化策略并不是全部，实际项目中可能需要根据具体情况进行更多的优化。性能优化是一个持续的过程，需要不断地进行监测和改进，以提供更好的用户体验。</p><h4 id="24-Vue组件通信的方式有哪些"><a href="#24-Vue组件通信的方式有哪些" class="headerlink" title="24.Vue组件通信的方式有哪些?"></a>24.Vue组件通信的方式有哪些?</h4><p>Vue组件通信有以下几种方式：</p><ol><li>父子组件通信：通过props和$emit实现父组件向子组件传递数据和子组件向父组件发送事件。</li><li>子组件访问父组件：通过this.$parent可以在子组件中访问父组件的数据和方法。</li><li>使用事件总线：创建一个Vue实例作为事件总线，在任意组件中使用$on和$emit来进行事件的监听和触发，实现非父子组件之间的通信。</li><li>使用Vuex：Vuex是Vue的状态管理库，用于在应用中管理共享状态。通过Vuex可以在任意组件中访问和修改全局状态，实现组件之间的数据共享和通信。</li><li>使用$refs：在父组件中通过ref属性给子组件添加引用，在父组件中可以直接通过this.$refs访问子组件的数据和方法。</li><li>使用provide和inject：在Vue 2.2.0及以上版本中，可以使用provide和inject来实现祖先组件向后代组件传递数据。</li><li>使用$attrs和$listeners：在Vue 2.4.0及以上版本中，可以通过$attrs和$listeners来实现父组件向子组件传递属性和事件监听器。</li></ol><p>不同的场景和需求可能会选择不同的通信方式。在简单的父子组件通信中，props和$emit是最常用的方式。对于大规模复杂应用，使用Vuex进行状态管理可能更为合适。使用事件总线可以在非父子组件之间进行灵活的通信，而使用provide和inject可以在祖先和后代组件之间传递数据。选择适当的通信方式可以使代码结构更加清晰和维护性更好。</p><h4 id="25-Vue常用的修饰符有哪些"><a href="#25-Vue常用的修饰符有哪些" class="headerlink" title="25.Vue常用的修饰符有哪些?"></a>25.Vue常用的修饰符有哪些?</h4><p>在Vue中，修饰符是在指令后面使用的特殊标记，用于修改指令的行为或添加额外的功能。以下是Vue常用的修饰符：</p><ol><li><p><code>.prevent</code>：阻止默认事件的触发，相当于调用<code>event.preventDefault()</code>。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;a v-on:click.prevent=&quot;doSomething&quot;&gt;Click Me&lt;/a&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>.stop</code>：阻止事件冒泡，相当于调用<code>event.stopPropagation()</code>。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div @click.stop=&quot;handleDivClick&quot;&gt;</span><br><span class="line">  &lt;button @click=&quot;handleButtonClick&quot;&gt;Button&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>.capture</code>：添加事件侦听器时使用事件捕获模式。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div @click.capture=&quot;handleDivClick&quot;&gt;</span><br><span class="line">  &lt;button @click=&quot;handleButtonClick&quot;&gt;Button&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>.self</code>：只当事件是从触发事件的元素自身触发时才触发回调。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div @click.self=&quot;handleDivClick&quot;&gt;</span><br><span class="line">  &lt;button @click=&quot;handleButtonClick&quot;&gt;Button&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>.once</code>：指令只会触发一次，然后自动解绑。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;button @click.once=&quot;handleButtonClick&quot;&gt;Click Me&lt;/button&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>.native</code>：监听组件根元素的原生事件。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;my-custom-component @click.native=&quot;handleClick&quot;&gt;&lt;/my-custom-component&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>.passive</code>：告诉浏览器该事件监听器不会调用<code>event.preventDefault()</code>。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div @scroll.passive=&quot;handleScroll&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure></li></ol><p>这些修饰符可以组合使用，例如：<code>@click.stop.prevent</code>用于阻止默认事件和阻止事件冒泡。使用修饰符可以在不改变事件处理函数逻辑的情况下，灵活地调整事件的行为，提高代码的可读性和维护性。</p><p>还有v-model中的lazy，trim，</p><p>绑定的 message 总是string类型，即使在我们设置 type 为 number 也是 string 类型</p><p>如果希望转换为数字类型，那么可以使用 .number 修饰符：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> v-model.<span class="property">number</span>=<span class="string">&quot;counter&quot;</span>&gt;</span><br></pre></td></tr></table></figure><p>在进行逻辑判断时，如果是一个string和数字类型对比，在可以转化的情况下会进行隐式转换</p><p>但typeof 查询的还是字符类型</p><h4 id="26-Vue中的-nextTick有什么作用-底层如何实现"><a href="#26-Vue中的-nextTick有什么作用-底层如何实现" class="headerlink" title="26.Vue中的$nextTick有什么作用?底层如何实现?"></a>26.Vue中的$nextTick有什么作用?底层如何实现?</h4><p><code>$nextTick</code>是Vue.js提供的一个方法，用于在DOM更新之后执行回调函数。它的作用是在当前代码执行周期结束后，等待DOM更新完成，然后执行回调函数，以确保在更新后对DOM进行操作或获取最新的DOM状态。</p><p><code>$nextTick</code>的主要作用有：</p><ol><li>更新后DOM操作：当需要在Vue实例数据发生变化后对DOM进行操作时，使用<code>$nextTick</code>可以确保DOM已经更新，避免出现获取旧的DOM状态的情况。</li><li>异步操作：Vue中的数据更新和DOM更新是异步进行的。使用<code>$nextTick</code>可以在下一次DOM更新之后执行回调，保证回调函数中的代码执行时已经是最新的DOM状态。</li></ol><p>底层实现原理：</p><p>在底层，<code>$nextTick</code>的实现利用了JavaScript中的微任务（Microtask）。微任务是一种高优先级的任务，它会在当前执行周期的末尾执行，而在下一个事件循环之前完成。这使得在微任务中执行的回调函数可以在DOM更新之后执行。</p><p>具体实现原理如下：</p><ol><li>当调用<code>$nextTick(callback)</code>时，Vue会将<code>callback</code>函数添加到一个队列中，标记为需要执行的回调。</li><li>在当前执行周期的末尾，当所有同步代码执行完毕后，JavaScript引擎会检查是否有微任务需要执行。</li><li>如果有微任务（即<code>$nextTick</code>的回调），则执行微任务队列中的所有回调函数。</li><li>等待微任务执行完毕后，下一个事件循环开始，此时DOM更新已经完成，回调函数中的代码可以获取到最新的DOM状态。</li></ol><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">htmlCopy code&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;button @click=&quot;updateMessage&quot;&gt;更新消息&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      message: &#x27;Hello&#x27;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    updateMessage() &#123;</span><br><span class="line">      // 更新数据</span><br><span class="line">      this.message = &#x27;Updated Message&#x27;;</span><br><span class="line"></span><br><span class="line">      // 在DOM更新后执行回调函数</span><br><span class="line">      this.$nextTick(() =&gt; &#123;</span><br><span class="line">        // 获取更新后的DOM状态</span><br><span class="line">        const updatedElement = document.querySelector(&#x27;p&#x27;);</span><br><span class="line">        console.log(updatedElement.textContent); // Output: &quot;Updated Message&quot;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>在上述示例中，当点击按钮更新数据后，我们使用<code>$nextTick</code>来确保在DOM更新之后执行回调函数。这样就可以获取到更新后的DOM状态，避免在数据更新后立即获取到旧的DOM状态。</p><h4 id="27-v-show和v-if有什么区别"><a href="#27-v-show和v-if有什么区别" class="headerlink" title="27.v-show和v-if有什么区别?"></a>27.v-show和v-if有什么区别?</h4><p><code>v-show</code> 和 <code>v-if</code> 都是 Vue.js 中用于条件渲染的指令，但它们有不同的工作原理和适用场景。</p><p><strong><code>v-show</code>：</strong></p><ul><li><code>v-show</code> 是一种 CSS 属性控制的条件渲染指令。</li><li>当表达式的值为真（truthy）时，元素会被设置为 <code>display: block</code>，从而显示在页面上。</li><li>当表达式的值为假（falsy）时，元素会被设置为 <code>display: none</code>，从而在页面上隐藏。</li><li>即使元素被隐藏，它依然在 DOM 中保留着，并且不会被销毁和重新创建，因此切换时的开销较小。</li><li>适用于频繁切换显示和隐藏的情况。</li></ul><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">htmlCopy code</span><br><span class="line">&lt;div v-show=&quot;isShown&quot;&gt;This is shown with v-show&lt;/div&gt;</span><br></pre></td></tr></table></figure><p><strong><code>v-if</code>：</strong></p><ul><li><code>v-if</code> 是一种条件渲染指令，根据表达式的值来动态地添加或移除元素。</li><li>当表达式的值为真（truthy）时，元素会被添加到 DOM 中，从而显示在页面上。</li><li>当表达式的值为假（falsy）时，元素会从 DOM 中移除，从而在页面上隐藏。</li><li>在切换时，会销毁和重新创建元素，因此切换时的开销较大。</li><li>适用于在渲染时不经常改变的内容。</li></ul><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">htmlCopy code</span><br><span class="line">&lt;div v-if=&quot;shouldBeRendered&quot;&gt;This is rendered with v-if&lt;/div&gt;</span><br></pre></td></tr></table></figure><p><strong>选择使用 <code>v-show</code> 还是 <code>v-if</code> 取决于实际需求：</strong></p><ul><li>如果元素的显示状态频繁变化（例如：通过按钮点击切换显示），而且元素内容不会改变，则可以使用 <code>v-show</code>，因为它只是简单地控制 <code>display</code> 属性，切换时的开销较小。</li><li>如果元素的显示状态较少改变（例如：根据用户权限显示不同内容），或者元素内容会频繁改变（例如：列表根据条件动态加载），则建议使用 <code>v-if</code>，因为它会根据表达式动态添加或移除元素，切换时的开销较大但可以减少不必要的渲染和内存占用。</li></ul><h4 id="28-有用过keep-alive吗-它有什么作用"><a href="#28-有用过keep-alive吗-它有什么作用" class="headerlink" title="28.有用过keep-alive吗? 它有什么作用?"></a>28.有用过keep-alive吗? 它有什么作用?</h4><p>是的，我有使用过<code>keep-alive</code>在Vue.js中。<code>keep-alive</code>是Vue.js提供的一个内置组件，用于缓存和重用组件，以提高性能和用户体验。它的主要作用是在组件切换时保持组件的状态，而不是在组件被切换到其他页面时销毁和重新创建。</p><p><code>keep-alive</code>组件的工作原理是将组件实例进行缓存，当组件被隐藏时（不在屏幕上显示），它会被保留在内存中。这样，当组件再次被激活或重新显示时，它可以从缓存中快速获取并显示，无需重新渲染或重新初始化。</p><p>使用<code>keep-alive</code>的主要优点有：</p><ol><li>提高性能：通过缓存组件，减少了重新渲染和重新初始化的次数，从而提高了渲染速度和整体性能。</li><li>保持状态：当组件被隐藏和重新激活时，它会保留之前的状态，包括数据和用户交互。这有助于在切换页面时无缝保持用户体验，而不会丢失用户输入或操作。</li><li>减少API调用：对于从API获取数据或进行复杂计算的组件，使用<code>keep-alive</code>可以避免在组件重新显示时进行重复的API调用和计算。</li></ol><p>使用示例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">htmlCopy code&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;keep-alive&gt;</span><br><span class="line">      &lt;!-- 被包裹在&lt;keep-alive&gt;中的组件会被缓存 --&gt;</span><br><span class="line">      &lt;your-component v-if=&quot;showComponent&quot; /&gt;</span><br><span class="line">    &lt;/keep-alive&gt;</span><br><span class="line"></span><br><span class="line">    &lt;button @click=&quot;toggleComponent&quot;&gt;切换组件&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import YourComponent from &#x27;./YourComponent.vue&#x27;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    YourComponent,</span><br><span class="line">  &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      showComponent: true,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    toggleComponent() &#123;</span><br><span class="line">      this.showComponent = !this.showComponent;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>在上述示例中，当<code>showComponent</code>为<code>false</code>时，<code>YourComponent</code>会被缓存并保持在内存中。当<code>showComponent</code>再次为<code>true</code>时，之前缓存的<code>YourComponent</code>实例会被重用，保留了之前的状态。这样，组件不需要重新创建和初始化，提供了更流畅的用户体验。</p><h4 id="29-如何实现一个虚拟DOM吗"><a href="#29-如何实现一个虚拟DOM吗" class="headerlink" title="29.如何实现一个虚拟DOM吗?"></a>29.如何实现一个虚拟DOM吗?</h4><p>实现一个完整的虚拟DOM系统是一个复杂的任务，但是可以通过简化的方式来演示其基本原理。下面是一个简化的虚拟DOM实现：</p><ol><li>定义虚拟DOM节点：<ul><li>首先，需要定义一个虚拟DOM节点的数据结构，可以使用JavaScript对象来表示，包含节点类型、属性、子节点等信息。</li></ul></li><li>创建虚拟DOM：<ul><li>当需要渲染一个新的视图时，首先根据数据生成虚拟DOM树，将整个视图表示为一个虚拟DOM树的结构。</li></ul></li><li>渲染虚拟DOM：<ul><li>将虚拟DOM树渲染成真实的DOM树。可以使用递归遍历虚拟DOM树，创建对应的真实DOM节点，并将其添加到DOM中。</li></ul></li><li>对比和更新：<ul><li>当数据发生变化时，会生成一个新的虚拟DOM树。这时，需要对比新旧两棵虚拟DOM树的差异，找出需要更新的节点。</li><li>对比可以使用深度优先遍历算法来进行，找出新增、删除和修改的节点。</li><li>然后根据差异来更新真实DOM，使其与最新的虚拟DOM树保持一致。</li></ul></li></ol><p>简化实现示例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy code// 定义虚拟DOM节点</span><br><span class="line">class VNode &#123;</span><br><span class="line">  constructor(tag, props, children) &#123;</span><br><span class="line">    this.tag = tag;</span><br><span class="line">    this.props = props;</span><br><span class="line">    this.children = children;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 创建虚拟DOM</span><br><span class="line">const vnode = new VNode(&#x27;div&#x27;, &#123; class: &#x27;container&#x27; &#125;, [</span><br><span class="line">  new VNode(&#x27;h1&#x27;, &#123; class: &#x27;title&#x27; &#125;, [&#x27;Hello, Virtual DOM&#x27;]),</span><br><span class="line">  new VNode(&#x27;p&#x27;, &#123; class: &#x27;content&#x27; &#125;, [&#x27;This is a simple Virtual DOM implementation.&#x27;]),</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">// 渲染虚拟DOM</span><br><span class="line">function render(vnode) &#123;</span><br><span class="line">  if (typeof vnode === &#x27;string&#x27;) &#123;</span><br><span class="line">    return document.createTextNode(vnode);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const element = document.createElement(vnode.tag);</span><br><span class="line">  for (const key in vnode.props) &#123;</span><br><span class="line">    element.setAttribute(key, vnode.props[key]);</span><br><span class="line">  &#125;</span><br><span class="line">  vnode.children.forEach((child) =&gt; &#123;</span><br><span class="line">    element.appendChild(render(child));</span><br><span class="line">  &#125;);</span><br><span class="line">  return element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 对比和更新</span><br><span class="line">function updateElement(parent, oldVnode, newVnode) &#123;</span><br><span class="line">  if (oldVnode === newVnode) &#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (oldVnode == null) &#123;</span><br><span class="line">    parent.appendChild(render(newVnode));</span><br><span class="line">  &#125; else if (newVnode == null) &#123;</span><br><span class="line">    parent.removeChild(parent.firstChild);</span><br><span class="line">  &#125; else if (oldVnode.tag === newVnode.tag) &#123;</span><br><span class="line">    for (const key in newVnode.props) &#123;</span><br><span class="line">      parent.setAttribute(key, newVnode.props[key]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const oldChildren = Array.from(oldVnode.children);</span><br><span class="line">    const newChildren = Array.from(newVnode.children);</span><br><span class="line">    const commonLength = Math.min(oldChildren.length, newChildren.length);</span><br><span class="line"></span><br><span class="line">    for (let i = 0; i &lt; commonLength; i++) &#123;</span><br><span class="line">      updateElement(parent.childNodes[i], oldChildren[i], newChildren[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (oldChildren.length &gt; newChildren.length) &#123;</span><br><span class="line">      for (let i = commonLength; i &lt; oldChildren.length; i++) &#123;</span><br><span class="line">        updateElement(parent.childNodes[i], oldChildren[i], null);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      for (let i = commonLength; i &lt; newChildren.length; i++) &#123;</span><br><span class="line">        updateElement(parent, null, newChildren[i]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    parent.replaceChild(render(newVnode), parent.firstChild);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 实现简单的数据更新</span><br><span class="line">const root = document.getElementById(&#x27;app&#x27;);</span><br><span class="line">updateElement(root, null, vnode);</span><br><span class="line"></span><br><span class="line">// 模拟数据更新</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">  const newVnode = new VNode(&#x27;div&#x27;, &#123; class: &#x27;container&#x27; &#125;, [</span><br><span class="line">    new VNode(&#x27;h1&#x27;, &#123; class: &#x27;title&#x27; &#125;, [&#x27;Hello, Updated Virtual DOM&#x27;]),</span><br><span class="line">    new VNode(&#x27;p&#x27;, &#123; class: &#x27;content&#x27; &#125;, [&#x27;This is an updated Virtual DOM implementation.&#x27;]),</span><br><span class="line">  ]);</span><br><span class="line">  updateElement(root, vnode, newVnode);</span><br><span class="line">&#125;, 3000);</span><br></pre></td></tr></table></figure><p>在上述简化示例中，我们实现了一个简单的虚拟DOM系统。虽然这个实现非常简单，并没有考虑性能优化等复杂情况，但它展示了虚拟DOM的基本原理：通过构建虚拟DOM树来描述视图，对比新旧虚拟DOM树的差异，然后更新真实DOM来保持视图的同步。在实际场景中，虚拟DOM系统会更加复杂和高效。</p><h4 id="30-为什么data属性是一个函数而不是一个对象，-具体原因是什么"><a href="#30-为什么data属性是一个函数而不是一个对象，-具体原因是什么" class="headerlink" title="30.为什么data属性是一个函数而不是一个对象， 具体原因是什么?"></a>30.为什么data属性是一个函数而不是一个对象， 具体原因是什么?</h4><p>在Vue中，组件的<code>data</code>属性可以是一个函数，也可以是一个对象。但推荐将<code>data</code>属性设置为一个函数，而不是一个对象。具体原因如下：</p><ol><li>数据隔离：<ul><li>将<code>data</code>设置为函数可以实现数据的隔离。每个组件实例都会有自己独立的数据副本，互不影响。这样可以避免多个组件实例之间共享同一个数据对象导致的数据混乱问题。</li></ul></li><li>数据响应式：<ul><li>当<code>data</code>属性是一个函数时，Vue在实例化组件时会将<code>data</code>函数执行，并将其返回的对象转换为响应式的。这样每个组件实例的数据都会成为响应式的，当数据发生变化时，视图会自动更新。</li></ul></li><li>优化性能：<ul><li>将<code>data</code>设置为函数还可以优化性能。如果<code>data</code>是一个对象，那么该对象会被所有组件实例共享，即所有实例都指向同一个引用。当一个组件实例修改了该对象的数据时，其他组件实例也会受到影响，可能导致意外的数据变化。</li><li>但当<code>data</code>是一个函数时，每个组件实例都会调用<code>data</code>函数获取独立的数据副本，相互之间不会影响，可以更好地保证组件的隔离性和数据独立性。</li></ul></li></ol><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">htmlCopy code&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123; count &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;button @click=&quot;increment&quot;&gt;Increment&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      count: 0,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    increment() &#123;</span><br><span class="line">      this.count++;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>在上述示例中，<code>data</code>属性被设置为一个函数，每个组件实例都会调用<code>data</code>函数获取独立的<code>count</code>属性，使得每个组件实例都拥有自己的<code>count</code>数据。这样在不同组件实例之间修改<code>count</code>属性时互不影响，实现了数据的隔离和响应式更新。</p><h4 id="31-Vue2的初始化过程你有过了解吗，做了哪些事情"><a href="#31-Vue2的初始化过程你有过了解吗，做了哪些事情" class="headerlink" title="31.Vue2的初始化过程你有过了解吗，做了哪些事情?"></a>31.Vue2的初始化过程你有过了解吗，做了哪些事情?</h4><p>是的，我了解Vue 2的初始化过程。Vue 2的初始化过程涉及几个关键步骤：</p><ol><li><strong>Vue实例的创建：</strong> 创建新的Vue实例时，它会经历一个初始化过程。在此过程中，Vue会初始化实例的数据、方法、计算属性和生命周期钩子。</li><li><strong>数据观察：</strong> Vue使用<code>Object.defineProperty</code>方法来设置数据观察，从而能够跟踪数据属性的变化并触发响应式更新。</li><li><strong>模板编译：</strong> Vue将提供给Vue实例的模板编译成一个渲染函数。渲染函数用于生成模板的虚拟DOM（VNode）表示。</li><li><strong>虚拟DOM的创建：</strong> Vue创建模板的虚拟DOM（VNode）表示。虚拟DOM是真实DOM结构的轻量级内存表示，用于在数据变化时高效比较和更新真实DOM。</li><li><strong>挂载：</strong> 在创建虚拟DOM后，Vue将实例挂载到真实DOM中的特定元素上。通常在创建Vue实例时使用<code>el</code>选项来指定挂载的元素。</li><li><strong>渲染和修补：</strong> Vue使用渲染函数触发初始渲染，并从虚拟DOM创建真实DOM树。然后，Vue跟踪数据属性和模板元素之间的依赖关系，每当数据发生变化时，通过“修补”（patching）的过程只更新受影响的DOM部分。</li><li><strong>数据响应性：</strong> 当访问或修改数据属性时，Vue的响应性系统会自动检测这些变化，并使用新值更新关联的模板元素。</li><li><strong>事件处理：</strong> Vue设置事件监听器来处理用户交互。它还处理指令和其他模板特性，如<code>v-if</code>、<code>v-for</code>等。</li><li><strong>生命周期钩子：</strong> Vue在实例的生命周期中特定时刻调用生命周期钩子，如<code>beforeCreate</code>、<code>created</code>、<code>beforeMount</code>、<code>mounted</code>等，允许开发者在组件生命周期的不同阶段插入自定义逻辑。</li><li><strong>观察者和依赖：</strong> Vue为每个响应式数据属性创建一个观察者。观察者负责在数据变化时更新关联的模板元素。依赖追踪机制使用依赖（Dep）对象来跟踪数据属性与观察者之间的依赖关系。</li></ol><p>Vue 2的初始化过程对于创建一个完全响应式和高性能的应用程序至关重要。它为Vue的响应性系统、渲染和事件处理机制奠定了基础，使其成为Vue设计和架构的关键方面之一。</p><h4 id="32-Vue3初始化的一个大概流程"><a href="#32-Vue3初始化的一个大概流程" class="headerlink" title="32.Vue3初始化的一个大概流程?"></a>32.Vue3初始化的一个大概流程?</h4><p>Vue 3的初始化流程相比Vue 2有所不同，它使用了Composition API，其中包含了<code>setup</code>函数来进行组件的初始化。下面是Vue 3初始化的大概流程：</p><ol><li>解析组件选项：<ul><li>Vue 3首先解析组件的选项，包括<code>template</code>、<code>data</code>、<code>methods</code>、<code>computed</code>等选项。</li></ul></li><li>创建组件实例：<ul><li>根据解析的组件选项，Vue 3创建组件的实例对象。在创建实例时，会先执行<code>setup</code>函数来初始化组件的数据和行为。</li></ul></li><li><code>setup</code>函数执行：<ul><li><code>setup</code>函数是Vue 3中新引入的一个函数，用于在组件创建阶段执行。在<code>setup</code>函数中，可以使用Vue 3的响应式API（如<code>reactive</code>、<code>ref</code>等）来处理组件的数据和行为。</li></ul></li><li>编译模板：<ul><li>在组件初始化阶段，Vue 3会将<code>template</code>模板编译成渲染函数（render function）。这个渲染函数会生成虚拟DOM（Virtual DOM）。</li></ul></li><li>创建和更新虚拟DOM：<ul><li>当组件初始化完成后，Vue 3会根据渲染函数生成虚拟DOM，并将虚拟DOM挂载到真实DOM上。</li></ul></li><li>响应式侦听：<ul><li>Vue 3会监听组件的响应式数据变化，当数据发生变化时，Vue 3会触发虚拟DOM的更新。</li></ul></li><li>视图更新：<ul><li>当虚拟DOM发生更新时，Vue 3会进行DOM Diff算法的比较，找出需要更新的部分，并进行DOM更新，保持视图和数据的同步。</li></ul></li><li>组件挂载：<ul><li>最后，Vue 3会将组件挂载到DOM上，完成组件的初始化和渲染。</li></ul></li></ol><p>总结： Vue 3的初始化流程主要包括解析组件选项、创建组件实例、执行<code>setup</code>函数、编译模板、创建和更新虚拟DOM、响应式侦听、视图更新和组件挂载等步骤。其中，<code>setup</code>函数是Vue 3中新的初始化阶段，用于处理组件的数据和行为。通过<code>setup</code>函数，Vue 3提供了更灵活和方便的方式来管理组件的状态和行为。</p><h4 id="33-vue3响应式api如何编写"><a href="#33-vue3响应式api如何编写" class="headerlink" title="33.vue3响应式api如何编写?"></a>33.vue3响应式api如何编写?</h4><p>在Vue 3中，响应式API与Vue 2有所不同。Vue 3使用了Composition API，其中包含了一些新的函数和模块来处理响应式数据。主要的响应式API函数是<code>reactive</code>、<code>ref</code>和<code>toRefs</code>。下面简要介绍它们的用法：</p><ol><li><p><code>reactive</code>函数：</p><ul><li><code>reactive</code>函数用于将一个普通对象转换为响应式对象。这个函数会递归地将对象的所有属性转换为响应式的，包括对象的嵌套属性。</li><li>示例：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy codeimport &#123; reactive &#125; from &#x27;vue&#x27;;</span><br><span class="line"></span><br><span class="line">const state = reactive(&#123;</span><br><span class="line">  count: 0,</span><br><span class="line">  message: &#x27;Hello&#x27;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><code>ref</code>函数：</p><ul><li><code>ref</code>函数用于将一个普通值转换为响应式的引用对象（Ref）。Ref对象包装了普通值，当Ref对象的值发生变化时，会触发视图更新。</li><li>示例：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy codeimport &#123; ref &#125; from &#x27;vue&#x27;;</span><br><span class="line"></span><br><span class="line">const count = ref(0);</span><br></pre></td></tr></table></figure></li><li><p><code>toRefs</code>函数：</p><ul><li><code>toRefs</code>函数用于将一个响应式对象转换为普通对象，并且每个属性都是一个单独的Ref对象。这个函数在将响应式对象的属性传递给子组件时非常有用。</li><li>示例：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy codeimport &#123; reactive, toRefs &#125; from &#x27;vue&#x27;;</span><br><span class="line"></span><br><span class="line">const state = reactive(&#123;</span><br><span class="line">  count: 0,</span><br><span class="line">  message: &#x27;Hello&#x27;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 将state对象转换为普通对象，其中每个属性都是一个Ref对象</span><br><span class="line">const stateRefs = toRefs(state);</span><br></pre></td></tr></table></figure></li></ol><p>这些响应式API函数可以与Vue 3的<code>setup</code>函数一起使用，<code>setup</code>函数是在组件创建阶段执行的一个函数，用于设置组件的数据和行为。在<code>setup</code>函数中，可以使用这些响应式API来处理组件的数据。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">htmlCopy code&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;p&gt;Count: &#123;&#123; count &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;button @click=&quot;increment&quot;&gt;Increment&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; ref &#125; from &#x27;vue&#x27;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    // 使用ref定义响应式数据</span><br><span class="line">    const count = ref(0);</span><br><span class="line"></span><br><span class="line">    // 定义组件的行为</span><br><span class="line">    function increment() &#123;</span><br><span class="line">      count.value++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 返回需要暴露给模板的数据和行为</span><br><span class="line">    return &#123;</span><br><span class="line">      count,</span><br><span class="line">      increment,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>在上述示例中，使用<code>ref</code>函数定义了<code>count</code>响应式数据和<code>increment</code>行为，并将它们返回给模板进行使用。</p><p>使用Vue 3的Composition API可以更灵活和方便地处理组件的数据和逻辑，推荐在Vue 3中使用Composition API来编写响应式数据。</p><h4 id="34-在Vue项目中你是如何做的SSR渲染"><a href="#34-在Vue项目中你是如何做的SSR渲染" class="headerlink" title="34.在Vue项目中你是如何做的SSR渲染?"></a>34.在Vue项目中你是如何做的SSR渲染?</h4><p>在Vue项目中实现SSR（服务器端渲染）需要进行以下步骤：</p><ol><li><strong>设置服务器环境：</strong> 首先，您需要设置服务器环境，可以选择使用Node.js或其他支持Vue SSR的服务器框架。</li><li><strong>创建服务端入口：</strong> 在服务器端，您需要创建一个服务端入口文件，用于处理来自客户端的请求。</li><li><strong>创建Vue实例：</strong> 在服务端入口文件中，您需要创建一个Vue实例，并将其设置为服务器渲染模式。</li><li><strong>获取数据：</strong> 在服务器渲染模式下，您需要在渲染之前获取组件所需的数据。可以使用Vuex或其他数据管理工具来获取数据并预取组件所需的状态。</li><li><strong>路由处理：</strong> 处理服务器端的路由匹配，根据请求的URL确定渲染哪个组件。</li><li><strong>渲染组件：</strong> 使用Vue的<code>renderToString</code>或<code>renderToNodeStream</code>方法将匹配的组件渲染为HTML字符串或流。</li><li><strong>将HTML返回给客户端：</strong> 将渲染好的HTML字符串或流返回给客户端，并在客户端上继续进行交互。</li><li><strong>客户端激活：</strong> 在客户端，您需要激活Vue实例，以便在前端继续处理交互和动态更新。</li></ol><p>以上步骤涉及到了很多细节和配置，因此在实际项目中，通常会使用现有的Vue SSR框架（如Nuxt.js）来简化和自动化SSR的过程。Nuxt.js是一个流行的Vue SSR框架，它提供了一系列配置和工具，使得SSR渲染更加方便和易于使用。</p><p>请注意，实施SSR需要考虑到很多因素，包括性能、服务器资源、SEO等。因此，在开始实施SSR之前，建议仔细研究和规划，确保选择适合您项目需求的SSR方案。</p><h4 id="35-在vue中怎么确定引入的方法或库需要加"><a href="#35-在vue中怎么确定引入的方法或库需要加" class="headerlink" title="35.在vue中怎么确定引入的方法或库需要加{}"></a>35.在vue中怎么确定引入的方法或库需要加{}</h4><p>在Vue中，如果要引入的方法或库是通过<code>export default</code>导出的，那么在导入时可以不需要使用大括号<code>&#123;&#125;</code>，直接通过<code>import</code>语句导入即可。这是因为<code>export default</code>只能导出一个默认值，所以在导入时直接获取该默认值即可。</p><p>例如，在使用Vue Router时，可以直接这样导入：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import VueRouter from &#x27;vue-router&#x27;;</span><br></pre></td></tr></table></figure><p>这里的<code>VueRouter</code>是通过<code>export default</code>导出的，默认导出了VueRouter的实例，因此可以直接导入使用。</p><p>然而，如果要引入的方法或库是通过命名导出（Named Export）的，那么在导入时需要使用大括号<code>&#123;&#125;</code>，并指定要导入的具体项。</p><p>例如，在使用Vuex时，可以这样导入：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; createStore &#125; from &#x27;vuex&#x27;;</span><br></pre></td></tr></table></figure><p>这里的<code>createStore</code>是通过命名导出的，所以需要使用大括号指定要导入的项。</p><p>总结：</p><ul><li>对于通过<code>export default</code>导出的方法或库，可以直接使用<code>import</code>导入，不需要使用大括号<code>&#123;&#125;</code>。</li><li>对于通过命名导出的方法或库，需要使用大括号<code>&#123;&#125;</code>指定要导入的具体项。</li></ul><p>在Vue项目中引入方法或库时，根据导出方式来使用正确的导入语法是很重要的，以确保代码的正确性和可读性。如果不确定是否需要使用大括号<code>&#123;&#125;</code>，可以查阅相关库或模块的文档，或者查看其源代码来了解导出方式。</p><h2 id="常用框架"><a href="#常用框架" class="headerlink" title="常用框架"></a>常用框架</h2><h3 id="Echarts"><a href="#Echarts" class="headerlink" title="Echarts"></a>Echarts</h3><h4 id="1-echarts-的基本用法"><a href="#1-echarts-的基本用法" class="headerlink" title="1.echarts 的基本用法?"></a>1.echarts 的基本用法?</h4><p>ECharts 是一个基于 JavaScript 的开源可视化库，用于绘制各种图表和图形，如折线图、柱状图、饼图等。以下是 ECharts 的基本用法：</p><ol><li>引入 ECharts 库：首先在 HTML 文件中引入 ECharts 库的 JavaScript 文件。</li><li>创建容器：在 HTML 文件中创建一个容器元素，用于展示图表。</li><li>初始化图表：在 JavaScript 中使用 <code>echarts.init()</code> 方法初始化一个图表实例，并传入容器元素。</li><li>配置图表：使用图表实例的 <code>setOption()</code> 方法配置图表的样式、数据和交互等。</li><li>渲染图表：最后调用图表实例的 <code>render()</code> 方法将图表渲染到页面上。</li></ol><p>以下是一个简单的示例代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">htmlCopy code&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;title&gt;ECharts 示例&lt;/title&gt;</span><br><span class="line">  &lt;!-- 引入 ECharts 库 --&gt;</span><br><span class="line">  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/echarts@5.1.2/dist/echarts.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;!-- 创建容器 --&gt;</span><br><span class="line">  &lt;div id=&quot;chart&quot; style=&quot;width: 600px; height: 400px;&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    // 初始化图表</span><br><span class="line">    var chart = echarts.init(document.getElementById(&#x27;chart&#x27;));</span><br><span class="line"></span><br><span class="line">    // 配置图表</span><br><span class="line">    var option = &#123;</span><br><span class="line">      title: &#123;</span><br><span class="line">        text: &#x27;折线图示例&#x27;</span><br><span class="line">      &#125;,</span><br><span class="line">      xAxis: &#123;</span><br><span class="line">        type: &#x27;category&#x27;,</span><br><span class="line">        data: [&#x27;周一&#x27;, &#x27;周二&#x27;, &#x27;周三&#x27;, &#x27;周四&#x27;, &#x27;周五&#x27;, &#x27;周六&#x27;, &#x27;周日&#x27;]</span><br><span class="line">      &#125;,</span><br><span class="line">      yAxis: &#123;</span><br><span class="line">        type: &#x27;value&#x27;</span><br><span class="line">      &#125;,</span><br><span class="line">      series: [&#123;</span><br><span class="line">        type: &#x27;line&#x27;,</span><br><span class="line">        data: [120, 200, 150, 80, 70, 110, 130]</span><br><span class="line">      &#125;]</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    // 渲染图表</span><br><span class="line">    chart.setOption(option);</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>通过以上步骤，就可以在页面上绘制一个简单的折线图。ECharts 提供了丰富的配置选项和交互功能，可以根据需求来创建各种复杂的图表和可视化效果。</p><h4 id="2-如何在vue中引入"><a href="#2-如何在vue中引入" class="headerlink" title="2.如何在vue中引入?"></a>2.如何在vue中引入?</h4><p>在 Vue 中引入 ECharts 有两种常用的方法：通过 <code>&lt;script&gt;</code> 标签直接引入和通过 npm 安装。</p><ol><li>通过 <code>&lt;script&gt;</code> 标签直接引入：</li></ol><p>在 HTML 文件中通过 <code>&lt;script&gt;</code> 标签引入 ECharts 的 JavaScript 文件，然后在 Vue 组件中使用全局变量 <code>echarts</code> 访问 ECharts 对象。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">htmlCopy code&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;title&gt;Vue ECharts 示例&lt;/title&gt;</span><br><span class="line">  &lt;!-- 引入 ECharts 库 --&gt;</span><br><span class="line">  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/echarts@5.1.2/dist/echarts.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    // Vue 实例</span><br><span class="line">    new Vue(&#123;</span><br><span class="line">      el: &#x27;#app&#x27;,</span><br><span class="line">      data: &#123;&#125;,</span><br><span class="line">      mounted() &#123;</span><br><span class="line">        // 在 mounted 钩子中创建图表</span><br><span class="line">        var chart = echarts.init(document.getElementById(&#x27;app&#x27;));</span><br><span class="line"></span><br><span class="line">        // 配置图表</span><br><span class="line">        var option = &#123;</span><br><span class="line">          // 配置项...</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        // 渲染图表</span><br><span class="line">        chart.setOption(option);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><ol><li>通过 npm 安装：</li></ol><p>在项目中使用 npm 安装 ECharts：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bashCopy code</span><br><span class="line">npm install echarts --save</span><br></pre></td></tr></table></figure><p>然后在 Vue 组件中使用 <code>import</code> 导入 ECharts：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vueCopy code&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import echarts from &#x27;echarts&#x27;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    // 在 mounted 钩子中创建图表</span><br><span class="line">    var chart = echarts.init(document.getElementById(&#x27;app&#x27;));</span><br><span class="line"></span><br><span class="line">    // 配置图表</span><br><span class="line">    var option = &#123;</span><br><span class="line">      // 配置项...</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    // 渲染图表</span><br><span class="line">    chart.setOption(option);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>通过这两种方法，你就可以在 Vue 中使用 ECharts 来绘制图表。</p><h4 id="3-如何绘制条形图"><a href="#3-如何绘制条形图" class="headerlink" title="3.如何绘制条形图?"></a>3.如何绘制条形图?</h4><p>要绘制条形图，你可以使用 ECharts 来实现。ECharts 是一个强大的图表库，支持多种图表类型，包括条形图。</p><p>以下是在 Vue 中使用 ECharts 绘制条形图的基本步骤：</p><ol><li>安装 ECharts：如果你还没有安装 ECharts，可以通过 npm 安装：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bashCopy code</span><br><span class="line">npm install echarts --save</span><br></pre></td></tr></table></figure><ol><li>导入 ECharts：在 Vue 组件中，使用 <code>import</code> 导入 ECharts：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vueCopy code&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;barChart&quot; style=&quot;width: 600px; height: 400px;&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import echarts from &#x27;echarts&#x27;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    // 在 mounted 钩子中创建图表</span><br><span class="line">    var chart = echarts.init(document.getElementById(&#x27;barChart&#x27;));</span><br><span class="line"></span><br><span class="line">    // 配置条形图数据</span><br><span class="line">    var option = &#123;</span><br><span class="line">      title: &#123;</span><br><span class="line">        text: &#x27;柱状图示例&#x27;</span><br><span class="line">      &#125;,</span><br><span class="line">      xAxis: &#123;</span><br><span class="line">        type: &#x27;category&#x27;,</span><br><span class="line">        data: [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;]</span><br><span class="line">      &#125;,</span><br><span class="line">      yAxis: &#123;</span><br><span class="line">        type: &#x27;value&#x27;</span><br><span class="line">      &#125;,</span><br><span class="line">      series: [&#123;</span><br><span class="line">        data: [10, 20, 15, 30, 25],</span><br><span class="line">        type: &#x27;bar&#x27;</span><br><span class="line">      &#125;]</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    // 渲染图表</span><br><span class="line">    chart.setOption(option);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>以上代码会在 Vue 组件中绘制一个简单的条形图，其中 x 轴代表类别，y 轴代表值。你可以根据实际数据和需求调整图表的配置。确保将图表的容器大小设置为适当的值，以便显示完整的图表。</p><h4 id="4-切换时卡顿如何解决"><a href="#4-切换时卡顿如何解决" class="headerlink" title="4.切换时卡顿如何解决?"></a>4.切换时卡顿如何解决?</h4><p>切换时卡顿通常是由于页面加载过多资源或执行复杂计算导致的。以下是一些常见的解决方法，可以帮助减少页面切换时的卡顿：</p><ol><li>优化代码：检查页面中是否有冗余或不必要的代码，尽量避免执行复杂的计算或操作，优化算法和逻辑。</li><li>图片压缩：对页面中的图片进行压缩，尽量使用适当大小的图片，并使用适当的图片格式，如 WebP。</li><li>懒加载：将页面中的图片、视频等资源设置为懒加载，在页面滚动到可见区域时再加载，减少初始加载时的负担。</li><li>分块加载：将页面分块加载，只加载当前页面所需的资源，而不是一次性加载全部资源。</li><li>异步加载：使用异步加载脚本，将不影响页面显示的脚本推迟加载，提高页面的响应速度。</li><li>使用缓存：合理使用浏览器缓存，对于不经常变化的资源，尽量设置缓存，减少重复加载。</li><li>使用虚拟列表：对于大量数据的列表展示，使用虚拟列表技术，只渲染可见区域的内容，减少页面渲染时间。</li><li>Web Worker：将一些计算密集型的任务放在 Web Worker 中执行，避免阻塞主线程。</li><li>减少重绘和回流：避免频繁的 DOM 操作，尽量一次性修改样式或内容，减少浏览器的重绘和回流。</li><li>使用 CSS3 动画：尽量使用 CSS3 动画代替 JavaScript 动画，利用 GPU 加速提高动画性能。</li></ol><p>以上方法可以根据具体情况选择使用，帮助优化页面性能，减少切换时的卡顿现象。</p><h4 id="5-echarts图表自适应div-resize问题"><a href="#5-echarts图表自适应div-resize问题" class="headerlink" title="5.echarts图表自适应div resize问题?"></a>5.echarts图表自适应div resize问题?</h4><p>在使用 ECharts 图表时，确保图表能够自适应 div 的 resize 是非常重要的，这样能够保证图表在不同尺寸的容器中正常显示。以下是解决 ECharts 图表自适应 div resize 问题的方法：</p><ol><li>使用 resize 事件：ECharts 提供了 resize 事件，在 div 尺寸发生变化时触发。你可以监听该事件，然后在事件回调函数中重新调用图表的 resize 方法，实现图表的自适应。</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy code// 监听resize事件</span><br><span class="line">window.addEventListener(&#x27;resize&#x27;, function () &#123;</span><br><span class="line">  // 调用图表的resize方法</span><br><span class="line">  myChart.resize();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol><li>debounce 函数优化：为了避免频繁调用 resize 方法，可以使用 debounce 函数进行优化。debounce 函数可以限制事件回调的频率，当 resize 事件触发时，只有在一定的延迟之后才会执行回调函数。</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy code// 引入lodash库</span><br><span class="line">import &#123; debounce &#125; from &#x27;lodash&#x27;;</span><br><span class="line"></span><br><span class="line">// 监听resize事件，并使用debounce进行优化</span><br><span class="line">window.addEventListener(&#x27;resize&#x27;, debounce(function () &#123;</span><br><span class="line">  // 调用图表的resize方法</span><br><span class="line">  myChart.resize();</span><br><span class="line">&#125;, 200)); // 延迟时间200毫秒</span><br></pre></td></tr></table></figure><ol><li>使用 CSS 控制 div 的大小：在 HTML 和 CSS 中，使用百分比或者 rem&#x2F;vw 单位来设置 div 的大小，这样 div 大小会根据父元素或者屏幕大小自动调整，从而实现图表的自适应。</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">htmlCopy code</span><br><span class="line">&lt;div id=&quot;chart&quot; style=&quot;width: 100%; height: 400px;&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><ol><li>使用 flex 布局：在父容器中使用 flex 布局，设置图表的宽度和高度为 100%。</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cssCopy code.parent-container &#123;</span><br><span class="line">  display: flex;</span><br><span class="line">  flex-direction: column;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#chart &#123;</span><br><span class="line">  flex: 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上方法中，第一种方法是最常用的，在图表初始化时监听 resize 事件，确保图表在 div 尺寸变化时能够自动调整大小。使用 debounce 函数优化可以避免频繁调用 resize 方法，提高性能。同时，合理使用 CSS 控制 div 大小和使用 flex 布局也可以有效实现图表的自适应。根据具体情况选择最合适的方法来解决图表自适应 div resize 问题。</p><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><h4 id="1-什么是Ajax-Ajax-都有哪些优点和缺点"><a href="#1-什么是Ajax-Ajax-都有哪些优点和缺点" class="headerlink" title="1.什么是Ajax, Ajax 都有哪些优点和缺点?"></a>1.什么是Ajax, Ajax 都有哪些优点和缺点?</h4><p>Ajax（Asynchronous JavaScript and XML）是一种用于在Web应用中进行异步数据交互的技术，它可以在不重新加载整个页面的情况下，通过JavaScript向服务器发送请求，并在获取到响应后更新页面的局部内容。</p><p>优点：</p><ol><li>异步请求：Ajax可以实现异步请求，不需要刷新整个页面，提升了用户体验和页面加载速度。</li><li>减少带宽：由于只更新局部内容，可以减少数据传输量，节省带宽。</li><li>提高页面响应速度：由于数据交互是异步进行的，页面可以更快地响应用户操作。</li><li>支持多种数据格式：除了XML，Ajax还支持JSON等多种数据格式，适应各种场景。</li><li>增强交互性：通过Ajax，可以实现动态加载数据，实现更丰富的交互效果。</li></ol><p>缺点：</p><ol><li>兼容性：早期的浏览器对Ajax支持不完善，需要处理跨浏览器兼容性问题。</li><li>安全性：由于Ajax可以在客户端发起请求，容易受到跨站请求伪造（CSRF）攻击，需要采取一定的安全措施。</li><li>SEO问题：搜索引擎爬虫不会执行JavaScript，如果页面内容主要由Ajax动态加载，可能会导致搜索引擎无法获取完整的页面内容，影响SEO。</li><li>可维护性：由于数据请求和处理逻辑可能分散在不同的地方，代码的可维护性较差。</li></ol><p>总结： Ajax是一种非常有用的技术，可以提升用户体验和页面加载速度，但在使用时需要注意兼容性、安全性和SEO等方面的问题，同时合理使用Ajax，避免滥用，以确保代码的可维护性和稳定性。</p><h4 id="2-请介绍一下XMLHTTPrequest对象及常用方法和属性"><a href="#2-请介绍一下XMLHTTPrequest对象及常用方法和属性" class="headerlink" title="2.请介绍一下XMLHTTPrequest对象及常用方法和属性"></a>2.请介绍一下XMLHTTPrequest对象及常用方法和属性</h4><p>XMLHttpRequest（XHR）对象是浏览器提供的用于在客户端发起HTTP请求的JavaScript API。它可以实现异步数据交互，用于获取数据、发送数据等操作，是实现AJAX的核心。</p><p>常用的XMLHttpRequest对象的方法和属性如下：</p><p>方法：</p><ol><li>open(method, url, async)：初始化一个请求，指定请求的方法（GET、POST等）、URL和是否异步。</li><li>send(data)：发送HTTP请求，可以传递参数和数据。</li><li>setRequestHeader(header, value)：设置HTTP请求头。</li><li>abort()：中止当前的HTTP请求。</li></ol><p>属性：</p><ol><li>onreadystatechange：表示处理请求的回调函数，当请求状态发生变化时被触发。</li><li>readyState：表示请求状态的属性，包含以下值：<ul><li>0：未初始化。XMLHttpRequest对象已创建，但未调用open()方法。</li><li>1：正在加载。open()方法已调用，但send()方法未调用。</li><li>2：加载完成。send()方法已调用，且已接收到全部响应数据。</li><li>3：交互。正在解析响应内容。</li><li>4：完成。响应内容已解析完成，可以在客户端使用。</li></ul></li><li>status：表示HTTP响应状态码，如200表示成功，404表示未找到资源等。</li><li>statusText：表示HTTP响应状态描述，如”OK”、”Not Found”等。</li><li>responseText：表示响应的文本内容。</li><li>responseXML：表示响应的XML内容，如果响应是XML格式的。</li><li>timeout：设置请求的超时时间，单位为毫秒。</li><li>withCredentials：指定是否跨域请求时发送凭据信息（如cookie）。</li></ol><p>这些方法和属性可以帮助我们在客户端通过JavaScript与服务器进行数据交互，并实现动态更新页面内容，提升用户体验。</p><h4 id="3-Ajax-的实现流程是怎样的"><a href="#3-Ajax-的实现流程是怎样的" class="headerlink" title="3.Ajax 的实现流程是怎样的?"></a>3.Ajax 的实现流程是怎样的?</h4><p>Ajax（Asynchronous JavaScript and XML）是一种利用JavaScript和XML进行异步数据交互的技术。它允许在不重新加载整个页面的情况下，通过异步方式向服务器发送请求并获取数据，然后用JavaScript来更新页面的部分内容。</p><p>Ajax的实现流程如下：</p><ol><li>创建XMLHttpRequest对象：首先，通过JavaScript创建一个XMLHttpRequest对象，该对象允许发送HTTP请求和接收服务器响应。</li><li>设置回调函数：然后，我们需要设置一个回调函数，用于处理服务器返回的响应数据。当服务器响应数据返回后，会触发该回调函数，从而处理响应数据并更新页面。</li><li>发送请求：使用XMLHttpRequest对象的open()方法和send()方法，向服务器发送HTTP请求。open()方法用于设置请求的方法、URL和是否采用异步方式，send()方法用于发送请求。</li><li>接收响应：当服务器返回响应数据时，XMLHttpRequest对象会触发onreadystatechange事件，并调用设置的回调函数来处理响应数据。</li><li>更新页面：在回调函数中，我们可以获取服务器返回的数据，然后利用JavaScript来更新页面的内容，例如将数据插入到指定的HTML元素中，或者更新页面的样式等。</li><li>错误处理：在发送请求时，还需要注意处理可能出现的错误情况，例如网络连接问题、服务器错误等，可以设置onerror事件来处理这些错误。</li></ol><p>总结：Ajax的实现流程主要包括创建XMLHttpRequest对象、设置回调函数、发送请求、接收响应和更新页面等步骤，通过这些步骤，可以实现异步数据交互，提升用户体验和页面性能。</p><h4 id="4-Ajax-接收到的数据类型有哪些，数据如何处理"><a href="#4-Ajax-接收到的数据类型有哪些，数据如何处理" class="headerlink" title="4.Ajax 接收到的数据类型有哪些，数据如何处理?"></a>4.Ajax 接收到的数据类型有哪些，数据如何处理?</h4><p>Ajax 接收到的数据类型可以有多种，常见的数据类型包括：</p><ol><li>JSON：服务器返回的数据为 JSON 格式，在前端通过 <code>JSON.parse()</code> 方法将 JSON 字符串转换为 JavaScript 对象进行处理。</li><li>XML：服务器返回的数据为 XML 格式，可以通过 DOM 或者使用 XML 解析库进行处理。</li><li>HTML：服务器返回的数据为 HTML 格式，可以直接插入到页面中显示。</li><li>Text：服务器返回的数据为普通文本，可以直接展示或进一步处理。</li></ol><p>对于接收到的数据，通常需要根据 <code>dataType</code> 参数指定的数据类型进行处理。例如，如果指定 <code>dataType: &quot;json&quot;</code>，则应该通过 <code>JSON.parse()</code> 方法将接收到的 JSON 字符串转换为 JavaScript 对象；如果指定 <code>dataType: &quot;xml&quot;</code>，则可以使用 DOM 或者 XML 解析库处理接收到的 XML 数据。</p><p>在处理数据时，可以根据具体的业务需求进行逻辑处理、渲染页面或其他操作。一般情况下，成功的回调函数 (<code>success</code>) 中处理服务器返回的数据，并更新页面内容；失败的回调函数 (<code>error</code>) 中处理请求失败的情况，并给用户适当的提示。</p><p>总的来说，根据接收到的数据类型，我们可以使用不同的方式将数据解析和处理，以满足业务需求。</p><h4 id="5-封装好的Ajax里的常见参数及其代表的含义"><a href="#5-封装好的Ajax里的常见参数及其代表的含义" class="headerlink" title="5.封装好的Ajax里的常见参数及其代表的含义"></a>5.封装好的Ajax里的常见参数及其代表的含义</h4><p>在封装好的 Ajax 函数中，常见的参数及其代表的含义如下：</p><ol><li><code>url</code>：请求的 URL 地址，指定要发送 Ajax 请求的目标地址。</li><li><code>method</code>：请求方法，指定请求类型，通常为 GET 或 POST。</li><li><code>data</code>：请求参数，用于传递需要提交的数据，可以是对象、字符串或 FormData。</li><li><code>headers</code>：请求头，用于设置自定义的请求头信息，如 Content-Type 等。</li><li><code>dataType</code>：返回数据类型，指定服务器返回的数据格式，可以是 “json”、”text”、”xml” 等。</li><li><code>timeout</code>：超时时间，设置请求超时的时间限制。</li><li><code>async</code>：是否异步，默认为 true，表示异步请求，false 表示同步请求。</li><li><code>beforeSend</code>：发送请求前的回调函数，可以在该函数中添加一些处理逻辑，如显示加载动画。</li><li><code>success</code>：请求成功时的回调函数，可以处理服务器返回的数据。</li><li><code>error</code>：请求失败时的回调函数，可以处理请求失败的情况。</li><li><code>complete</code>：请求完成后的回调函数，无论请求成功或失败，都会执行该回调。</li></ol><p>这些参数可以根据实际需求进行配置，用于控制 Ajax 请求的行为和处理请求返回的数据。封装好的 Ajax 函数可以简化 Ajax 请求的操作，提高代码复用性和可维护性。</p><h4 id="6-Ajax注意事项及适用和不适用场景"><a href="#6-Ajax注意事项及适用和不适用场景" class="headerlink" title="6.Ajax注意事项及适用和不适用场景"></a>6.Ajax注意事项及适用和不适用场景</h4><p>Ajax 是一种用于创建异步请求的技术，它可以在不刷新整个页面的情况下与服务器进行通信，从而实现局部更新页面的效果。在使用 Ajax 时，需要注意以下几点：</p><p>注意事项：</p><ol><li>跨域问题：由于同源策略的限制，Ajax 请求不能跨域进行。需要使用 JSONP、CORS、代理等方式解决跨域问题。</li><li>安全性：在使用 Ajax 时，应当注意防止 XSS 攻击和 CSRF 攻击，确保传输的数据安全。</li><li>异步回调：由于 Ajax 是异步的，所以要注意处理异步回调，确保在请求成功后正确处理返回的数据。</li><li>错误处理：需要正确处理请求失败的情况，避免用户在无网络或请求错误时出现问题。</li></ol><p>适用场景：</p><ol><li>局部刷新：适用于局部内容的更新，可以提高用户体验，减少页面刷新。</li><li>表单提交：通过 Ajax 可以异步提交表单，不刷新整个页面，实现表单验证和提交。</li><li>动态加载数据：通过 Ajax 可以异步加载数据，实现动态更新内容。</li></ol><p>不适用场景：</p><ol><li>对 SEO 重要的页面：由于搜索引擎爬虫不会执行 JavaScript，使用 Ajax 加载内容的页面可能对 SEO 不友好。</li><li>大量数据处理：当需要处理大量数据时，使用 Ajax 可能会导致页面响应较慢，影响用户体验。</li></ol><p>总体来说，Ajax 是前端开发中非常常用的技术，可以优化用户体验和页面性能，但在使用时需要注意跨域、安全性和异步处理等问题，并根据具体场景选择合适的方式使用。</p><h4 id="7-HTTP状态码以及代表的意义"><a href="#7-HTTP状态码以及代表的意义" class="headerlink" title="7.HTTP状态码以及代表的意义"></a>7.HTTP状态码以及代表的意义</h4><p>HTTP状态码是服务器在响应请求时返回的三位数字代码，用于表示服务器对请求的处理结果。状态码分为五类，每一类代表不同的意义：</p><p>1xx（信息性状态码）：表示请求已接收，继续处理。</p><ul><li>100 Continue：服务器已收到请求的头部，客户端应继续发送请求的主体部分。</li><li>101 Switching Protocols：服务器已经理解并接受了客户端的请求，正在切换协议。</li></ul><p>2xx（成功状态码）：表示请求已成功处理。</p><ul><li>200 OK：请求成功，服务器返回所请求的数据。</li><li>201 Created：请求成功，服务器新建了资源。</li><li>204 No Content：请求成功，但响应报文中不含实体的主体部分。</li></ul><p>3xx（重定向状态码）：表示需要进行附加操作以完成请求。</p><ul><li>301 Moved Permanently：请求的资源已永久移动到新的URL。</li><li>302 Found：请求的资源临时从不同的URL响应请求。</li><li>304 Not Modified：客户端发送附带条件的请求，且未满足条件的情况下，服务器允许返回该状态码，表示资源未修改。</li></ul><p>4xx（客户端错误状态码）：表示客户端错误，请求包含语法错误或无法完成请求。</p><ul><li>400 Bad Request：请求报文存在语法错误。</li><li>401 Unauthorized：请求需要用户身份验证。</li><li>403 Forbidden：服务器拒绝执行请求。</li><li>404 Not Found：请求的资源不存在。</li></ul><p>5xx（服务器错误状态码）：表示服务器端错误，服务器无法完成合法请求。</p><ul><li>500 Internal Server Error：服务器在执行请求时发生错误。</li><li>502 Bad Gateway：服务器作为网关或代理，从上游服务器收到无效的响应。</li><li>503 Service Unavailable：服务器当前无法处理请求，一段时间后可能恢复正常。</li></ul><p>通过状态码，客户端能够了解服务器处理请求的结果，从而进行相应的处理和错误处理。</p><h4 id="8-301-302-303状态码的区别"><a href="#8-301-302-303状态码的区别" class="headerlink" title="8.301 302 303状态码的区别?"></a>8.301 302 303状态码的区别?</h4><p>301、302 和 303 状态码都是用于HTTP重定向的，它们之间的区别在于重定向的方式和语义含义。</p><ol><li>301 Moved Permanently：表示请求的资源已经被永久移动到了新的URL，并且以后的所有请求都应该使用新的URL。这意味着搜索引擎会将原始URL的权重转移到新的URL，同时浏览器会自动缓存新的URL，下次请求时直接跳转到新的URL，不再请求原始URL。</li><li>302 Found：表示请求的资源临时被移动到了新的URL。这个状态码是临时性的，浏览器和搜索引擎会继续使用原始URL，不会缓存新的URL。换句话说，搜索引擎不会将原始URL的权重转移到新的URL。</li><li>303 See Other：表示请求的资源存在另一个URL，客户端应该使用GET方法去请求这个新的URL。这个状态码通常用于POST请求之后的重定向，让客户端使用GET请求获取重定向的资源。</li></ol><p>总结：</p><ul><li>301 是永久重定向，浏览器和搜索引擎都会缓存新的URL；</li><li>302 是临时重定向，浏览器和搜索引擎不会缓存新的URL；</li><li>303 是将POST请求转为GET请求的重定向。</li></ul><h4 id="9-什么是同源策略"><a href="#9-什么是同源策略" class="headerlink" title="9.什么是同源策略"></a>9.什么是同源策略</h4><p>同源策略（Same-Origin Policy）是浏览器的一种安全策略，用于限制一个网页中的脚本只能与来自相同协议、域名和端口的资源进行交互。换句话说，同源策略要求网页中的脚本只能与同一站点下的资源进行通信，而不能与其他站点的资源进行通信。</p><p>具体来说，同源策略限制了以下几种行为：</p><ol><li>Cookie、LocalStorage 和 IndexDB 等存储性数据：这些数据在浏览器中是以域名为单位进行存储的，不同域名之间的数据不能相互访问。</li><li>DOM：JavaScript脚本可以获取和修改当前页面的DOM，但不能获取和修改其他域名下的DOM。</li><li>Ajax 请求：XMLHttpRequest 和 Fetch 等网络请求在发送请求时受到同源策略的限制，只能向同一域名下的接口发送请求。</li></ol><p>同源策略的存在是为了保护用户的隐私和安全，防止恶意网站通过脚本获取用户的敏感信息或执行恶意操作。然而，有时候跨域是必要的，比如前后端分离的开发中需要与不同域名的接口进行交互。为了解决这个问题，可以使用CORS（跨域资源共享）、JSONP、代理等方式来实现跨域通信，前面我已经提到过了。</p><h4 id="10-为什么会有跨域的问题出现，如何解决跨域问题"><a href="#10-为什么会有跨域的问题出现，如何解决跨域问题" class="headerlink" title="10.为什么会有跨域的问题出现，如何解决跨域问题"></a>10.为什么会有跨域的问题出现，如何解决跨域问题</h4><p>跨域问题是由于浏览器的同源策略(Same-Origin Policy)引起的。同源策略要求网页只能向与其本身相同协议、域名和端口的服务器发送请求，而不能向其他域名发送请求。如果跨域请求不受限制，那么网页就可以通过脚本获取其他网站的数据，这样就会带来安全风险。</p><p>跨域问题可以通过以下几种方式进行解决：</p><ol><li>JSONP：通过动态添加<code>&lt;script&gt;</code>标签，以JSONP的形式进行跨域请求。JSONP利用了<code>&lt;script&gt;</code>标签没有同源限制的特性，服务器返回一段JavaScript代码，客户端通过执行该代码来获取数据。</li><li>CORS（跨域资源共享）：CORS是一种机制，通过在服务器设置响应头中的<code>Access-Control-Allow-Origin</code>字段来允许指定域名的请求。当浏览器发现请求的响应头中包含了合法的<code>Access-Control-Allow-Origin</code>字段时，就允许跨域请求。</li><li>代理：通过在同源服务器上设置代理，将跨域请求转发到目标服务器。前端请求同源服务器的接口，同源服务器再去请求目标服务器的数据，然后将数据返回给前端。</li><li>postMessage：使用HTML5中的<code>postMessage</code>方法，可以在不同窗口（包括不同域名的窗口）之间进行跨文档通信。</li><li>WebSocket：WebSocket是一种基于TCP的协议，它不受同源策略的限制，可以实现跨域通信。</li><li>Nginx反向代理：通过Nginx服务器作为代理服务器，将跨域请求转发到目标服务器，并将响应返回给客户端。</li></ol><p>需要根据具体的业务需求和安全性考虑选择合适的解决方案。常见的解决跨域问题的方式是使用CORS和JSONP。</p><h4 id="11-Get-和Post的区别以及使用场景"><a href="#11-Get-和Post的区别以及使用场景" class="headerlink" title="11.Get 和Post的区别以及使用场景"></a>11.Get 和Post的区别以及使用场景</h4><p>GET和POST是HTTP协议中的两种常用请求方法，它们有以下区别和适用场景：</p><ol><li>参数传递方式：<ul><li>GET：通过URL的查询字符串传递参数，参数会显示在URL中，形式为<code>key=value</code>，多个参数之间用<code>&amp;</code>连接。例如：<code>https://example.com/?username=John&amp;age=25</code></li><li>POST：通过请求体传递参数，参数不会显示在URL中，而是以键值对的形式在请求体中传递。POST请求适用于传递大量数据或敏感信息，更安全。</li></ul></li><li>参数长度限制：<ul><li>GET：由于参数在URL中传递，URL的长度是有限制的，通常不能超过2KB左右，因此GET请求适合传递较少的参数。</li><li>POST：由于参数在请求体中传递，没有长度限制，适合传递大量数据。</li></ul></li><li>安全性：<ul><li>GET：由于参数显示在URL中，可能会被缓存、浏览器历史记录等泄露信息，因此不适合传递敏感信息。</li><li>POST：由于参数在请求体中传递，相对于GET请求更加安全，适合传递敏感信息。</li></ul></li><li>缓存：<ul><li>GET：GET请求可以被缓存，多次相同的GET请求会返回相同的结果。</li><li>POST：POST请求不会被缓存，每次请求都是实时的。</li></ul></li><li>使用场景：<ul><li>GET：适合获取数据，获取资源，不涉及状态的改变。例如获取文章列表、搜索内容等。</li><li>POST：适合提交表单数据，进行资源的创建、更新和删除，涉及状态的改变。例如提交用户注册信息、上传文件等。</li></ul></li></ol><p>总结：GET和POST是HTTP协议中常用的请求方法，GET适合获取数据，不涉及状态改变，参数显示在URL中；POST适合提交数据，进行资源的创建、更新和删除，参数在请求体中传递，更加安全。根据具体的场景需求选择合适的请求方法。</p><h4 id="12-解释jsonp的原理"><a href="#12-解释jsonp的原理" class="headerlink" title="12.解释jsonp的原理"></a>12.解释jsonp的原理</h4><p>JSONP（JSON with Padding）是一种跨域数据请求的方法，它利用了script标签不受同源策略限制的特性来实现跨域数据传输。</p><p>JSONP的原理如下：</p><ol><li>前端页面通过创建一个script标签，src属性指向目标服务器的API接口，并传递一个回调函数名作为查询参数。</li><li>目标服务器接收到请求后，将需要传递的数据包装成一个函数调用，并将数据作为参数传递给这个函数。</li><li>目标服务器返回的数据被包裹在回调函数中，返回给前端页面。</li><li>前端页面接收到数据后，由于script标签的特性，浏览器会立即执行返回的脚本，从而调用回调函数，并传入目标数据。</li></ol><p>通过这种方式，JSONP实现了跨域数据传输，解决了浏览器的同源策略限制。不过需要注意的是，JSONP只支持GET请求，且只能接收到目标服务器返回的数据，并不能像AJAX那样实现完整的请求和响应过程。</p><p>尽管JSONP能够实现跨域数据传输，但由于其存在一些安全隐患（容易被注入恶意代码），现在通常推荐使用CORS（跨域资源共享）来处理跨域请求。CORS是一种服务器端设置，通过在响应头中添加一些特定的字段，来允许前端页面从不同的源访问资源。</p><h4 id="13-HTTP与HTTPS的区别"><a href="#13-HTTP与HTTPS的区别" class="headerlink" title="13.HTTP与HTTPS的区别"></a>13.HTTP与HTTPS的区别</h4><p>HTTP（Hypertext Transfer Protocol）和HTTPS（Hypertext Transfer Protocol Secure）都是用于在客户端和服务器之间传输数据的协议，它们之间的主要区别在于安全性。</p><ol><li>安全性：<ul><li>HTTP是明文传输数据的协议，数据在传输过程中是不加密的，因此容易被窃听和篡改，存在安全风险。</li><li>HTTPS使用SSL&#x2F;TLS协议对数据进行加密传输，使得数据在传输过程中不易被窃听和篡改，提供了更高的安全性。</li></ul></li><li>端口号：<ul><li>HTTP默认使用端口80进行通信。</li><li>HTTPS默认使用端口443进行通信。</li></ul></li><li>证书：<ul><li>在使用HTTPS时，服务器需要获得一个SSL证书，该证书由可信的第三方机构（如CA机构）签发，用于验证服务器身份的真实性和合法性。</li><li>HTTP不需要证书，因为数据是明文传输，无法验证服务器的身份。</li></ul></li><li>性能：<ul><li>由于HTTPS需要进行加密解密操作，会导致比HTTP更多的计算和网络开销，因此HTTPS相对于HTTP来说在性能上稍微有些差异。但是随着硬件和网络的进步，这个差异已经越来越小。</li></ul></li></ol><p>总结：HTTP是明文传输数据的协议，安全性较差；而HTTPS通过SSL&#x2F;TLS协议对数据进行加密传输，提供更高的安全性。因此，对于涉及用户隐私或敏感数据的网站，建议使用HTTPS来保障数据的安全传输。</p><h4 id="14-简述web前端Cookie机制，并结合该机制说明会话保持原理"><a href="#14-简述web前端Cookie机制，并结合该机制说明会话保持原理" class="headerlink" title="14.简述web前端Cookie机制，并结合该机制说明会话保持原理"></a>14.简述web前端Cookie机制，并结合该机制说明会话保持原理</h4><p>Web前端的Cookie机制是一种在浏览器端存储少量数据的方法，它通过在客户端保存键值对，来实现会话状态的保持和数据的持久化。</p><p>当服务器响应浏览器的请求时，可以通过在响应头中设置Set-Cookie字段来向浏览器写入Cookie。浏览器接收到响应后，将Cookie保存在本地，下次请求同一域名的网页时，会将相应的Cookie信息自动包含在请求头中发送给服务器。</p><p>Cookie通常用于以下几个方面：</p><ol><li>会话保持：当用户登录后，服务器可以在响应中设置一个包含用户身份标识的Cookie，浏览器保存这个Cookie，之后的每次请求都会携带该Cookie，从而让服务器知道用户的身份。</li><li>跟踪用户行为：通过在Cookie中记录用户的一些操作或偏好设置，可以跟踪用户的行为，从而为用户提供个性化的服务或广告。</li><li>记住登录状态：在用户勾选“记住我”选项后，服务器可以设置一个长期有效的Cookie，使用户下次访问时自动登录。</li><li>存储临时数据：将一些临时数据保存在Cookie中，可以在不同页面间共享数据。</li></ol><p>需要注意的是，由于Cookie保存在客户端，所以存在一定的安全隐患，例如可能会被篡改或盗用。为了提高安全性，通常应将Cookie设置为HttpOnly，使其只能通过HTTP协议传递，无法通过JavaScript访问，从而防止XSS攻击。另外，为了避免敏感信息泄露，Cookie应该尽量设置为Secure，只在通过HTTPS协议传输时才发送。</p><p>总结：Cookie机制是通过在浏览器保存键值对来实现会话保持和数据持久化的方法。服务器通过在响应头中设置Set-Cookie字段，将Cookie写入浏览器，浏览器自动在每次请求中携带Cookie，从而实现会话状态的保持。</p><h4 id="15-你知道的HTTP请求方式有几种"><a href="#15-你知道的HTTP请求方式有几种" class="headerlink" title="15.你知道的HTTP请求方式有几种"></a>15.你知道的HTTP请求方式有几种</h4><p>HTTP协议定义了多种请求方法（也称为HTTP动词或HTTP谓词），用于指定对资源的操作类型。常见的HTTP请求方式有以下几种：</p><ol><li>GET：用于获取资源，向服务器请求数据。GET请求是幂等的，即对同一个URL的多次GET请求应该返回相同的结果。</li><li>POST：用于提交数据，向服务器提交数据以进行处理。POST请求不是幂等的，即对同一个URL的多次POST请求可能会产生不同的结果。</li><li>PUT：用于更新资源，向服务器上传新的数据取代指定的资源。</li><li>DELETE：用于删除资源，向服务器删除指定的资源。</li><li>HEAD：类似于GET请求，但只返回响应头部，不返回实际内容。</li><li>OPTIONS：用于获取支持的HTTP请求方法和服务器支持的功能。</li><li>PATCH：用于对资源进行部分更新。</li></ol><p>除了以上常见的请求方法，HTTP&#x2F;1.1还引入了一些扩展的方法，例如：CONNECT、TRACE、PROPFIND、PROPPATCH等。</p><p>不同的请求方法适用于不同的场景和操作类型。在实际应用中，根据业务需求选择合适的请求方法是很重要的。</p><h4 id="16-谈谈你理解的RESTFUL规范"><a href="#16-谈谈你理解的RESTFUL规范" class="headerlink" title="16.谈谈你理解的RESTFUL规范"></a>16.谈谈你理解的RESTFUL规范</h4><h4 id="17-解释一下三次握手是什么，具体流程。变为二次握手会发生什么问题"><a href="#17-解释一下三次握手是什么，具体流程。变为二次握手会发生什么问题" class="headerlink" title="17.解释一下三次握手是什么，具体流程。变为二次握手会发生什么问题?"></a>17.解释一下三次握手是什么，具体流程。变为二次握手会发生什么问题?</h4><p>三次握手是TCP&#x2F;IP协议中建立TCP连接的过程，用于确保客户端和服务器之间的连接是可靠的。具体流程如下：</p><ol><li>客户端向服务器发送连接请求（SYN包），客户端进入SYN_SEND状态。</li><li>服务器收到连接请求后，回复客户端一个确认信息（SYN+ACK包），服务器进入SYN_RECV状态。</li><li>客户端收到服务器的确认信息后，再向服务器发送一个确认信息（ACK包），客户端进入ESTABLISHED状态，表示连接建立成功。</li><li>服务器收到客户端的确认信息后，也进入ESTABLISHED状态，表示连接建立成功。</li></ol><p>这个过程中，第一次握手用于客户端请求连接，第二次握手用于服务器确认请求，并回复确认信息，第三次握手用于客户端确认服务器的确认信息。</p><p>如果变为二次握手，即只进行一次连接请求和服务器的确认，会产生以下问题：</p><ol><li>可能会导致服务器与客户端之间的连接不稳定，无法确认连接是否真正建立成功。</li><li>可能会出现半连接状态，即服务器在收到客户端的连接请求后，虽然向客户端回复了确认信息，但由于客户端未收到确认信息，所以客户端会一直等待确认，导致连接无法正常建立。</li></ol><p>因此，为了确保连接的可靠性和稳定性，TCP采用了三次握手的机制。三次握手可以保证客户端和服务器都确认对方的确认信息，从而建立一个稳定的连接。</p><h4 id="18-TCP和UDP分别是什么"><a href="#18-TCP和UDP分别是什么" class="headerlink" title="18.TCP和UDP分别是什么?"></a>18.TCP和UDP分别是什么?</h4><p>TCP（Transmission Control Protocol）和UDP（User Datagram Protocol）都是在网络通信中常见的传输层协议。</p><p>TCP是一种面向连接的协议，它确保数据传输的可靠性。在TCP连接中，通信双方会建立连接，然后进行数据传输，确保数据按顺序到达目的地，并且不会丢失或损坏。TCP通过序列号和确认机制来实现数据的可靠传输，同时还可以进行拥塞控制和流量控制。TCP适用于对数据可靠性要求较高的场景，如文件传输、电子邮件等。</p><p>UDP是一种无连接的协议，它不保证数据传输的可靠性。在UDP中，通信双方不需要建立连接，直接发送数据包，不进行确认和重传操作。UDP的优点是传输速度快，适用于实时性要求高的场景，如视频直播、实时游戏等。但UDP也容易丢包，数据传输不可靠。</p><p>总结：</p><ul><li>TCP是面向连接的，保证数据可靠性，适用于对数据可靠性要求高的场景。</li><li>UDP是无连接的，传输速度快，适用于实时性要求高的场景，但数据传输不可靠。</li></ul><h4 id="19-WebSocket的实现和应用。"><a href="#19-WebSocket的实现和应用。" class="headerlink" title="19.WebSocket的实现和应用。"></a>19.WebSocket的实现和应用。</h4><h4 id="20-一个图片url-访问后直接下载怎样实现"><a href="#20-一个图片url-访问后直接下载怎样实现" class="headerlink" title="20.一个图片url 访问后直接下载怎样实现?"></a>20.一个图片url 访问后直接下载怎样实现?</h4><p>要实现一个图片URL在访问后直接下载，可以通过设置HTTP响应头来实现。具体步骤如下：</p><ol><li>后端配置： 在后端服务器端，针对该图片URL，设置HTTP响应头，告诉浏览器该资源的Content-Disposition为”attachment”，这样浏览器会将该资源视为附件并提示用户下载。</li><li>后端代码示例（Node.js + Express）：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy codeconst express = require(&#x27;express&#x27;);</span><br><span class="line">const app = express();</span><br><span class="line"></span><br><span class="line">app.get(&#x27;/download-image&#x27;, (req, res) =&gt; &#123;</span><br><span class="line">  // 设置响应头，Content-Disposition为&quot;attachment&quot;</span><br><span class="line">  res.setHeader(&#x27;Content-Disposition&#x27;, &#x27;attachment; filename=image.jpg&#x27;);</span><br><span class="line"></span><br><span class="line">  // 读取图片文件，并将其作为响应发送给客户端</span><br><span class="line">  // 这里可以根据实际情况从文件系统或其他地方读取图片</span><br><span class="line">  // 然后使用res.sendFile()将图片发送给客户端</span><br><span class="line">  res.sendFile(&#x27;/path/to/image.jpg&#x27;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(3000, () =&gt; &#123;</span><br><span class="line">  console.log(&#x27;Server is running on port 3000&#x27;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol><li>前端页面调用： 在前端页面中，使用一个链接或按钮来触发该图片URL的访问，这样当用户点击该链接或按钮时，浏览器会直接下载该图片。</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">htmlCopy code&lt;!-- 假设图片下载链接为/download-image --&gt;</span><br><span class="line">&lt;a href=&quot;/download-image&quot;&gt;Download Image&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>当用户点击上述链接时，浏览器会下载图片，并以”image.jpg”为默认文件名保存到本地。注意，后端代码示例中的”&#x2F;path&#x2F;to&#x2F;image.jpg”需要替换成实际的图片路径，同时可以根据需要对文件名进行动态设置。</p><h4 id="21-说一下http2-0"><a href="#21-说一下http2-0" class="headerlink" title="21.说一下http2.0"></a>21.说一下http2.0</h4><h4 id="22-补充400和401、403-状态码"><a href="#22-补充400和401、403-状态码" class="headerlink" title="22.补充400和401、403 状态码"></a>22.补充400和401、403 状态码</h4><h4 id="23-fetch发送2次请求的原因"><a href="#23-fetch发送2次请求的原因" class="headerlink" title="23.fetch发送2次请求的原因"></a>23.fetch发送2次请求的原因</h4><p>当使用Fetch API发送请求时，可能会出现发送两次请求的情况。这通常是由于浏览器的预请求（Preflight Request）机制导致的。</p><p>预请求是一种由浏览器发送的特殊请求，用于在发送真正的请求之前检查服务器是否支持某些特定的请求头或方法。预请求通常发生在以下情况：</p><ol><li>跨域请求：当发送跨域请求时（例如从<a href="http://example.com向http//api.example.com%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82%EF%BC%89%EF%BC%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BC%9A%E5%8F%91%E9%80%81%E9%A2%84%E8%AF%B7%E6%B1%82%E6%9D%A5%E7%A1%AE%E8%AE%A4%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%98%AF%E5%90%A6%E5%85%81%E8%AE%B8%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E3%80%82">http://example.com向http://api.example.com发送请求），浏览器会发送预请求来确认服务器是否允许跨域请求。</a></li><li>自定义请求头：当请求中包含一些自定义的请求头（例如Authorization头），而且该请求头在服务器端没有设置允许，浏览器会发送预请求来检查服务器是否支持该请求头。</li></ol><p>预请求的工作原理是，浏览器在发送真正的请求之前先发送一个OPTIONS请求（也称为预请求）到服务器，服务器返回预请求响应，浏览器根据预请求响应决定是否发送真正的请求。</p><p>为了避免Fetch API发送多次请求，可以采取以下措施：</p><ol><li>服务器端设置CORS（跨域资源共享）：在服务器端设置CORS规则，允许来自特定域名的跨域请求。这样可以避免预请求，直接发送真正的请求。</li><li>避免自定义请求头：尽量避免在请求中包含自定义的请求头，或者在服务器端设置允许这些自定义请求头，这样可以减少预请求的发送。</li><li>使用JSONP或者代理：如果跨域请求无法避免，可以考虑使用JSONP或者代理方式来发送请求，这样可以避免预请求的发送。</li></ol><p>总之，发送多次请求通常是由于浏览器的预请求机制导致的，可以通过设置CORS规则、避免自定义请求头等方式来避免预请求，从而解决发送多次请求的问题。</p><h4 id="24-对HTML语义化标签的理解"><a href="#24-对HTML语义化标签的理解" class="headerlink" title="24.对HTML语义化标签的理解"></a>24.对HTML语义化标签的理解</h4><p>HTML语义化是指在编写HTML代码时，合理地选择和使用标签，使得标签的结构和内容能够反映页面的结构和内容，使页面的结构和意义更加清晰明了，同时对搜索引擎和开发者友好。</p><p>使用语义化标签的好处有以下几点：</p><ol><li>代码可读性更好：通过语义化标签，代码的结构和含义更加明了，方便其他开发者阅读和理解代码。</li><li>对搜索引擎友好：搜索引擎能够更容易地理解页面的结构和内容，提高网页的搜索排名。</li><li>无障碍性：语义化标签能够提供更好的无障碍性支持，使得残障人士能够更容易地访问和理解页面内容。</li><li>便于维护和修改：使用语义化标签可以使得代码结构更加清晰，便于后期的维护和修改。</li></ol><p>常见的HTML语义化标签包括：</p><ol><li><code>&lt;header&gt;</code>：表示页面或者页面的一部分的页眉，通常包含网站的logo、导航菜单等。</li><li><code>&lt;nav&gt;</code>：表示导航栏，用于包含页面的导航链接。</li><li><code>&lt;main&gt;</code>：表示页面的主要内容，一个页面中通常只会包含一个main标签。</li><li><code>&lt;article&gt;</code>：表示一篇独立的文章或者内容块。</li><li><code>&lt;section&gt;</code>：表示页面的一个区域或者部分。</li><li><code>&lt;aside&gt;</code>：表示页面的侧边栏内容，通常用于包含与页面主要内容相关但又不是主要内容的部分。</li><li><code>&lt;footer&gt;</code>：表示页面或者页面的一部分的页脚，通常包含版权信息、联系方式等。</li><li><code>&lt;h1&gt;</code> - <code>&lt;h6&gt;</code>：表示标题，h1是最高级别的标题，h6是最低级别的标题。</li></ol><p>除了以上标签，还可以使用<code>&lt;p&gt;</code>、<code>&lt;ul&gt;</code>、<code>&lt;ol&gt;</code>、<code>&lt;li&gt;</code>等标签来表示段落、列表等内容，以及<code>&lt;figure&gt;</code>、<code>&lt;figcaption&gt;</code>等标签来表示图片和图题。</p><p>通过合理使用这些语义化标签，我们可以使得页面的结构更加清晰，对搜索引擎更友好，并提高页面的可访问性和可维护性。</p><h4 id="25-Cookie-和session的区别"><a href="#25-Cookie-和session的区别" class="headerlink" title="25.Cookie 和session的区别"></a>25.Cookie 和session的区别</h4><p>Cookie和Session都是用于在Web应用中存储用户状态和数据的方式，但它们有一些区别：</p><ol><li>存储位置：<ul><li>Cookie是存储在客户端（浏览器）的小型文本文件，通过响应头的Set-Cookie字段发送给浏览器，浏览器会保存在本地并在每次请求中携带在请求头中发送给服务器。</li><li>Session是存储在服务器上的会话数据，服务器会为每个用户创建一个唯一的Session，并将SessionID发送给客户端的Cookie中，客户端在每次请求中携带SessionID，服务器根据SessionID找到对应的Session数据。</li></ul></li><li>安全性：<ul><li>Cookie是存储在客户端，因此有一定的安全风险，例如Cookie可能被篡改、被盗用，因此不适合存储敏感信息。</li><li>Session数据存储在服务器上，相对来说更加安全，但仍然需要防止Session劫持等攻击。</li></ul></li><li>存储容量：<ul><li>Cookie的存储容量较小，通常只有几KB。</li><li>Session存储容量相对较大，取决于服务器的配置。</li></ul></li><li>生命周期：<ul><li>Cookie可以设置过期时间，可以长期保持，也可以设置为会话Cookie，在浏览器关闭后自动删除。</li><li>Session一般会设置一个较短的过期时间，一旦超过过期时间，Session数据将被销毁。</li></ul></li><li>使用场景：<ul><li>Cookie适合存储一些小型的非敏感数据，例如用户登录状态、用户偏好设置等。</li><li>Session适合存储一些较大或敏感的数据，例如用户购物车数据、用户登录信息等。</li></ul></li></ol><p>在实际应用中，Cookie和Session经常一起使用，比如服务器将用户的登录状态保存在Session中，然后将SessionID保存在Cookie中，这样在用户每次请求时，服务器可以根据SessionID找到对应的Session数据，从而实现用户状态的保持和管理。</p><h4 id="26-强缓存和协商缓存区别-什么时候用哪个-本质是"><a href="#26-强缓存和协商缓存区别-什么时候用哪个-本质是" class="headerlink" title="26.强缓存和协商缓存区别?什么时候用哪个?本质是?"></a>26.强缓存和协商缓存区别?什么时候用哪个?本质是?</h4><h4 id="27-cache-control-的值有哪些"><a href="#27-cache-control-的值有哪些" class="headerlink" title="27.cache-control 的值有哪些"></a>27.cache-control 的值有哪些</h4><h4 id="28-谈谈304状态码"><a href="#28-谈谈304状态码" class="headerlink" title="28.谈谈304状态码"></a>28.谈谈304状态码</h4><p>HTTP状态码中，状态码304表示”Not Modified”，它是一种缓存优化的状态码。当客户端发送一个条件请求（通常是GET请求）到服务器，并且该资源在服务器上没有发生过修改时，服务器会返回304状态码，表示客户端缓存的资源是最新的，无需重新传输相同的资源内容。</p><p>304状态码的工作流程如下：</p><ol><li>客户端发送一个条件请求，通常是带有If-Modified-Since或If-None-Match等请求头的GET请求。</li><li>服务器收到该请求后，会检查请求头中的条件参数（如Last-Modified或Etag等）与服务器上资源的实际情况进行对比。</li><li>如果服务器上的资源没有发生过修改，并且请求头中的条件参数与资源的实际情况匹配，服务器会返回304状态码，表示资源未被修改。</li><li>客户端收到304状态码后，会从本地缓存中读取该资源，并继续使用缓存的资源，无需重新下载。</li></ol><p>使用304状态码可以有效减少网络流量和服务器负载，提高网站的性能和响应速度。客户端和服务器之间的交互变为”请求-响应-缓存”的模式，减少了不必要的数据传输和服务器资源消耗。</p><p>要使用304状态码进行缓存优化，服务器通常会设置合适的缓存策略和响应头，包括设置Expires或Cache-Control等响应头，以及设置Last-Modified或Etag等条件参数，使得客户端和服务器可以进行缓存的判断和验证。同时，客户端也需要正确处理304状态码，从本地缓存中读取资源，并且在合适的时机重新发起条件请求，以确保缓存的资源始终是最新的</p><h4 id="29-什么是CDN-以及如何优化"><a href="#29-什么是CDN-以及如何优化" class="headerlink" title="29.什么是CDN,以及如何优化?"></a>29.什么是CDN,以及如何优化?</h4><p>CDN（Content Delivery Network）是内容分发网络的缩写。它是一种分布式的网络架构，通过将内容（如网页、图片、视频等静态资源）存储在离用户最近的服务器上，以提供更快速、可靠的内容传输和访问体验。</p><p>CDN优化的主要目标是减少网络延迟和提高页面加载速度，从而改善用户体验和网站性能。以下是一些CDN优化的方法：</p><ol><li><strong>内容缓存：</strong> CDN会将网站的静态资源缓存到多个节点服务器上，当用户请求访问这些资源时，可以直接从最近的节点服务器获取，避免了跨地区的数据传输，减少了网络延迟。</li><li><strong>负载均衡：</strong> CDN可以根据服务器的负载情况和用户的地理位置，将用户的请求分配给最合适的节点服务器，从而实现负载均衡，提高服务器的处理能力。</li><li><strong>数据压缩：</strong> CDN可以对网站的静态资源进行压缩，减小文件大小，从而减少数据传输量，提高页面加载速度。</li><li><strong>智能DNS解析：</strong> CDN会对DNS解析进行优化，根据用户的地理位置选择最近的节点服务器，从而加速DNS解析过程。</li><li><strong>预加载：</strong> CDN可以对网站的静态资源进行预加载，提前将资源缓存在节点服务器上，当用户请求访问时，可以直接从缓存中获取，减少等待时间。</li><li><strong>HTTP&#x2F;2支持：</strong> CDN支持HTTP&#x2F;2协议，可以提供多路复用和服务器推送等功能，从而减少连接数量和提高资源加载效率。</li><li><strong>缓存策略优化：</strong> 合理设置缓存策略，对不经常变化的静态资源进行长时间缓存，对动态资源进行短时间缓存，可以有效减少对源服务器的请求。</li></ol><p>通过使用CDN优化，可以有效提高网站的性能和用户体验，减少服务器负载，增加访问速度，并提高网站的可用性和稳定性。</p><h4 id="30-DNS是什么"><a href="#30-DNS是什么" class="headerlink" title="30.DNS是什么"></a>30.DNS是什么</h4><p>DNS是Domain Name System（域名系统）的缩写。它是一种用于将域名（如”<a href="http://www.example.xn--com"">www.example.com"）转换为对应的IP地址（如192.0.2.1）的分布式命名系统。在互联网中，每台计算机都需要一个唯一的IP地址来进行通信，而IP地址通常是一串数字，不方便记忆。因此，人们使用域名来代替IP地址进行访问。</a>ip(192-oo1u065hlha146amqldom1mx505gwrtf.0.2.xn–1)-6d5cy0f8p907bvwbrw4gzfmkoe.xn–%2Cip%2Cip%2C-5t3kaf8l1nhb6ey2f93jkqa861disfnnldfe77af192xo9qh2j423buzb7ufbqltmbe70g4c0f3dtbeb2ahxfvzcwx9j3ckg2v5sag74lijcha435hxw7e.xn–%2Cip-zn9djh0by1es0y1rgdxalf19ei28g0fbi48a861bj98de8mbnswu2a.&#x2F;)</p><p>DNS的主要作用是将域名映射到对应的IP地址，使得用户可以通过输入域名来访问网站，而不需要记住复杂的IP地址。DNS使用一种分层、分布式的结构，由多个DNS服务器组成，它们相互协作来提供域名解析服务。</p><p>当用户在浏览器中输入一个域名时，浏览器会向本地DNS服务器发起查询，询问该域名对应的IP地址。如果本地DNS服务器没有缓存这个域名的解析结果，它就会向更上层的DNS服务器发起查询，逐级向上查询，直到找到一个能够提供域名解析的DNS服务器。</p><p>DNS的查询过程是逐级向上查询的过程，但在实际运行中，为了加快查询速度，DNS服务器会将查询结果缓存一段时间，以便下次查询时可以直接返回结果，而不需要再进行逐级查询。</p><p>总结来说，DNS是一种将域名映射到IP地址的系统，它在互联网中起到了非常重要的作用，是实现域名访问的基础。</p><h4 id="31-什么是四层、七层网络模型"><a href="#31-什么是四层、七层网络模型" class="headerlink" title="31.什么是四层、七层网络模型?"></a>31.什么是四层、七层网络模型?</h4><p>四层和七层网络模型是计算机网络中常用的两种网络模型，用于描述网络中不同层次的功能和协议。</p><ol><li><strong>四层网络模型（OSI模型）</strong>：</li></ol><p>四层网络模型，也称为OSI模型，是由国际标准化组织（ISO）制定的网络通信参考模型，将网络通信划分为四个层次，每个层次负责不同的功能。</p><ul><li><strong>物理层（Physical Layer）</strong>：负责物理传输介质上的数据传输，例如网线、光纤等。</li><li><strong>数据链路层（Data Link Layer）</strong>：处理相邻节点之间的数据传输，确保数据在物理介质上的可靠传输，如MAC地址。</li><li><strong>网络层（Network Layer）</strong>：负责网络之间的数据传输和路由选择，如IP地址。</li><li><strong>传输层（Transport Layer）</strong>：负责端到端的数据传输和错误检测，如TCP和UDP协议。</li></ul><ol><li><strong>七层网络模型（OSI&#x2F;RM模型）</strong>：</li></ol><p>七层网络模型是由国际标准化组织（ISO）和国际电信联盟（ITU）共同制定的网络通信参考模型，也称为OSI&#x2F;RM模型，将网络通信划分为七个层次，每个层次负责不同的功能。</p><ul><li><strong>物理层（Physical Layer）</strong>：同四层模型一样，负责物理传输介质上的数据传输。</li><li><strong>数据链路层（Data Link Layer）</strong>：同四层模型一样，处理相邻节点之间的数据传输。</li><li><strong>网络层（Network Layer）</strong>：同四层模型一样，负责网络之间的数据传输和路由选择。</li><li><strong>传输层（Transport Layer）</strong>：同四层模型一样，负责端到端的数据传输和错误检测。</li><li><strong>会话层（Session Layer）</strong>：负责建立、维护和终止应用程序之间的会话连接。</li><li><strong>表示层（Presentation Layer）</strong>：负责数据的格式转换、加密和压缩，确保数据在应用层之间的正确传递。</li><li><strong>应用层（Application Layer）</strong>：提供应用程序之间的通信服务，包括HTTP、FTP、SMTP等协议。</li></ul><p>七层网络模型在功能上更加细分，每个层次的职责更加明确，但在实际网络通信中，更常用的是四层网络模型，因为它更加简单，更符合实际应用场景。七层模型主要用于理论研究和教学。</p><h2 id="网络安全"><a href="#网络安全" class="headerlink" title="网络安全"></a>网络安全</h2><h4 id="1-什么是xss攻击及如何防范"><a href="#1-什么是xss攻击及如何防范" class="headerlink" title="1.什么是xss攻击及如何防范"></a>1.什么是xss攻击及如何防范</h4><p>XSS（Cross-Site Scripting）跨站脚本攻击是一种常见的网络安全漏洞，攻击者通过在网页中插入恶意脚本，使用户的浏览器执行这些恶意脚本，从而窃取用户信息、篡改网页内容或进行其他恶意行为。</p><p>XSS攻击分为三种类型：</p><ol><li><strong>存储型XSS</strong>：恶意脚本被存储在服务器上，并在用户访问被感染的页面时执行。攻击者通常通过提交带有恶意脚本的表单或评论等方式将恶意脚本存储到服务器中。</li><li><strong>反射型XSS</strong>：恶意脚本作为URL的一部分，用户点击恶意链接时，恶意脚本被传递给服务器并执行。攻击者通常会将恶意链接通过电子邮件、社交媒体等方式传播给用户。</li><li><strong>DOM型XSS</strong>：恶意脚本直接修改网页的DOM结构，从而触发执行。攻击者通常通过改变URL或其他用户可控的参数来触发DOM型XSS攻击。</li></ol><p>为了防范XSS攻击，可以采取以下措施：</p><ol><li><strong>输入验证和过滤</strong>：对于用户输入的数据，进行严格的验证和过滤，确保只接受合法的数据，防止恶意脚本被插入。</li><li><strong>输出转义</strong>：在将用户输入数据输出到网页时，将特殊字符转义为HTML实体，例如将”&lt;”转义为”&lt;”，这样可以防止脚本被执行。</li><li><strong>HttpOnly标记</strong>：在设置cookie时，使用HttpOnly标记，防止JavaScript脚本获取cookie，从而减少受到XSS攻击的风险。</li><li><strong>设置Content Security Policy（CSP）</strong>：CSP是一种HTTP头，可以指定哪些外部资源可以被加载和执行，从而限制恶意脚本的来源和执行。</li><li><strong>使用安全的编程实践</strong>：避免在网页中直接拼接动态内容，而是使用安全的编程实践，例如使用模板引擎来插入动态内容。</li><li><strong>限制用户的输入权限</strong>：对于一些用户权限较高的功能，要求用户进行身份验证或授权，避免未授权用户执行恶意操作。</li></ol><p>总的来说，防范XSS攻击需要综合考虑多种方法，包括前端和后端的安全措施，以确保用户的信息和网站的安全。同时，及时更新网站的漏洞和安全策略，以防止新型的XSS攻击。</p><h4 id="2-什么是ddos攻击及如何防范"><a href="#2-什么是ddos攻击及如何防范" class="headerlink" title="2.什么是ddos攻击及如何防范?"></a>2.什么是ddos攻击及如何防范?</h4><p>DDoS攻击是一种分布式的拒绝服务攻击，旨在通过大量虚假请求或恶意流量，使目标服务器或网络不可用，从而使合法用户无法访问服务。</p><p>DDoS攻击通常涉及多台被控制的计算机或设备（称为僵尸机），这些机器同时向目标服务器发送大量请求，导致服务器资源耗尽，无法处理合法用户的请求，从而导致服务停止响应。</p><p>防范DDoS攻击可以采取以下措施：</p><ol><li><strong>使用DDoS防火墙</strong>：DDoS防火墙可以识别和过滤掉恶意流量，阻止攻击流量达到目标服务器。</li><li><strong>负载均衡</strong>：通过使用负载均衡器，将请求分发到多台服务器，可以分散DDoS攻击对单个服务器的影响。</li><li><strong>增加带宽和服务器资源</strong>：增加网络带宽和服务器资源可以增加服务器的承载能力，从而更好地应对DDoS攻击。</li><li><strong>黑名单和白名单</strong>：对于IP地址进行黑名单和白名单管理，可以阻止或允许特定IP地址的访问，从而过滤掉恶意流量。</li><li><strong>合理设置请求频率限制</strong>：设置请求频率限制，限制单个IP地址或用户在特定时间内的请求次数，可以防止DDoS攻击中的某些恶意请求。</li><li><strong>网络流量监测和分析</strong>：实时监测网络流量，及时发现异常流量并采取措施进行阻断。</li><li><strong>云防护服务</strong>：使用云防护服务可以将攻击流量分散到云端进行处理，保护服务器免受DDoS攻击。</li></ol><p>总的来说，防范DDoS攻击需要采取多层次的安全措施，包括网络层面的防护和服务器层面的优化，以确保网络和服务的稳定性和可用性。同时，及时监测和响应异常流量，快速恢复服务也是重要的应对策略。</p><h4 id="3-什么是csrf攻击及如何防范"><a href="#3-什么是csrf攻击及如何防范" class="headerlink" title="3.什么是csrf攻击及如何防范?"></a>3.什么是csrf攻击及如何防范?</h4><p>CSRF（Cross-Site Request Forgery）跨站请求伪造，是一种常见的网络安全攻击方式。攻击者利用用户已登录的身份，在用户不知情的情况下，发送伪造的请求，以达到窃取用户信息、执行非法操作等恶意目的。</p><p>CSRF攻击的原理是利用网站对用户请求的信任，攻击者通过诱使用户访问恶意网站或点击恶意链接，触发网站对另一个站点的请求。由于浏览器会自动携带用户的登录信息，因此攻击者可以利用这个漏洞发送伪造请求，从而实施攻击。</p><p>为了防范CSRF攻击，可以采取以下措施：</p><ol><li><strong>验证来源站点</strong>：服务器可以检查请求的来源站点，如果请求不是来自合法的站点，可以拒绝该请求。</li><li><strong>使用验证码</strong>：要求用户在重要操作前输入验证码，可以防止CSRF攻击，因为攻击者无法获取验证码。</li><li><strong>添加随机令牌</strong>：在用户登录后，服务器生成一个随机令牌，并将其添加到用户的会话中和每个表单提交中。当用户提交表单时，服务器验证令牌的有效性，如果令牌无效，则拒绝请求。</li><li><strong>设置同源策略</strong>：使用同源策略限制跨站点的请求，可以有效防止CSRF攻击。</li><li><strong>设置HttpOnly标记</strong>：在设置用户的身份认证cookie时，使用HttpOnly标记，防止JavaScript脚本获取cookie，减少受到攻击的风险。</li><li><strong>定期更改密码</strong>：建议用户定期更改密码，减少受到CSRF攻击的风险。</li><li><strong>使用POST请求</strong>：在涉及敏感操作时，尽量使用POST请求，因为CSRF攻击通常利用GET请求来实施攻击。</li></ol><p>总的来说，防范CSRF攻击需要综合考虑多种方法，包括服务器端的验证和安全策略，以及前端的措施，确保用户请求的合法性，保护用户的安全和隐私。</p><h2 id="前端工程化"><a href="#前端工程化" class="headerlink" title="前端工程化"></a>前端工程化</h2><h4 id="1-如何理解前端模块化、前端组件化，二者有何区别"><a href="#1-如何理解前端模块化、前端组件化，二者有何区别" class="headerlink" title="1.如何理解前端模块化、前端组件化，二者有何区别?"></a>1.如何理解前端模块化、前端组件化，二者有何区别?</h4><p>前端模块化和前端组件化是两个重要的概念，它们都是为了更好地组织和管理前端代码，提高开发效率和代码复用性。</p><ol><li>前端模块化：</li></ol><p>前端模块化是将一个大的前端应用拆分成多个小的模块，每个模块都有自己的功能和职责，通过模块化的方式将代码进行分离和组织，使得代码更加清晰、可维护性更强。</p><p>常见的前端模块化方案有 CommonJS、AMD、ES6 Modules 等。这些方案允许开发者使用 <code>require</code> 或 <code>import</code> 等语法来导入其他模块，并将模块中的代码进行封装，避免了全局变量污染，提高了代码的可维护性和可复用性。</p><ol><li>前端组件化：</li></ol><p>前端组件化是将页面的各个部分拆分成独立的组件，每个组件都是一个相对独立的单元，具有自己的样式和行为，可以在多个页面中重复使用。</p><p>通过前端组件化，可以将页面拆分成多个小的组件，每个组件专注于处理一个特定的功能或展示效果，使得代码更加模块化、可复用性更高，同时也方便团队协作和维护。</p><p>区别：</p><p>前端模块化和前端组件化是两个不同的概念，但它们有一些相似之处。前端模块化强调的是代码的组织方式，将代码按功能进行拆分和组织，而前端组件化强调的是页面的组织方式，将页面拆分成独立的组件来构建。</p><p>前端模块化更注重代码的复用性，可以在不同的模块中导入和使用其他模块的代码；前端组件化更注重页面的复用性，可以在不同的页面中使用相同的组件。</p><p>综合来说，前端模块化和前端组件化是相辅相成的概念，它们都是为了实现代码的高度复用和可维护性，帮助开发者构建更加高效、健壮的前端应用。</p><h4 id="2-如何理解前后端分离"><a href="#2-如何理解前后端分离" class="headerlink" title="2.如何理解前后端分离?"></a>2.如何理解前后端分离?</h4><p>前后端分离是一种软件架构模式，它将前端和后端的开发分离开来，使得前端和后端可以独立开发，通过接口进行数据交互。在前后端分离的架构中，前端和后端是两个独立的项目，它们可以使用不同的技术栈和开发语言，从而提高开发效率和灵活性。</p><p>在传统的开发模式中，前端和后端的开发是耦合在一起的，前端负责展示页面和用户交互，后端负责处理业务逻辑和数据存储。这种模式下，前端和后端的开发必须紧密配合，前端需要等待后端接口的开发和联调，而后端需要等待前端页面的开发完成。</p><p>而在前后端分离的模式下，前端和后端是完全独立的，它们之间通过接口进行数据交互。前端负责页面的渲染和用户交互，后端负责处理业务逻辑和数据存储，前端和后端可以并行开发，互不影响。这样可以提高开发效率，减少开发时间，同时也方便不同团队协同开发。</p><p>前后端分离的架构模式还有以下优点：</p><ol><li>前后端独立部署：前端和后端可以独立部署，前端部署在Web服务器上，后端部署在应用服务器上，分别负责不同的任务，提高了系统的稳定性和可扩展性。</li><li>增加前端重用性：前后端分离后，前端可以根据需要在不同的项目中重用组件和页面，提高了前端代码的重用性。</li><li>前端技术栈灵活：前后端分离允许前端使用任意的技术栈，可以选择最适合项目需求的技术，不再受限于后端的技术栈。</li><li>接口规范化：前后端分离需要定义接口规范，使得前后端之间的数据交互更加明确和规范化，有利于团队协作和开发。</li></ol><p>总的来说，前后端分离是一种优秀的软件架构模式，它将前端和后端的开发解耦，提高了开发效率和代码重用性，使得前后端开发更加灵活和高效。</p><h3 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h3><h4 id="3-有自己配置过webpack吗-如果需求是多页面与单页面并行，需要如何配置"><a href="#3-有自己配置过webpack吗-如果需求是多页面与单页面并行，需要如何配置" class="headerlink" title="3.有自己配置过webpack吗?如果需求是多页面与单页面并行，需要如何配置?"></a>3.有自己配置过webpack吗?如果需求是多页面与单页面并行，需要如何配置?</h4><h5 id="配置Webpack支持多页面和单页面并行："><a href="#配置Webpack支持多页面和单页面并行：" class="headerlink" title="配置Webpack支持多页面和单页面并行："></a>配置Webpack支持多页面和单页面并行：</h5><ol><li><strong>目录结构准备</strong>：首先，需要在项目中建立不同的页面目录结构，每个页面目录下应包含一个入口文件（如index.js）和一个HTML模板文件（如index.html）。</li><li><strong>配置入口</strong>：在Webpack的配置文件中，使用entry配置多个入口点，每个入口点对应一个页面目录的入口文件。</li><li><strong>配置输出</strong>：使用output配置输出文件的规则，确保输出文件名与入口文件对应，并设置正确的输出路径。</li><li><strong>配置HtmlWebpackPlugin</strong>：使用HtmlWebpackPlugin插件为每个页面生成HTML文件，并指定对应的入口文件。</li><li><strong>配置多页面路由</strong>：如果有多个页面需要共享一些公共组件或资源，可以通过配置多页面路由来实现。</li></ol><p>示例Webpack配置如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    page1: &#x27;./src/page1/index.js&#x27;,</span><br><span class="line">    page2: &#x27;./src/page2/index.js&#x27;,</span><br><span class="line">    app: &#x27;./src/app/index.js&#x27; // 单页面应用的入口文件</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &#x27;[name].[contenthash].js&#x27;,</span><br><span class="line">    path: path.resolve(__dirname, &#x27;dist&#x27;)</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    new HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: &#x27;./src/page1/index.html&#x27;,</span><br><span class="line">      chunks: [&#x27;page1&#x27;],</span><br><span class="line">      filename: &#x27;page1.html&#x27;</span><br><span class="line">    &#125;),</span><br><span class="line">    new HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: &#x27;./src/page2/index.html&#x27;,</span><br><span class="line">      chunks: [&#x27;page2&#x27;],</span><br><span class="line">      filename: &#x27;page2.html&#x27;</span><br><span class="line">    &#125;),</span><br><span class="line">    // 其他插件和配置</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在以上示例中，Webpack配置了多个入口文件，并使用HtmlWebpackPlugin插件为每个页面生成对应的HTML文件。同时，也配置了单页面应用的入口文件，使多页面和单页面可以并行开发。</p><p>根据项目的实际需求，还可以进一步配置不同的Loader和Plugin，以满足不同页面的开发和优化需求。请根据您的具体项目结构和需求进行调整和扩展。</p><h4 id="4-Webpack的优点是什么"><a href="#4-Webpack的优点是什么" class="headerlink" title="4.Webpack的优点是什么?"></a>4.Webpack的优点是什么?</h4><p>Webpack具有许多优点，使其成为前端项目中最受欢迎的打包工具之一。以下是Webpack的一些优点：</p><ol><li><strong>模块化支持</strong>：Webpack支持将项目拆分成小模块，并通过导入和导出语法进行模块化开发，提高代码的可维护性和复用性。</li><li><strong>代码拆分</strong>：Webpack支持将代码拆分成多个bundle，实现按需加载，减少初次加载的时间和页面大小。</li><li><strong>丰富的Loader支持</strong>：Webpack允许通过Loader对不同类型的文件进行处理和转换，例如处理CSS、Less、Sass、图片等文件，使得开发过程更加灵活。</li><li><strong>插件扩展性</strong>：Webpack提供了丰富的插件系统，可以通过插件来扩展和优化Webpack的功能，满足不同项目的需求。</li><li><strong>开发工具</strong>：Webpack提供了强大的开发工具，例如热模块替换（HMR）、代码分析工具等，帮助开发者提高开发效率和调试能力。</li><li><strong>代码压缩和优化</strong>：Webpack可以对代码进行压缩和优化，减小文件体积，提高页面加载速度。</li><li><strong>多环境支持</strong>：Webpack支持多环境配置，可以根据开发、测试和生产环境的不同需求来进行配置。</li><li><strong>社区活跃</strong>：Webpack拥有庞大的开发者社区，有大量的文档、插件和开源项目可供使用，解决问题和学习都非常方便。</li><li><strong>资源加载优化</strong>：Webpack可以将小图片转换成base64格式，减少HTTP请求，提高页面加载速度。</li></ol><p>综上所述，Webpack具有丰富的功能和强大的生态系统，能够帮助开发者更高效地构建、打包和优化前端项目。</p><h4 id="5-Webpack的构建流程是什么-从读取配置到输出文件这个过程尽量说全"><a href="#5-Webpack的构建流程是什么-从读取配置到输出文件这个过程尽量说全" class="headerlink" title="5.Webpack的构建流程是什么?从读取配置到输出文件这个过程尽量说全"></a>5.Webpack的构建流程是什么?从读取配置到输出文件这个过程尽量说全</h4><p>Webpack的构建流程主要包括以下几个步骤：</p><ol><li><strong>读取配置文件</strong>：Webpack会首先读取项目根目录下的webpack配置文件（通常为webpack.config.js），获取其中的配置信息。</li><li><strong>解析入口文件</strong>：根据配置文件中的entry字段，Webpack会找到所有的入口文件，并从这些入口文件开始分析和构建依赖关系。</li><li><strong>依赖图分析</strong>：Webpack会递归地分析入口文件和它们的依赖文件，构建一个完整的依赖图，形成模块之间的依赖关系。</li><li><strong>模块解析和转换</strong>：Webpack会根据模块的类型（JavaScript、CSS、图片等）使用对应的Loader对模块进行解析和转换，将其转换成有效的JavaScript代码。</li><li><strong>插件处理</strong>：在模块转换的过程中，Webpack会根据配置文件中的plugins字段使用相应的插件对代码进行处理，例如代码压缩、文件拷贝等操作。</li><li><strong>输出文件</strong>：当所有的模块解析和转换完成后，Webpack会将最终的构建结果输出到指定的输出目录中。输出的文件名和路径通常由output字段配置决定。</li><li><strong>模块加载和代码执行</strong>：当浏览器加载输出的文件时，Webpack会将模块加载器（通常是webpack-runtime.js）插入到输出文件的头部，用于在浏览器中解析和加载模块。</li><li><strong>运行时逻辑处理</strong>：Webpack会根据配置文件中的mode字段确定运行时的逻辑，例如在开发环境下会添加热模块替换的逻辑，以实现代码的实时更新。</li></ol><p>总体来说，Webpack的构建流程包括了对入口文件和依赖文件的解析、模块转换和插件处理，最终将构建结果输出到指定的输出目录中，供浏览器加载和执行。在整个构建过程中，Webpack会根据配置文件中的设置来决定具体的构建行为和优化策略。</p><h4 id="6-说一下Webpack的热更新原理"><a href="#6-说一下Webpack的热更新原理" class="headerlink" title="6.说一下Webpack的热更新原理"></a>6.说一下Webpack的热更新原理</h4><p>Webpack的热更新（Hot Module Replacement，简称HMR）是一种提高开发效率的技术，它使得在开发过程中，当代码发生改变时，只更新发生改变的部分，而不需要整个页面刷新，从而减少了开发的重复工作和等待时间。</p><p>热更新的原理主要分为以下几个步骤：</p><ol><li>监听文件变化：Webpack通过监听文件系统的变化，当文件发生改变时，Webpack能够感知到。</li><li>构建新模块：当文件发生改变时，Webpack会重新构建该模块，并生成新的模块代码。</li><li>传递更新信号：在构建新模块后，Webpack会通过WebSocket或者XHR等方式向客户端发送更新信号。</li><li>客户端更新：客户端收到更新信号后，通过HMR Runtime（内置在Webpack生成的代码中），会根据更新信号进行更新，将新的模块代码插入到页面中，同时更新页面的状态。</li></ol><p>通过这种方式，热更新可以实现在不刷新整个页面的情况下，更新页面的部分内容，保持页面的状态和用户的交互，从而提高开发效率。</p><p>在使用Webpack时，开启热更新可以通过在配置文件中加入相应的配置来实现，例如使用<code>webpack-dev-server</code>插件或<code>webpack-hot-middleware</code>插件来实现热更新功能。</p><p>需要注意的是，热更新只在开发环境下使用，不应该在生产环境中使用，因为它会增加额外的代码和开销。在生产环境中应该使用Webpack的代码分割和缓存等技术来优化性能。</p><h4 id="7-有哪些常见的Loader-他们是解决什么问题的"><a href="#7-有哪些常见的Loader-他们是解决什么问题的" class="headerlink" title="7.有哪些常见的Loader?他们是解决什么问题的?"></a>7.有哪些常见的Loader?他们是解决什么问题的?</h4><p>常见的Loader是用于处理各种非JavaScript文件，将它们转换为Webpack可识别的模块。以下是一些常见的Loader及它们解决的问题：</p><ol><li>babel-loader：将ES6+的代码转换成向后兼容的JavaScript，解决不同浏览器对新语法的支持问题。</li><li>css-loader：解析CSS文件，并处理其中的import和url()等语法，使得Webpack可以识别CSS文件并将其打包。</li><li>style-loader：将解析后的CSS代码以<style>标签的形式插入到HTML文件中，使得样式可以生效。</li><li>sass-loader：解析Sass&#x2F;Scss文件，将其转换为CSS文件。</li><li>less-loader：解析Less文件，将其转换为CSS文件。</li><li>file-loader：处理图片、字体等文件，将它们复制到输出目录，并返回对应的路径。</li><li>url-loader：类似于file-loader，但可以根据文件大小将文件转换成DataURL，减少HTTP请求。</li><li>vue-loader：处理Vue单文件组件，将其转换为JavaScript模块。</li><li>json-loader：解析JSON文件，将其转换为JavaScript对象。</li><li>xml-loader：解析XML文件。</li></ol><p>这些Loader可以使得Webpack可以处理各种类型的资源文件，并将它们转换为可以被打包和使用的模块。通过使用不同的Loader，我们可以实现对不同类型文件的自动转换和处理，从而提高开发效率和优化前端资源。</p><h4 id="8-Loader-和Plugin的不同"><a href="#8-Loader-和Plugin的不同" class="headerlink" title="8.Loader 和Plugin的不同?"></a>8.Loader 和Plugin的不同?</h4><p>Loader和Plugin是Webpack两个重要的概念，它们的作用和用途有所不同：</p><ol><li>Loader：</li></ol><p>Loader是Webpack的核心功能之一，它用于处理非JavaScript文件（例如CSS、图片、字体等），将它们转换为Webpack可识别的模块。在Webpack的配置文件中，通过配置不同的Loader，可以将不同类型的文件转换成适合打包的模块。</p><p>Loader的作用是将源文件进行转换和处理，从而让Webpack可以识别和打包这些文件。例如，可以使用css-loader将CSS文件转换成JS模块，使用file-loader将图片转换成文件。</p><ol><li>Plugin：</li></ol><p>Plugin也是Webpack的核心功能，它用于扩展Webpack的功能，解决一些其他任务。Plugin在Webpack构建过程的不同阶段被调用，可以用于执行各种任务，例如压缩代码、代码分割、生成HTML文件、提取CSS等。</p><p>Plugin的作用是在Webpack构建过程中，对资源进行处理和优化。它可以修改输出文件、增加新的文件、在特定阶段执行自定义逻辑等。</p><p>总结：</p><p>Loader主要是用来处理文件，将文件转换成模块，让Webpack能够处理这些非JavaScript资源。而Plugin主要是用来扩展Webpack的功能，解决其他与文件转换无关的任务，如优化、代码注入、资源管理等。</p><p>在Webpack的配置中，Loader通过<code>module.rules</code>配置进行使用，而Plugin通过<code>plugins</code>配置进行使用。Loader和Plugin是Webpack中实现自动化构建和优化的两个重要组成部分，它们共同构成了Webpack的核心功能。</p><h4 id="9-如何利用Webpack来优化前端性能"><a href="#9-如何利用Webpack来优化前端性能" class="headerlink" title="9.如何利用Webpack来优化前端性能"></a>9.如何利用Webpack来优化前端性能</h4><p>Webpack可以通过以下方式来优化前端性能：</p><ol><li>代码分割：使用Webpack的代码分割功能，将代码分割成多个小块，按需加载，减少首次加载的时间和资源消耗。</li><li>文件压缩：使用Webpack的UglifyJsPlugin等插件来压缩JavaScript代码，使用OptimizeCSSAssetsPlugin来压缩CSS代码，减少文件的大小，加快加载速度。</li><li>Tree Shaking：使用Webpack的Tree Shaking功能，移除未使用的代码，减少打包后的文件大小。</li><li>图片优化：使用url-loader或者image-webpack-loader来优化图片，可以将小图片转换成DataURL或者压缩图片，减少图片的大小。</li><li>缓存优化：使用Webpack的hash或者chunkhash来为输出的文件添加hash值，实现文件的缓存优化。</li><li>异步加载：使用Webpack的动态import()或者使用import()函数来实现模块的异步加载，减少初始加载时间。</li><li>代码拆分：使用Webpack的SplitChunksPlugin来拆分代码块，将公共代码提取出来，减少重复加载和提高缓存利用率。</li><li>使用CDN：将一些公共库或者静态资源放在CDN上，加快加载速度。</li><li>缓存配置：对Webpack的构建结果进行缓存配置，加快重复构建的速度。</li><li>懒加载：使用Webpack的动态import()或者require.ensure()来实现模块的懒加载，提高页面的加载速度。</li></ol><p>以上是一些常见的Webpack优化方式，通过合理地配置Webpack，可以显著地提高前端性能，减少页面加载时间，提升用户体验。</p><h4 id="10-否过Loader和Plugin-描述一下编写-loader或plugin的思路"><a href="#10-否过Loader和Plugin-描述一下编写-loader或plugin的思路" class="headerlink" title="10.否过Loader和Plugin?描述一下编写 loader或plugin的思路?"></a>10.否过Loader和Plugin?描述一下编写 loader或plugin的思路?</h4><p>Loader和Plugin是Webpack中两个重要的概念，它们分别用于处理模块和扩展Webpack的功能。下面分别描述编写Loader和Plugin的思路：</p><h5 id="编写Loader的思路："><a href="#编写Loader的思路：" class="headerlink" title="编写Loader的思路："></a>编写Loader的思路：</h5><ol><li>确定输入和输出：首先确定Loader的输入和输出。Loader接收的是模块的源代码或资源文件，并输出经过处理后的代码或资源。</li><li>了解文件类型：根据需要处理的文件类型，了解其格式和结构，确定处理方式。</li><li>编写处理逻辑：根据文件类型和需求，编写处理逻辑。可以使用正则表达式、字符串替换、AST解析等方式对源代码进行转换和处理。</li><li>处理选项：考虑是否需要提供可配置的处理选项，以便用户在webpack配置中灵活地调整Loader的行为。</li><li>错误处理：在处理过程中，注意捕获和处理错误，确保Loader的健壮性和稳定性。</li><li>单元测试：编写单元测试来验证Loader的功能和正确性。</li><li>注册Loader：最后，将编写好的Loader注册到webpack配置中，让Webpack在构建过程中使用你的Loader。</li></ol><h5 id="编写Plugin的思路："><a href="#编写Plugin的思路：" class="headerlink" title="编写Plugin的思路："></a>编写Plugin的思路：</h5><ol><li>了解钩子：Plugin通过挂载在Webpack的钩子上来实现功能。首先了解Webpack提供了哪些钩子，选择合适的钩子来实现你的功能。</li><li>确定功能：明确Plugin的功能和目标，确保你的Plugin能够满足特定的需求。</li><li>编写插件代码：编写插件的代码逻辑，可以是一系列的处理步骤或是一个独立的功能。</li><li>处理参数：考虑是否需要接受参数，通过配置来灵活调整插件的功能。</li><li>错误处理：在插件的处理过程中，注意捕获和处理错误，确保插件的稳定性。</li><li>效率优化：尽量避免耗时的操作，考虑效率优化，减少构建时间。</li><li>测试插件：编写测试用例，验证插件的功能和正确性。</li><li>注册插件：将编写好的插件注册到webpack配置中，让Webpack在构建过程中使用你的插件。</li></ol><p>编写Loader和Plugin都需要深入了解Webpack的内部工作原理和提供的API，同时要考虑到用户的需求和使用场景，确保编写出高效、稳定且易用的Loader和Plugin。</p><h4 id="11-使用Webpack开发时，你用过哪些可以提高效率的插件"><a href="#11-使用Webpack开发时，你用过哪些可以提高效率的插件" class="headerlink" title="11.使用Webpack开发时，你用过哪些可以提高效率的插件?"></a>11.使用Webpack开发时，你用过哪些可以提高效率的插件?</h4><ol><li>HtmlWebpackPlugin：自动生成HTML文件，并自动引入打包后的资源文件。</li><li>MiniCssExtractPlugin：将CSS代码提取成单独的文件，避免将CSS嵌入到JS文件中。</li><li>CleanWebpackPlugin：在每次构建前清理输出目录，防止旧的文件残留。</li><li>HotModuleReplacementPlugin：启用热模块替换，实现无需刷新页面即可更新模块。</li><li>DefinePlugin：定义全局变量，例如在开发环境和生产环境中切换接口地址。</li><li>UglifyJsPlugin：压缩JS代码，减少文件体积。</li><li>OptimizeCSSAssetsPlugin：压缩CSS代码，减少文件体积。</li><li>BundleAnalyzerPlugin：可视化分析打包文件的大小和组成，帮助优化打包结果。</li><li>CopyWebpackPlugin：拷贝静态资源文件到输出目录。</li><li>HappyPack：多线程构建，加快打包速度。</li><li>CompressionWebpackPlugin：对输出的资源文件进行gzip压缩，加快网络传输速度。</li><li>SpeedMeasureWebpackPlugin：测量每个插件和loader的耗时，用于优化构建速度。</li><li>MiniProgramWebpackPlugin：用于开发小程序的插件，可以实现小程序的构建和优化。</li></ol><p>这些插件都可以根据项目的需要灵活配置和使用，帮助您提高开发效率和优化构建过程。</p><h4 id="12-什么是长缓存-在Webpack中如何做到长缓存优化"><a href="#12-什么是长缓存-在Webpack中如何做到长缓存优化" class="headerlink" title="12.什么是长缓存?在Webpack中如何做到长缓存优化?"></a>12.什么是长缓存?在Webpack中如何做到长缓存优化?</h4><h4 id="13-如何提高Webpack的构建速度"><a href="#13-如何提高Webpack的构建速度" class="headerlink" title="13.如何提高Webpack的构建速度?"></a>13.如何提高Webpack的构建速度?</h4><p>提高Webpack的构建速度是前端开发中非常重要的优化措施，可以从以下几个方面着手：</p><ol><li>使用最新版本的Webpack和相关插件：Webpack不断更新和优化，新版本通常会有性能改进。确保你使用的是最新版本的Webpack和相关插件，可以获得更好的构建性能。</li><li>减少入口文件大小：将入口文件的依赖项和逻辑控制保持最小。尽量避免在入口文件中引入大量不必要的模块，以减少构建时间。</li><li>使用多线程&#x2F;多进程构建：使用Webpack的多线程或多进程构建插件，如<code>thread-loader</code>或<code>parallel-webpack</code>，可以利用多核处理器的优势，加快构建速度。</li><li>合理使用Loader和Plugin：优化Loader和Plugin的配置，确保只对必要的文件进行处理。避免不必要的重复工作，如对已经处理过的文件再次进行处理。</li><li>使用缓存：使用缓存插件，如<code>cache-loader</code>或<code>hard-source-webpack-plugin</code>，可以缓存构建过程中的中间结果，避免重复计算和处理，提高构建速度。</li><li>拆分代码：通过代码拆分（Code Splitting）将大型的代码块拆分成较小的模块，可以实现按需加载，减少初始加载时间，提高页面响应速度。</li><li>压缩和优化代码：在生产环境下使用压缩和优化插件，如<code>UglifyJsPlugin</code>和<code>OptimizeCSSAssetsPlugin</code>，可以减小文件大小，提高加载速度。</li><li>使用动态导入：使用动态导入（Dynamic Import）来延迟加载不必要的模块，避免一次性加载过多的代码，优化页面加载速度。</li><li>配置resolve.alias：通过配置resolve.alias将一些常用的模块路径映射为简短的别名，可以减少Webpack的查找时间，加快构建速度。</li><li>删除不必要的插件和Loader：确保只使用必要的插件和Loader，删除不必要的配置，减少构建的复杂性。</li></ol><p>通过以上优化措施，可以显著提高Webpack的构建速度，加快项目的开发和部署过程。</p><h4 id="14-怎么实现Webpack的按需加载-什么是神奇注释"><a href="#14-怎么实现Webpack的按需加载-什么是神奇注释" class="headerlink" title="14.怎么实现Webpack的按需加载?什么是神奇注释?"></a>14.怎么实现Webpack的按需加载?什么是神奇注释?</h4><h4 id="15-Babel-的原理是什么"><a href="#15-Babel-的原理是什么" class="headerlink" title="15.Babel 的原理是什么?"></a>15.Babel 的原理是什么?</h4><p>Babel是一个用于将现代JavaScript代码转换成向后兼容版本的工具。它的主要原理是通过使用插件和预设来将新的JavaScript语法和功能转换为ES5或更早版本的代码，从而在旧版浏览器中也能够正确运行。</p><p>Babel的工作原理可以分为以下几个步骤：</p><ol><li>解析：Babel首先将输入的JavaScript代码解析成抽象语法树（AST），这样可以更方便地对代码进行分析和处理。</li><li>转换：Babel接下来会遍历AST，通过使用各种插件来进行代码转换。每个插件都负责处理特定的语法或功能，并将其转换成等效的ES5或更早版本的代码。</li><li>生成：最后，Babel会将经过转换的AST再次转换回字符串形式的代码，并输出为最终的转换结果。</li></ol><p>Babel的转换过程是高度可配置的，用户可以根据需要选择不同的插件和预设来实现不同的转换效果。例如，用户可以根据目标浏览器版本选择不同的预设，以便只转换那些需要兼容的语法和功能。</p><p>通过Babel的转换，开发者可以使用最新的JavaScript语法和功能，同时保证代码在各种浏览器中都能够正常运行。这使得开发者能够更加自由地选择和使用新的语言特性，而不必担心兼容性问题。</p><h4 id="16-如何写一个babel插件"><a href="#16-如何写一个babel插件" class="headerlink" title="16.如何写一个babel插件?"></a>16.如何写一个babel插件?</h4><h4 id="17-rebase-与merge的区别"><a href="#17-rebase-与merge的区别" class="headerlink" title="17.rebase 与merge的区别?"></a>17.rebase 与merge的区别?</h4><h4 id="18-git-reset、git-revert和git-checkout有什么区别"><a href="#18-git-reset、git-revert和git-checkout有什么区别" class="headerlink" title="18.git reset、git revert和git checkout有什么区别?"></a>18.git reset、git revert和git checkout有什么区别?</h4><p><code>git reset</code>、<code>git revert</code>和<code>git checkout</code>是Git中用于撤销和回退操作的三个命令，它们的区别如下：</p><ol><li><code>git reset</code>：</li></ol><ul><li><p>作用：<code>git reset</code>用于撤销提交，并且可以移动HEAD指针和分支引用。</p></li><li><p>操作：有三种模式可以使用，分别是</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--soft</span><br></pre></td></tr></table></figure><p>、</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--mixed</span><br></pre></td></tr></table></figure><p>和</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--hard</span><br></pre></td></tr></table></figure><p>。</p><ul><li><code>--soft</code>：仅撤销提交，不会修改暂存区和工作区的内容，可以重新提交。</li><li><code>--mixed</code>（默认模式）：撤销提交，并且会取消暂存区的内容，但不会修改工作区的内容。</li><li><code>--hard</code>：彻底撤销提交，并且会取消暂存区和工作区的所有更改，慎用，数据会被永久删除。</li></ul></li></ul><ol><li><code>git revert</code>：</li></ol><ul><li>作用：<code>git revert</code>用于撤销一个或多个提交，但不会移动HEAD指针和分支引用，而是生成一个新的提交来记录撤销的更改。</li><li>操作：<code>git revert &lt;commit&gt;</code>可以撤销指定的提交，生成一个新的提交来撤销该提交的更改。</li></ul><ol><li><code>git checkout</code>：</li></ol><ul><li>作用：<code>git checkout</code>用于切换分支或恢复文件，也可以用于撤销工作区的更改。</li><li>操作：<code>git checkout &lt;branch&gt;</code>可以切换到指定的分支，<code>git checkout &lt;file&gt;</code>可以恢复指定文件到最新提交的状态，<code>git checkout &lt;commit&gt; &lt;file&gt;</code>可以恢复文件到指定提交的状态。</li></ul><p>总结：</p><ul><li><code>git reset</code>用于撤销提交，并且可以移动HEAD指针和分支引用，慎用。</li><li><code>git revert</code>用于撤销提交，但不会移动HEAD指针和分支引用，生成一个新的提交来记录撤销的更改。</li><li><code>git checkout</code>用于切换分支、恢复文件和撤销工作区的更改。</li></ul><h4 id="19-webpack-和vite区别-模块化与流的区别"><a href="#19-webpack-和vite区别-模块化与流的区别" class="headerlink" title="19.webpack 和vite区别(模块化与流的区别)"></a>19.webpack 和vite区别(模块化与流的区别)</h4><p>Webpack和Vite是两种前端构建工具，它们在模块化和构建方式上有一些区别：</p><ol><li>模块化：</li></ol><p>Webpack使用的是传统的模块化方案，即采用CommonJS或者ES6的模块化规范。在Webpack中，所有的模块都需要提前编译成通用的模块格式，然后再进行打包。</p><p>Vite则使用了现代的ES模块（ESM）模块化方案。在Vite中，开发时的模块是以原生ES模块的形式存在的，不需要提前编译成通用的模块格式。这样可以避免模块编译的过程，加快开发的速度。</p><ol><li>构建方式：</li></ol><p>Webpack是基于Node.js的构建工具，它在构建过程中需要先把所有的模块都加载进内存，再进行编译和打包。因此，Webpack的构建速度相对较慢。</p><p>Vite是基于浏览器的构建工具，它利用了浏览器原生支持ES模块的特性，可以直接在浏览器中进行模块加载和编译。这样可以避免了繁琐的编译过程，使得Vite的构建速度更快。</p><p>总结：</p><p>Webpack是一种通用的构建工具，适用于复杂的项目和多样化的需求。它的优势在于可以处理各种类型的资源，并提供了丰富的Loader和Plugin来满足不同的开发场景。</p><p>Vite是一种专注于开发体验的构建工具，适用于中小型项目和对开发效率要求较高的场景。它利用了浏览器原生支持ES模块的特性，加快了开发速度，但相对于Webpack功能相对较简单。</p><p>选择使用Webpack还是Vite，取决于项目的复杂程度和对开发效率的需求。对于大型项目或复杂的需求，Webpack可能更适合；而对于中小型项目或对开发效率要求较高的场景，Vite可能是更好的选择。</p><h4 id="20-webpack文件指纹策略-hash-chunkhash-contenthash"><a href="#20-webpack文件指纹策略-hash-chunkhash-contenthash" class="headerlink" title="20.webpack文件指纹策略: hash chunkhash contenthash"></a>20.webpack文件指纹策略: hash chunkhash contenthash</h4><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><h4 id="1-做过哪些前端性能优化相关的事情"><a href="#1-做过哪些前端性能优化相关的事情" class="headerlink" title="1.做过哪些前端性能优化相关的事情?"></a>1.做过哪些前端性能优化相关的事情?</h4><h4 id="2-要加载大量图片，你有哪些方法优化方案"><a href="#2-要加载大量图片，你有哪些方法优化方案" class="headerlink" title="2.要加载大量图片，你有哪些方法优化方案?"></a>2.要加载大量图片，你有哪些方法优化方案?</h4><p>加载大量图片可能会影响页面加载速度和用户体验。为了优化加载大量图片的方案，可以考虑以下几点：</p><ol><li><strong>懒加载</strong>：将页面上不可见区域的图片先不加载，等到用户滚动到可见区域时再进行加载。这样可以避免一次性加载大量图片导致页面加载缓慢。</li><li><strong>图片压缩</strong>：使用合适的图片压缩工具来减小图片文件的大小，提高加载速度。可以使用在线图片压缩工具或者通过构建工具进行图片压缩。</li><li><strong>延迟加载</strong>：如果页面上的图片不是首屏必须展示的内容，可以延迟加载这些图片，等到页面其他重要内容加载完毕后再加载图片。</li><li><strong>使用合适的图片格式</strong>：根据图片内容选择合适的图片格式，例如使用JPEG格式对照片进行压缩，使用PNG格式对于图标和透明图片。</li><li><strong>使用图片精灵</strong>：将多个小图片合并为一个大图片，然后通过CSS的background-position属性来显示需要的部分，减少HTTP请求次数。</li><li><strong>使用CDN</strong>：将图片资源放在CDN上，提高图片加载速度，减轻服务器负担。</li><li><strong>使用Base64编码</strong>：将小图片直接转换为Base64编码嵌入到HTML或CSS中，减少图片的HTTP请求。</li><li><strong>利用缓存</strong>：合理设置图片的缓存策略，让浏览器对图片进行缓存，提高二次加载速度。</li><li><strong>预加载</strong>：对于即将出现在页面上的图片，可以使用预加载技术，在首屏加载完成后，提前加载其他页面的图片资源，以提升用户体验。</li><li><strong>图片懒加载占位符</strong>：在图片加载前使用占位符，防止图片未加载时页面布局错乱。</li></ol><p>综合应用上述优化方案，可以有效地提高大量图片的加载性能，优化用户体验。在实际开发中，根据具体场景和需求来选择适合的优化方案。</p><h4 id="3-列表无限滚动，数据越来越多，页面卡顿，如何解决"><a href="#3-列表无限滚动，数据越来越多，页面卡顿，如何解决" class="headerlink" title="3.列表无限滚动，数据越来越多，页面卡顿，如何解决?"></a>3.列表无限滚动，数据越来越多，页面卡顿，如何解决?</h4><h4 id="4-for-let-i-x3D-0-i-lt-1000000-i-console-log-i-如何优化"><a href="#4-for-let-i-x3D-0-i-lt-1000000-i-console-log-i-如何优化" class="headerlink" title="4.for (let i&#x3D;0;i&lt;1000000; i++) {console.log(i)} 如何优化?"></a>4.for (let i&#x3D;0;i&lt;1000000; i++) {console.log(i)} 如何优化?</h4><p>在这个代码中，使用<code>console.log(i)</code>打印1000000个数字会导致浏览器控制台输出大量数据，从而影响性能。为了优化这段代码，可以考虑减少输出的数量或者采用其他方式进行输出。</p><p>一种优化方式是通过条件限制输出的数量，例如只输出前100个数字：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy codefor (let i = 0; i &lt; 1000000; i++) &#123;</span><br><span class="line">  if (i &lt; 100) &#123;</span><br><span class="line">    console.log(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一种方式是使用定时器来控制输出的频率，避免一次性输出大量数据：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy codelet i = 0;</span><br><span class="line">const interval = setInterval(() =&gt; &#123;</span><br><span class="line">  console.log(i);</span><br><span class="line">  i++;</span><br><span class="line">  if (i === 1000000) &#123;</span><br><span class="line">    clearInterval(interval);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, 10); // 每10毫秒输出一个数字</span><br></pre></td></tr></table></figure><p>这样可以控制输出的速度，避免一次性输出大量数据导致性能问题。</p><p>另外，如果只是为了测试性能或者查看数据，可以考虑使用性能分析工具来查看循环的执行时间，而不是直接输出到控制台。例如，在Chrome浏览器中可以使用Performance工具来分析代码的性能表现。</p><h4 id="5-谈谈你是如何判断网站的性能的"><a href="#5-谈谈你是如何判断网站的性能的" class="headerlink" title="5.谈谈你是如何判断网站的性能的?"></a>5.谈谈你是如何判断网站的性能的?</h4><p>判断网站性能可以从多个方面进行评估，以下是一些常见的指标和方法：</p><ol><li><strong>页面加载速度</strong>：测量网站的页面加载速度是评估性能的关键指标之一。可以使用工具如Lighthouse、PageSpeed Insights、WebPageTest等来测试页面的加载速度，并查看各项指标，如首次内容绘制（FCP）、可交互时间（TTI）、DOMContentLoaded事件等。</li><li><strong>网络请求优化</strong>：减少网页的网络请求可以加快页面加载速度。优化图片、CSS和JavaScript文件大小，使用CDN加速静态资源，合并和压缩文件，减少不必要的请求，都是优化网络请求的常见方法。</li><li><strong>缓存策略</strong>：合理使用缓存策略可以减少重复的网络请求，提高网站的性能。设置适当的缓存头，包括缓存过期时间、缓存的资源等，可以有效地减少服务器的负载和页面加载时间。</li><li><strong>响应式设计</strong>：确保网站能够在不同设备和屏幕尺寸上良好地展示，并且能够快速响应用户的操作，提供良好的用户体验。</li><li><strong>代码优化</strong>：优化前端代码，包括JavaScript、CSS和HTML，可以减少页面的加载时间和渲染时间。使用合理的数据结构和算法，避免使用过多的第三方库和插件，精简不必要的代码，都可以提高网站性能。</li><li><strong>服务器性能</strong>：优化服务器的配置和性能，包括使用高性能的服务器和数据库，优化数据库查询，使用缓存和负载均衡等技术，都可以提高网站的响应速度和并发能力。</li><li><strong>监测与分析</strong>：定期监测网站的性能指标，并进行分析，找出性能瓶颈和优化的空间。可以使用工具如Google Analytics、New Relic、GTMetrix等来进行性能监测和分析。</li></ol><p>总的来说，判断网站的性能需要综合考虑多个因素，从前端到后端，从服务器到网络，都需要进行优化和改进。定期进行性能测试和监测，以及持续的优化工作，可以帮助提高网站的性能和用户体验。</p><h4 id="6-解释一下，性能指标FP-FCP-FMP，如何查看。"><a href="#6-解释一下，性能指标FP-FCP-FMP，如何查看。" class="headerlink" title="6.解释一下，性能指标FP FCP FMP，如何查看。"></a>6.解释一下，性能指标FP FCP FMP，如何查看。</h4><h4 id="7-谈谈浏览器的渲染过程，DOM树和渲染树的区别。"><a href="#7-谈谈浏览器的渲染过程，DOM树和渲染树的区别。" class="headerlink" title="7.谈谈浏览器的渲染过程，DOM树和渲染树的区别。"></a>7.谈谈浏览器的渲染过程，DOM树和渲染树的区别。</h4><p>浏览器的渲染过程可以简单地描述为以下几个步骤：</p><ol><li><strong>构建DOM树</strong>：浏览器从顶部的HTML文档开始解析，构建DOM（文档对象模型）树，将HTML标签解析为DOM节点，构成一个树状结构，表示文档的层级结构。</li><li><strong>构建CSSOM树</strong>：同时，浏览器还会解析CSS样式文件，构建CSSOM（CSS对象模型）树，将CSS样式解析为CSS规则，并与DOM树关联，形成一个包含样式信息的树状结构。</li><li><strong>合并成渲染树</strong>：浏览器将DOM树和CSSOM树合并成一个渲染树（Render Tree），渲染树只包含需要显示的节点和样式信息，不包含不需要显示的节点（例如隐藏的元素）或者不影响样式的节点（例如script标签）。</li><li><strong>布局计算</strong>：渲染树中的每个节点都有自己的位置和大小信息，浏览器根据渲染树进行布局计算，确定每个节点在页面中的位置和大小。</li><li><strong>绘制页面</strong>：根据布局计算的结果，浏览器将页面中的每个节点绘制出来，形成最终的页面内容。</li></ol><p>值得注意的是，DOM树和渲染树是两个不同的概念：</p><ul><li><strong>DOM树</strong>：DOM树是由HTML文档解析生成的，它是表示文档内容和结构的树状结构，它包含了HTML标签及其嵌套关系，但不包含样式信息。</li><li><strong>渲染树</strong>：渲染树是由DOM树和CSSOM树合并生成的，它包含了需要显示的节点和样式信息，用于进行页面的布局和绘制。</li></ul><p>渲染树是浏览器最终用于渲染页面的数据结构，因为它只包含需要显示的内容和样式信息，所以渲染树的构建过程是非常高效的，这也是浏览器能够快速渲染页面的重要原因。而DOM树和CSSOM树的构建过程相对较慢，因为它们需要对HTML文档和CSS样式进行解析和处理。因此，在前端开发中，我们可以通过合理优化HTML和CSS的结构，来提高渲染性能。</p><h4 id="8-一个页面从输入URL到页面加载显示完成，这个过程中都发生了什么。"><a href="#8-一个页面从输入URL到页面加载显示完成，这个过程中都发生了什么。" class="headerlink" title="8.一个页面从输入URL到页面加载显示完成，这个过程中都发生了什么。"></a>8.一个页面从输入URL到页面加载显示完成，这个过程中都发生了什么。</h4><p>一个页面从输入URL到页面加载显示完成的过程可以分为以下几个阶段：</p><ol><li><strong>DNS解析</strong>：浏览器首先会对输入的URL进行DNS解析，将域名解析为服务器的IP地址，以便能够发送请求。</li><li><strong>建立TCP连接</strong>：浏览器通过TCP三次握手与服务器建立连接，确保双方能够正常通信。</li><li><strong>发送HTTP请求</strong>：浏览器向服务器发送HTTP请求，请求页面所需的HTML、CSS、JavaScript和其他资源。</li><li><strong>服务器处理请求</strong>：服务器接收到浏览器发送的请求，进行相应的处理，读取数据库或进行其他业务逻辑。</li><li><strong>返回HTTP响应</strong>：服务器将处理结果封装成HTTP响应，包括状态码、内容类型和实际内容等信息，发送回浏览器。</li><li><strong>接收响应数据</strong>：浏览器接收到服务器返回的HTTP响应数据，根据响应中的内容类型确定如何处理数据。</li><li><strong>解析HTML文档</strong>：浏览器解析HTML文档，构建DOM树，并开始加载其中引用的其他资源，如CSS和JavaScript。</li><li><strong>加载资源</strong>：浏览器并行加载HTML中引用的CSS和JavaScript文件，并执行JavaScript代码。</li><li><strong>渲染页面</strong>：浏览器根据DOM树和CSS样式对页面进行渲染，生成渲染树，并绘制页面内容。</li><li><strong>显示页面</strong>：最后，浏览器将渲染好的页面显示在用户的屏幕上，完成整个页面加载过程。</li></ol><p>在这个过程中，还可能会涉及到缓存、重定向、安全校验等其他步骤，不同的网站和网络环境可能会有一些差异。整个过程是一个复杂的协调和交互过程，其中每个步骤都对最终页面加载的速度和性能产生影响。因此，在开发和优化网页时，需要综合考虑各个方面，以提供更好的用户体验。</p><h4 id="9-什么是SPA单页面应用，首屏加载你是如何优化的"><a href="#9-什么是SPA单页面应用，首屏加载你是如何优化的" class="headerlink" title="9.什么是SPA单页面应用，首屏加载你是如何优化的"></a>9.什么是SPA单页面应用，首屏加载你是如何优化的</h4><p>SPA（Single Page Application）单页面应用是指在Web应用中只有一个HTML页面，通过动态加载内容实现页面的切换和更新，而不需要每次加载新的页面。在SPA中，所有的交互都在同一个页面中进行，通过前端路由实现页面切换，提升用户体验和页面加载速度。</p><p>优化首屏加载是SPA中的一个重要任务，因为用户访问网站时，首屏加载速度直接影响用户的第一印象和用户体验。以下是优化SPA首屏加载的一些常见方法：</p><ol><li><strong>代码分割</strong>：使用Webpack等构建工具进行代码分割，将不同页面的代码分割成多个bundle，实现按需加载，减小首屏加载体积。</li><li><strong>懒加载</strong>：将页面中的一些非必要组件或模块进行懒加载，即在需要使用时再进行加载，而不是一开始就全部加载，减少首屏加载时间。</li><li><strong>预加载</strong>：对于用户可能会访问的页面，可以使用预加载技术，在首屏加载完成后，提前加载其他页面的代码和资源，以提升后续页面的加载速度。</li><li><strong>首屏优化</strong>：将首屏需要展示的内容和功能尽量放在HTML的顶部部分，避免用户需要滚动页面才能看到有意义的内容。</li><li><strong>压缩和优化资源</strong>：对CSS、JavaScript、图片等资源进行压缩和优化，减小文件体积，提高加载速度。</li><li><strong>缓存策略</strong>：合理设置缓存策略，让浏览器对静态资源进行缓存，减少重复加载。</li><li><strong>使用CDN</strong>：将静态资源部署到CDN（内容分发网络），提高资源加载速度。</li><li><strong>服务端渲染（SSR）</strong>：对于一些对SEO和首屏加载速度要求较高的页面，可以考虑使用服务器端渲染技术，将首屏内容直接输出到HTML中，减少浏览器加载时间。</li></ol><p>以上方法是优化SPA单页面应用首屏加载的一些常见手段，结合项目实际情况，可以综合应用这些方法来提升用户的首屏加载体验。</p><h2 id="移动web开发"><a href="#移动web开发" class="headerlink" title="移动web开发"></a>移动web开发</h2><h4 id="1-知道PWA吗"><a href="#1-知道PWA吗" class="headerlink" title="1.知道PWA吗"></a>1.知道PWA吗</h4><p>渐进式网络应用程序（PWA）是一组网页技术和设计理念，旨在为用户在移动设备或桌面上访问网站时提供类似原生应用的体验。PWA结合了Web和移动应用程序的最佳功能，使其更快、更可靠、更吸引人。</p><p>渐进式网络应用程序的主要特点和特性包括：</p><ol><li>渐进增强：PWA被设计为在任何设备上工作，无论是什么平台或浏览器，采用了渐进增强的原则。它为所有用户提供基线体验，然后在支持高级功能的设备和浏览器上增强体验。</li><li>响应式设计：PWA采用响应式设计技术构建，确保用户界面在各种屏幕尺寸和方向上适应并运行良好。</li><li>离线支持：PWA可以在网络连接较差或没有网络连接的情况下工作。它利用服务工作者（Service Workers）缓存重要资源，使用户可以在先前访问过的页面或数据处于离线状态下访问。</li><li>类应用体验：PWA被设计成感觉像原生应用，提供平滑的动画、手势支持和沉浸式用户交互。</li><li>推送通知：PWA可以向用户发送推送通知，使得网站能够重新吸引用户并在浏览器关闭时提供及时更新。</li><li>可安装性：用户可以将PWA安装到主屏幕或应用程序抽屉中，就像原生应用一样，使他们无需经过应用商店安装即可快速访问。</li><li>安全：PWA必须通过HTTPS提供，以确保用户数据的安全性，并确保服务工作者能够正常工作。</li><li>可发现性：PWA可被搜索引擎发现，使得它们通过网络搜索轻松访问。</li></ol><p>通过整合这些特性，渐进式网络应用程序弥合了Web和原生应用体验之间的差距，提供了更无缝和愉悦的用户体验。它们在业务和开发者中变得越来越受欢迎，是一种高效的方式，让企业和开发者无需通过应用商店安装即可提供高质量的应用，并且能够大大提高用户的参与和留存率。</p><h4 id="2-移动布局方案"><a href="#2-移动布局方案" class="headerlink" title="2.移动布局方案"></a>2.移动布局方案</h4><p>移动布局方案主要是为了适应不同移动设备的屏幕尺寸和分辨率，确保网页在各种移动设备上都能呈现良好的用户体验。以下是几种常见的移动布局方案：</p><ol><li>响应式布局（Responsive Web Design，RWD）：响应式布局是一种灵活的布局方式，使用CSS媒体查询来根据不同设备的屏幕尺寸和分辨率应用不同的样式规则。通过调整元素的大小、位置和显示方式，以及使用弹性盒子（Flexbox）和网格布局（Grid Layout）等技术，网页可以自动适应不同设备的屏幕尺寸。</li><li>移动优先布局：移动优先布局是指首先针对移动设备设计网页，然后再逐步扩展到更大的屏幕。这种布局方式可以确保网页在移动设备上表现良好，并且可以优雅地适应更大的屏幕，提供更好的用户体验。</li><li>自适应布局：自适应布局是指根据设备的屏幕尺寸和分辨率，采用不同的固定布局或百分比布局。通过设置不同的样式规则，元素的大小和位置可以根据设备的屏幕尺寸进行适配。</li><li>视口布局（Viewport Layout）：视口布局是指通过meta标签设置视口的宽度，使得网页能够在移动设备上正确缩放和显示。可以使用以下meta标签来设置视口：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br></pre></td></tr></table></figure><ol><li>弹性图片：在移动布局中，图片大小和分辨率的适应也很重要。可以使用CSS的max-width属性或通过媒体查询来调整图片大小，确保图片在不同设备上显示合适。</li></ol><p>综合使用上述布局方案，可以实现适应不同移动设备的网页布局，并提供更好的用户体验。在实际开发中，根据具体需求和设计，可以选择其中一种或多种布局方案进行实现。</p><h4 id="3-Rem布局及其优缺点"><a href="#3-Rem布局及其优缺点" class="headerlink" title="3.Rem布局及其优缺点"></a>3.Rem布局及其优缺点</h4><p>Rem（Root Em）布局是一种相对于根元素的字体大小来确定尺寸的布局方式。在Rem布局中，网页中的所有尺寸都是相对于根元素（通常是html元素）的字体大小来计算的，而不是相对于浏览器默认字体大小。</p><p>优点：</p><ol><li>响应式布局：Rem布局能够根据根元素的字体大小自动适应不同屏幕尺寸，实现响应式布局，简化了在不同设备上的开发工作。</li><li>简单易用：只需要设置根元素的字体大小，其他元素的尺寸就可以按照相对大小来设置，减少了对具体尺寸的计算。</li><li>高度可控：由于所有尺寸都是相对于根元素的字体大小来计算的，开发者可以通过设置根元素的字体大小来统一调整整个页面的尺寸。</li><li>提高性能：使用Rem布局，可以减少在页面中使用固定尺寸的元素，从而减少页面重绘和回流的次数，提高性能。</li></ol><p>缺点：</p><ol><li>兼容性：Rem布局在一些老旧的浏览器中可能不兼容，需要做兼容性处理。</li><li>学习成本：对于一些初学者来说，可能需要一定的学习成本来理解和使用Rem布局。</li></ol><p>为了解决一些Rem布局的缺点，一些开发者可能会选择使用postcss-pxtorem等工具来自动将固定尺寸的像素值转换成Rem单位，从而简化开发过程。综合来看，Rem布局在现代web开发中是一种非常实用的布局方式，特别适合用于移动端开发和响应式设计。</p><h4 id="4-讲讲viewport和移动端布局"><a href="#4-讲讲viewport和移动端布局" class="headerlink" title="4.讲讲viewport和移动端布局"></a>4.讲讲viewport和移动端布局</h4><p>Viewport 是一个浏览器提供的窗口视口（viewport），它用于决定网页的初始显示尺寸和缩放比例，从而在移动设备上呈现合适的页面布局。在移动端，由于不同设备的屏幕尺寸和像素密度不同，使用Viewport 可以确保网页在不同移动设备上获得一致的展示效果。</p><p>移动端布局的目标是使网页在不同设备上显示良好，并提供优秀的用户体验。常见的移动端布局方案包括：</p><ol><li>响应式布局（Responsive Web Design，RWD）：使用 CSS 媒体查询来根据不同设备的屏幕尺寸和方向，应用不同的样式规则。响应式布局可以使网页自适应各种屏幕尺寸，提供良好的用户体验。</li><li>移动优先布局：移动优先布局是一种设计理念，首先将网页针对移动设备进行设计，然后再逐渐扩展到更大的屏幕。移动优先布局可以确保网页在移动设备上表现出色，并适应更大屏幕的设备。</li><li>视口布局（Viewport Layout）：通过 meta 标签设置视口（viewport）的宽度，使得网页能够在移动设备上正确缩放和显示。使用以下 meta 标签来设置视口：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">htmlCopy code</span><br><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br></pre></td></tr></table></figure><ol><li>弹性图片：在移动布局中，图片大小和分辨率的适应也很重要。可以使用 CSS 的 max-width 属性或通过媒体查询来调整图片大小，确保图片在不同设备上显示合适。</li><li>CSS3 媒体查询：通过 CSS3 的媒体查询，可以根据不同的屏幕尺寸、方向或像素密度应用不同的样式规则，从而实现更精确的移动端布局。</li></ol><p>综合使用上述布局方案，可以实现适应不同移动设备的网页布局，并提供更好的用户体验。在实际开发中，需要根据具体的需求和设计选择合适的移动端布局方案。</p><h4 id="5-移动端适配1px的问题"><a href="#5-移动端适配1px的问题" class="headerlink" title="5.移动端适配1px的问题"></a>5.移动端适配1px的问题</h4><p>在移动端适配中，处理1px问题是为了解决不同设备的像素密度（DPR，Device Pixel Ratio）差异，避免在高像素密度的设备上显示边框、线条等细节时出现虚化或粗细变化的问题。通常，移动设备的像素密度是1x、2x、3x等，而CSS中的像素单位是逻辑像素（CSS Pixel），与设备像素密度有关。</p><p>解决移动端1px问题的常用方法有：</p><ol><li>使用 border-image: 通过设置border-image属性来实现1px的边框效果，可以解决1px边框虚化的问题。</li><li>使用 transform: scale: 可以通过transform属性的scale缩放来实现1px边框，这样可以避免使用细线条，从而避免粗细变化。</li><li>使用伪元素 + transform: scale: 通过添加伪元素，并对伪元素进行scale缩放来实现1px边框的效果。</li><li>使用viewport单位：可以使用vw（视口宽度的百分比）单位来设置1px边框，这样可以根据设备宽度来适配1px效果。</li><li>使用flexible布局：可以使用lib-flexible等库来自动处理不同设备的像素密度差异，实现1px边框的适配。</li><li>使用@media媒体查询：可以通过媒体查询根据不同设备的像素密度设置不同的1px样式。</li></ol><p>需要注意的是，不同的解决方案适用于不同的场景，选择合适的方法取决于具体项目需求和开发环境。综合考虑兼容性、性能和开发复杂度等因素，可以选择最适合的解决方案来解决移动端1px问题。</p><h4 id="6-移动端性能优化相关经验"><a href="#6-移动端性能优化相关经验" class="headerlink" title="6.移动端性能优化相关经验"></a>6.移动端性能优化相关经验</h4><p>移动端性能优化对于提升用户体验、减少资源消耗和增加网页可用性都非常重要。以下是一些移动端性能优化的相关经验：</p><ol><li>图片优化：使用合适的图片格式（如WebP），对图片进行压缩和裁剪，以减少图片的大小和加载时间。</li><li>延迟加载：对于非首屏展示的内容，使用延迟加载技术，只在需要时加载资源，减少首次加载时间。</li><li>使用CDN：使用内容分发网络（CDN）来加速资源的传输，使资源可以从离用户更近的服务器获取，提高加载速度。</li><li>压缩资源：对CSS、JavaScript和HTML等静态资源进行压缩和合并，减少文件大小，提高加载速度。</li><li>避免重定向：尽量避免页面的重定向，减少请求次数和加载时间。</li><li>使用缓存：合理设置缓存策略，使页面内容可以在客户端缓存，减少重复请求，提高访问速度。</li><li>减少HTTP请求：合并CSS和JavaScript文件，减少HTTP请求次数，提高页面加载速度。</li><li>使用CSS动画：使用CSS动画替代JavaScript动画，以减少CPU和内存的消耗。</li><li>优化DOM操作：避免频繁的DOM操作，尽量减少重排和重绘，优化页面渲染性能。</li><li>使用Web Workers：对于耗时的计算和处理，可以使用Web Workers在后台进行，避免阻塞主线程，提高页面性能。</li><li>移除不必要的插件和库：只加载必要的插件和库，避免加载不必要的资源，减少页面加载时间。</li><li>优化字体：选择合适的字体格式和字体大小，减少字体文件的大小，提高页面加载速度。</li></ol><p>综合使用以上优化方法，可以显著提升移动端网页的性能，提供更好的用户体验。在实际项目中，需要根据具体情况进行性能分析和优化，不断优化和改进，以实现最佳的性能表现。</p><h4 id="7-移动端兼容性"><a href="#7-移动端兼容性" class="headerlink" title="7.移动端兼容性"></a>7.移动端兼容性</h4><p>移动端兼容性是指网页在不同移动设备和不同浏览器中的展示效果和功能兼容性。由于移动设备和浏览器的多样性，网页在不同设备上可能会出现样式错乱、功能不可用等问题。为了确保移动端网页能够在各种设备上正常运行，需要注意以下一些兼容性问题：</p><ol><li>浏览器兼容性：不同移动设备使用不同的浏览器，如iOS上使用Safari，安卓上使用Chrome、UC等。需要测试网页在不同浏览器中的兼容性，并及时修复兼容性问题。</li><li>分辨率和像素密度：移动设备的屏幕尺寸、分辨率和像素密度差异较大，需要使用响应式布局或移动优先布局来适应不同设备的屏幕尺寸。</li><li>触摸事件和手势：在移动设备上，用户主要使用触摸事件和手势操作，需要确保网页对触摸事件和手势操作的支持良好。</li><li>CSS3和HTML5支持：一些较旧的移动设备和浏览器可能不支持CSS3和HTML5的新特性，需要适当地使用polyfill和垫片来提供兼容性支持。</li><li>JavaScript兼容性：不同移动设备上的JavaScript引擎可能存在差异，需要测试网页在不同设备上的JavaScript兼容性，并做好兼容性处理。</li><li>性能优化：移动设备的性能相对较弱，需要注意优化网页的性能，减少HTTP请求、压缩资源、合并文件等，以提高网页的加载速度和响应性能。</li><li>移动设备特性：一些移动设备具有特殊的硬件和功能，如GPS、加速度计、摄像头等，可以利用这些特性来提供更丰富的功能和交互体验。</li></ol><p>总的来说，移动端兼容性是移动端开发中不可忽视的重要问题。在开发过程中，需要测试和优化网页在不同移动设备和浏览器中的兼容性，并根据具体需求选择合适的兼容性方案。</p><h4 id="8-小程序"><a href="#8-小程序" class="headerlink" title="8.小程序"></a>8.小程序</h4><p>小程序的移动端界面开发主要涉及到WXML（WeiXin Markup Language）和WXSS（WeiXin Style Sheet）的使用，同时需要考虑移动设备的特性和响应式布局。</p><p>以下是小程序移动端界面开发的一些关键点：</p><ol><li>使用WXML构建页面结构：WXML类似于HTML，用于构建页面的结构。在WXML中，可以使用小程序提供的组件来构建页面，也可以自定义组件。合理使用视图容器和布局组件可以实现页面的良好排版。</li><li>使用WXSS定义页面样式：WXSS类似于CSS，用于定义页面的样式。在移动端开发中，需要考虑不同设备的屏幕大小和像素密度，使用相对单位（如rpx）可以实现页面的响应式布局。</li><li>优化图片资源：移动设备的带宽和性能有限，需要优化图片资源的大小和加载速度。使用合适的图片格式和压缩工具可以提高页面加载速度。</li><li>响应式布局：针对不同屏幕大小和设备方向，可以使用弹性盒子布局（Flexbox）或栅格布局来实现响应式布局，以适应不同设备的显示效果。</li><li>触摸事件处理：在移动端界面开发中，需要处理用户的触摸事件，如点击、滑动、拖拽等。通过绑定合适的事件处理函数，可以实现页面的交互效果。</li><li>移动端特性考虑：在移动端开发中，需要考虑到用户操作习惯和设备特性，如触摸滑动、横竖屏切换、手势操作等。</li><li>良好的用户体验：移动端界面开发需要注重用户体验，如页面加载速度、交互效果、页面布局等，保证用户在移动设备上的良好体验。</li><li>调试和预览：在开发过程中，可以使用小程序开发者工具进行实时调试和预览，以便及时发现和解决问题。</li></ol><p>总的来说，小程序的移动端界面开发需要考虑到页面的结构、样式和交互，同时要注重移动设备的特性和用户体验，通过合理的布局和优化，打造出用户友好的移动端应用。</p><h4 id="9-2X图3X图适配"><a href="#9-2X图3X图适配" class="headerlink" title="9.2X图3X图适配"></a>9.2X图3X图适配</h4><p>在移动端开发中，2X图和3X图是为了适配不同像素密度的设备而准备的不同分辨率的图片。移动设备通常分为1X、2X、3X等不同像素密度的设备，其中2X设备的像素密度是1X的两倍，3X设备的像素密度是1X的三倍。</p><p>为了在不同像素密度的设备上展示高清晰度的图片，我们通常会提供2X和3X两种分辨率的图片，然后在CSS中根据设备的像素密度来选择合适的图片。假设我们有一张图片叫做image.png，那么在项目中，我们会准备以下三种图片：</p><ul><li>image.png：1X图，通常为图片的原始分辨率。</li><li><a href="mailto:image@2x.png">image@2x.png</a>：2X图，分辨率是1X图的两倍，用于2X像素密度的设备。</li><li><a href="mailto:image@3x.png">image@3x.png</a>：3X图，分辨率是1X图的三倍，用于3X像素密度的设备。</li></ul><p>在CSS中，我们可以使用媒体查询来选择合适的图片。例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* 默认使用1X图 */</span><br><span class="line">.image &#123;</span><br><span class="line">  background-image: url(&#x27;image.png&#x27;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 2X像素密度的设备使用2X图 */</span><br><span class="line">@media only screen and (-webkit-min-device-pixel-ratio: 2),</span><br><span class="line">       only screen and (min-resolution: 192dpi) &#123;</span><br><span class="line">  .image &#123;</span><br><span class="line">    background-image: url(&#x27;image@2x.png&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 3X像素密度的设备使用3X图 */</span><br><span class="line">@media only screen and (-webkit-min-device-pixel-ratio: 3),</span><br><span class="line">       only screen and (min-resolution: 288dpi) &#123;</span><br><span class="line">  .image &#123;</span><br><span class="line">    background-image: url(&#x27;image@3x.png&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，在不同像素密度的设备上，会自动选择合适的图片，从而保证图片显示的清晰度和质量。通过使用2X图和3X图的适配方式，我们可以提供更好的用户体验，同时也避免了在高像素密度设备上出现模糊或失真的问题。</p><h4 id="10-图片在安卓上，有些设备模糊问题"><a href="#10-图片在安卓上，有些设备模糊问题" class="headerlink" title="10.图片在安卓上，有些设备模糊问题"></a>10.图片在安卓上，有些设备模糊问题</h4><p>在安卓设备上出现图片模糊问题通常与设备的像素密度（DPI）和图片的分辨率有关。安卓设备通常分为不同的像素密度，例如1X、1.5X、2X、3X等，不同的设备使用不同的像素密度，从而影响了图片在设备上的显示效果。</p><p>如果在某些安卓设备上出现了图片模糊问题，可以尝试以下几种解决方法：</p><ol><li>提供高分辨率图片：确保图片的分辨率足够高，特别是针对高像素密度的设备，提供更高分辨率的图片可以避免模糊问题。</li><li>使用矢量图：对于一些图标和矢量图形，可以考虑使用SVG格式的矢量图，这样可以无损缩放，适应不同像素密度的设备。</li><li>使用2X和3X图：根据设备的像素密度提供不同分辨率的图片，如之前提到的2X图和3X图适配方式，确保图片在不同设备上显示清晰。</li><li>使用CSS缩放：在某些情况下，可以使用CSS的transform属性来对图片进行缩放，以适应不同设备的像素密度，但需要注意缩放后可能出现细节损失。</li><li>使用viewport标签：确保在HTML的head标签中添加viewport标签，正确设置viewport的缩放和宽度，以保证页面在不同设备上正确显示。</li></ol><p>总的来说，图片模糊问题在安卓设备上可能由于像素密度差异造成，可以通过提供高分辨率图片、使用矢量图、适配不同像素密度等方法来解决。同时，建议在开发过程中多进行测试，确保网页在不同设备上显示效果良好。</p><h4 id="11-固定定位布局键盘挡住输入框内容"><a href="#11-固定定位布局键盘挡住输入框内容" class="headerlink" title="11.固定定位布局键盘挡住输入框内容"></a>11.固定定位布局键盘挡住输入框内容</h4><p>在移动端开发中，当使用固定定位（<code>position: fixed</code>）布局时，的确会遇到键盘挡住输入框内容的问题。这种情况通常发生在用户点击输入框进行输入时，键盘会弹出覆盖在页面上方，可能会遮挡住部分内容，特别是底部的输入框。</p><p>为了解决这个问题，可以采用以下几种方法：</p><ol><li>输入框聚焦时自动滚动：可以通过监听输入框的<code>focus</code>事件，在键盘弹出时自动滚动页面，使输入框不被键盘遮挡。可以使用<code>scrollIntoView</code>方法将输入框滚动到可视区域内。</li><li>键盘事件监听：监听键盘弹出和收起事件，根据键盘的高度调整页面布局。可以使用<code>window.onresize</code>事件监听键盘弹出和收起。</li><li>使用CSS样式：在键盘弹出时，可以通过CSS样式对输入框的位置进行调整，使其不被键盘遮挡。可以使用<code>@media</code>查询或<code>window.matchMedia</code>方法来检测键盘弹出和收起，然后通过CSS样式进行调整。</li><li>使用viewport单位：使用<code>vh</code>（视窗高度单位）来设置元素的高度，使其随着视窗高度的变化而变化，可以避免键盘遮挡问题。</li></ol><p>需要注意的是，不同设备和浏览器可能会有不同的行为和兼容性问题，因此在解决键盘遮挡问题时，需要进行充分的测试和调试，确保在各种情况下都能有良好的用户体验。同时，建议在设计和布局页面时尽量避免将重要的输入框放在页面底部，以减少键盘遮挡问题的发生。</p><h4 id="12-click-的300ms延迟问题和点击穿透问题"><a href="#12-click-的300ms延迟问题和点击穿透问题" class="headerlink" title="12.click 的300ms延迟问题和点击穿透问题"></a>12.click 的300ms延迟问题和点击穿透问题</h4><p>点击延迟问题（300ms延迟问题）和点击穿透问题都是在移动端开发中常见的问题，特别是在使用浏览器的默认click事件时可能会出现。以下是对这两个问题的解释和解决方案：</p><ol><li><p>点击延迟问题（300ms延迟问题）： 点击延迟问题是指在移动设备上，浏览器默认对于双击缩放（double tap to zoom）的处理机制。当用户点击页面上的一个可点击元素（例如链接、按钮等）时，浏览器会等待300毫秒的时间来判断用户是否在进行双击缩放操作。如果没有进行双击缩放操作，则触发点击事件。</p><p>解决方案：为了解决点击延迟问题，可以采用以下方法之一：</p><ul><li>使用<code>touchstart</code>或<code>touchend</code>事件来代替<code>click</code>事件，这样可以避免延迟问题，但可能会导致点击穿透问题。</li><li>使用<code>fastclick</code>库或<code>zepto.js</code>等移动端框架，这些框架都对点击延迟问题进行了处理。</li></ul></li><li><p>点击穿透问题： 点击穿透问题是指当一个元素在点击事件触发后，底层的元素也会被点击。这种情况通常发生在触发了一个点击事件后，上层元素消失（如弹窗关闭），而下层的元素被穿透点击。</p><p>解决方案：为了解决点击穿透问题，可以采用以下方法之一：</p><ul><li>使用<code>touchend</code>事件来代替<code>click</code>事件，因为<code>touchend</code>事件在元素消失之后不会继续传递，可以避免点击穿透问题。</li><li>使用<code>preventDefault</code>或<code>stopPropagation</code>方法来阻止事件冒泡，防止事件继续传递到底层元素。</li></ul></li></ol><p>需要注意的是，对于一些特殊场景，可能需要综合考虑点击延迟问题和点击穿透问题，采用合适的解决方案来确保良好的用户体验。同时，在移动端开发中，建议使用更适合移动设备的交互方式，如使用<code>touch</code>事件来代替<code>click</code>事件，避免延迟和穿透问题的出现。</p><h4 id="13-防止手机中页面放大和缩小"><a href="#13-防止手机中页面放大和缩小" class="headerlink" title="13.防止手机中页面放大和缩小"></a>13.防止手机中页面放大和缩小</h4><p>防止手机中页面放大和缩小，通常涉及到以下几个方面的考虑：</p><ol><li><p>禁用双击缩放：通过设置<code>meta</code>标签中的<code>user-scalable</code>属性来禁用双击缩放功能。将<code>user-scalable</code>属性设置为<code>no</code>可以防止用户在手机上通过双击页面来进行缩放操作。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no&quot;&gt;</span><br></pre></td></tr></table></figure></li><li><p>禁用手势缩放：通过CSS样式来禁用手势缩放功能。在某些浏览器中，用户可以使用手势缩放页面，通过以下CSS样式可以阻止手势缩放。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">  touch-action: pan-x pan-y;</span><br><span class="line">  /* 或者 */</span><br><span class="line">  touch-action: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>固定viewport尺寸：在<code>meta</code>标签中，将<code>viewport</code>的<code>width</code>设置为固定值，可以防止页面根据设备的宽度自动缩放。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">htmlCopy code</span><br><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=375, initial-scale=1.0&quot;&gt;</span><br></pre></td></tr></table></figure></li></ol><p>需要注意的是，禁用页面缩放可能会影响用户体验，特别是对于一些视力较差的用户。因此，在进行这些设置时，需要谨慎考虑，并进行充分的测试，确保在各种设备上都能有良好的用户体验。</p><h4 id="14-px、em、rem、-、vw、-vh、vm这些单位的区别"><a href="#14-px、em、rem、-、vw、-vh、vm这些单位的区别" class="headerlink" title="14.px、em、rem、 %、vw、 vh、vm这些单位的区别"></a>14.px、em、rem、 %、vw、 vh、vm这些单位的区别</h4><p>这些单位是用于前端开发中进行长度和尺寸的表示的，它们的区别如下：</p><ol><li>px（像素）：像素是屏幕上显示的最小单位，1px表示一个像素点。px是一个绝对单位，它在不同设备上具有相同的物理尺寸，但在高分辨率屏幕上可能会显得较小。</li><li>em：em是相对于父元素的字体大小的单位。如果父元素的字体大小是16px，1em就等于16px，2em就等于32px，以此类推。</li><li>rem：rem也是相对于根元素（html元素）的字体大小的单位。rem与em不同的是，rem的参考是根元素的字体大小，而em的参考是其父元素的字体大小。rem可以用于实现响应式布局，因为它的值不会受到父元素的影响。</li><li>%：百分比是相对于父元素的尺寸的百分比。例如，如果一个元素的宽度设置为50%，它将会是其父元素宽度的一半。</li><li>vw（视口宽度）：vw是相对于视口宽度的单位，1vw表示视口宽度的1%。例如，如果视口宽度为1000px，1vw将等于10px。</li><li>vh（视口高度）：vh是相对于视口高度的单位，1vh表示视口高度的1%。例如，如果视口高度为800px，1vh将等于8px。</li><li>vm：vm是相对于视口宽度和高度中较小的那个的单位。例如，如果视口宽度为1000px，视口高度为800px，1vm将等于8px（较小的值）。</li></ol><p>不同的单位在不同的场景下有不同的用途。px是绝对单位，常用于确定元素的固定大小；em和rem是相对单位，常用于实现相对于字体大小的缩放；%常用于相对于父元素的大小进行缩放；vw、vh、vm常用于实现响应式布局，相对于视口的大小进行缩放。在选择使用哪种单位时，需要根据具体的需求和设计进行选择。</p><h4 id="15-移动端适配-dpr浅析"><a href="#15-移动端适配-dpr浅析" class="headerlink" title="15.移动端适配-dpr浅析"></a>15.移动端适配-dpr浅析</h4><p>在移动端适配中，dpr（设备像素比）是一个非常重要的概念。设备像素比指的是设备的物理像素与逻辑像素的比例关系，它用来衡量设备屏幕的清晰度和显示效果。通常情况下，dpr的值为1、2或3，不同的设备有不同的dpr值。</p><p>一般来说，dpr越高，设备的屏幕显示越清晰，同时也意味着设备像素越多，页面元素需要更多的物理像素来渲染。因此，在移动端适配中，我们需要根据设备的dpr值来调整页面的布局和尺寸，以保证页面在不同dpr设备上的显示效果一致。</p><p>常见的dpr值及对应的设备类型：</p><ul><li>dpr为1：普通屏幕，如老款iPhone、普通Android手机。</li><li>dpr为2：高清屏幕，如iPhone Retina系列、高配Android手机。</li><li>dpr为3：超高清屏幕，如iPhone Plus系列、高配Android手机。</li></ul><p>为了实现移动端适配，我们通常会使用以下方法：</p><ol><li>使用viewport设置：通过设置<code>&lt;meta&gt;</code>标签中的<code>viewport</code>属性，根据设备的dpr值来调整页面缩放比例和显示效果。</li><li>使用rem单位：通过设置<code>&lt;html&gt;</code>元素的<code>font-size</code>为屏幕宽度的一定比例，然后使用rem单位来设置元素的尺寸，从而实现根据屏幕宽度自适应调整。</li><li>使用媒体查询：根据设备的dpr值和屏幕宽度，使用CSS媒体查询来适配不同的设备。</li></ol><p>综合使用以上方法，可以实现移动端适配，保证页面在不同设备上显示效果良好，避免出现错位、模糊等问题。</p><h4 id="16-移动端扩展点击区域"><a href="#16-移动端扩展点击区域" class="headerlink" title="16.移动端扩展点击区域"></a>16.移动端扩展点击区域</h4><p>在移动端开发中，有时候为了提高用户体验，可以通过扩展点击区域来增加点击目标的触发区域，使用户更容易点击到目标元素，特别是对于小尺寸的元素或者靠近屏幕边缘的元素。这样做可以减少用户误操作，提高页面的可用性。</p><p>有几种常见的方法可以实现移动端扩展点击区域：</p><ol><li>使用padding：为目标元素设置一定的padding值，这样可以增加元素的点击区域，但不改变元素的布局。</li><li>使用透明的伪元素：通过为目标元素添加一个透明的伪元素，将伪元素放置在目标元素周围，从而增加点击区域。</li><li>使用绝对定位和负边距：将目标元素设置为绝对定位，并为其设置负边距，使其超出父容器，从而增加点击区域。</li><li>使用透明图片：为目标元素设置一个透明的图片作为背景，将图片设置为合适的尺寸，从而增加点击区域。</li></ol><p>需要注意的是，在扩展点击区域时，要确保不会影响到其他元素的布局和交互。同时，要进行充分的测试，确保在不同设备上点击效果正常，不会产生误操作或影响用户体验。在实际开发中，根据具体的情况选择合适的方法来实现扩展点击区域，以提升用户体验。</p><h4 id="17-上下拉动滚动条时卡顿、慢"><a href="#17-上下拉动滚动条时卡顿、慢" class="headerlink" title="17.上下拉动滚动条时卡顿、慢"></a>17.上下拉动滚动条时卡顿、慢</h4><p>卡顿和慢的滚动体验通常是由于页面过多的元素或复杂的渲染引起的。在移动端开发中，特别是在滚动长页面时，可以采取以下措施来优化滚动性能：</p><ol><li>减少页面元素：尽量减少页面中不必要的元素，包括文字、图片和其他内容。页面中的元素越多，浏览器需要处理的内容也就越多，导致滚动体验变慢。</li><li>图片优化：确保图片尺寸适当，并使用合适的图片格式，例如JPEG和WebP格式，以减少图片的加载时间和文件大小。</li><li>使用CSS硬件加速：使用CSS属性<code>transform</code>和<code>will-change</code>来触发GPU硬件加速，从而优化页面的滚动和动画性能。</li><li>避免复杂的CSS选择器和样式：复杂的CSS选择器和样式会增加页面的渲染和布局计算时间，尽量使用简单的选择器和样式。</li><li>使用虚拟滚动：对于长列表或大量数据的滚动，可以考虑使用虚拟滚动技术，只渲染可见区域的内容，减少不必要的渲染。</li><li>使用防抖和节流：对于滚动事件和其他频繁触发的事件，可以使用防抖和节流技术来降低事件触发的频率，减少不必要的计算和操作。</li><li>使用合适的滚动库：对于复杂的滚动需求，可以考虑使用优化过的滚动库，例如iScroll、better-scroll等，以获得更流畅的滚动体验。</li></ol><p>通过以上优化措施，可以有效改善页面滚动时的卡顿和慢的问题，提升用户体验。同时，优化滚动性能也需要综合考虑页面的整体结构和内容，尽量避免过度复杂和冗余的内容，使页面保持简洁和高效。</p><h4 id="18-长时间按住页面出现闪退"><a href="#18-长时间按住页面出现闪退" class="headerlink" title="18.长时间按住页面出现闪退"></a>18.长时间按住页面出现闪退</h4><p>长时间按住页面可能导致页面出现闪退的问题是因为浏览器或设备对于长时间的触摸事件进行了处理，可能会触发浏览器或设备的某些保护机制，导致页面崩溃或闪退。</p><p>这种问题通常是由于页面处理长时间触摸事件的能力不足，或者页面代码中存在一些性能问题导致的。为了避免页面出现闪退问题，可以考虑以下几个方面的优化：</p><ol><li>避免过度复杂的事件处理：如果页面上有复杂的事件处理逻辑，尤其是长时间触摸事件的处理逻辑，可能会影响页面的性能。尽量简化事件处理逻辑，避免过多的计算和操作。</li><li>使用防抖和节流：对于长时间触摸事件，可以使用防抖和节流技术来控制事件的触发频率，从而避免过多的事件触发导致性能问题。</li><li>优化页面性能：检查页面代码，确保页面中没有冗余的代码和过度复杂的DOM结构。优化图片和资源加载，减少不必要的网络请求。尽量避免使用过多的动画效果和复杂的布局。</li><li>测试不同设备和浏览器：不同设备和浏览器对于长时间触摸事件的处理可能有所不同。在开发过程中，应该测试页面在不同设备和浏览器上的表现，及时发现和解决潜在的问题。</li></ol><p>如果页面在长时间触摸时仍然出现闪退问题，建议使用开发者工具查看浏览器的错误日志，以便更好地了解问题的具体原因，并进行针对性的优化。在优化页面性能时，需要综合考虑页面的整体结构和功能，寻找最优的解决方案，以提供更好的用户体验。</p><h4 id="19-webkit-mask兼容处理"><a href="#19-webkit-mask兼容处理" class="headerlink" title="19.webkit mask兼容处理"></a>19.webkit mask兼容处理</h4><p>WebKit是一种浏览器引擎，主要用于苹果的Safari浏览器和谷歌的Chrome浏览器。其中，<code>-webkit-mask</code>是WebKit引擎中用于实现元素遮罩的CSS属性。</p><p>由于不同浏览器对CSS属性的支持不同，为了确保在各种浏览器中正确显示元素遮罩，需要进行兼容处理。以下是一些常见的兼容处理方法：</p><ol><li>使用<code>-webkit-mask</code>和<code>mask</code>属性：为了在WebKit浏览器中正确显示元素遮罩，可以同时使用<code>-webkit-mask</code>和<code>mask</code>属性。例如：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.element &#123;</span><br><span class="line">  -webkit-mask: url(&#x27;mask.png&#x27;) no-repeat center;</span><br><span class="line">  mask: url(&#x27;mask.png&#x27;) no-repeat center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>使用浏览器引擎前缀：为了兼容不同浏览器，可以使用浏览器引擎前缀来设置元素遮罩。例如：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.element &#123;</span><br><span class="line">  -webkit-mask: url(&#x27;mask.png&#x27;) no-repeat center;</span><br><span class="line">  -moz-mask: url(&#x27;mask.png&#x27;) no-repeat center;</span><br><span class="line">  mask: url(&#x27;mask.png&#x27;) no-repeat center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>使用媒体查询：如果元素遮罩只在特定的浏览器或设备上需要兼容处理，可以使用媒体查询来针对不同的浏览器引擎设置元素遮罩。例如：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.element &#123;</span><br><span class="line">  mask: url(&#x27;mask.png&#x27;) no-repeat center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@media screen and (-webkit-min-device-pixel-ratio: 0) &#123;</span><br><span class="line">  .element &#123;</span><br><span class="line">    -webkit-mask: url(&#x27;mask.png&#x27;) no-repeat center;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>使用JavaScript检测：如果以上方法仍无法解决兼容性问题，可以使用JavaScript来检测浏览器引擎，并根据浏览器类型动态添加合适的样式。</li></ol><p>总之，兼容WebKit引擎的方法主要是使用<code>-webkit-mask</code>和<code>mask</code>属性，并结合浏览器引擎前缀和媒体查询来进行处理。根据具体的需求和兼容性要求，选择合适的方法来确保元素遮罩在不同浏览器中正常显示。</p><h4 id="20-transiton-闪屏"><a href="#20-transiton-闪屏" class="headerlink" title="20.transiton 闪屏"></a>20.transiton 闪屏</h4><p>在使用CSS的<code>transition</code>属性时，有时会出现闪屏的问题，特别是在使用<code>transform</code>属性进行动画过渡时。这是由于浏览器的优化机制造成的，浏览器会对<code>transform</code>属性进行硬件加速，导致元素在开始动画过渡时会先进行一次重绘，然后再执行动画，造成闪屏的效果。</p><p>为了避免<code>transition</code>闪屏问题，可以尝试以下几个方法：</p><ol><li>使用<code>transform</code>属性进行动画：<code>transform</code>属性是一种CSS硬件加速属性，因此动画会更加流畅。尽量避免使用其他需要重绘的属性，如<code>width</code>、<code>height</code>、<code>top</code>、<code>left</code>等，以减少重绘带来的闪屏问题。</li><li>使用<code>will-change</code>属性：<code>will-change</code>属性可以提示浏览器该元素将要进行动画效果，从而使浏览器提前做好优化准备。例如：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.element &#123;</span><br><span class="line">  will-change: transform;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>使用<code>translateZ(0)</code>进行强制3D加速：通过给元素添加<code>transform: translateZ(0)</code>，强制开启3D加速，可以减少闪屏问题。但是需要注意，不要在不需要硬件加速的情况下滥用3D加速，以免造成不必要的性能损耗。</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.element &#123;</span><br><span class="line">  transform: translateZ(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>使用<code>requestAnimationFrame</code>代替<code>setTimeout</code>或<code>setInterval</code>：在实现动画时，使用<code>requestAnimationFrame</code>代替<code>setTimeout</code>或<code>setInterval</code>可以更好地与浏览器的重绘机制同步，避免闪屏问题。</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function animate() &#123;</span><br><span class="line">  // 动画操作</span><br><span class="line">  requestAnimationFrame(animate);</span><br><span class="line">&#125;</span><br><span class="line">animate();</span><br></pre></td></tr></table></figure><p>总体而言，<code>transition</code>闪屏问题主要是由浏览器的优化机制造成的。通过合理使用CSS硬件加速属性、<code>will-change</code>属性和<code>requestAnimationFrame</code>方法，可以有效减少闪屏问题，提升页面动画的流畅性和用户体验。</p><h2 id="研发流程"><a href="#研发流程" class="headerlink" title="研发流程"></a>研发流程</h2><h2 id="Nodejs"><a href="#Nodejs" class="headerlink" title="Nodejs"></a>Nodejs</h2><h4 id="1-对Node-js有没有了解，它有什么特点，适合做什么业务"><a href="#1-对Node-js有没有了解，它有什么特点，适合做什么业务" class="headerlink" title="1.对Node.js有没有了解，它有什么特点，适合做什么业务"></a>1.对Node.js有没有了解，它有什么特点，适合做什么业务</h4><p>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行时环境，它使 JavaScript 可以在服务器端运行。Node.js 具有以下特点：</p><ol><li>非阻塞、异步 I&#x2F;O：Node.js 采用事件驱动、非阻塞 I&#x2F;O 模型，使得它能够高效处理大量并发请求，适用于高性能的网络应用。</li><li>单线程：Node.js 是单线程的，但通过事件循环机制和异步非阻塞 I&#x2F;O 实现了并发处理。这使得它能够处理高并发请求而不会导致线程阻塞。</li><li>轻量和高效：Node.js 是一个轻量级的运行时环境，具有高度的可伸缩性和低系统资源消耗，适用于构建高效的服务器应用。</li><li>统一的编程语言：Node.js 使用 JavaScript 作为编程语言，这使得前端开发人员能够在服务器端使用相同的语言和技术栈，简化了开发流程。</li><li>NPM：Node.js 附带了 NPM（Node Package Manager），是一个强大的包管理工具，提供了大量的开源库和模块，方便开发人员进行代码共享和复用。</li></ol><p>适合使用 Node.js 的业务包括：</p><ol><li>实时应用：Node.js 在处理高并发、实时通信的场景下表现优秀，适合构建实时聊天应用、多人在线游戏等。</li><li>Web 服务：Node.js 可以快速构建高性能的 Web 服务，适合构建 RESTful API、后端服务等。</li><li>微服务架构：Node.js 的轻量特性和高并发能力使其成为构建微服务架构的理想选择。</li><li>I&#x2F;O 密集型任务：Node.js 的异步非阻塞 I&#x2F;O 特性适合处理 I&#x2F;O 密集型任务，如文件读写、数据库操作等。</li><li>服务器端渲染：Node.js 可以用于服务器端渲染，将动态数据嵌入到网页模板中，提高网站的性能和搜索引擎优化。</li></ol><p>需要注意的是，Node.js 是单线程的，对于 CPU 密集型任务，其性能可能不如其他多线程的语言和平台。因此，在选择使用 Node.js 时，应该根据具体业务需求和特点进行合理的选择。</p><h4 id="2-Node和前端项目怎么解决跨域的"><a href="#2-Node和前端项目怎么解决跨域的" class="headerlink" title="2.Node和前端项目怎么解决跨域的"></a>2.Node和前端项目怎么解决跨域的</h4><p>在前端项目中，跨域问题通常是由浏览器的同源策略所导致的，而在 Node.js 环境中，由于没有浏览器的限制，不存在同源策略，因此不会出现跨域问题。在 Node.js 中可以轻松地访问不同域的资源。</p><p>然而，Node.js 通常用于构建后端服务器，而前端项目在浏览器中运行，所以跨域问题主要出现在前端项目中。在前端项目中解决跨域问题的常见方式包括：</p><ol><li>JSONP：使用 JSONP (JSON with Padding) 技术来进行跨域请求。JSONP 利用 <code>&lt;script&gt;</code> 标签的跨域特性，通过动态创建 <code>&lt;script&gt;</code> 元素并设置其 <code>src</code> 属性来请求跨域数据。</li><li>CORS（Cross-Origin Resource Sharing）：CORS 是一种现代的跨域解决方案，通过在服务器端设置响应头来授权特定的域名访问资源。在前端项目中，可以在发起跨域请求时设置 <code>withCredentials: true</code> 来携带认证信息。</li><li>代理：可以在前端项目的服务器端设置一个代理服务器，将跨域请求转发给目标服务器，并将响应返回给前端项目。这种方式需要在后端进行配置。</li><li>Nginx 反向代理：使用 Nginx 配置反向代理规则，将跨域请求转发给目标服务器，同时在服务器端设置 CORS 头部来允许跨域访问。</li><li>WebSocket：如果前端项目需要实现实时通信，可以使用 WebSocket 协议，它不受同源策略限制，可以在客户端与服务器之间建立长连接。</li></ol><p>需要根据具体的前端项目和后端服务器的部署情况来选择合适的解决方案。通常情况下，推荐使用 CORS 解决跨域问题，它是一种现代化的、更安全的跨域解决方案。对于不支持 CORS 的老旧浏览器，可以考虑使用 JSONP 或其他代理方式来实现跨域请求。</p><h4 id="3-Node的优点是什么-缺点是什么"><a href="#3-Node的优点是什么-缺点是什么" class="headerlink" title="3.Node的优点是什么?缺点是什么"></a>3.Node的优点是什么?缺点是什么</h4><ol><li>异步非阻塞：Node.js采用异步非阻塞I&#x2F;O模型，能够高效处理大量并发请求，使得应用具有出色的性能和响应能力。</li><li>单线程：Node.js是单线程的，通过事件循环机制实现并发处理，简化了多线程的复杂性，提高了开发效率。</li><li>快速构建：使用JavaScript作为开发语言，使得前端开发人员可以在服务器端使用相同的语言和技术栈，简化了开发流程，加快了开发速度。</li><li>轻量高效：Node.js是一个轻量级的运行时环境，具有高度的可伸缩性和低系统资源消耗，适用于构建高性能的服务器应用。</li><li>NPM支持：Node.js附带了NPM（Node Package Manager），是一个强大的包管理工具，提供了大量的开源库和模块，方便代码共享和复用。</li><li>广泛的社区支持：Node.js拥有庞大的开发者社区和丰富的第三方库，可以快速找到解决方案和组件，加速开发进度。</li></ol><p>Node.js的一些缺点包括：</p><ol><li>单线程：虽然单线程的设计使得Node.js在处理I&#x2F;O密集型任务方面表现优异，但在处理CPU密集型任务时性能可能不如多线程的语言和平台。</li><li>回调地狱：由于Node.js采用异步回调方式处理I&#x2F;O操作，可能导致嵌套过多的回调函数，造成代码难以阅读和维护，即所谓的”回调地狱”。</li><li>模块版本问题：由于NPM上的模块更新频繁，可能导致不同版本之间的兼容性问题，需要注意版本控制和模块依赖管理。</li><li>不适合CPU密集型任务：由于Node.js是单线程的，不适合处理CPU密集型任务，因为它会导致整个应用阻塞。</li><li>缺乏成熟的安全机制：Node.js在安全性方面相对较弱，需要开发者注意处理一些安全问题，如跨站脚本攻击（XSS）和SQL注入等。</li></ol><p>总体来说，Node.js在构建高性能、实时应用和I&#x2F;O密集型任务时表现优秀，但对于CPU密集型任务和一些特定场景，可能不太适合。因此，在选择使用Node.js时，应根据应用的需求和场景进行合理的选择。</p><h4 id="4-commonJS中的require-x2F-exports和ES6中import-x2F-export的区别是什么"><a href="#4-commonJS中的require-x2F-exports和ES6中import-x2F-export的区别是什么" class="headerlink" title="4.commonJS中的require&#x2F;exports和ES6中import&#x2F;export的区别是什么"></a>4.commonJS中的require&#x2F;exports和ES6中import&#x2F;export的区别是什么</h4><p>CommonJS 和 ES6 是 JavaScript 中两种不同的模块化规范，它们在模块导入和导出的语法和特性上有一些区别：</p><ol><li>导入语法：<ul><li>CommonJS 使用 <code>require()</code> 来导入模块，例如：<code>const moduleA = require(&#39;./moduleA&#39;)</code>。</li><li>ES6 使用 <code>import</code> 来导入模块，例如：<code>import moduleA from &#39;./moduleA&#39;</code>。</li></ul></li><li>导出语法：<ul><li>CommonJS 使用 <code>module.exports</code> 或 <code>exports</code> 来导出模块，例如：<code>module.exports = &#123;&#125;</code> 或 <code>exports.someFunction = function() &#123;&#125;</code>。</li><li>ES6 使用 <code>export</code> 来导出模块，例如：<code>export default &#123;&#125;</code> 或 <code>export function someFunction() &#123;&#125;</code>。</li></ul></li><li>动态导入：<ul><li>CommonJS 不支持动态导入，<code>require()</code> 只能在模块的顶层使用，不能在条件语句或函数中使用。</li><li>ES6 支持动态导入，可以使用 <code>import()</code> 函数动态加载模块，允许在运行时根据需要导入模块。</li></ul></li><li>导入和导出的细粒度控制：<ul><li>ES6 的导入和导出语法更灵活，可以使用 <code>import &#123; ... &#125; from &#39;module&#39;</code> 和 <code>export &#123; ... &#125;</code> 来导入和导出特定的变量或函数，而不是整个模块。</li></ul></li><li>静态解析：<ul><li>ES6 的模块导入和导出是静态解析的，意味着导入和导出的模块在编译时就确定了，这使得打包工具可以在编译时进行优化。</li><li>CommonJS 的导入和导出是动态的，无法在编译时静态确定模块的依赖关系。</li></ul></li></ol><p>总体而言，ES6 的模块化规范在语法上更加简洁和灵活，支持动态导入和细粒度导入导出，而 CommonJS 更适合在服务器端使用。在浏览器端和现代的前端项目中，通常使用 ES6 的模块化规范，而在 Node.js 环境下，可以继续使用 CommonJS 的模块化规范。在使用模块时，可以根据项目的需求和平台的支持情况来选择合适的模块化规范。</p><h4 id="5-简述同步和异步的区别，如何避免回调地狱，Node-的异步问题是如何解决的"><a href="#5-简述同步和异步的区别，如何避免回调地狱，Node-的异步问题是如何解决的" class="headerlink" title="5.简述同步和异步的区别，如何避免回调地狱，Node 的异步问题是如何解决的"></a>5.简述同步和异步的区别，如何避免回调地狱，Node 的异步问题是如何解决的</h4><p>同步和异步是关于任务执行顺序的概念：</p><ol><li>同步：同步任务是按照代码的顺序依次执行的，每个任务必须等待上一个任务执行完成后才能执行。</li><li>异步：异步任务是不按照代码顺序执行的，它会先放到任务队列中，等待同步任务执行完成后，再由事件循环机制来执行。</li></ol><p>避免回调地狱的方法有：</p><ol><li>使用 Promise：Promise 是一种用于处理异步操作的对象，它可以让异步代码更加清晰和可读。通过 Promise 的链式调用，可以避免回调地狱。</li><li>使用 async&#x2F;await：async&#x2F;await 是 ES2017 中引入的特性，它可以让异步代码看起来像同步代码一样，提高代码的可读性。</li></ol><p>Node.js 的异步问题解决方法主要有以下几种：</p><ol><li>回调函数：Node.js 采用回调函数来处理异步操作，通过回调函数可以在异步操作完成后执行相应的逻辑。</li><li>事件监听：Node.js 使用事件驱动的模型，通过事件监听和触发来处理异步操作。</li><li>Promise：Node.js 支持使用 Promise 来处理异步操作，通过链式调用可以避免回调地狱。</li><li>async&#x2F;await：Node.js 支持使用 async&#x2F;await 来处理异步操作，让异步代码看起来像同步代码一样，提高代码可读性。</li></ol><p>使用这些方法，可以更加优雅地处理 Node.js 中的异步问题，避免回调地狱，并提高代码的可维护性。</p><h4 id="6-dependencies-和devDependencies两者区别"><a href="#6-dependencies-和devDependencies两者区别" class="headerlink" title="6.dependencies 和devDependencies两者区别"></a>6.dependencies 和devDependencies两者区别</h4><p>在 Node.js 项目中，<code>dependencies</code> 和 <code>devDependencies</code> 是两个常见的属性，用于在 <code>package.json</code> 文件中声明不同类型的依赖。</p><ol><li><code>dependencies</code>：<ul><li><code>dependencies</code> 属性用于声明项目运行时所需的依赖项，即在项目运行时必须加载的模块。</li><li>这些依赖项会被安装在生产环境中，用于构建和运行项目的正式版本。</li><li>在生产环境中运行 <code>npm install</code> 或 <code>npm ci</code> 时，只会安装 <code>dependencies</code> 中声明的依赖项。</li></ul></li><li><code>devDependencies</code>：<ul><li><code>devDependencies</code> 属性用于声明开发过程中所需的依赖项，即仅在开发和构建过程中使用的模块。</li><li>这些依赖项不会被包含在最终生成的项目代码中，只会在开发过程中使用，例如测试框架、构建工具、代码检查等。</li><li>在生产环境中运行 <code>npm install</code> 或 <code>npm ci</code> 时，不会安装 <code>devDependencies</code> 中声明的依赖项。</li></ul></li></ol><p>示例 <code>package.json</code> 文件：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;my-project&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">  &quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;express&quot;: &quot;^4.17.1&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;devDependencies&quot;: &#123;</span><br><span class="line">    &quot;jest&quot;: &quot;^27.1.1&quot;,</span><br><span class="line">    &quot;babel&quot;: &quot;^7.15.0&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的示例中，<code>express</code> 是一个运行时依赖项，而 <code>jest</code> 和 <code>babel</code> 是开发依赖项。运行 <code>npm install</code> 时，只会安装 <code>express</code>，而 <code>jest</code> 和 <code>babel</code> 仅在运行 <code>npm install --only=dev</code> 或 <code>npm ci</code> 时才会被安装。这样可以使项目的依赖项更清晰，减少生产环境的冗余依赖。</p><h4 id="7-描述一下从接到url开始，到逻辑处理，到DB查询-到返回结果，整个过程是怎么处理的"><a href="#7-描述一下从接到url开始，到逻辑处理，到DB查询-到返回结果，整个过程是怎么处理的" class="headerlink" title="7.描述一下从接到url开始，到逻辑处理，到DB查询,到返回结果，整个过程是怎么处理的?"></a>7.描述一下从接到url开始，到逻辑处理，到DB查询,到返回结果，整个过程是怎么处理的?</h4><p>整个过程涉及到前端、后端和数据库的协作。下面是一般的流程描述：</p><ol><li>前端请求：<ul><li>客户端（浏览器或移动设备）向服务器发送 HTTP 请求，请求的 URL 包含了需要访问的资源或需要执行的操作。</li></ul></li><li>后端接收请求：<ul><li>服务器接收到请求后，通过路由系统将请求分发到对应的处理程序（后端控制器或中间件）。</li></ul></li><li>逻辑处理：<ul><li>后端控制器或中间件根据请求的 URL 和参数进行相应的逻辑处理，可能涉及到业务逻辑、验证等操作。</li></ul></li><li>数据库查询：<ul><li>如果逻辑处理需要从数据库中获取数据，后端将通过数据访问层（例如 ORM 或原生 SQL）向数据库发送查询请求。</li></ul></li><li>数据库操作：<ul><li>数据库接收到查询请求后，执行相应的查询操作，从数据库中获取所需的数据。</li></ul></li><li>处理结果：<ul><li>数据库将查询结果返回给后端。</li></ul></li><li>后端响应：<ul><li>后端控制器或中间件根据数据库查询结果进行适当的处理，构造响应数据。</li></ul></li><li>响应传输：<ul><li>后端将处理后的响应数据打包成 HTTP 响应，包括响应状态码、头部信息和响应体。</li></ul></li><li>前端接收：<ul><li>客户端接收到 HTTP 响应后，根据响应状态码和头部信息进行相应处理，如果响应体是 JSON 数据，则进行解析。</li></ul></li><li>前端渲染：<ul><li>前端根据接收到的数据进行相应的渲染，将数据显示在页面上。</li></ul></li></ol><p>整个过程可以根据具体的应用场景和技术栈进行细节调整。前端通过 HTTP 请求与后端进行交互，后端处理请求，并与数据库进行数据交互，最终将处理结果返回给前端，前端再将数据展示给用户。这样的交互过程构成了一次完整的前后端交互流程。</p><h4 id="8-谈谈你对Koa和Express的理解，二-者的区别是"><a href="#8-谈谈你对Koa和Express的理解，二-者的区别是" class="headerlink" title="8.谈谈你对Koa和Express的理解，二 者的区别是?"></a>8.谈谈你对Koa和Express的理解，二 者的区别是?</h4><p>Koa 和 Express 都是 Node.js 中常用的 Web 框架，用于快速构建 Web 应用程序和 RESTful API。它们都基于 Node.js 的 HTTP 模块，并提供了简洁的 API 和中间件来处理请求和响应。</p><p>Koa 的特点和理解：</p><ol><li>Koa 是一个更轻量级的框架，由 Express 的原作者设计。它采用了 ES6 的语法和 async&#x2F;await，使得代码更加简洁、可读性更强。</li><li>Koa 中间件机制非常灵活，使用了洋葱模型（Onion Model）来处理中间件的执行顺序，可以更方便地实现链式调用。</li><li>Koa 不包含任何默认中间件，需要开发者根据需求手动引入，并且可以根据项目的实际情况灵活地组织中间件。</li><li>Koa 的错误处理更加优雅，采用了 try…catch 来处理异常，并且提供了一个专门的错误处理中间件来集中处理错误。</li><li>Koa 使用了洋葱模型，因此在一些复杂的场景中，可能会更加清晰易懂。</li></ol><p>Express 的特点和理解：</p><ol><li>Express 是一个成熟的、功能丰富的框架，已经被广泛应用于许多项目。它有着强大的社区支持和丰富的插件。</li><li>Express 的中间件机制相对简单，采用了栈式调用的方式。中间件的执行顺序按照添加的顺序执行。</li><li>Express 包含了一些默认中间件，如处理静态文件、处理 JSON 数据等，因此在一些情况下会比 Koa 更加快速地搭建项目。</li><li>Express 的错误处理相对简单，通过在路由中直接抛出错误，然后通过专门的错误处理中间件来处理。</li></ol><p>两者的区别：</p><ol><li>语法：Koa 使用了 ES6 的 async&#x2F;await 语法，代码更加简洁；而 Express 使用了回调函数，代码相对冗长。</li><li>中间件：Koa 的中间件机制更加灵活，使用了洋葱模型，链式调用更直观；而 Express 使用栈式调用，添加和执行顺序一致。</li><li>默认中间件：Koa 不包含任何默认中间件，需要手动引入；而 Express 包含了一些默认中间件，如处理静态文件和 JSON 数据。</li><li>错误处理：Koa 使用了 try…catch 来处理异常，错误处理相对更加优雅；而 Express 通过在路由中抛出错误，然后通过错误处理中间件来处理。</li></ol><p>总体而言，Koa 更加轻量级、灵活，适合喜欢新的语法和更自由组织中间件的开发者；而 Express 更加成熟、功能丰富，适合需要快速搭建项目并且喜欢传统回调函数写法的开发者。选择使用哪个框架，可以根据项目的需求、个人偏好和团队经验来进行权衡。</p><h4 id="9-谈谈对egg和nest-js的理解，二者的区别是"><a href="#9-谈谈对egg和nest-js的理解，二者的区别是" class="headerlink" title="9.谈谈对egg和nest.js的理解，二者的区别是 ?"></a>9.谈谈对egg和nest.js的理解，二者的区别是 ?</h4><p>Egg 和 Nest.js 都是用于构建 Node.js 后端应用程序的框架，它们有不同的设计理念和特点。</p><p>Egg 的特点和理解：</p><ol><li>Egg 是一个企业级的 Node.js 框架，它基于 Koa 和 Express，并在此基础上提供了更多企业级的功能和插件。</li><li>Egg 遵循 “约定优于配置” 的设计原则，提供了一套约定和规范，可以快速开发出高质量的应用。</li><li>Egg 提供了插件系统，可以通过安装和配置插件来扩展功能，社区提供了丰富的插件。</li><li>Egg 的插件体系支持热插拔，可以动态开启和关闭插件，而无需重启应用。</li><li>Egg 提供了完善的开发调试工具，例如开发环境下的热更新、调试工具和单元测试支持等。</li></ol><p>Nest.js 的特点和理解：</p><ol><li>Nest.js 是一个用于构建高度可扩展的、模块化的 Node.js 后端应用程序的框架。</li><li>Nest.js 基于 TypeScript，它提供了强类型的开发体验，有助于代码的可维护性和可读性。</li><li>Nest.js 使用依赖注入（DI）和模块化的架构，使得应用的组织和管理更加清晰和灵活。</li><li>Nest.js 支持多种传输层协议，例如 HTTP、WebSocket 等，并且内置了 GraphQL 的支持。</li><li>Nest.js 提供了一套完善的工具和功能，如过滤器、中间件、拦截器等，使得开发者可以更方便地实现一些通用的功能。</li></ol><p>两者的区别：</p><ol><li>设计理念：Egg 更侧重于企业级应用，提供了约定和规范来保证应用的质量和稳定性，支持插件化开发；而 Nest.js 更侧重于模块化的架构和依赖注入，使得应用的组织和管理更加清晰和灵活。</li><li>语言和类型系统：Egg 使用 JavaScript 和部分 TypeScript，它对类型的支持较弱；而 Nest.js 使用 TypeScript，它对强类型的支持更加全面。</li><li>插件和功能支持：Egg 提供了丰富的插件，可以快速实现一些常用的功能；而 Nest.js 提供了一套完善的工具和功能，如过滤器、中间件、拦截器等，方便开发者实现通用的功能。</li></ol><p>选择使用 Egg 还是 Nest.js，可以根据项目的需求、团队技术栈和开发者个人偏好来决定。如果需要一个成熟、稳定的企业级框架并且对 TypeScript 有较高要求，可以选择 Egg；如果注重模块化架构和依赖注入，并且喜欢使用 TypeScript 进行开发，可以选择 Nest.js。</p><h2 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h2><h4 id="1-mysql-和mongoDB有什么区别"><a href="#1-mysql-和mongoDB有什么区别" class="headerlink" title="1.mysql 和mongoDB有什么区别"></a>1.mysql 和mongoDB有什么区别</h4><p>MySQL和MongoDB是两种不同类型的数据库管理系统，它们有一些显著的区别：</p><ol><li>数据模型：<ul><li>MySQL是一种关系型数据库管理系统（RDBMS），它使用表格来存储数据，每个表格包含固定的列和行，表格之间通过外键关联。</li><li>MongoDB是一种文档型数据库，它使用类似JSON的BSON格式来存储数据，数据以文档的形式存储，每个文档可以具有不同的结构。</li></ul></li><li>数据模式：<ul><li>MySQL要求事先定义表格的结构和数据类型，即采用固定的数据模式。</li><li>MongoDB是无模式的，允许在同一集合中存储不同结构的文档。</li></ul></li><li>查询语言：<ul><li>MySQL使用结构化查询语言（SQL）来进行数据查询和操作。</li><li>MongoDB使用基于对象的查询语言。</li></ul></li><li>主键：<ul><li>MySQL要求每个表格必须有主键来唯一标识每行数据。</li><li>MongoDB的文档默认具有一个 <code>_id</code> 字段作为主键。</li></ul></li><li>扩展性：<ul><li>MySQL通常在单个服务器上运行，并且垂直扩展性（增加硬件资源）有限。</li><li>MongoDB支持水平扩展性（增加服务器数量）以处理大规模数据和高并发请求。</li></ul></li><li>事务支持：<ul><li>MySQL支持事务，可以保证数据的一致性和完整性。</li><li>MongoDB在较早的版本中不支持事务，但从MongoDB 4.0开始提供了部分事务支持。</li></ul></li><li>存储引擎：<ul><li>MySQL支持多种存储引擎，如InnoDB、MyISAM等，每种引擎有不同的特点和用途。</li><li>MongoDB使用默认的WiredTiger存储引擎。</li></ul></li><li>使用场景：<ul><li>MySQL通常用于事务处理和需要严格数据模型的应用，如电子商务网站、金融系统等。</li><li>MongoDB适用于大规模的非结构化或半结构化数据，如日志、社交媒体数据、实时大数据等。</li></ul></li></ol><p>总体而言，MySQL适用于需要复杂查询和事务支持的应用，而MongoDB适用于需要灵活的数据模型和高度可扩展性的应用。选择使用哪种数据库取决于应用的需求和数据特性。</p>]]></content>
      
      
      <categories>
          
          <category> 面试题整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IT前端 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue</title>
      <link href="/archives/f8e09374.html"/>
      <url>/archives/f8e09374.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><h2 id="1-邂逅Vue"><a href="#1-邂逅Vue" class="headerlink" title="1.邂逅Vue"></a>1.邂逅Vue</h2><h3 id="1、Vue在前端的重要性"><a href="#1、Vue在前端的重要性" class="headerlink" title="1、Vue在前端的重要性"></a>1、Vue在前端的重要性</h3><p>Vue 是一套用于构建用户界面的渐进式 JavaScript 框架</p><p>它基于标准 HTML、CSS和JavaScript构建，并提供了一套声明式的、组件化的编程模型</p><p>帮助你高效地开发用户界面，无论任务是简单还是复杂</p><p>什么是渐进式框架？</p><p>表示我们可以在项目中一点点来引入和使用Vue，而不一定需要全部使用Vue来开发整个项目</p><p>目前前端最流行的是三大框架：Vue、React、Angular</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230409072236471.png" alt="image-20230409072236471"></p><p>国外，优先推荐React、其次是Vue和Angular</p><p>国内，优先推荐且必须学习Vue，其次是React，其次是Angular</p><h3 id="2、Vue2还是Vue3"><a href="#2、Vue2还是Vue3" class="headerlink" title="2、Vue2还是Vue3"></a>2、Vue2还是Vue3</h3><p>Vue3：更好的性能；更小的打包体积；更好的TypeScript集成；更优秀的 API 设计</p><p>Vue3 目前已经是稳定的版本，并且 Vue3 在2022年2月7日已经成为默认安装版本</p><p>目前社区也经过一定时间的沉淀，更加的完善了，包括 AntDesignVue、Element-Plus 都提供了对 Vue3 的支持，所以很多公司目前新的项目都已经在使用 Vue3 来进行开发了</p><p>并且在面试的时候，几乎都会问到各种各样 Vue3 相关的问题</p><p>Vue 的本质，就是一个 JavaScript 的库</p><p>使用 Vue 的方式</p><ul><li>在页面通过CDN的方式来引入<ul><li><a href="https://unpkg.com/vue@next">https://unpkg.com/vue@next</a></li></ul></li><li>下载 Vue 的 JS 文件，并且自己手动引入</li><li>通过 npm 包管理工具安装使用它</li><li>直接通过 Vue CIL 创建项目，并且使用它</li></ul><h3 id="3、Vue-初体验"><a href="#3、Vue-初体验" class="headerlink" title="3、Vue 初体验"></a>3、Vue 初体验</h3><p>Vue 页面</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./lib/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 1.创建app </span></span><br><span class="line">  <span class="keyword">const</span> app = <span class="title class_">Vue</span>.<span class="title function_">createApp</span>(&#123;</span><br><span class="line">    <span class="attr">template</span>: <span class="string">`&lt;h1&gt;Hello Vue&lt;/h2&gt;`</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.挂载app</span></span><br><span class="line">  app.<span class="title function_">mount</span>(<span class="string">&quot;#app&quot;</span>)</span><br></pre></td></tr></table></figure><p>案例1.动态message</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">template</span>: <span class="string">`&lt;h2&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt;`</span></span><br></pre></td></tr></table></figure><p>案例2. 列表数据</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">       &lt;h2&gt;电影列表&lt;/h2&gt;</span></span><br><span class="line"><span class="string">       &lt;ul&gt;</span></span><br><span class="line"><span class="string">         &lt;li v-for=&quot;item in movies&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt; </span></span><br><span class="line"><span class="string">       &lt;/ul&gt;</span></span><br><span class="line"><span class="string">     `</span>,</span><br><span class="line">     <span class="attr">data</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> &#123;</span><br><span class="line">         <span class="attr">message</span>: <span class="string">&quot;你好啊，ikun&quot;</span>,</span><br><span class="line">         <span class="attr">movies</span>: [ <span class="string">&quot;大话西游&quot;</span>, <span class="string">&quot;恶灵&quot;</span>, <span class="string">&quot;少年派&quot;</span>, <span class="string">&quot;盗梦空间&quot;</span>, <span class="string">&quot;五十度灰&quot;</span> ]</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>案例3.计数器</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>当前计数: &#123;&#123;counter&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;increment&quot;</span>&gt;</span>+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;decrement&quot;</span>&gt;</span>-1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> app = <span class="title class_">Vue</span>.<span class="title function_">createApp</span>(&#123;</span><br><span class="line">    <span class="attr">data</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">counter</span>: <span class="number">0</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">methods</span>: &#123;</span><br><span class="line">      <span class="attr">increment</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 暂时了解：this通过bild绑定某个对象 可以改变data的return&#123;&#125; 中的对象</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">counter</span>++</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">decrement</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">counter</span>--</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  app.<span class="title function_">mount</span>(<span class="string">&quot;#app&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="4、命令式与声明式编程"><a href="#4、命令式与声明式编程" class="headerlink" title="4、命令式与声明式编程"></a>4、命令式与声明式编程</h3><p>原生开发和Vue开发的模式和特点是完全不同的，涉及到两种不同的编程范式</p><ul><li><p>命令式编程和声明式编程</p></li><li><p>命令式编程关注的是 “how to do”自己完成整个how的过程</p></li><li><p>声明式编程关注的是 “what to do”，由框架(机器)完成 “how”的过程</p></li></ul><p>在原生的实现过程中</p><ul><li><p>每完成一个操作，都需要通过JavaScript编写一条代码，来给浏览器一个指令</p></li><li><p>这样的编写代码的过程，我们称之为命令式编程</p></li><li><p>在早期的原生JavaScript和jQuery开发的过程中，都是通过这种命令式的方式编写代码</p></li></ul><p>在Vue的实现过程中的操作</p><ul><li><p>在createApp传入的对象中声明需要的内容，模板template、数据data、方法methods</p></li><li><p>这样的编写代码的过程，我们称之为是声明式编程</p></li><li><p>目前Vue、React、Angular、小程序的编程模式，我们称之为声明式编程</p></li></ul><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/%E5%91%BD%E4%BB%A4%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%92%8C%E5%A3%B0%E6%98%8E%E5%BC%8F%E7%BC%96%E7%A8%8B%E7%9A%84%E6%80%9D%E6%83%B3%E5%8C%BA%E5%88%AB.png" alt="命令式编程和声明式编程的思想区别"></p><h3 id="5、MVC和MVVM的模型区别"><a href="#5、MVC和MVVM的模型区别" class="headerlink" title="5、MVC和MVVM的模型区别"></a>5、MVC和MVVM的模型区别</h3><p>MVC和MVVM都是一种软件的体系结构</p><ul><li><p>MVC是Model – View –Controller的简称，是在前期被使用非常框架的架构模式，比如iOS、前端；</p></li><li><p>MVVM是Model-View-ViewModel的简称，是目前非常流行的架构模式</p></li></ul><p>通常情况下，我们也经常称Vue是一个MVVM的框架</p><ul><li>Vue官方其实有说明，Vue虽然并没有完全遵守MVVM的模型，但整个设计受到它的启发</li></ul><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230409203218899.png" alt="image-20230409203218899"></p><h3 id="6、常用-options-api"><a href="#6、常用-options-api" class="headerlink" title="6、常用 options api"></a>6、常用 options api</h3><h4 id="1-data"><a href="#1-data" class="headerlink" title="1.data"></a>1.data</h4><p>data属性是传入一个函数，并且该函数需要返回一个对象</p><ul><li><p>在 Vue2.x 的时候，也可以传入一个对象（虽然官方推荐是一个函数）</p></li><li><p>在 Vue3.x 的时候，必须传入一个函数，否则就会直接在浏览器中报错</p></li></ul><p>data中返回的对象会被Vue的响应式系统劫持，之后对该对象的修改或者访问都会在劫持中被处理</p><ul><li><p>在 template 或者 app 中通过 <code>&#123;&#123;counter&#125;&#125;</code> 访问 ounter，可以从对象中获取到数据</p></li><li><p>修改counter的值时，app中的 <code>&#123;&#123;counter&#125;&#125;</code>也会发生改变</p></li></ul><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/data%E6%95%B0%E6%8D%AE%E5%A6%82%E4%BD%95%E8%A2%AB%E5%B1%95%E7%A4%BA%E7%9A%84.png" alt="data数据如何被展示的"></p><h4 id="2-methods"><a href="#2-methods" class="headerlink" title="2.methods"></a>2.methods</h4><p>methods 属性是一个对象，通常我们会在这个对象中定义很多的方法：</p><ul><li><p>这些方法可以被绑定到模板中</p></li><li><p>在该方法中，我们可以使用 this 关键字来直接访问到data中返回的对象的属性</p></li></ul><p>问题一：为什么不能使用箭头函数（官方文档有给出解释）</p><ul><li>我们在 methods 中要使用 data 返回对象中的数据，那么这个 this 是必须有值的，并且应该可以通过 this 获取到data返回对象中的数据，不可以是 window，因为 window 中我们无法获取到 data 返回对象中的数据，但是如果我们使用箭头函数，那么这个 this 就会是window了</li></ul><p>问题二：不使用箭头函数的情况下，this 到底指向的是什么？（可以作为一道面试题）</p><p>proxy，事实上Vue的源码当中就是对 methods 中的所有函数进行了遍历，并且通过bind绑定了 this</p><h3 id="7、vscode-代码片段"><a href="#7、vscode-代码片段" class="headerlink" title="7、vscode 代码片段"></a>7、vscode 代码片段</h3><p>便于快速生成Vue的基本代码结构</p><p>具体的步骤如下：</p><ul><li><p>第一步，复制自己需要生成代码片段的代码</p></li><li><p>第二步，<a href="https://snippet-generator.app/%E5%9C%A8%E8%AF%A5%E7%BD%91%E7%AB%99%E4%B8%AD%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5">https://snippet-generator.app/在该网站中生成代码片段</a></p></li><li><p>第三步，在VSCode中配置代码片段</p></li></ul><h2 id="2-模板语法"><a href="#2-模板语法" class="headerlink" title="2.模板语法"></a>2.模板语法</h2><h3 id="1、Mustache-语法"><a href="#1、Mustache-语法" class="headerlink" title="1、Mustache 语法"></a>1、Mustache 语法</h3><p>React的开发模式：</p><ul><li><p>React使用的jsx，所以对应的代码都是编写的类似于js的一种语法</p></li><li><p>之后通过Babel将jsx编译成 React.createElement 函数调用</p></li></ul><p>Vue也支持jsx的开发模式</p><ul><li><p>但大多数情况下，使用基于HTML的模板语法</p></li><li><p>在模板中，允许开发者以声明式的方式将DOM和底层组件实例的数据绑定在一起</p></li><li><p>在底层的实现中，Vue将模板编译成虚拟DOM渲染函数</p></li></ul><p>把数据显示到模板（template）中，使用最多的语法是“Mustache”语法 (双大括号)的文本插值</p><ul><li><p>并且data返回的对象是有添加到Vue的响应式系统中</p></li><li><p>当data中的数据发生改变时，对应的内容也会发生更新</p></li><li><p>Mustache中不仅仅可以是data中的属性，也可以是一个JavaScript的表达式</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">  &lt;!-- <span class="number">1.</span>基本使用 --&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>当前计数: &#123;&#123;counter&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">  &lt;!-- <span class="number">2.</span>表达式 --&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>双倍计数: &#123;&#123; counter * 2 &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>展示信息: &#123;&#123; infos.split(&quot; &quot;).join(&quot;-&quot;) &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">  &lt;!-- <span class="number">3.</span>三元表达式 --&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123; age &gt;= 18 ? &quot;成年人&quot; : &quot;未成年人&quot; &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">  &lt;!-- <span class="number">4.</span>调用methods中函数 --&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123; formateDate(123) &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">  &lt;!-- <span class="number">5.</span>注意：这里不能定义语句 --&gt;</span><br><span class="line">  &lt;!-- <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123; const name = &quot;why&quot;; name&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span> --&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>若是在createApp对象中使用template并写入东西，则会覆盖挂载的app中的原来的html结构，所以可以不写template，而挂载app中的div的html结构会当做template模板，便于书写html结构</p><h3 id="2、常见基本指令"><a href="#2、常见基本指令" class="headerlink" title="2、常见基本指令"></a>2、常见基本指令</h3><h4 id="1-v-once"><a href="#1-v-once" class="headerlink" title="1.v-once"></a>1.v-once</h4><p>用于指定元素或者组件只渲染一次：</p><ul><li><p>当数据发生变化时，元素或者组件以及其所有的子元素将视为静态内容并且跳过</p></li><li><p>该指令可以用于性能优化</p></li><li><p>如果是子节点，也是只会渲染一次</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- 指令：v-once 自身以及子元素只渲染一次 --&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-once</span>&gt;</span> </span></span><br><span class="line"><span class="language-xml">      &#123;&#123;message&#125;&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">span</span>&gt;</span>数字: &#123;&#123;counter&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">模板中使用&#123;&#123;&#125;&#125;进行渲染一次之后，不能修改所渲染的数据（数据能被修改但是渲染的数据仍是第一次渲染的数据）</span><br></pre></td></tr></table></figure><h4 id="2-v-text"><a href="#2-v-text" class="headerlink" title="2.v-text"></a>2.v-text</h4><p>用于更新元素的 textContent</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;h2&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt;</span><br><span class="line">如果&#123;&#123;message不含别的解释内容，则两者等价，不然v-text会替换标签中原有的内容&#125;&#125;</span><br><span class="line">   &lt;!-- 将data对应的文本设置到元素中  message会替换aaa--&gt;</span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-text</span>=<span class="string">&quot;message&quot;</span>&gt;</span>aaa<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h4 id="3-v-html"><a href="#3-v-html" class="headerlink" title="3.v-html"></a>3.v-html</h4><p>默认情况下，如果我们展示的内容本身是html的，那么vue并不会对其进行特殊的解析</p><ul><li>如果我们希望这个内容被Vue可以解析出来，那么可以使用 v-html 来展示</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;h2&gt;&#123;&#123; content &#125;&#125;&lt;/h2&gt;</span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-html</span>=<span class="string">&quot;content&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="attr">data</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> &#123;</span><br><span class="line">         <span class="attr">content</span>: <span class="string">`&lt;span style=&quot;color: red; font-size: 30px;&quot;&gt;哈哈哈&lt;/span&gt;`</span></span><br><span class="line">       &#125;</span><br><span class="line">     &#125;,</span><br></pre></td></tr></table></figure><h4 id="4-v-pre"><a href="#4-v-pre" class="headerlink" title="4.v-pre"></a>4.v-pre</h4><p>v-pre用于跳过元素和它的子元素的编译过程，显示原始的Mustache标签：</p><ul><li>跳过不需要编译的节点，加快编译的速度</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div v-pre&gt;</span><br><span class="line">     <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">     <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>当前计数: &#123;&#123; counter &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">     <span class="language-xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-pre</span>&gt;</span>&#123;&#123;&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">   &lt;/div&gt;</span><br><span class="line"><span class="comment">// div中设置了 v-pre则子元素也不会进行编译</span></span><br></pre></td></tr></table></figure><h4 id="5-v-cloak"><a href="#5-v-cloak" class="headerlink" title="5.v-cloak"></a>5.v-cloak</h4><p>这个指令保持在元素上直到关联组件实例结束编译</p><ul><li>和 CSS 规则与 [v-cloak] { display: none } 一起用时，这个指令可以隐藏未编译的 Mustache 标签直到组件实例准备完毕</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">  [v-cloak] &#123;</span><br><span class="line">    <span class="attr">display</span>: none;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-cloak</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> app = <span class="title class_">Vue</span>.<span class="title function_">createApp</span>(&#123;</span><br><span class="line">      <span class="attr">data</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">          <span class="attr">message</span>: <span class="string">&quot;Hello Vue&quot;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">    app.<span class="title function_">mount</span>(<span class="string">&quot;#app&quot;</span>)</span><br><span class="line">  &#125;, <span class="number">3000</span>)</span><br></pre></td></tr></table></figure><h4 id="6-v-memo"><a href="#6-v-memo" class="headerlink" title="6.v-memo"></a>6.v-memo</h4><p>缓存一个模板的子树，在元素和组件上都可以使用，为了实现缓存，该指令需要传入一个固定长度的依赖值数组进行比较。如果数组里的每个值都与最后一次的渲染相同，那么整个子树的更新将被跳过</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> &lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">   &lt;!-- name 和 age 都保持不变才跳过对数据的修改操作 --&gt;</span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-memo</span>=<span class="string">&quot;[name, age]&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;<span class="name">h2</span>&gt;</span>name: &#123;&#123; name &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;<span class="name">h2</span>&gt;</span>age: &#123;&#123; age &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;<span class="name">h2</span>&gt;</span>height: &#123;&#123; height &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeMessage&quot;</span>&gt;</span>改变信息<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"> &lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title class_">Vue</span>.<span class="title function_">createApp</span>(&#123;</span><br><span class="line">     <span class="attr">data</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> &#123;</span><br><span class="line">         <span class="attr">name</span>: <span class="string">&quot;sws&quot;</span>,</span><br><span class="line">         <span class="attr">age</span>: <span class="number">23</span>,</span><br><span class="line">         <span class="attr">height</span>: <span class="number">1.84</span></span><br><span class="line">       &#125;</span><br><span class="line">     &#125;,</span><br><span class="line">     <span class="attr">methods</span>: &#123;</span><br><span class="line">       <span class="title function_">changeMessage</span>(<span class="params"></span>) &#123;</span><br><span class="line">         <span class="comment">// this.name = &quot;swd&quot;,</span></span><br><span class="line">         <span class="variable language_">this</span>.<span class="property">age</span> = <span class="number">21</span>,</span><br><span class="line">         <span class="variable language_">this</span>.<span class="property">height</span> = <span class="number">1.82</span></span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;)</span><br></pre></td></tr></table></figure><h3 id="3、v-bind-绑定属性"><a href="#3、v-bind-绑定属性" class="headerlink" title="3、v-bind 绑定属性"></a>3、v-bind 绑定属性</h3><p>动态的绑定一个或多个 attribute，也可以是组件的 prop（向另一个组件传递props值）</p><p>当用于绑定 class 或 style attribute， 支持额外的值类型如数组或对象</p><h4 id="1-绑定基本属性"><a href="#1-绑定基本属性" class="headerlink" title="1.绑定基本属性"></a>1.绑定基本属性</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- <span class="number">1.</span>绑定img的src --&gt;</span><br><span class="line">   &lt;!-- 语法糖: v-bind -&gt; : --&gt;</span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">v-bind:src</span>=<span class="string">&quot;showImgUrl&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="comment">&lt;!-- 2.绑定a的超链接 --&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;<span class="name">a</span> <span class="attr">:href</span>=<span class="string">&quot;href&quot;</span>&gt;</span>百度一下<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>案例：点击切换图片</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;button @click=<span class="string">&quot;changeImg&quot;</span>&gt;切换图片&lt;/button&gt;</span><br><span class="line">   <span class="attr">data</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> &#123;</span><br><span class="line">           <span class="attr">imgUrl1</span>: <span class="string">&quot;xxx1&quot;</span>,</span><br><span class="line">           <span class="attr">imgUrl2</span>: <span class="string">&quot;xxx2&quot;</span>,</span><br><span class="line">           <span class="attr">showImgUrl</span>: <span class="string">&quot;xxx1&quot;</span>,</span><br><span class="line">           <span class="attr">href</span>: <span class="string">&quot;https://www.baidu.com&quot;</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="attr">methods</span>: &#123;</span><br><span class="line">       <span class="title function_">changeImg</span>(<span class="params"></span>) &#123;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">showImgUrl</span> = <span class="variable language_">this</span>.<span class="property">showImgUrl</span> === <span class="variable language_">this</span>.<span class="property">imgUrl1</span> ? <span class="variable language_">this</span>.<span class="property">imgUrl2</span> : <span class="variable language_">this</span>.<span class="property">imgUrl1</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="2-绑定class"><a href="#2-绑定class" class="headerlink" title="2.绑定class"></a>2.绑定class</h4><p>开发中，有时候我们的元素class也是动态的，比如：</p><ul><li><p>当数据为某个状态时，字体显示红色</p></li><li><p>当数据另一个状态时，字体显示黑色</p></li></ul><p>绑定class有两种方式：</p><ul><li><p>对象语法：可以传给 :class (v-bind:class 的简写) 一个对象，以动态地切换 class</p></li><li><p>数组语法：可以把一个数组传给 :class，以应用一个 class 列表</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">  &lt;style&gt;</span><br><span class="line">    .<span class="property">active</span> &#123;</span><br><span class="line">      <span class="attr">color</span>: red;</span><br><span class="line">   &#125;</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="comment">&lt;!-- 1.基本绑定class --&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h2</span> <span class="attr">:class</span>=<span class="string">&quot;classes&quot;</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    <span class="comment">&lt;!-- 2.动态class可以写对象语法 --&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">:class</span>=<span class="string">&quot; isActive ? &#x27;active&#x27; : &#x27;&#x27; &quot;</span> @<span class="attr">click</span>=<span class="string">&quot;btnClick&quot;</span>&gt;</span>我是按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span> </span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    <span class="comment">&lt;!-- 2.1对象语法的基本使用 --&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">:class</span>=<span class="string">&quot;&#123;active: isActive&#125;&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;btnClick&quot;</span>&gt;</span>我是&#123;&#123; message &#125;&#125;按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    <span class="comment">&lt;!-- 2.2对象语法的多个键值对 --&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">:class</span>=<span class="string">&quot;&#123;active: isActive, why: true, kobe: false&#125;&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;btnClick&quot;</span>&gt;</span>我是&#123;&#123; message &#125;&#125;按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    <span class="comment">&lt;!-- 2.3动态绑定的class可以个普通的class并列使用 --&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;abc bcd&quot;</span> <span class="attr">:class</span>=<span class="string">&quot;&#123;active: isActive, why: true, kobe: false&#125;&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;btnClick&quot;</span>&gt;</span>我是&#123;&#123; message &#125;&#125;按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    <span class="comment">&lt;!-- 2.4动态绑定的class可以个普通的class并列使用 --&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;abc bcd&quot;</span> <span class="attr">:class</span>=<span class="string">&quot;getDynamicClasses()&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;btnClick&quot;</span>&gt;</span>我是&#123;&#123; message &#125;&#125;按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    <span class="comment">&lt;!-- 3.动态class可以写数组语法 --&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h2</span> <span class="attr">:class</span>=<span class="string">&#x27;[&quot;abc&quot;, &quot;sss&quot;]&#x27;</span>&gt;</span>Hello Array<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h2</span> <span class="attr">:class</span>=<span class="string">&#x27;[&quot;abc&quot;, className]&#x27;</span>&gt;</span>Hello Array<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h2</span> <span class="attr">:class</span>=<span class="string">&#x27;[&quot;abc&quot;, className, isActive? &quot;active&quot; : &quot;&quot;]&#x27;</span>&gt;</span>Hello Array<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h2</span> <span class="attr">:class</span>=<span class="string">&#x27;[&quot;abc&quot;, className, &#123; active: isActive &#125;]&#x27;</span>&gt;</span>Hello Array<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./lib/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">const</span> app = <span class="title class_">Vue</span>.<span class="title function_">createApp</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">data</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="attr">message</span>: <span class="string">&quot;原色&quot;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="attr">classes</span>: <span class="string">&quot;ads scw fvs&quot;</span>, </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="attr">isActive</span>: <span class="literal">false</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="attr">className</span>: <span class="string">&quot;sdw&quot;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">methods</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="title function_">btnClick</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="variable language_">this</span>.<span class="property">isActive</span> = !<span class="variable language_">this</span>.<span class="property">isActive</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="variable language_">this</span>.<span class="property">message</span> = <span class="variable language_">this</span>.<span class="property">message</span> === <span class="string">&quot;原色&quot;</span> ? <span class="string">&quot;红色&quot;</span> : <span class="string">&quot;原色&quot;</span> </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">getDynamicClasses</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="keyword">return</span> &#123; <span class="attr">active</span>: <span class="variable language_">this</span>.<span class="property">isActive</span>, <span class="attr">why</span>: <span class="literal">true</span>, <span class="attr">kobe</span>: <span class="literal">false</span>&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    app.<span class="title function_">mount</span>(<span class="string">&quot;#app&quot;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h4 id="3-绑定style"><a href="#3-绑定style" class="headerlink" title="3.绑定style"></a>3.绑定style</h4><p>可以利用v-bind:style来绑定一些CSS内联样式：</p><ul><li><p>这是因为某些样式我们需要根据数据动态来决定</p></li><li><p>比如某段文字的颜色，大小等等</p></li></ul><p>CSS property 名可以用驼峰式或短横线（使用括号）分隔 ，记得用引号括起来来命名</p><p>绑定class有两种方式：</p><ul><li><p>对象语法</p></li><li><p>数组语法：:style 的数组语法可以将多个样式对象应用到同一个元素上</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">   &lt;!-- <span class="number">1.</span>普通的style写法 --&gt;</span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">style</span>=<span class="string">&quot;color: red; font-size: 30px;&quot;</span>&gt;</span>哈哈哈<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">   &lt;!-- <span class="number">2.</span>style中的某些值，来自data中 --&gt;</span><br><span class="line">   &lt;!-- <span class="number">2.1</span>动态绑定style 在后面跟上 对象类型 --&gt;</span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">:style</span>=<span class="string">&quot;&#123; color: fontColor, fontSize: fontSize + &#x27;px&#x27; &#125;&quot;</span>&gt;</span>嘻嘻嘻<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">   &lt;!-- <span class="number">2.2</span> 动态的绑定属性，这个属性是一个对象 --&gt;</span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">:style</span>=<span class="string">&quot;objStyle&quot;</span>&gt;</span>哈哈哈<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">   &lt;!-- <span class="number">3.</span>style的数组语法 --&gt;</span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">:style</span>=<span class="string">&quot;[objStyle, &#123;backgroundColor: &#x27;purple&#x27;&#125;]&quot;</span>&gt;</span>嘿嘿嘿<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="attr">data</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> &#123;</span><br><span class="line">         <span class="attr">fontColor</span>: <span class="string">&#x27;blue&#x27;</span>,</span><br><span class="line">         <span class="attr">fontSize</span>: <span class="number">30</span>,</span><br><span class="line">         <span class="attr">objStyle</span>: &#123;</span><br><span class="line">           <span class="attr">fontSize</span>: <span class="string">&#x27;50px&#x27;</span>,</span><br><span class="line">           <span class="attr">color</span>: <span class="string">&#x27;green&#x27;</span></span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><h4 id="4-动态绑定属性"><a href="#4-动态绑定属性" class="headerlink" title="4.动态绑定属性"></a>4.动态绑定属性</h4><p>某些情况下，我们属性的名称可能也不是固定的：</p><ul><li><p>如果属性名称不是固定的，我们可以使用 :[属性名]&#x3D;“值” 的格式来定义</p></li><li><p>这种绑定的方式，我们称之为动态绑定属性</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">:</span>[<span class="attr">name</span>]=<span class="string">&quot;&#x27;aaa&#x27;&quot;</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">  <span class="attr">data</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">          <span class="attr">message</span>: <span class="string">&quot;Hello Vue&quot;</span>,</span><br><span class="line">          <span class="attr">name</span>: <span class="string">&quot;class&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="5-绑定对象"><a href="#5-绑定对象" class="headerlink" title="5.绑定对象"></a>5.绑定对象</h4><p>如果希望将一个对象的所有属性绑定到元素上的所有属性：</p><ul><li>可以直接使用 v-bind 绑定一个 对象</li></ul><p>案例：infos对象会被拆解成div的各个属性</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>&lt;h2 :name=<span class="string">&quot;name&quot;</span> :age=<span class="string">&quot;age&quot;</span> :height=<span class="string">&quot;height&quot;</span>&gt;<span class="title class_">Hello</span> <span class="title class_">World</span>&lt;/h2&gt;</span><br><span class="line">    &lt;!-- v-bind绑定对象  给组件传递参数 --&gt;</span><br><span class="line"><span class="number">2</span>   &lt;h2 v-bind=<span class="string">&quot;props&quot;</span>&gt;<span class="title class_">Hello</span> <span class="title class_">Bind</span>&lt;/h2&gt;</span><br><span class="line"><span class="attr">data</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">props</span>: &#123;</span><br><span class="line">                <span class="attr">name</span>: <span class="string">&quot;why&quot;</span>,</span><br><span class="line">                <span class="attr">age</span>: <span class="number">23</span>,</span><br><span class="line">                <span class="attr">height</span>: <span class="number">1.44</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&quot;why&quot;</span>,</span><br><span class="line">            <span class="attr">age</span>: <span class="number">23</span>,</span><br><span class="line">            <span class="attr">height</span>: <span class="number">1.44</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    <span class="comment">// 1 2效果相同</span></span><br></pre></td></tr></table></figure><h3 id="4-、Vue-的事件绑定"><a href="#4-、Vue-的事件绑定" class="headerlink" title="4 、Vue 的事件绑定"></a>4 、Vue 的事件绑定</h3><p>为了与用户进行交互，必须监听用户发生的事件</p><p>v-on的使用：</p><ul><li><p>缩写（语法糖）：@</p></li><li><p>预期：Function | Inline Statement | Object</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- <span class="number">1.</span>基本的写法 --&gt;</span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span> <span class="attr">v-on:click</span>=<span class="string">&quot;divClick&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">   &lt;!-- <span class="number">2.</span>语法糖写法 --&gt;</span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;divClick&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">   &lt;!-- <span class="number">3.</span>绑定的方法位置，也可以写成一个表达式（不常用,不推荐） --&gt;</span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123; counter &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;increment&quot;</span>&gt;</span>+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;counter--&quot;</span>&gt;</span>-1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">   &lt;!-- <span class="number">4.</span>绑定其他方法 --&gt;</span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span> @<span class="attr">mousemove</span>=<span class="string">&quot;divMousemove&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">   &lt;!-- <span class="number">5.</span>绑定多个事件 分开传入或者传入对象 --&gt;</span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;divClick&quot;</span> @<span class="attr">mousemove</span>=<span class="string">&quot;divMousemove&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="comment">// v-on: == v-on 下方这儿:可以省略</span></span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span> <span class="attr">v-on:</span>=<span class="string">&quot;&#123; click: divClick, mousemove: divMousemove &#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span> @=<span class="string">&quot;&#123; click: divClick, mousemove: divMousemove &#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="title function_">divClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">         <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;divClick&quot;</span>)</span><br><span class="line">       &#125;,</span><br><span class="line">       <span class="title function_">increment</span>(<span class="params"></span>) &#123;</span><br><span class="line">         <span class="variable language_">this</span>.<span class="property">counter</span>++</span><br><span class="line">       &#125;,</span><br><span class="line">       <span class="title function_">divMousemove</span>(<span class="params"></span>) &#123;</span><br><span class="line">         <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;mousemove&quot;</span>)</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><ul><li>参数：event</li><li>自定义参数</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- <span class="number">1.</span>默认传递event对象 --&gt;</span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;btn1Click&quot;</span>&gt;</span>按钮1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">   &lt;!-- <span class="number">2.</span>只有自己的参数 --&gt;</span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;btn2Click(&#x27;why&#x27;, age)&quot;</span>&gt;</span>按钮2<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">   &lt;!-- <span class="number">3.</span>明确的参数和event对象 --&gt;</span><br><span class="line">   &lt;!-- 在模板中想要明确的获取event对象：$event --&gt;</span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;btn3Click(&#x27;swd&#x27;, age, $event)&quot;</span>&gt;</span>按钮3<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.默认参数：event对象</span></span><br><span class="line">       <span class="comment">// 总结：如果在绑定事件的时候，没有传递任何的参数，那么event对象会被默认传递进来</span></span><br><span class="line">       <span class="title function_">btn1Click</span>(<span class="params"></span>) &#123;</span><br><span class="line">         <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;btnClick:&quot;</span>, event)</span><br><span class="line">       &#125;,</span><br><span class="line">       <span class="title function_">btn2Click</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">         <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;btn2Click&quot;</span>, name, age)</span><br><span class="line">       &#125;,</span><br><span class="line">       <span class="title function_">btn3Click</span>(<span class="params">name, age, event</span>) &#123;</span><br><span class="line">         <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;btn3Click&quot;</span>, name, age, event)</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><ul><li><p>修饰符：</p><ul><li>.stop - 调用 event.stopPropagation()</li><li>.prevent - 调用 event.preventDefault()</li><li>.capture - 添加事件侦听器时使用 capture 模式</li><li>.self - 只当事件是从侦听器绑定的元素本身触发时才触发回调</li><li>.{keyAlias} - 仅当事件是从特定键触发时才触发回调</li><li>.once - 只触发一次回调</li><li>.left - 只当点击鼠标左键时触发</li><li>.right - 只当点击鼠标右键时触发</li><li>.middle - 只当点击鼠标中键时触发</li><li>.passive - { passive: true } 模式添加侦听器</li></ul></li><li><p>用法：绑定事件监听</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div <span class="keyword">class</span>=<span class="string">&quot;box&quot;</span> @click=<span class="string">&quot;divClick&quot;</span>&gt;</span><br><span class="line">     <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.stop</span>=<span class="string">&quot;btnClick&quot;</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">   &lt;/div&gt;</span><br></pre></td></tr></table></figure><h3 id="5、Vue-的条件渲染"><a href="#5、Vue-的条件渲染" class="headerlink" title="5、Vue 的条件渲染"></a>5、Vue 的条件渲染</h3><p>某些情况下需要根据当前的条件决定某些元素或组件是否渲染，这时就需要进行条件判断</p><p>v-if、v-else、v-else-if用于根据条件来渲染某一块的内容：</p><ul><li><p>这些内容只有在条件为true时，才会被渲染出来</p></li><li><p>这三个指令与JavaScript的条件语句if、else、else if类似</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-if</span>=<span class="string">&quot;score &gt; 90&quot;</span>&gt;</span>优秀<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-else-if</span>=<span class="string">&quot;score &gt; 80&quot;</span>&gt;</span>良好<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-else-if</span>=<span class="string">&quot;score &gt;= 60&quot;</span>&gt;</span>及格<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-else</span>&gt;</span>不及格<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><h4 id="1-v-if的渲染原理"><a href="#1-v-if的渲染原理" class="headerlink" title="1.v-if的渲染原理"></a>1.v-if的渲染原理</h4><ul><li><p>v-if是惰性的</p></li><li><p>当条件为false时，其判断的内容完全不会被渲染或者会被销毁掉</p></li><li><p>当条件为true时，才会真正渲染条件块中的内容</p></li></ul><p>即当v-if所判断的条件为false时，页面查看代码中没有其创建的元素</p><h4 id="2-template-元素"><a href="#2-template-元素" class="headerlink" title="2.template 元素"></a>2.template 元素</h4><p>因为v-if是一个指令，所以必须将其添加到一个元素上：</p><ul><li><p>但是如果我们希望切换的是多个元素</p></li><li><p>此时我们渲染div，但是我们并不希望div这种元素被渲染</p></li><li><p>这个时候，我们可以选择使用template</p></li></ul><p>template元素可以当做不可见的包裹元素，并且在v-if上使用，但是最终template不会被渲染出来：</p><ul><li>有点类似于小程序中的block</li></ul><h4 id="3-v-show和v-if的区别"><a href="#3-v-show和v-if的区别" class="headerlink" title="3.v-show和v-if的区别"></a>3.v-show和v-if的区别</h4><p>在用法上的区别：</p><ul><li><p>v-show是不支持template</p></li><li><p>v-show不可以和v-else一起使用</p></li></ul><p>本质的区别：</p><ul><li><p>v-show元素无论是否需要显示到浏览器上，它的DOM实际都是有存在的，只是通过CSS的display属性来进行切换</p></li><li><p>v-if当条件为false时，其对应的元素压根不会被渲染到DOM中</p></li></ul><p>开发中选择</p><ul><li><p>如果我们的元素需要在显示和隐藏之间频繁的切换，那么使用v-show</p></li><li><p>如果不会频繁的发生切换，那么使用v-if</p></li></ul><h3 id="6、Vue-的列表渲染"><a href="#6、Vue-的列表渲染" class="headerlink" title="6、Vue 的列表渲染"></a>6、Vue 的列表渲染</h3><h4 id="1-渲染（遍历）方式"><a href="#1-渲染（遍历）方式" class="headerlink" title="1.渲染（遍历）方式"></a>1.渲染（遍历）方式</h4><p>开发中，我们往往会从服务器拿到一组数据，并且需要对其进行渲染</p><ul><li><p>这时可以使用v-for来完成</p></li><li><p>v-for类似于JavaScript的for循环，可以用于遍历一组数据</p></li></ul><p>v-for的基本格式是 “item in 数组”：</p><ul><li><p>数组通常是来自data或者prop，也可以是其他方式</p></li><li><p>item是我们给每项元素起的一个别名，这个别名可以自定来定义</p></li></ul><p>我们知道，在遍历一个数组的时候会经常需要拿到数组的索引：</p><ul><li><p>如果我们需要索引，可以使用格式： “(item, index) in 数组”</p></li><li><p>注意上面的顺序：数组元素项item是在前面的，索引项index是在后面的</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- <span class="number">1.</span>电影列表进行渲染 --&gt;</span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>电影列表<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;movie in movies&quot;</span>&gt;</span>&#123;&#123;movie&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">   &lt;!-- <span class="number">2.</span>电影列表同时索引(数组) --&gt;</span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">     // 支持 of  </span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(movie, index) in movies&quot;</span>&gt;</span>&#123;&#123;index + 1&#125;&#125; - &#123;&#123;movie&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">   &lt;!-- <span class="number">3.</span>遍历数组复杂数据 --&gt;</span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>商品列表<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span> <span class="attr">v-for</span>=<span class="string">&quot;item in products&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;<span class="name">h3</span> <span class="attr">class</span>=<span class="string">&quot;title&quot;</span>&gt;</span>商品:&#123;&#123;item.name&#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;<span class="name">span</span>&gt;</span>价格:&#123;&#123;item.price&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;<span class="name">p</span>&gt;</span>秒杀:&#123;&#123;item.desc&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>v-for也支持遍历对象，并且支持有一二三个参数：</p><ul><li><p>一个参数： “value in object”</p></li><li><p>二个参数： “(value, key) in object”</p></li><li><p>三个参数： “(value, key, index) in object”</p></li></ul><p>v-for同时也支持数字的遍历：</p><ul><li>每一个item都是一个数字</li></ul><p>v-for也可以遍历其他可迭代对象(Iterable)</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- <span class="number">1.</span>遍历对象 --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(value, key, index) in info&quot;</span>&gt;</span>&#123;&#123;value&#125;&#125;-&#123;&#123;key&#125;&#125;-&#123;&#123;index&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;!--<span class="number">2.</span>遍历字符串 --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in message&quot;</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;!-- <span class="number">3.</span>遍历数字 --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in 10&quot;</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h4 id="2-template元素"><a href="#2-template元素" class="headerlink" title="2.template元素"></a>2.template元素</h4><p>类似于v-if，你可以使用 template 元素来循环渲染一段包含多个元素的内容：</p><ul><li>使用template来对多个元素进行包裹，而不是使用div来完成；</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- 如果div没有实际的意义，可以使用template替换 --&gt;</span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">&quot;(value, key, index) in infos&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;value&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;<span class="name">strong</span>&gt;</span>&#123;&#123;key&#125;&#125;<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;<span class="name">i</span>&gt;</span>&#123;&#123;index&#125;&#125;<span class="tag">&lt;/<span class="name">i</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h4 id="3-数组更新检测"><a href="#3-数组更新检测" class="headerlink" title="3.数组更新检测"></a>3.数组更新检测</h4><p>Vue 将被侦听的数组的变更方法进行了包裹，所以它们也将会触发视图更新</p><p>这些被包裹过的方法包括：</p><ul><li><p>push()</p></li><li><p>pop()</p></li><li><p>shift()</p></li><li><p>unshift()</p></li><li><p>splice()</p></li><li><p>sort()</p></li><li><p>reverse()</p></li></ul><p>替换数组的方法</p><ul><li>上面的方法会直接修改原来的数组</li></ul><p>但是某些方法不会替换原来的数组，而是会生成新的数组，比如 filter()、concat() 和 slice()</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> &lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in names&quot;</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;btnClick&quot;</span>&gt;</span>修改数组<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"> &lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> &#123;</span><br><span class="line">         <span class="attr">names</span>: [<span class="string">&quot;sdw&quot;</span>, <span class="string">&quot;dwdx&quot;</span>, <span class="string">&quot;wwa&quot;</span>]</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;,</span><br><span class="line">     <span class="attr">methods</span>: &#123;</span><br><span class="line">       <span class="title function_">btnClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">         <span class="comment">// 1.将数组修改为新的数组</span></span><br><span class="line">         <span class="comment">// this.names = [&#x27;scs&#x27;,&#x27;dwa&#x27;]</span></span><br><span class="line"></span><br><span class="line">         <span class="comment">// 2.通过一些数组的方法法，修改数组中的元素</span></span><br><span class="line">         <span class="comment">// this.names.push(&quot;ig&quot;)</span></span><br><span class="line"></span><br><span class="line">         <span class="comment">// this.names.splice(2,1,&quot;why&quot;)</span></span><br><span class="line">         <span class="comment">// this.names.sort()</span></span><br><span class="line">         <span class="comment">// this.names.reverse()</span></span><br><span class="line"></span><br><span class="line">         <span class="comment">// 3.不修改原数组的方法是不能侦听（watch）</span></span><br><span class="line">         <span class="keyword">const</span> newNames = <span class="variable language_">this</span>.<span class="property">names</span>.<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> item + <span class="string">&quot;why&quot;</span>)</span><br><span class="line">         <span class="variable language_">this</span>.<span class="property">names</span> = newNames</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><h4 id="4-v-for中的key"><a href="#4-v-for中的key" class="headerlink" title="4.v-for中的key"></a>4.v-for中的key</h4><h5 id="1、了解key属性"><a href="#1、了解key属性" class="headerlink" title="1、了解key属性"></a>1、了解key属性</h5><p>在使用v-for进行列表渲染时，我们通常会给元素或者组件绑定一个key属性</p><ul><li><p>key属性主要用在Vue的虚拟DOM算法，在新旧nodes对比时辨识VNodes</p></li><li><p>如果不使用key，Vue会使用一种最大限度减少动态元素并且尽可能的尝试就地修改&#x2F;复用相同类型元素的算法</p></li><li><p>而使用key时，它会基于key的变化重新排列元素顺序，并且会移除&#x2F;销毁key不存在的元素</p></li></ul><h5 id="2、虚拟DOM"><a href="#2、虚拟DOM" class="headerlink" title="2、虚拟DOM"></a>2、虚拟DOM</h5><p>VNode：先理解HTML元素创建出来的VNode</p><ul><li><p>VNode的全称是Virtual Node，也就是虚拟节点</p></li><li><p>无论是组件还是元素，它们最终在Vue中表示出来的都是一个个VNode</p></li><li><p>VNode的本质是一个JavaScript的对象</p></li></ul><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230410203039359.png" alt="image-20230410203039359"></p><p>如果不只是一个简单的div，而是有一堆元素，那么应该会形成一个VNode Tree</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230410203141402.png" alt="image-20230410203141402"></p><p>作用：</p><ul><li>跨平台：将对象进行多端的解析，以展示于不同的平台</li></ul><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230410203257959.png" alt="image-20230410203257959"></p><ul><li>diff 算法</li></ul><p>案例：点击按钮在 li 插入 f 元素</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;button @click=<span class="string">&quot;insetF&quot;</span>&gt;插入F&lt;/button&gt;</span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="comment">&lt;!-- key要求唯一：id --&gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in letters&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;item&quot;</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="attr">methods</span>: &#123;</span><br><span class="line">       <span class="title function_">insetF</span>(<span class="params"></span>) &#123;</span><br><span class="line">         <span class="variable language_">this</span>.<span class="property">letters</span>.<span class="title function_">splice</span>(<span class="number">2</span>, <span class="number">0</span>, <span class="string">&quot;f&quot;</span>)</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>这次更新对于ul和button是不需要进行更新，需要更新的是我们li的列表</p><ul><li><p>在Vue中，对于相同父元素的子元素节点并不会重新渲染整个列表</p></li><li><p>因为对于列表中 a、b、c、d它们都是没有变化的</p></li><li><p>在操作真实DOM的时候，我们只需要在中间插入一个f的li即可</p></li></ul><p>Vue中对于列表的更新究竟是如何操作的呢？</p><p>Vue事实上会对于有key和没有key会调用两个不同的方法</p><ul><li><p>有key，那么就使用 patchKeyedChildren方法</p></li><li><p>没有key，那么久使用 patchUnkeyedChildren方法</p></li></ul><p>在没有key时diff算法效率并不高</p><ul><li><p>c和d来说它们事实上并不需要有任何的改动</p></li><li><p>但是c被f所使用了，所有后续所有的内容都要一次进行改动，并且最后进行新增</p></li></ul><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230410203723802.png" alt="image-20230410203723802"></p><h5 id="3、key的作用"><a href="#3、key的作用" class="headerlink" title="3、key的作用"></a>3、key的作用</h5><p>有key的diff算法</p><p>第一步的操作是从头开始进行遍历、比较</p><ul><li><p>a和b是一致的会继续进行比较</p></li><li><p>c和f因为key不一致，所以就会break跳出循环</p></li></ul><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230410204040153.png" alt="image-20230410204040153"></p><p>第二步的操作是从尾部开始进行遍历、比较</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230410204053987.png" alt="image-20230410204053987"></p><p>第三步是如果旧节点遍历完毕，但是依然有新的节点，那么就新增节点</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230410204020323.png" alt="image-20230410204020323"></p><p>第四步是如果新的节点遍历完毕，但是依然有旧的节点，那么就移除旧节点</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230410204005807.png" alt="image-20230410204005807"></p><p>第五步是最特色的情况，中间还有很多未知的或者乱序的节点</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230410203948482.png" alt="image-20230410203948482"></p><p>所以可以发现，Vue在进行diff算法的时候，会尽量利用我们的key来进行优化操作</p><ul><li><p>在没有key的时候我们的效率是非常低效的</p></li><li><p>在进行插入或者重置顺序的时候，保持相同的key可以让diff算法更加的高效</p></li></ul><h2 id="3-Options-API"><a href="#3-Options-API" class="headerlink" title="3.Options API"></a>3.Options API</h2><h3 id="1、计算属性computed"><a href="#1、计算属性computed" class="headerlink" title="1、计算属性computed"></a>1、计算属性computed</h3><h4 id="1-基本使用"><a href="#1-基本使用" class="headerlink" title="1.基本使用"></a>1.基本使用</h4><p>在模板中可以直接通过插值语法显示一些data中的数据</p><p>但是某些情况可能需要对数据进行一些转化后再显示，或者需要将多个数据结合起来进行显示</p><ul><li><p>比如需要对多个data数据进行运算、三元运算符来决定结果、数据进行某种转化后显示</p></li><li><p>在模板中使用表达式，可以非常方便的实现，但是设计它们的初衷是用于简单的运算</p></li><li><p>在模板中放入太多的逻辑会让模板过重和难以维护</p></li><li><p>并且如果多个地方都使用到，那么会有大量重复的代码</p></li></ul><p>有没有什么方法可以将逻辑抽离出去</p><ul><li><p>可以，其中一种方式就是将逻辑抽取到一个method中，放到methods的options中</p></li><li><p>但是这种做法有一个直观的弊端，就是所有的data使用过程都会变成了一个方法的调用</p></li></ul><p>另外一种方式就是使用计算属性computed</p><p>计算属性</p><ul><li><p>官方并没有给出直接的概念解释</p></li><li><p>而是说：对于任何包含响应式数据的复杂逻辑，你都应该使用计算属性</p></li><li><p>计算属性将被混入到组件实例中</p><ul><li>所有 getter 和 setter 的 this 上下文自动地绑定为组件实例；</li></ul></li></ul><p>计算属性的用法：</p><ul><li><p>选项：computed</p></li><li><p>类型：{ [key: string]: Function | { get: Function, set: Function } }</p></li></ul><h5 id="案例对比实现"><a href="#案例对比实现" class="headerlink" title="案例对比实现"></a>案例对比实现</h5><h6 id="1-模板语法："><a href="#1-模板语法：" class="headerlink" title="1.模板语法："></a>1.模板语法：</h6><ul><li><p>缺点一：模板中存在大量的复杂逻辑，不便于维护（模板中表达式的初衷是用于简单的计算）</p></li><li><p>缺点二：当有多次一样的逻辑时，存在重复的代码</p></li><li><p>缺点三：多次使用的时候，很多运算也需要多次执行，没有缓存</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- 插值语法表达式直接拼接 --&gt;</span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123; firstName + &quot; &quot; + lastName&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123; firstName&#125;&#125; &#123;&#123;lastName&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">   &lt;!-- <span class="number">2.</span>显示等级 --&gt;</span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123; score &gt;= 60 ? &#x27;及格&#x27; : &#x27;不及格&#x27; &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">   &lt;!-- <span class="number">3.</span>反转单词 --&gt;</span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123; message.split(&quot; &quot;).reverse().join(&quot; &quot;) &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"> &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">     <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> &#123;</span><br><span class="line">         <span class="comment">// 1.姓名</span></span><br><span class="line">         <span class="attr">firstName</span>: <span class="string">&quot;kobe&quot;</span>,</span><br><span class="line">         <span class="attr">lastName</span>: <span class="string">&quot;bryant&quot;</span>,</span><br><span class="line">         <span class="comment">// 2.分数  及格/不及格</span></span><br><span class="line">         <span class="attr">score</span>: <span class="number">80</span>,</span><br><span class="line">         <span class="comment">// 3.一串文本，对文本中的单词进行反转显示</span></span><br><span class="line">         <span class="attr">message</span>: <span class="string">&#x27;my name is wbh&#x27;</span></span><br><span class="line">       &#125;</span><br><span class="line">     &#125;,</span><br></pre></td></tr></table></figure><h6 id="2-methods-实现"><a href="#2-methods-实现" class="headerlink" title="2.methods 实现"></a>2.methods 实现</h6><ul><li><p>缺点一：我们事实上需要显示的是一个结果，但是都变成了一种方法的调用</p></li><li><p>缺点二：多次使用方法的时候，没有缓存，也需要多次计算</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">methods</span>: &#123;</span><br><span class="line">      <span class="title function_">getFullName</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">firstName</span> + <span class="string">&quot; &quot;</span> + <span class="variable language_">this</span>.<span class="property">lastName</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="title function_">scoreLevel</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">score</span> &gt;= <span class="number">60</span> ? <span class="string">&#x27;及格&#x27;</span> : <span class="string">&#x27;不及格&#x27;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="title function_">reverseMessage</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">message</span>.<span class="title function_">split</span>(<span class="string">&quot; &quot;</span>).<span class="title function_">reverse</span>().<span class="title function_">join</span>(<span class="string">&quot; &quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h6 id="3-computed-实现"><a href="#3-computed-实现" class="headerlink" title="3.computed 实现"></a>3.computed 实现</h6><ul><li><p>注意：计算属性看起来像是一个函数，但是我们在使用的时候不需要加()，这个后面讲setter和getter时会讲到</p></li><li><p>发现无论是直观上，还是效果上计算属性都是更好的选择</p></li><li><p>并且计算属性是有缓存的</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">!-- 插值语法表达式直接拼接 --&gt;</span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123; fullName &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123; fullName &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">   &lt;!-- <span class="number">2.</span>显示等级 --&gt;</span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123; scoreLevel &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">   &lt;!-- <span class="number">3.</span>反转单词 --&gt;</span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123; reverseMessage &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"> <span class="attr">computed</span>: &#123;</span><br><span class="line">       <span class="comment">// 1.计算属性默认对应的是一个函数</span></span><br><span class="line">       <span class="title function_">fullName</span>(<span class="params"></span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">firstName</span> + <span class="string">&quot; &quot;</span> + <span class="variable language_">this</span>.<span class="property">lastName</span></span><br><span class="line">       &#125;,</span><br><span class="line">       <span class="title function_">scoreLevel</span>(<span class="params"></span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">score</span> &gt;= <span class="number">60</span> ? <span class="string">&quot;及格&quot;</span> : <span class="string">&quot;不及格&quot;</span></span><br><span class="line">       &#125;,</span><br><span class="line">       <span class="title function_">reverseMessage</span>(<span class="params"></span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">message</span>.<span class="title function_">split</span>(<span class="string">&quot; &quot;</span>).<span class="title function_">reverse</span>().<span class="title function_">join</span>(<span class="string">&quot; &quot;</span>)</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><h4 id="2-computed-和-methods-的区别"><a href="#2-computed-和-methods-的区别" class="headerlink" title="2.computed 和 methods 的区别"></a>2.computed 和 methods 的区别</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">methods</span>: &#123;</span><br><span class="line">     <span class="title function_">getFullName</span>(<span class="params"></span>) &#123;</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;methods--------&quot;</span>)  <span class="comment">// 调用几次执行几次</span></span><br><span class="line">       <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">firstName</span> + <span class="string">&quot; &quot;</span> + <span class="variable language_">this</span>.<span class="property">lastName</span></span><br><span class="line">     &#125;,</span><br><span class="line">     <span class="title function_">changeLastName</span>(<span class="params"></span>) &#123;</span><br><span class="line">       <span class="variable language_">this</span>.<span class="property">lastName</span> = <span class="string">&quot;why&quot;</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="attr">computed</span>: &#123;</span><br><span class="line">     <span class="title function_">fullName</span>(<span class="params"></span>) &#123;</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;--------&quot;</span>) <span class="comment">//执行一次 会有缓存</span></span><br><span class="line">       <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">firstName</span> + <span class="string">&quot; &quot;</span> + <span class="variable language_">this</span>.<span class="property">lastName</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>原因：</p><ul><li><p>计算属性会基于它们的依赖关系进行缓存</p></li><li><p>在数据不发生变化时，计算属性是不需要重新计算的</p></li><li><p>但是如果依赖的数据发生变化，在使用时，计算属性依然会重新进行计算</p></li></ul><h4 id="3-computed-的-setter-和-getter"><a href="#3-computed-的-setter-和-getter" class="headerlink" title="3.computed 的 setter 和 getter"></a>3.computed 的 setter 和 getter</h4><p>计算属性在大多数情况下，只需要一个getter方法即可，所以我们会将计算属性直接写成一个函数</p><p>如果我们确实想设置计算属性的值，也可以给计算属性设置一个setter的方法</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123; fullname &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;setFullName&quot;</span>&gt;</span>设置fullname<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;  </span><br><span class="line"> <span class="attr">methods</span>: &#123;</span><br><span class="line">      <span class="title function_">setFullName</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">fullname</span> = <span class="string">&quot;coder why&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,  </span><br><span class="line"> <span class="attr">computed</span>: &#123;</span><br><span class="line">      <span class="comment">// 语法糖的写法：</span></span><br><span class="line">      <span class="comment">// fullname() &#123;</span></span><br><span class="line">      <span class="comment">//   return this.firstName + &quot; &quot; + this.lastName</span></span><br><span class="line">      <span class="comment">// &#125;,</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 完整的写法:</span></span><br><span class="line">      <span class="attr">fullname</span>: &#123;</span><br><span class="line">        <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">firstName</span> + <span class="string">&quot; &quot;</span> + <span class="variable language_">this</span>.<span class="property">lastName</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">set</span>: <span class="keyword">function</span>(<span class="params">value</span>) &#123;</span><br><span class="line">          <span class="keyword">const</span> names = value.<span class="title function_">split</span>(<span class="string">&quot; &quot;</span>)</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">firstName</span> = names[<span class="number">0</span>]</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">lastName</span> = names[<span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>源码对setter和getter的处理</p><ul><li>Vue源码内部只是做了一个逻辑判断而已</li></ul><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230410210215389.png" alt="image-20230410210215389"></p><h3 id="2、侦听器watch"><a href="#2、侦听器watch" class="headerlink" title="2、侦听器watch"></a>2、侦听器watch</h3><h4 id="1-什么是侦听器"><a href="#1-什么是侦听器" class="headerlink" title="1.什么是侦听器"></a>1.什么是侦听器</h4><ul><li><p>开发中我们在data返回的对象中定义了数据，这个数据通过插值语法等方式绑定到template中</p></li><li><p>当数据变化时，template会自动进行更新来显示最新的数据</p></li><li><p>但是在某些情况下，我们希望在代码逻辑中监听某个数据的变化，这个时候就需要用侦听器watch来完成</p></li></ul><p>用法：</p><ul><li>选项：watch</li><li>类型：{ [key: string]: string | Function | Object | Array}</li></ul><h4 id="2-基本侦听"><a href="#2-基本侦听" class="headerlink" title="2.基本侦听"></a>2.基本侦听</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeMessage&quot;</span>&gt;</span>修改message<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;  </span><br><span class="line"></span><br><span class="line"> <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">message</span>: <span class="string">&quot;Hello Vue&quot;</span>,</span><br><span class="line">        <span class="attr">infos</span>: &#123; <span class="attr">name</span>:<span class="string">&#x27;why&#x27;</span>, <span class="attr">age</span>: <span class="number">23</span>&#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">methods</span>: &#123;</span><br><span class="line">      <span class="title function_">changeMessage</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">message</span> = <span class="string">&quot;dwsa&quot;</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">infos</span> = &#123; <span class="attr">name</span>:<span class="string">&#x27;kobe&#x27;</span> &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">watch</span>: &#123;</span><br><span class="line">      <span class="comment">// 1.默认有两个参数：newValue/oldVale</span></span><br><span class="line">      <span class="title function_">message</span>(<span class="params">newValue, oldValue</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;message数据发生了变化&quot;</span>, newValue, oldValue)</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="title function_">infos</span>(<span class="params">newValue, oldValue</span>) &#123;</span><br><span class="line">        <span class="comment">// 2.如果是对象类型，那么拿到的是代理对象 proxy</span></span><br><span class="line">        <span class="comment">// console.log(&quot;infos数据发生了变化&quot;, oldValue, newValue)</span></span><br><span class="line">        <span class="comment">// console.log(newValue.name, oldValue.name)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.获取原始对象</span></span><br><span class="line">        <span class="comment">// console.log(&#123; ...newValue &#125;)</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Vue</span>.<span class="title function_">toRaw</span>(oldValue))</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h4 id="3-侦听选项"><a href="#3-侦听选项" class="headerlink" title="3.侦听选项"></a>3.侦听选项</h4><p>例子:当我们点击按钮的时候会修改info.name的值</p><ul><li><p>这个时候使用watch来侦听info，可以侦听到吗？答案是不可以</p></li><li><p>这是因为默认情况下，watch只是在侦听info的引用变化，对于内部属性的变化是不会做出响应的</p><ul><li>这个时候我们可以使用一个选项deep进行更深层的侦听；</li></ul></li></ul><p>注意前面我们说过watch里面侦听的属性对应的也可以是一个Object</p><p>还有另外一个属性，是希望一开始的就会立即执行一次：</p><ul><li><p>使用immediate选项</p></li><li><p>这个时候无论后面数据是否有变化，侦听的函数都会先执行一次</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">     <span class="keyword">return</span> &#123;</span><br><span class="line">       <span class="attr">infos</span>: &#123; <span class="attr">name</span>:<span class="string">&#x27;why&#x27;</span>, <span class="attr">age</span>: <span class="number">23</span>&#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="attr">methods</span>: &#123;</span><br><span class="line">     <span class="title function_">changeMessage</span>(<span class="params"></span>) &#123;</span><br><span class="line">       <span class="comment">// 1.创建一个新对象，赋值给info</span></span><br><span class="line">       <span class="comment">// this.infos = &#123; name:&#x27;kobe&#x27; &#125;</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 2.直接修改原对象的某一个属性</span></span><br><span class="line">       <span class="variable language_">this</span>.<span class="property">infos</span>.<span class="property">name</span> = <span class="string">&quot;kobe&quot;</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="attr">watch</span>: &#123;</span><br><span class="line">     <span class="comment">// 默认watch的监听不会进行深度监听</span></span><br><span class="line">     <span class="comment">// infos(newValue, oldValue) &#123;</span></span><br><span class="line">     <span class="comment">//   console.log(&quot;侦听infos改变&quot;,newValue, oldValue)</span></span><br><span class="line">     <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">// 进行深度监听</span></span><br><span class="line">     <span class="attr">infos</span>: &#123;</span><br><span class="line">       <span class="title function_">handler</span>(<span class="params">newValue, oldValue</span>) &#123;</span><br><span class="line">         <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;侦听infos改变&quot;</span>, newValue, oldValue)</span><br><span class="line">         <span class="variable language_">console</span>.<span class="title function_">log</span>(newValue === oldValue)</span><br><span class="line">       &#125;,</span><br><span class="line">       <span class="comment">// 监听器的一个配置选项</span></span><br><span class="line">       <span class="comment">// infos进行深度监听</span></span><br><span class="line">       <span class="attr">deep</span>: <span class="literal">true</span>,</span><br><span class="line">       <span class="comment">// 第一次渲染直接执行一次监听器</span></span><br><span class="line">       <span class="attr">immediate</span>: <span class="literal">true</span></span><br><span class="line">     &#125;,</span><br><span class="line">     <span class="comment">// 监听name得到改变</span></span><br><span class="line">     <span class="string">&quot;infos.name&quot;</span>: <span class="keyword">function</span>(<span class="params">newValue, oldValue</span>) &#123;</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;侦听infos.name改变&quot;</span>, newValue, oldValue)</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><h4 id="4-其他的写法"><a href="#4-其他的写法" class="headerlink" title="4.其他的写法"></a>4.其他的写法</h4><p>可以在created的生命周期中，使用this.$watchs 来侦听</p><ul><li><p>第一个参数是要侦听的源</p></li><li><p>第二个参数是侦听的回调函数callback</p></li><li><p>第三个参数是额外的其他选项，比如deep、immediate</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 生命周期的回调函数:当前的组件被创建时自动执行</span></span><br><span class="line">   <span class="comment">// 一般在该函数中，会进行网络请求</span></span><br><span class="line">   <span class="title function_">created</span>(<span class="params"></span>) &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;created&quot;</span>)</span><br><span class="line"></span><br><span class="line">     <span class="variable language_">this</span>.$watch(<span class="string">&quot;message&quot;</span>, <span class="function">(<span class="params">newValue, oldValue</span>) =&gt;</span> &#123;</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;message数据变化&quot;</span>,newValue, oldValue)</span><br><span class="line">     &#125;, &#123;<span class="attr">deep</span>: <span class="literal">true</span>, <span class="attr">immediate</span>: <span class="literal">true</span>&#125;)</span><br><span class="line">   &#125;,</span><br></pre></td></tr></table></figure><h3 id="3、阶段练习"><a href="#3、阶段练习" class="headerlink" title="3、阶段练习"></a>3、阶段练习</h3><p>书籍购物车案例</p><h2 id="4-Vue-的双向绑定"><a href="#4-Vue-的双向绑定" class="headerlink" title="4. Vue 的双向绑定"></a>4. Vue 的双向绑定</h2><h3 id="1、基本使用"><a href="#1、基本使用" class="headerlink" title="1、基本使用"></a>1、基本使用</h3><p>表单提交是开发中非常常见的功能，也是和用户交互的重要手段：</p><ul><li><p>比如用户在登录、注册时需要提交账号密码</p></li><li><p>比如用户在检索、创建、更新信息时，需要提交一些数据</p></li></ul><p>这些都要求我们能在代码逻辑中获取到用户提交的数据，通常会使用v-model指令来完成</p><ul><li><p>v-model指令可以在表单 input、textarea以及select元素上创建双向数据绑定</p></li><li><p>它会根据控件类型自动选取正确的方法来更新元素</p></li><li><p>尽管有些神奇，但 v-model 本质上不过是语法糖，它负责监听用户的输入事件来更新数据，并在某种极端场景下进行一些特殊处理</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> v-model=<span class="string">&quot;message&quot;</span>&gt;</span><br></pre></td></tr></table></figure><h3 id="2、v-model-的原理"><a href="#2、v-model-的原理" class="headerlink" title="2、v-model 的原理"></a>2、v-model 的原理</h3><ul><li><p>v-bind绑定value属性的值</p></li><li><p>v-on绑定input事件监听到函数中，函数会获取最新的值赋值到绑定的属性中</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> :value=<span class="string">&quot;message&quot;</span> @input=<span class="string">&quot;inputChange&quot;</span>&gt;</span><br></pre></td></tr></table></figure><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230412110510508.png" alt="image-20230412110510508"></p><p>事实上v-model更加复杂</p><h3 id="3、绑定其他类型"><a href="#3、绑定其他类型" class="headerlink" title="3、绑定其他类型"></a>3、绑定其他类型</h3><h4 id="1-v-model-绑定-textarea"><a href="#1-v-model-绑定-textarea" class="headerlink" title="1.v-model 绑定 textarea"></a>1.v-model 绑定 textarea</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;textarea cols=<span class="string">&quot;30&quot;</span> rows=<span class="string">&quot;10&quot;</span> v-model=<span class="string">&quot;content&quot;</span>&gt;&lt;/textarea&gt;</span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;content&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h4 id="2-v-model-绑定-checkbox"><a href="#2-v-model-绑定-checkbox" class="headerlink" title="2.v-model 绑定 checkbox"></a>2.v-model 绑定 checkbox</h4><h5 id="单选框"><a href="#单选框" class="headerlink" title="单选框"></a>单选框</h5><ul><li><p>v-model 即为布尔值。</p></li><li><p>此时 input 的 value 属性并不影响 v-model 的值</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">   &lt;!-- <span class="number">1.</span>checkbox单选框，绑定到属性的值是一个<span class="title class_">Boolean</span> --&gt;</span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;agree&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;agree&quot;</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;isAgree&quot;</span>&gt;</span> 同意协议</span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">isAgree: false</span></span><br></pre></td></tr></table></figure><h5 id="多选框"><a href="#多选框" class="headerlink" title="多选框"></a>多选框</h5><ul><li><p>当是多个复选框时，因为可以选中多个，所以对应的 data 中属性是一个数组</p></li><li><p>当选中某一个时，就会将 input 的 value 添加到数组中</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">   &lt;label <span class="keyword">for</span>=<span class="string">&quot;sing&quot;</span>&gt;</span><br><span class="line">       <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;sing&quot;</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;hobbies&quot;</span> <span class="attr">value</span>=<span class="string">&quot;sing&quot;</span>&gt;</span> 唱</span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;jump&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;jump&quot;</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;hobbies&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jump&quot;</span>&gt;</span> 跳</span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">hobbies: []</span></span><br></pre></td></tr></table></figure><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230412110951563.png" alt="image-20230412110951563" style="zoom: 50%;" /><h4 id="3-v-model-绑定-radio"><a href="#3-v-model-绑定-radio" class="headerlink" title="3.v-model 绑定 radio"></a>3.v-model 绑定 radio</h4><p>v-model 绑定 radio，用于选择其中一项</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">   &lt;div <span class="keyword">class</span>=<span class="string">&quot;gender&quot;</span>&gt;</span><br><span class="line">     &lt;!-- v-model绑定同一个值 会自动radio的互斥 可以不需要name属性--&gt;</span><br><span class="line">     <span class="language-xml"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;male&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;male&quot;</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;male&quot;</span>&gt;</span> 男</span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;female&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;female&quot;</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;female&quot;</span>&gt;</span> 女de</span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;<span class="name">h2</span>&gt;</span>性别：&#123;&#123;gender&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">gender: &quot;male&quot;  // 可以默认初始值</span></span><br></pre></td></tr></table></figure><h4 id="4-v-model-绑定-select"><a href="#4-v-model-绑定-select" class="headerlink" title="4.v-model 绑定 select"></a>4.v-model 绑定 select</h4><p>单选：只能选中一个值</p><ul><li><p>v-model 绑定的是一个值</p></li><li><p>当我们选中 option 中的一个时，会将它对应的 value 赋值到 fruit 中</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">   &lt;!-- select的单选   v-model 绑定到的是 select 中--&gt;</span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">select</span> <span class="attr">v-model</span>=<span class="string">&quot;fruit&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;apple&quot;</span>&gt;</span>苹果<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;orange&quot;</span>&gt;</span>橘子<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;banana&quot;</span>&gt;</span>香蕉<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="attr">fruit</span>: <span class="string">&quot;orange&quot;</span>  <span class="comment">// 默认值</span></span><br></pre></td></tr></table></figure><p>多选：可以选中多个值</p><ul><li><p>v-model绑定的是一个数组</p></li><li><p>当选中多个值时，就会将选中的option对应的value添加到数组fruit中</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;select multiple size=<span class="string">&quot;3&quot;</span> v-model=<span class="string">&quot;fruits&quot;</span>&gt;</span><br><span class="line">     <span class="language-xml"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;apple&quot;</span>&gt;</span>苹果<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span></span><br><span class="line">     <span class="language-xml"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;orange&quot;</span>&gt;</span>橘子<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span></span><br><span class="line">     <span class="language-xml"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;banana&quot;</span>&gt;</span>香蕉<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span></span><br><span class="line">   &lt;/select&gt;</span><br><span class="line"></span><br><span class="line"><span class="attr">fruits</span>: []</span><br></pre></td></tr></table></figure><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230412111708135.png" alt="image-20230412111708135" style="zoom: 67%;" /><h4 id="5-v-model-的值绑定"><a href="#5-v-model-的值绑定" class="headerlink" title="5.v-model 的值绑定"></a>5.v-model 的值绑定</h4><p>目前我们在前面的案例中大部分的值都是在template中固定好的：</p><ul><li><p>比如gender的两个输入框值male、female</p></li><li><p>比如hobbies的三个输入框值basketball、football</p></li></ul><p>在开发中，数据可能是来自服务器的，那么可以先将值请求下来，绑定到data返回的对象中，再通过v-bind来进行值的绑定，这个过程就是值绑定</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- <span class="number">1.</span>select的值绑定 --&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">select</span> <span class="attr">multiple</span> <span class="attr">size</span>=<span class="string">&quot;3&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;fruits&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">option</span> <span class="attr">v-for</span>=<span class="string">&quot;item in allFruits&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;item.value&quot;</span> <span class="attr">:value</span>=<span class="string">&quot;item.value&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;&#123; item.text &#125;&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">option</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;!-- <span class="number">2.</span>checkbox的值绑定 --&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-for</span>=<span class="string">&quot;item in allHobbies&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;item.value&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">label</span> <span class="attr">:for</span>=<span class="string">&quot;item.value&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">:id</span>=<span class="string">&quot;item.value&quot;</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;hobbies&quot;</span> <span class="attr">:value</span>=<span class="string">&quot;item.value&quot;</span>&gt;</span> &#123;&#123;item.text&#125;&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="4-v-model-修饰符"><a href="#4-v-model-修饰符" class="headerlink" title="4.v-model 修饰符"></a>4.v-model 修饰符</h3><h4 id="1、lazy"><a href="#1、lazy" class="headerlink" title="1、lazy"></a>1、lazy</h4><ul><li><p>默认情况下，v-model在进行双向绑定时，绑定的是input事件，那么会在每次内容输入后就将最新的值和绑定的属性进行同步</p></li><li><p>如果我们在v-model后跟上lazy修饰符，那么会将绑定的事件切换为 change 事件，只有在提交时（比如回车）才会触发</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> v-model.<span class="property">lazy</span>=<span class="string">&quot;message&quot;</span>&gt;</span><br></pre></td></tr></table></figure><h4 id="2、number"><a href="#2、number" class="headerlink" title="2、number"></a>2、number</h4><p>绑定的 message 总是string类型，即使在我们设置 type 为 number 也是 string 类型</p><p>如果希望转换为数字类型，那么可以使用 .number 修饰符：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> v-model.<span class="property">number</span>=<span class="string">&quot;counter&quot;</span>&gt;</span><br></pre></td></tr></table></figure><p>在进行逻辑判断时，如果是一个string和数字类型对比，在可以转化的情况下会进行隐式转换</p><p>但typeof 查询的还是字符类型</p><h4 id="3、trim"><a href="#3、trim" class="headerlink" title="3、trim"></a>3、trim</h4><p>如果要自动过滤用户输入的守卫空白字符，可以给 v-model 添加 trim 修饰符</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> v-model.<span class="property">trim</span>=<span class="string">&quot;content&quot;</span>&gt;</span><br></pre></td></tr></table></figure><h4 id="4、多个修饰符一起使用"><a href="#4、多个修饰符一起使用" class="headerlink" title="4、多个修饰符一起使用"></a>4、多个修饰符一起使用</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> v-model.<span class="property">lazy</span>.<span class="property">trim</span>=<span class="string">&quot;content2&quot;</span>&gt;</span><br></pre></td></tr></table></figure><h2 id="5-组件化开发"><a href="#5-组件化开发" class="headerlink" title="5.组件化开发"></a>5.组件化开发</h2><h3 id="1、认识组件化开发"><a href="#1、认识组件化开发" class="headerlink" title="1、认识组件化开发"></a>1、认识组件化开发</h3><h4 id="1-开发思想"><a href="#1-开发思想" class="headerlink" title="1.开发思想"></a>1.开发思想</h4><ul><li><p>如果将一个页面中所有的处理逻辑全部放在一起，处理起来就会变得非常复杂，而且不利于后续的管理以及扩展</p></li><li><p>但如果们把一个页面拆分成一个个小的功能块，每个功能块完成属于自己这部分独立的功能，那么之后整个页面的管理和维护就变得非常容易</p></li><li><p>如果将一个个功能块拆分后，就可以像搭建积木一下来搭建我们的项目</p></li></ul><p>现在可以说整个的大前端开发都是组件化的天下</p><ul><li><p>无论从三大框架（Vue、React、Angular），还是跨平台方案的Flutter，甚至是移动端都在转向组件化开发，包括小程序的开发也是采用组件化开发的思想</p></li><li><p>所以，学习组件化最重要的是它的思想，每个框架或者平台可能实现方法不同，但是思想都是一样的</p></li></ul><p>组件化思想构建程序</p><ul><li><p>将一个完整的页面分成很多个组件</p></li><li><p>每个组件都用于实现页面的一个功能块</p></li><li><p>而每一个组件又可以进行细分</p></li><li><p>而组件本身又可以在多个地方进行复用</p></li></ul><h4 id="2-Vue-的组件化"><a href="#2-Vue-的组件化" class="headerlink" title="2.Vue 的组件化"></a>2.Vue 的组件化</h4><ul><li>createApp 函数传入了一个对象App，这个对象本质上就是一个组件，也是应用程序的根组件</li><li>组件化提供了一种抽象，让我们可以开发出一个个独立可复用的小组件来构造我们的应用</li><li>任何的应用都会被抽象成一颗组件树</li></ul><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230412113210135.png" alt="image-20230412113210135"></p><h3 id="2、注册组件"><a href="#2、注册组件" class="headerlink" title="2、注册组件"></a>2、注册组件</h3><p>注册组件分成两种：</p><ul><li><p>全局组件：在任何其他的组件中都可以使用的组件</p></li><li><p>局部组件：只有在注册的组件中才能使用的组件</p></li></ul><h4 id="1-注册全局组件"><a href="#1-注册全局组件" class="headerlink" title="1.注册全局组件"></a>1.注册全局组件</h4><ul><li><p>全局组件需要使用我们全局创建的app来注册组件</p></li><li><p>通过 component 方法传入组件名称、组件对象即可注册一个全局组件</p></li><li><p>之后，可以在 App 组件的template中直接使用这个全局组件</p></li><li><p>组件本身也可以有自己的代码逻辑，比如自己的data、methods等</p></li><li><p>全局组件的特点是：一旦注册成功后，可以在任意其他组件的template中使用</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- 组件 product-item的模板 --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;item&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;product&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span> </span><br><span class="line">   <span class="number">1.</span>通过app.<span class="property">component</span>（组件名称，组件的对象）</span><br><span class="line">    <span class="number">2.</span>在<span class="title class_">App</span>组件的模板中，可以直接使用product-item的组件</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1.组件：App组件（根组件）</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title class_">App</span> = &#123;&#125;</span><br><span class="line">  <span class="comment">// 2.创建app</span></span><br><span class="line">  <span class="keyword">const</span> app = <span class="title class_">Vue</span>.<span class="title function_">createApp</span>(<span class="title class_">App</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.注册一个全局组件</span></span><br><span class="line">  <span class="comment">// product-item全局组件</span></span><br><span class="line">  app.<span class="title function_">component</span>(<span class="string">&quot;product-item&quot;</span>, &#123;</span><br><span class="line">    <span class="comment">// 通过 id 使用在html中构建的模板 </span></span><br><span class="line">    <span class="attr">template</span>: <span class="string">&quot;#item&quot;</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><h4 id="2-组件的名称"><a href="#2-组件的名称" class="headerlink" title="2.组件的名称"></a>2.组件的名称</h4><p>通过app.component注册一个组件的时候，第一个参数是组件的名称</p><p>方法1：使用kebab-case（短横线分割符）</p><ul><li>当使用 kebab-case  定义一个组件时，你也必须在引用这个自定义元素时使用 kebab-case</li></ul><p>方法2：使用PascalCase（驼峰标识符）大驼峰</p><ul><li><p>当使用 PascalCase 定义一个组件时，你在引用这个自定义元素时两种命名法都可以使用</p></li><li><p>也就是说 my-component-name 和 MyComponentName 都是可接受的（大驼峰标签在.vue文件中才生效，在 html 文件中不能使用）</p></li></ul><h4 id="3-局部组件"><a href="#3-局部组件" class="headerlink" title="3.局部组件"></a>3.局部组件</h4><p>全局组件往往是在应用程序一开始就会全局组件完成，那么就意味着某些组件就算没有用到也会一起被注册：</p><ul><li><p>比如注册了三个全局组件：ComponentA、ComponentB、ComponentC</p></li><li><p>在开发中我们只使用了ComponentA、ComponentB，如果ComponentC没有用到但是我们依然在全局进行了注册，那么就意味着类似于webpack这种打包工具在打包项目时，依然会对其进行打包</p></li><li><p>这样最终打包出的 JavaScript 包就会有关于 ComponentC 的内容，用户在下载对应的 JavaScript 时也会增加包的大小</p></li></ul><p>开发中通常在使用组件的时候采用的都是局部注册：</p><ul><li><p>局部注册是在我们需要使用到的组件中，通过components属性选项来进行注册</p></li><li><p>比如之前的App组件中，我们有data、computed、methods等选项了，还可以有一个components选项</p></li><li><p>该components选项对应的是一个对象，对象中的键值对是 组件的名称: 组件对象</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">ProductItem</span> = &#123;</span><br><span class="line">     <span class="attr">template</span>: <span class="string">&quot;#product&quot;</span>,</span><br><span class="line">       <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> &#123;</span><br><span class="line">           <span class="attr">title</span>: <span class="string">&quot;我是商品&quot;</span>,</span><br><span class="line">           <span class="attr">price</span>: <span class="number">99.9</span></span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.创建app</span></span><br><span class="line">   <span class="comment">// 1.1组件打算在哪里被使用</span></span><br><span class="line">     <span class="keyword">const</span> app = <span class="title class_">Vue</span>.<span class="title function_">createApp</span>(&#123;</span><br><span class="line">     <span class="comment">// components: option api</span></span><br><span class="line">     <span class="attr">components</span>: &#123;</span><br><span class="line">       <span class="title class_">ProductItem</span>,   <span class="comment">// 对象抽出来了</span></span><br><span class="line">       <span class="title class_">HomeNav</span>: &#123;</span><br><span class="line">         <span class="attr">template</span>: <span class="string">&quot;#nav&quot;</span>,</span><br><span class="line">         <span class="attr">components</span>: &#123;</span><br><span class="line">           <span class="title class_">ProductItem</span></span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><h3 id="3、Vue-的开发模式"><a href="#3、Vue-的开发模式" class="headerlink" title="3、Vue 的开发模式"></a>3、Vue 的开发模式</h3><p>目前使用vue的过程都是在html文件中，通过template编写自己的模板、脚本逻辑、样式等。</p><p>但是随着项目越来越复杂，我们会采用组件化的方式来进行开发：</p><ul><li><p>这意味着每个组件都会有自己的模板、脚本逻辑、样式等</p></li><li><p>依然可以把它们抽离到单独的js、css文件中，但是它们还是会分离开来</p></li><li><p>也包括我们的script是在一个全局的作用域下，很容易出现命名冲突的问题</p></li><li><p>并且我们的代码为了适配一些浏览器，必须使用ES5的语法</p></li><li><p>在我们编写代码完成之后，依然需要通过工具对代码进行构建、代码</p></li></ul><p>所以开发中，可以通过一个后缀名为 .vue的single-file-components (单文件组件)来解决，并且可以使用webpack或vite或rollup等构建工具来对其进行处理</p><p>单文件的特点</p><p>在这个组件中我们可以获得非常多的特性：</p><ul><li><p>代码的高亮</p></li><li><p>ES6、CommonJS的模块化能力</p></li><li><p>组件作用域的CSS</p></li><li><p>可以使用预处理器来构建更加丰富的组件，比如TypeScript、Babel、Less、Sass等</p></li></ul><p>如何支持 SFC</p><p>使用SFC的.vue文件比较常见的两种方式</p><ul><li><p>方式一：使用Vue CLI来创建项目，项目会默认帮助我们配置好所有的配置选项，可以在其中直接使用.vue文件</p></li><li><p>方式二：自己使用webpack或rollup或vite这类打包工具，对其进行打包处理</p></li></ul><p>VSCode对SFC的支持</p><ul><li><p>插件一：Vetur，从Vue2开发就一直在使用的VSCode支持Vue的插件</p></li><li><p>插件二：Volar，官方推荐的插件</p></li></ul><h3 id="4、Vue-CLI-脚手架"><a href="#4、Vue-CLI-脚手架" class="headerlink" title="4、Vue CLI 脚手架"></a>4、Vue CLI 脚手架</h3><h4 id="1-什么是脚手架"><a href="#1-什么是脚手架" class="headerlink" title="1.什么是脚手架"></a>1.什么是脚手架</h4><ul><li><p>在真实开发中，我们通常会使用脚手架来创建一个项目，Vue的项目我们使用的就是Vue的脚手架</p></li><li><p>脚手架其实是建筑工程中的一个概念，在软件工程中也会将一些帮助我们搭建项目的工具称之为脚手架</p></li></ul><p>Vue的脚手架就是Vue CLI</p><ul><li><p>CLI是Command-Line Interface, 翻译为命令行界面</p></li><li><p>可以通过CLI选择项目的配置和创建出我们的项目</p></li><li><p>Vue CLI已经内置了webpack相关的配置，我们不需要从零来配置</p></li></ul><h4 id="2-Vue-CLI-安装和使用"><a href="#2-Vue-CLI-安装和使用" class="headerlink" title="2.Vue CLI 安装和使用"></a>2.Vue CLI 安装和使用</h4><p>安装 Vue CLI</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">全局安装：npm install @vue/cli -g</span><br><span class="line">升级：npm update @vue/cli -g</span><br><span class="line">查看版本：vue -V</span><br><span class="line">通过<span class="title class_">Vue</span>创建项目：vue create 项目名称</span><br></pre></td></tr></table></figure><p>使用</p><p>引入 Vue 的版本：</p><ul><li>App 对象可以在 App.vue 中引入，这样引入 Vue 的版本是：<ul><li>import { createApp } from ‘vue’</li></ul></li><li>也能在 main.js 中自己定义 App 对象，这样引入 Vue 的版本是：<ul><li>import { createApp } from ‘vue&#x2F;dist&#x2F;vue.esm-bundler’</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br></pre></td></tr></table></figure><p>在 App.vue 文件中设置根组件导出，并在 main.js 中导入注册挂载</p><p>全局组件也是类似的方法，需要使用 app.component 进行全局注册</p><p>局部组件则需要在使用的地方导入并注册就行</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根组件</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(<span class="title class_">App</span>)</span><br><span class="line">app.<span class="title function_">mount</span>(<span class="string">&quot;#app&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全局组件</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ProductItem</span> <span class="keyword">from</span> <span class="string">&#x27;./ProductItem.vue&#x27;</span></span><br><span class="line">app.<span class="title function_">component</span>(<span class="string">&quot;product-item&quot;</span>, <span class="title class_">ProductItem</span>)</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 局部组件</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ProductItem</span> <span class="keyword">from</span> <span class="string">&#x27;./ProductItem.vue&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">components</span>: &#123; <span class="title class_">ProductItem</span> &#125;,</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">title</span>: <span class="string">&quot;我也是标题&quot;</span>,</span><br><span class="line">      <span class="attr">counter</span>: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-项目文件夹说明"><a href="#3-项目文件夹说明" class="headerlink" title="3.项目文件夹说明"></a>3.项目文件夹说明</h4><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230412143013515.png" alt="image-20230412143013515" style="zoom: 50%;" /><h4 id="4-Vue-CLI-的运行原理"><a href="#4-Vue-CLI-的运行原理" class="headerlink" title="4.Vue CLI 的运行原理"></a>4.Vue CLI 的运行原理</h4><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230412143116839.png" alt="image-20230412143116839"></p><h4 id="5-补充"><a href="#5-补充" class="headerlink" title="5.补充"></a>5.补充</h4><h5 id="1、jsconfig-json"><a href="#1、jsconfig-json" class="headerlink" title="1、jsconfig.json"></a>1、jsconfig.json</h5><p>作用：给vscode来进行读取，vscode在读取到其中的内容时，给我们的代码更友好的支持</p><p>比如在一个文件嵌套很深的条件下，需要调用上层的函数，就会出现..&#x2F;..&#x2F;..&#x2F;这种不友好的路径表现，可以配置 vue.config.js</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">configureWebpack</span>: &#123;</span><br><span class="line">    <span class="attr">resolve</span>: &#123;</span><br><span class="line">      <span class="comment">// 配置路径别名</span></span><br><span class="line">      <span class="comment">// @是已经配置好的路径别名：对应的是src的路径</span></span><br><span class="line">      <span class="attr">alias</span>: &#123;</span><br><span class="line">        <span class="string">&quot;utils&quot;</span>: <span class="string">&quot;@/utils&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这样可以直接使用配置好的路径，但是 vscode 并不会对此有所提示</p><p>就该配置 jsconfig.json 文件的 path，就能得到友好的代码提示</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;utils/*&quot;</span>: [</span><br><span class="line">     <span class="string">&quot;src/utils/*&quot;</span></span><br><span class="line">   ]</span><br></pre></td></tr></table></figure><h5 id="2、引入Vue的版本"><a href="#2、引入Vue的版本" class="headerlink" title="2、引入Vue的版本"></a>2、引入Vue的版本</h5><p>上文有说明使用的区别</p><p>出现这种情况的本质：</p><ul><li>在以前创建 vue 项目时会出现选择 runtime  &#x2F; runtime + compile 编译两种选择</li><li>编译并不是说其不会编译 vue 文件，而是指对别的对象（vue文件之外）中的 template 模板中元素的编译</li><li>而默认版本是 vue，不会对上者情况的 template 编译，因为没有 compile 源码对其进行编译</li><li>所以在 main.js 中创建 App 根组件并使用的话，使用默认 vue 并不会对其进行渲染</li><li>这时该选择 vue.esm-bundler 版本</li></ul><h5 id="3、style-的作用域"><a href="#3、style-的作用域" class="headerlink" title="3、style 的作用域"></a>3、style 的作用域</h5><p>每一个组件都应该存在自己独立的作用域，不然在使用时会重复的覆盖，不便于对每一个组件的样式进行设置</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;&lt;/style scoped&gt;</span><br></pre></td></tr></table></figure><h5 id="4、vite-创建-vue-项目"><a href="#4、vite-创建-vue-项目" class="headerlink" title="4、vite 创建 vue 项目"></a>4、vite 创建 vue 项目</h5><p>创建 vue 项目的方式</p><p>方式1：vue cli：vue create   -&gt; 基于 webpack</p><p>方式2：npm init vue@latest  -&gt; 基于 vite</p><ul><li>1.安装一个本地工具：create-vue</li><li>2.使用create-vue创建一个 vue 项目</li></ul><p>编译速度更快，和其底层有关系</p><h2 id="6-组件间的通信"><a href="#6-组件间的通信" class="headerlink" title="6.组件间的通信"></a>6.组件间的通信</h2><h3 id="1、组件的嵌套关系"><a href="#1、组件的嵌套关系" class="headerlink" title="1、组件的嵌套关系"></a>1、组件的嵌套关系</h3><p>在之前只是创建了一个组件App</p><p>如果一个应用程序将所有的逻辑都放在一个组件中，那么这个组件就会变成非常的臃肿和难以维护</p><ul><li><p>所以组件化的核心思想应该是对组件进行拆分，拆分成一个个小的组件</p></li><li><p>再将这些组件组合嵌套在一起，最终形成我们的应用程序</p></li></ul><p>将所有的代码逻辑全部放到一个组件中，代码是非常的臃肿和难以维护的</p><ul><li><p>并且在开发中，会有更多的内容和代码逻辑，对于扩展性和可维护性来说都是非 常差的</p></li><li><p>所以，在真实的开发中会对组件进行拆分，拆分成一个个功能的小组件</p></li></ul><p>将各模块抽为单独的局部组件，在使用的地方进行引入</p><h4 id="组件的拆分"><a href="#组件的拆分" class="headerlink" title="组件的拆分"></a>组件的拆分</h4><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230412190521688.png" alt="image-20230412190521688"></p><h3 id="2、父组件传递子组件"><a href="#2、父组件传递子组件" class="headerlink" title="2、父组件传递子组件"></a>2、父组件传递子组件</h3><p>上面的嵌套逻辑如下，它们存在如下关系：</p><ul><li><p>App组件是Header、Main、Footer组件的父组件</p></li><li><p>Main组件是Banner、ProductList组件的父组件</p></li></ul><p>在开发过程中，我们会经常遇到需要组件之间相互进行通信：</p><ul><li><p>比如App可能使用了多个Header，每个地方的Header展示的内容不同，那么我们就需要使用者传递给Header一些数据，让其进行展示</p></li><li><p>又比如我们在Main中一次性请求了Banner数据和ProductList数据，那么就需要传递给它们来进行展示</p></li><li><p>也可能是子组件中发生了事件，需要由父组件来完成某些操作，那就需要子组件向父组件传递事件</p></li></ul><p>总之，在一个Vue项目中，组件之间的通信是非常重要的环节</p><h4 id="1-父子组件之间通信的方式"><a href="#1-父子组件之间通信的方式" class="headerlink" title="1.父子组件之间通信的方式"></a>1.父子组件之间通信的方式</h4><ul><li><p>父组件传递给子组件：通过props属性</p></li><li><p>子组件传递给父组件：通过$emit触发事件</p></li></ul><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230412204202490.png" alt="image-20230412204202490"></p><h4 id="2-父传子方法"><a href="#2-父传子方法" class="headerlink" title="2.父传子方法"></a>2.父传子方法</h4><p>通过props来完成组件之间的通信</p><p>什么是Props</p><ul><li><p>Props是你可以在组件上注册一些自定义的attribute</p></li><li><p>父组件给这些attribute赋值，子组件通过attribute的名称获取到对应的值</p></li></ul><p>Props有两种常见的用法</p><ul><li><p>方式一：字符串数组，数组中的字符串就是attribute的名称</p></li><li><p>方式二：对象类型，对象类型我们可以在指定attribute名称的同时，指定它需要传递的类型、是否是必须的、默认值等等</p></li></ul><h5 id="1、Props-的数组用法"><a href="#1、Props-的数组用法" class="headerlink" title="1、Props 的数组用法"></a>1、Props 的数组用法</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">子组件：</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;infos&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>姓名： &#123;&#123;name&#125;&#125; <span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>年龄： &#123;&#123;age&#125;&#125; <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;others&quot;</span> <span class="attr">v-bind</span>=<span class="string">&quot;$attrs&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// propos 作用：接受父组件传递过来的属性</span></span><br><span class="line">    <span class="comment">// 数组语法</span></span><br><span class="line">    <span class="comment">// 弊端：1&gt; 不能对类型进行验证 2&gt; 没有默认值的</span></span><br><span class="line">    <span class="comment">// props: [&quot;name&quot;, &quot;age&quot;, &quot;height&quot;]</span></span><br><span class="line"></span><br><span class="line">父组件：</span><br><span class="line"><span class="comment">// 补充 使用子组件的时候可以使用单标签，与双标签的区别在插槽中讲</span></span><br><span class="line">  &lt;show-infos name=<span class="string">&quot;mas&quot;</span> age=<span class="string">&quot;23&quot;</span>&gt;&lt;/show-infos&gt;</span><br></pre></td></tr></table></figure><h5 id="2、Props-的对象用法"><a href="#2、Props-的对象用法" class="headerlink" title="2、Props 的对象用法"></a>2、Props 的对象用法</h5><p>数组用法中我们只能说明传入的attribute的名称，并不能对其进行任何形式的限制，接下来我们来看一下对象的写法是如何让 我们的props变得更加完善的</p><p>当使用对象语法的时候，我们可以对传入的内容限制更多：</p><ul><li><p>比如指定传入的attribute的类型</p></li><li><p>比如指定传入的attribute是否是必传的</p></li><li><p>比如指定没有传入时，attribute的默认值</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">props</span>: &#123;</span><br><span class="line">     <span class="attr">name</span>: &#123;</span><br><span class="line">       <span class="attr">type</span>: <span class="title class_">String</span>,</span><br><span class="line">       <span class="attr">default</span>: <span class="string">&quot;默认值&quot;</span></span><br><span class="line">     &#125;,</span><br><span class="line">     <span class="attr">age</span>: &#123;</span><br><span class="line">       <span class="attr">type</span>: <span class="title class_">Number</span>,</span><br><span class="line">       <span class="attr">required</span>: <span class="literal">true</span>,</span><br><span class="line">       <span class="attr">default</span>: <span class="number">10</span></span><br><span class="line">     &#125;,</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h5 id="3、type-的类型"><a href="#3、type-的类型" class="headerlink" title="3、type 的类型"></a>3、type 的类型</h5><p>String、Number、Boolean、Array、Object、Date、Function、Symbol</p><p>对象类型的其他写法：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 重要的原则：对象类型写默认值时，需要编写default的函数，函数返回默认值</span></span><br><span class="line">      <span class="attr">friend</span>: &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="title class_">Object</span>,</span><br><span class="line">        <span class="attr">default</span>: <span class="function">() =&gt;</span> (&#123; <span class="attr">name</span>: <span class="string">&quot;james&quot;</span> &#125;)</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">hobbies</span>: &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="title class_">Array</span>,</span><br><span class="line">        <span class="attr">default</span>: <span class="function">() =&gt;</span> [<span class="string">&quot;篮球&quot;</span>, <span class="string">&quot;rap&quot;</span>]</span><br><span class="line">      &#125;,</span><br></pre></td></tr></table></figure><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230412205345651.png" alt="image-20230412205345651"></p><h5 id="4、Props的大小写"><a href="#4、Props的大小写" class="headerlink" title="4、Props的大小写"></a>4、Props的大小写</h5><p>Prop 的大小写命名(camelCase vs kebab-case)</p><ul><li><p>HTML 中的 attribute 名是大小写不敏感的，所以浏览器会把所有大写字符解释为小写字符</p></li><li><p>这意味着当你使用 DOM 中的模板时，camelCase (驼峰命名法) 的 prop 名需要使用其等价的 kebab-case (短横线分隔命名)  命名</p></li></ul><p>即在 props 中使用小驼峰，在父组件中传递过来可以使用小驼峰也能使用 - 连接</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">show-message=<span class="string">&quot;哈哈哈&quot;</span></span><br><span class="line">showMessage=<span class="string">&quot;哈哈哈&quot;</span></span><br><span class="line"><span class="attr">showMessage</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="title class_">String</span>,</span><br><span class="line">    <span class="attr">default</span>: <span class="string">&quot;dsa&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、非props的attribute"><a href="#3、非props的attribute" class="headerlink" title="3、非props的attribute"></a>3、非props的attribute</h3><p>什么是非Prop的Attribute</p><ul><li><p>当我们传递给一个组件某个属性，但是该属性并没有定义对应的 props 或者 emits 时，就称之为非Prop的Attribute</p></li><li><p>常见的包括class、style、id属性等</p></li></ul><p>Attribute继承</p><ul><li>当组件有单个根节点时，非Prop的Attribute将自动添加到根节点的Attribute中</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div <span class="keyword">class</span>=<span class="string">&quot;infos sws&quot;</span> address=<span class="string">&quot;北京&quot;</span>&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>禁用Attribute继承和多根节点</p><p>如果我们不希望组件的根元素继承attribute，可以在组件中设置 inheritAttrs: false</p><ul><li><p>禁用attribute继承的常见情况是需要将attribute应用于根元素之外的其他元素</p></li><li><p>我们可以通过 $attrs来访问所有的非props的attribute</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">inheritAttrs</span>: <span class="literal">false</span>  <span class="comment">// 写在options api</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用子节点来接收  不禁掉inheritAttrs时根节点也同时拿到</span></span><br><span class="line">&lt;h2 :<span class="keyword">class</span>=<span class="string">&quot;$attrs.address&quot;</span>&gt;姓名： &#123;&#123;name&#125;&#125; &lt;/h2&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多个根：使用另一个根节点接收非 props</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;others&quot;</span> <span class="attr">v-bind</span>=<span class="string">&quot;$attrs&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="4、子组件传递父组件"><a href="#4、子组件传递父组件" class="headerlink" title="4、子组件传递父组件"></a>4、子组件传递父组件</h3><p>子组件需要传递内容到父组件的情况</p><ul><li><p>当子组件有一些事件发生的时候，比如在组件中发生了点击，父组件需要切换内容</p></li><li><p>子组件有一些内容想要传递给父组件的时</p></li></ul><p>操作</p><ul><li><p>首先，我们需要在子组件中定义好在某些情况下触发的事件名称</p></li><li><p>其次，在父组件中以v-on的方式传入要监听的事件名称，并且绑定到对应的方法中</p></li><li><p>最后，在子组件中发生某个事件的时候，根据事件名称触发对应的事件</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">父组件：</span><br><span class="line">    &lt;h2&gt;当前计数: &#123;&#123;counter&#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;!-- <span class="number">1.</span>自定义 add-counter 并且监听内部的add事件 --&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">add-counter</span> @<span class="attr">add</span>=<span class="string">&quot;addBtnClick&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">add-counter</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="attr">methods</span>: &#123;</span><br><span class="line">      <span class="title function_">addBtnClick</span>(<span class="params">count</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">counter</span> += count</span><br><span class="line">      &#125;,</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">子组件：</span><br><span class="line">    &lt;button @click=<span class="string">&quot;btnClick(1)&quot;</span>&gt;+<span class="number">1</span>&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">    <span class="attr">methods</span>: &#123;</span><br><span class="line">      <span class="title function_">btnClick</span>(<span class="params">count</span>) &#123;</span><br><span class="line">        <span class="comment">// 让子组件发出去一个自定义事件</span></span><br><span class="line">        <span class="comment">// 第一个参数，自定义事件的名称</span></span><br><span class="line">        <span class="comment">// 第二个参数是传递的参数</span></span><br><span class="line">        <span class="variable language_">this</span>.$emit(<span class="string">&quot;add&quot;</span>, count)</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>自定义事件的参数和验证</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.emits的数组写法  options api 中</span></span><br><span class="line"><span class="attr">emits</span>: [<span class="string">&quot;add&quot;</span>],</span><br><span class="line"><span class="comment">// 2.emits的对象写法  vue3 新加的对参数验证  可以写一个函数</span></span><br><span class="line"><span class="comment">// emits: &#123;</span></span><br><span class="line"><span class="comment">//   add: function(count) &#123;</span></span><br><span class="line"><span class="comment">//     if (count &lt;= 10) &#123;   // 不符合也能看到  就是报警告</span></span><br><span class="line"><span class="comment">//       return true</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//     return false   </span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line"><span class="comment">// &#125;,</span></span><br></pre></td></tr></table></figure><h3 id="5、案例练习"><a href="#5、案例练习" class="headerlink" title="5、案例练习"></a>5、案例练习</h3><p>tab-control 的案例练习</p><h2 id="7-组件插槽"><a href="#7-组件插槽" class="headerlink" title="7.组件插槽"></a>7.组件插槽</h2><h3 id="1、认识插槽Slot作用"><a href="#1、认识插槽Slot作用" class="headerlink" title="1、认识插槽Slot作用"></a>1、认识插槽Slot作用</h3><p>在开发中，我们会经常封装一个个可复用的组件：</p><ul><li><p>前面我们会通过props传递给组件一些数据，让组件来进行展示</p></li><li><p>但是为了让这个组件具备更强的通用性，我们不能将组件中的内容限制为固定的div、span等等这些元素</p></li><li><p>比如某种情况下我们使用组件，希望组件显示的是一个按钮，某种情况下我们使用组件希望显示的是一张图片</p></li><li><p>我们应该让使用者可以决定某一块区域到底存放什么内容和元素</p></li></ul><p>举个栗子：假如定制一个通用的导航组件 — NavBar</p><ul><li><p>这个组件分成三块区域：左边-中间-右边，每块区域的内容是不固定</p></li><li><p>左边区域可能显示一个菜单图标，也可能显示一个返回按钮，可能什么都不显示</p></li><li><p>中间区域可能显示一个搜索框，也可能是一个列表，也可能是一个标题，等等</p></li><li><p>右边可能是一个文字，也可能是一个图标，也可能什么都不显示</p></li></ul><p>这时可以来定义插槽slot</p><ul><li><p>插槽的使用过程其实是抽取共性、预留不同</p></li><li><p>我们会将共同的元素、内容依然在组件内进行封装</p></li><li><p>同时会将不同的元素使用slot作为占位，让外部决定到底显示什么样的元素</p></li></ul><p>如何使用 slot</p><ul><li>Vue 中将 slot 元素作为承载分发内容的出口</li><li>在封装组件中，使用特殊的元素就可以为封装组件开启一个插槽</li><li>该插槽插入什么内容取决于父组件如何使用</li></ul><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230413113750153.png" alt="image-20230413113750153"></p><h3 id="2、插槽Slot基本使用"><a href="#2、插槽Slot基本使用" class="headerlink" title="2、插槽Slot基本使用"></a>2、插槽Slot基本使用</h3><p>有时候在使用插槽时，如果没有插入对应的内容，需要显示一个默认的内容</p><ul><li>这个默认的内容只会在没有提供插入的内容时，才会显示</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">父组件：</span><br><span class="line">&lt;show-message title=<span class="string">&quot;哈哈&quot;</span>&gt;</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">button</span>&gt;</span>我是按钮元素<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">    &lt;/show-message&gt;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">子组件：</span><br><span class="line">&lt;!-- 内容是一个按钮 --&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">slot</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是默认内容 哈哈哈<span class="tag">&lt;/<span class="name">p</span>&gt;</span>   // 默认内容</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="3、具名插槽Slot使用"><a href="#3、具名插槽Slot使用" class="headerlink" title="3、具名插槽Slot使用"></a>3、具名插槽Slot使用</h3><p>如果一个组件中含有多个插槽，会发现默认情况下每个插槽都会获取到我们插入的内容来显示</p><p>即多个元素都有在一个插槽中展示</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230413114755709.png" alt="image-20230413114755709"></p><p>而想要达到的效果是插槽对应的显示，这个时候我们就可以使用具名插槽</p><ul><li>具名插槽顾名思义就是给插槽起一个名字， 元素有一个特殊的 attribute：name</li><li>一个不带 name 的slot，会带有隐含的名字 default</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">父组件：</span><br><span class="line">  &lt;nav-bar&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">template</span> #<span class="attr">left</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span>&gt;</span> &#123;&#123;leftText&#125;&#125; <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">template</span> #<span class="attr">center</span>&gt;</span>  // # 语法糖</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">span</span>&gt;</span>内容<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:right</span>&gt;</span>  // 使用template元素 并 v-slot:name</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line">  &lt;/nav-bar&gt;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">子组件：</span><br><span class="line">  &lt;div <span class="keyword">class</span>=<span class="string">&quot;nav-bar&quot;</span>&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;left&quot;</span>&gt;</span>left<span class="tag">&lt;/<span class="name">slot</span>&gt;</span>   // 取 name</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;center&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;center&quot;</span>&gt;</span>center<span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;right&quot;</span>&gt;</span>right<span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &lt;/div&gt;</span><br></pre></td></tr></table></figure><p>动态插槽名：</p><p>目前我们使用的插槽名称都是固定的</p><ul><li>比如 v-slot:left、v-slot:center 等等</li><li>可以通过 v-slot:[dynamicSlotName] 方式动态绑定一个名称</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">父组件：</span><br><span class="line">  &lt;!-- nav-bar 只给一个插槽传入 --&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">nav-bar</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:</span>[<span class="attr">position</span>]&gt;</span>    // data 中定义默认的 position</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>注册<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">nav-bar</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;position=&#x27;left&#x27;&quot;</span>&gt;</span>左边<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;position = &#x27;center&#x27;&quot;</span>&gt;</span>中间<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;position = &#x27;right&#x27;&quot;</span>&gt;</span>右边<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">子组件：同上一个</span><br></pre></td></tr></table></figure><p>具名插槽使用的时候缩写</p><ul><li><p>跟 v-on 和 v-bind 一样，v-slot 也有缩写</p></li><li><p>即把参数之前的所有内容 (v-slot:) 替换为字符 #</p></li></ul><h3 id="4、作用域插槽Slot使用"><a href="#4、作用域插槽Slot使用" class="headerlink" title="4、作用域插槽Slot使用"></a>4、作用域插槽Slot使用</h3><p>在Vue中有渲染作用域的概念：</p><ul><li><p>父级模板里的所有内容都是在父级作用域中编译的</p></li><li><p>子模板里的所有内容都是在子作用域中编译的</p></li></ul><p>案例： </p><ul><li><p>案例中ChildCpn自然是可以访问自己作用域中的title内容的</p></li><li><p>但是在App中，是访问不了ChildCpn中的内容的，因为它们是跨作用域的访问</p></li></ul><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230413115537939.png" alt="image-20230413115537939"></p><h4 id="1-插槽作用域"><a href="#1-插槽作用域" class="headerlink" title="1.插槽作用域"></a>1.插槽作用域</h4><p>插槽可以访问到子组件中的内容是非常重要的</p><ul><li><p>当一个组件被用来渲染一个数组元素时，我们使用插槽，并且希望插槽中没有显示每项的内容</p></li><li><p>这个Vue给我们提供了作用域插槽</p></li></ul><p>案例：</p><ul><li><p>1.在App.vue中定义好数据</p></li><li><p>2.传递给 ShowNames 组件中</p></li><li><p>3.ShowNames 组件中遍历 names 数据</p></li><li><p>4.定义插槽的prop</p></li><li><p>5.通过 v-slot:default 的方式获取到 slot 的 props</p></li><li><p>6.使用 slotProps 中的 item 和 index</p></li></ul><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230413115833886.png" alt="image-20230413115833886"></p><p>简单理解：就是父组件传入数据插入到子组件，子组件对传入的数据进行遍历并插入到 slot 中，但是这时 slot 内默认的元素是写死的，我们希望这个元素可以被自定义，这时就使用作用域插槽</p><h4 id="2-使用"><a href="#2-使用" class="headerlink" title="2.使用"></a>2.使用</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">父组件：</span><br><span class="line">   &lt;tab-control :titles=<span class="string">&quot;[&#x27;衣服&#x27;, &#x27;裤子&#x27;, &#x27;鞋子&#x27;]&quot;</span> @tab-item-click=<span class="string">&quot;tabItemClick&quot;</span>&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:default</span>=<span class="string">&quot;props&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>&#123;&#123; props.item &#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span>   // 使用 a 元素展示传到子组件的 item</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line">   &lt;/tab-control&gt;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">子组件：</span><br><span class="line">&lt;template v-<span class="keyword">for</span>=<span class="string">&quot;(item, index) in titles&quot;</span> :key=<span class="string">&quot;item&quot;</span>&gt;</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;tab-control-item&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;itemClick(index)&quot;</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">:class</span>=<span class="string">&quot;&#123; active: index === currentIndex &#125;&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">slot</span> <span class="attr">:item</span>=<span class="string">&quot;item&quot;</span>&gt;</span>   // 定义 :item = &quot;item&quot;</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123; item &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span>  // 默认组件</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &lt;/template&gt;</span><br></pre></td></tr></table></figure><h5 id="1、独占默认插槽的缩写"><a href="#1、独占默认插槽的缩写" class="headerlink" title="1、独占默认插槽的缩写"></a>1、独占默认插槽的缩写</h5><ul><li>如果我们的插槽是默认插槽default，那么在使用的时候 v-slot:default&#x3D;”slotProps”可以简写为v-slot&#x3D;”slotProps”</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;tab-control :titles=<span class="string">&quot;[&#x27;衣服&#x27;, &#x27;裤子&#x27;, &#x27;鞋子&#x27;]&quot;</span> @tab-item-click=<span class="string">&quot;tabItemClick&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">template</span> #<span class="attr">default</span>=<span class="string">&quot;props&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="comment">&lt;!-- 独占默认插槽的简写 --&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="comment">&lt;!-- &lt;template v-slot=&quot;props&quot;&gt; --&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span>&gt;</span>&#123;&#123; props.item &#125;&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">tab-control</span>&gt;</span></span></span><br></pre></td></tr></table></figure><ul><li>并且如果我们的插槽只有默认插槽时，组件的标签可以被当做插槽的模板来使用，这样可以将 v-slot 直接用在组件上</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- 如果只有一个默认插槽 那么template可以省略 --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">tab-control</span> <span class="attr">:titles</span>=<span class="string">&quot;[&#x27;衣服&#x27;, &#x27;裤子&#x27;, &#x27;鞋子&#x27;]&quot;</span> @<span class="attr">tab-item-click</span>=<span class="string">&quot;tabItemClick&quot;</span> <span class="attr">v-slot</span>=<span class="string">&quot;props&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>&#123;&#123;props.item&#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">tab-control</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h5 id="2、默认插槽和具名插槽混合使用"><a href="#2、默认插槽和具名插槽混合使用" class="headerlink" title="2、默认插槽和具名插槽混合使用"></a>2、默认插槽和具名插槽混合使用</h5><ul><li><p>如果我们有默认插槽和具名插槽，那么按照完整的template来编写</p></li><li><p>只要出现多个插槽，请始终为所有的插槽使用完整的基于 template 的语法</p></li></ul><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230413120925169.png" alt="image-20230413120925169"></p><h3 id="5、非父子组件的通信"><a href="#5、非父子组件的通信" class="headerlink" title="5、非父子组件的通信"></a>5、非父子组件的通信</h3><p>在开发中构建了组件树之后，除了父子组件之间的通信之外，还会有非父子组件之间的通信</p><p>两种方式：</p><ul><li>Provide&#x2F;Inject</li><li>全局事件总线</li></ul><h4 id="1-依赖注入Provide-x2F-Inject"><a href="#1-依赖注入Provide-x2F-Inject" class="headerlink" title="1.依赖注入Provide&#x2F;Inject"></a>1.依赖注入Provide&#x2F;Inject</h4><h5 id="1、作用"><a href="#1、作用" class="headerlink" title="1、作用"></a>1、作用</h5><p>Provide&#x2F;Inject用于非父子组件之间共享数据</p><ul><li><p>比如有一些深度嵌套的组件，子组件想要获取父组件的部分内容</p></li><li><p>在这种情况下，如果我们仍然将props沿着组件链逐级传递下去，就会非常的麻烦</p></li></ul><p>对于这种情况可以使用 Provide 和 Inject </p><ul><li><p>无论层级结构有多深，父组件都可以作为其所有子组件的依赖提供者</p></li><li><p>父组件有一个 provide 选项来提供数据</p></li><li><p>子组件有一个 inject 选项来开始使用这些数据</p></li></ul><p>实际上可以将依赖注入看作是 “long range props”</p><ul><li><p>父组件不需要知道哪些子组件使用它 provide 的 property</p></li><li><p>子组件不需要知道 inject 的 property 来自哪里</p></li></ul><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230413160855262.png" alt="image-20230413160855262" style="zoom:50%;" /><h5 id="2、基本使用"><a href="#2、基本使用" class="headerlink" title="2、基本使用"></a>2、基本使用</h5><p>所使用结构类似于：</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230413161943865.png" alt="image-20230413161943865"></p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230413162151996.png" alt="image-20230413162151996"></p><h5 id="3、Provide-和-Inject-函数的写法"><a href="#3、Provide-和-Inject-函数的写法" class="headerlink" title="3、Provide 和 Inject 函数的写法"></a>3、Provide 和 Inject 函数的写法</h5><ul><li>如果Provide中提供的一些数据是来自data，那可能会想要通过 this 获取</li><li>由于 this 指向的问题，对象不能形成作用域，获取不了 data 中的数据，所以使用函数写法</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">App</span>.<span class="property">vue</span>:</span><br><span class="line">    <span class="comment">// provide 一般写为函数  options api</span></span><br><span class="line">    <span class="title function_">provide</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&quot;wbh&quot;</span>,</span><br><span class="line">        <span class="attr">age</span>: <span class="number">21</span>,</span><br><span class="line">        <span class="attr">message</span>: <span class="variable language_">this</span>.<span class="property">message</span></span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">HomeBanner</span>:</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>homebanner: &#123;&#123;name&#125;&#125; - &#123;&#123;age&#125;&#125;-&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">inject</span>: [<span class="string">&quot;name&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;message&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4、处理响应式数据"><a href="#4、处理响应式数据" class="headerlink" title="4、处理响应式数据"></a>4、处理响应式数据</h5><p>此时，如果我们修改了this.names的内容，那么使用 message 的子组件不是响应式的</p><ul><li>这是因为当我们修改了 message 之后，之前在 provide 中引入的 this.message 本身并不是响应式的</li></ul><p>怎么让的数据变成响应式</p><ul><li><p>可以使用响应式的一些API来完成这些功能，比如说computed函数</p></li><li><p>这个computed是vue3的新特性</p></li></ul><p>注意：</p><ul><li><p>在使用 message 的时候需要获取其中的 value</p></li><li><p>这是因为 computed 返回的是一个ref对象，需要取出其中的 value 来使用</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">App</span>.<span class="property">vue</span>:  </span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>app: &#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span>   <span class="comment">// 查看message的改变</span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;message = &#x27;hello wodrds&#x27;&quot;</span>&gt;</span>修改message<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">import</span> &#123; computed &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>  <span class="comment">// 引入 computed script中 export外</span></span><br><span class="line"></span><br><span class="line">    <span class="title function_">provide</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&quot;wbh&quot;</span>,</span><br><span class="line">        <span class="attr">age</span>: <span class="number">21</span>,</span><br><span class="line">        <span class="attr">message</span>: <span class="title function_">computed</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 拿到的是 message 的引用 返回的是一个ref对象，需要使用.value来解包才能获取其真正的值</span></span><br><span class="line">          <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">message</span></span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">HomeBanner</span>.<span class="property">vue</span>:</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>homebanner: &#123;&#123;name&#125;&#125; - &#123;&#123;age&#125;&#125;-&#123;&#123;message.value&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h4 id="2-全局事件总线使用"><a href="#2-全局事件总线使用" class="headerlink" title="2.全局事件总线使用"></a>2.全局事件总线使用</h4><p>Vue3从实例中移除了 $on、$off 和 $once 方法，如果希望继续使用全局事件总线，要通过第三方的库：</p><ul><li><p>Vue3官方有推荐一些库，例如 mitt 或 tiny-emitter</p></li><li><p>主要介绍 hy-event-store 的使用</p></li></ul><p>前期工作</p><ul><li><p>安装：npm install hy-event-bus</p></li><li><p>封装一个工具 eventBus.js</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">HYEventBus</span> &#125; <span class="keyword">from</span> <span class="string">&quot;hy-event-store&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> eventBus = <span class="keyword">new</span> <span class="title class_">HYEventBus</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> eventBus</span><br></pre></td></tr></table></figure><p>使用：监听，结构：App -&gt; Home -&gt; HomeBanner</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">App</span>.<span class="property">vue</span>:</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>App message: &#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">home</span>&gt;</span><span class="tag">&lt;/<span class="name">home</span>&gt;</span></span></span><br><span class="line">  <span class="keyword">import</span> eventBus <span class="keyword">from</span> <span class="string">&quot;./utils/event-bus&quot;</span>;  <span class="comment">// 在需要使用时间总线的地方导入</span></span><br><span class="line"></span><br><span class="line">    <span class="title function_">created</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// 事件监听</span></span><br><span class="line">      eventBus.<span class="title function_">on</span>(<span class="string">&quot;whyEvent&quot;</span>, <span class="function">(<span class="params">name, age, height</span>) =&gt;</span> &#123;  <span class="comment">// 监听事件</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;whyEvent事件在app中的监听&quot;</span>, name, age, height)</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">message</span> = <span class="string">`name:<span class="subst">$&#123;name&#125;</span>, age:<span class="subst">$&#123;age&#125;</span>,height:<span class="subst">$&#123;height&#125;</span>`</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">HomeBanner</span>:</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;bannerBtnClick&quot;</span>&gt;</span>banner按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">  <span class="keyword">import</span> eventBus <span class="keyword">from</span> <span class="string">&#x27;./utils/event-bus&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">methods</span>: &#123;</span><br><span class="line">      <span class="title function_">bannerBtnClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;bannerBtnClick&quot;</span>)</span><br><span class="line">        eventBus.<span class="title function_">emit</span>(<span class="string">&quot;whyEvent&quot;</span>, <span class="string">&quot;why&quot;</span>, <span class="number">23</span>, <span class="number">1.94</span>)  <span class="comment">// 传出事件，可以加参数</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>使用：事件取消，结构：App -&gt; Category</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">App</span>:  添加了按钮移除 category 页面的展示，目的：在目录页面销毁时给其取消事件监听</span><br><span class="line">&lt;button @click=<span class="string">&quot;isShowCategory = false&quot;</span>&gt;是否显示category&lt;/button&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">category</span> <span class="attr">v-if</span>=<span class="string">&quot;isShowCategory&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">category</span>&gt;</span></span>  <span class="comment">// 定义变量记录页面是否展示</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Category</span>:</span><br><span class="line">  <span class="keyword">import</span> eventBus <span class="keyword">from</span> <span class="string">&#x27;./utils/event-bus&#x27;</span>;</span><br><span class="line">    <span class="attr">methods</span>: &#123;</span><br><span class="line">      <span class="title function_">whyEventHandler</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;在category中监听&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,  </span><br><span class="line">    <span class="comment">// 由于这里需要使用箭头函数，便于使用 this，但是在移除监听时第二个参数需要是事件监听的函数</span></span><br><span class="line">    <span class="comment">// 为了拿到这个函数，可以将函数放在 methods 中，使用 this 指向这个函数</span></span><br><span class="line">    <span class="title function_">created</span>(<span class="params"></span>) &#123;</span><br><span class="line">      eventBus.<span class="title function_">on</span>(<span class="string">&quot;whyEvent&quot;</span>, <span class="variable language_">this</span>.<span class="property">whyEventHandler</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 移除监听</span></span><br><span class="line">    <span class="title function_">unmounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;categoty unmounted&quot;</span>)</span><br><span class="line">      eventBus.<span class="title function_">off</span>(<span class="string">&quot;whyEvent&quot;</span>, <span class="variable language_">this</span>.<span class="property">whyEventHandler</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li><p>在一般的组件通信应使用 Vue 官方推荐的方法</p></li><li><p>只有需要在很多组件中进行传递时才考虑使用事件总线</p></li></ul><h2 id="8-额外知识补充"><a href="#8-额外知识补充" class="headerlink" title="8.额外知识补充"></a>8.额外知识补充</h2><h3 id="1、生命周期"><a href="#1、生命周期" class="headerlink" title="1、生命周期"></a>1、生命周期</h3><p>什么是生命周期</p><ul><li><p>生物学上，生物生命周期指得是一个生物体在生命开始到结束周而复始所历经的一系列变化过程</p></li><li><p>每个组件都可能会经历从创建、挂载、更新、卸载等一系列的过程</p></li><li><p>在这个过程中的某一个阶段，我们可能会想要添加一些属于自己的代码逻辑（比如组件创建完后就请求一些服务器数据）</p></li><li><p>如何可以知道目前组件正在哪一个过程？Vue 提供了组件的生命周期函数</p></li></ul><p>生命周期函数</p><ul><li><p>生命周期函数是一些钩子函数（回调函数），在某个时间会被Vue源码内部进行回调</p></li><li><p>通过对生命周期函数的回调，我们可以知道目前组件正在经历什么阶段</p></li><li><p>那么我们就可以在该生命周期中编写属于自己的逻辑代码了</p></li></ul><h4 id="生命周期的流程"><a href="#生命周期的流程" class="headerlink" title="生命周期的流程"></a>生命周期的流程</h4><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230415110343000.png" alt="image-20230415110343000"></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">    <span class="comment">// 1.组件被创建之前</span></span><br><span class="line">    <span class="title function_">beforeCreate</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;beforeCreate&quot;</span>)</span><br><span class="line">    &#125;,  </span><br><span class="line">    <span class="comment">// 2.组件被创建完成</span></span><br><span class="line">    <span class="title function_">created</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;组件被创建完成&quot;</span>)</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;1.发送网络请求，请求数据&quot;</span>)</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;2.监听eventBus事件&quot;</span>)</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;3.监听watch数据&quot;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 3.组件template准备被挂载</span></span><br><span class="line">    <span class="title function_">beforeMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;beforeMount&quot;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 4.组件template被挂载：x虚拟DOM -&gt; 真实DOM</span></span><br><span class="line">    <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;mounted&quot;</span>)</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;1.获取DOM&quot;</span>)</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;2.使用DOM&quot;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 5.数据发生改变</span></span><br><span class="line">    <span class="comment">// 5.1准备更新DOM</span></span><br><span class="line">    <span class="title function_">beforeUpdate</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;beforeUpdate&quot;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 5.2 更新DOM</span></span><br><span class="line">    <span class="title function_">updated</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;updated&quot;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 6准备卸载VNode -&gt; DOM元素  </span></span><br><span class="line">    <span class="comment">// 6.1卸载之前</span></span><br><span class="line">    <span class="title function_">beforeUnmount</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;beforeUnmoute&quot;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 6.2 DOM元素被卸载完成</span></span><br><span class="line">    <span class="title function_">unmounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;unmounted&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">在 <span class="title class_">App</span>.<span class="property">vue</span>中查看不到卸载效果，在子组件中可以使用v-<span class="keyword">if</span>查看</span><br></pre></td></tr></table></figure><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230415110746460.png" alt="image-20230415110746460"></p><h3 id="2、ref-获取元素组件"><a href="#2、ref-获取元素组件" class="headerlink" title="2、ref 获取元素组件"></a>2、ref 获取元素组件</h3><p>某些情况下，我们在组件中想要直接获取到元素对象或者子组件实例</p><ul><li><p>在Vue开发中我们是不推荐进行DOM操作的</p></li><li><p>可以给元素或者组件绑定一个ref的attribute属性</p></li></ul><p>组件实例有一个$refs属性：</p><ul><li>它一个对象Object，持有注册过 ref attribute 的所有 DOM 元素和组件实例</li></ul><p>$parent和$root：可以通过$parent来访问父元素</p><ul><li>HelloWorld.vue的实现：<ul><li>这里我们也可以通过$root来实现，因为App是我们的根组件</li></ul></li></ul><p>注意：在Vue3中已经移除了$children的属性，所以不可以使用</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">   &lt;h2 ref=<span class="string">&quot;title&quot;</span> <span class="keyword">class</span>=<span class="string">&quot;title&quot;</span> :style=<span class="string">&quot;&#123; color: titleColor &#125;&quot;</span>&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt;</span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">ref</span>=<span class="string">&quot;btn&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;changeTitle&quot;</span>&gt;</span>修改title<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>    </span><br><span class="line"></span><br><span class="line"><span class="attr">methods</span>: &#123;</span><br><span class="line">     <span class="title function_">changeTitle</span>(<span class="params"></span>) &#123;</span><br><span class="line">       <span class="comment">// 1.不要主动的去获取DOM 并且修改DOM内容</span></span><br><span class="line">       <span class="comment">// this.message = &quot;你好啊，李银河!&quot;,</span></span><br><span class="line">       <span class="comment">// this.titleColor = &quot;blue&quot;</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 2.获取h2/button元素</span></span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">title</span>)</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">btn</span>)</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 3.获取 banner 子组件:组件实例</span></span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">banner</span>)</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 3.1 在父组件中可以主动调用子组件的对象方法</span></span><br><span class="line">       <span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">banner</span>.<span class="title function_">bannerClick</span>()</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 3.2 获取banner组件实例，获取banner组件中的元素</span></span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">banner</span>.<span class="property">$el</span>)</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 3.3 如果banner template是多个根 那么会拿到第一个node节点</span></span><br><span class="line">       <span class="comment">// 注意：在开发中不推荐一个组件的template中有多个根元素</span></span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">banner</span>.<span class="property">$el</span>.<span class="property">nextSibling</span>)</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 4.组件实例还有两个实例</span></span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$parent</span>)  <span class="comment">// 获取父组件</span></span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$root</span>)  <span class="comment">// 获取根组件</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="3、动态切换组件"><a href="#3、动态切换组件" class="headerlink" title="3、动态切换组件"></a>3、动态切换组件</h3><p>比如在想要实现了一个功能：点击一个tab-bar，切换不同的组件显示</p><p>可以通过两种不同的实现思路来实现：</p><ul><li>方式一：通过v-if来判断，显示不同的组件</li><li>方式二：动态组件的方式</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- <span class="number">1.</span>第一种做法：v-<span class="keyword">if</span>判断逻辑，以显示不同的组件 --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-if</span>=<span class="string">&quot;currentIndex === 0&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">home</span>&gt;</span><span class="tag">&lt;/<span class="name">home</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-else-if</span>=<span class="string">&quot;currentIndex === 1&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">About</span>&gt;</span><span class="tag">&lt;/<span class="name">About</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-else-if</span>=<span class="string">&quot;currentIndex === 2&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">Category</span>&gt;</span><span class="tag">&lt;/<span class="name">Category</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- <span class="number">2.</span>第二种做法：动态组件component --&gt;</span><br><span class="line">&lt;!-- is中的组件需要来自两个地方：全局注册的组件/局部注册的组件 --&gt;</span><br><span class="line"><span class="comment">//tabs </span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;tabs[currentIndex]&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h4 id="其它操作"><a href="#其它操作" class="headerlink" title="其它操作"></a>其它操作</h4><p>父组件传数据到子组件进行接收</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;component name=<span class="string">&quot;wbh&quot;</span> :age=<span class="string">&quot;age&quot;</span> :is=<span class="string">&quot;currentTab&quot;</span>&gt;&lt;/component&gt;</span><br></pre></td></tr></table></figure><p>在子组件使用 props 接收</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;h2&gt;<span class="title class_">Home</span>组件: &#123;&#123;name&#125;&#125;-&#123;&#123;age&#125;&#125;&lt;/h2&gt;    </span><br><span class="line"></span><br><span class="line">   <span class="attr">props</span>: &#123;</span><br><span class="line">      <span class="attr">name</span>: &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="title class_">String</span>,</span><br><span class="line">        <span class="attr">default</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">age</span>: &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="title class_">Number</span>,</span><br><span class="line">        <span class="attr">default</span>: <span class="number">0</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><p>子组件传数据（事件）到父组件</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">子组件定义事件并传出：</span><br><span class="line">&lt;button @click=<span class="string">&quot;homeClick&quot;</span>&gt;homeBtn&lt;/button&gt;</span><br><span class="line"><span class="attr">$emits</span>: [<span class="string">&quot;homeClick&quot;</span>],</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="title function_">homeClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.$emit(<span class="string">&quot;homeClick&quot;</span>, <span class="string">&quot;home&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">父组件接收并使用参数：</span><br><span class="line">&lt;component @homeClick=<span class="string">&quot;homeClick&quot;</span> :is=<span class="string">&quot;currentTab&quot;</span>&gt;&lt;/component&gt;</span><br><span class="line"></span><br><span class="line"><span class="title function_">homeClick</span>(<span class="params">arg</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;HomeClick:&quot;</span>, arg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、Keep-Alive-的使用"><a href="#4、Keep-Alive-的使用" class="headerlink" title="4、Keep-Alive 的使用"></a>4、Keep-Alive 的使用</h3><p>先对之前的案例中About组件进行改造：</p><ul><li>在其中增加了一个按钮，点击可以递增的功能</li></ul><p>比如将counter点到10，那么在切换到home再切换回来about时，状态是否可以保持？</p><ul><li><p>答案是否定的</p></li><li><p>因为默认情况下，在切换组件后，about组件会被销毁掉，再次回来时会重新创建组件</p></li></ul><p>但是，在开发中某些情况我们希望继续保持组件的状态，而不是销毁掉，这个时候我们就可以使用一个内置组件：keep-alive</p><p>keep-alive 的属性</p><ul><li>include - string | RegExp | Array。只有名称匹配的组件会被缓存</li><li>exclude - string | RegExp | Array。任何名称匹配的组件都不会被缓存</li><li>max - number | string。最多可以缓存多少组件实例，一旦达到这个数字，那么缓存组件中最近没有被访问的实例会被销毁</li></ul><p>include 和 exclude prop 允许组件有条件地缓存：</p><ul><li><p>二者都可以用逗号分隔字符串、正则表达式或一个数组来表示</p></li><li><p>匹配首先检查组件自身的 name 选项</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div <span class="keyword">class</span>=<span class="string">&quot;view&quot;</span>&gt;</span><br><span class="line">    &lt;!-- <span class="attr">include</span>:以逗号隔开且不能添加空格 --&gt;</span><br><span class="line">    &lt;!-- <span class="attr">include</span>:名称来自于组件定义时name选项 --&gt;</span><br><span class="line">    <span class="comment">// 对于需要保持活性的组件，需要在其根组件定义 name 属性，使用的便是此name名称</span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">include</span>=<span class="string">&quot;home,about&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;currentTab&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><h4 id="缓存组件的生命周期"><a href="#缓存组件的生命周期" class="headerlink" title="缓存组件的生命周期"></a>缓存组件的生命周期</h4><p>对于缓存的组件来说，再次进入时，我们是不会执行created或者mounted等生命周期函数的：</p><ul><li><p>但是有时候我们确实希望监听到何时重新进入到了组件，何时离开了组件</p></li><li><p>这个时候我们可以使用activated 和 deactivated 这两个生命周期钩子函数来监听</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对于保持keep-alive组件，监听有没有获取</span></span><br><span class="line"><span class="comment">// keep-alive组件进入活跃状态</span></span><br><span class="line"><span class="title function_">activated</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;home activated&quot;</span>)</span><br><span class="line">&#125;,</span><br><span class="line">    <span class="title function_">deactivated</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;home deactivated&quot;</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="5、异步组件的使用"><a href="#5、异步组件的使用" class="headerlink" title="5、异步组件的使用"></a>5、异步组件的使用</h3><p>在此之前，我们需要对项目通过 webpack 的打包进行了解</p><ul><li>一般在项目完成后，打包后 js 文件夹中有四个文件</li><li>app 中默认存放的是全部的逻辑代码</li><li>chunk-vendors 存放的是相关的第三方引入的库的版本</li></ul><h4 id="1-所以默认的打包过程"><a href="#1-所以默认的打包过程" class="headerlink" title="1.所以默认的打包过程"></a>1.所以默认的打包过程</h4><ul><li><p>默认情况下，在构建整个组件树的过程中，因为组件和组件之间是通过模块化直接依赖的，那么webpack在打包时就会将组 件模块打包到一起（比如一个app.js文件中）</p></li><li><p>这个时候随着项目的不断庞大，app.js文件的内容过大，会造成首屏的渲染速度变慢</p></li></ul><p>打包时，代码的分包：</p><ul><li>所以，对于一些不需要立即使用的组件，我们可以单独对它们进行拆分，拆分成一些小的代码块chunk.js</li><li>这些chunk.js会在需要时从服务器加载下来，并且运行代码，显示对应的内容</li></ul><h4 id="2-文件的分包"><a href="#2-文件的分包" class="headerlink" title="2.文件的分包"></a>2.文件的分包</h4><p>对于 utils 之类的 js 文件，想对其进行分包</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// import &#123; sum &#125; from &#x27;./utils/math.js&#x27;  </span></span><br><span class="line"><span class="comment">// sum(10, 20) // 默认在main.js中的引入与使用是不能对其进行分包</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// js 文件的分包</span></span><br><span class="line"><span class="comment">// import(&quot;./utils/math&quot;).then(res =&gt; &#123;</span></span><br><span class="line"><span class="comment">//   res.sum(10, 20)</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br></pre></td></tr></table></figure><h4 id="3-实现异步组件"><a href="#3-实现异步组件" class="headerlink" title="3.实现异步组件"></a>3.实现异步组件</h4><p>Vue中实现异步组件：对于想要单独分包的组件</p><ul><li>如果我们的项目过大了，对于某些组件我们希望通过异步的方式来进行加载（目的是可以对其进行分包处理），那么Vue中给我们提供了一个函数：defineAsyncComponent</li></ul><p>defineAsyncComponent接受两种类型的参数</p><ul><li><p>类型一：工厂函数，该工厂函数需要返回一个Promise对象</p></li><li><p>类型二：接受一个对象类型，对异步函数进行配置</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineAsyncComponent &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>  <span class="comment">// 先导入对应的方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">AsyncCategory</span> = <span class="title function_">defineAsyncComponent</span>(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&quot;./views/Category.vue&quot;</span>))  <span class="comment">// 导入方式</span></span><br><span class="line">  </span><br><span class="line"><span class="title class_">Category</span>: <span class="title class_">AsyncCategory</span>  <span class="comment">// 注册方式</span></span><br></pre></td></tr></table></figure><p>类型二的写法：</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230415171317358.png" alt="image-20230415171317358"></p><h3 id="6、组件的-v-model"><a href="#6、组件的-v-model" class="headerlink" title="6、组件的 v-model"></a>6、组件的 v-model</h3><h4 id="1-基本使用-1"><a href="#1-基本使用-1" class="headerlink" title="1.基本使用"></a>1.基本使用</h4><p>在input中可以使用v-model来完成双向绑定：</p><ul><li><p>这个时候往往会非常方便，因为v-model默认帮助我们完成了两件事</p></li><li><p>v-bind:value 的数据绑定和 @input 的事件监听</p></li></ul><p>如果现在封装了一个组件，其他地方在使用这个组件时，是否也可以使用 v-model 来同时完成这两个功能？</p><ul><li>也是可以的，vue也支持在组件上使用v-model</li></ul><p>当我们在组件上使用的时候，等价于如下的操作：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- <span class="number">2.</span>组件v-<span class="attr">model</span>:默认的 modelValue --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">counter</span> <span class="attr">v-model</span>=<span class="string">&quot;appCounter&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">counter</span>&gt;</span></span></span><br><span class="line"><span class="comment">// 两行代码等价  默认固定写为 modelValue</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">counter</span> <span class="attr">:modelValue</span>=<span class="string">&quot;appCounter&quot;</span> @<span class="attr">update:modelValue</span>=<span class="string">&quot;appCounter = $event&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">counter</span>&gt;</span></span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">在子组件中：</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Counter: &#123;&#123;modelValue&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeCounter&quot;</span>&gt;</span>修改counter<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">  &lt;/div&gt;</span><br><span class="line"><span class="comment">// 接受传过来的 modelValue</span></span><br><span class="line">    <span class="attr">props</span>: &#123;</span><br><span class="line">      <span class="attr">modelValue</span>: &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="title class_">Number</span>,</span><br><span class="line">        <span class="attr">default</span>: <span class="number">0</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"><span class="comment">// 修改modelValue：固定写法</span></span><br><span class="line">    <span class="attr">emits</span>: [<span class="string">&quot;update:modelValue&quot;</span>],</span><br><span class="line">    <span class="attr">methods</span>: &#123;</span><br><span class="line">      <span class="title function_">changeCounter</span>(<span class="params"></span>) &#123;</span><br><span class="line">          <span class="comment">// 999 是改变 App 中绑定的 appCounter 的值</span></span><br><span class="line">        <span class="variable language_">this</span>.$emit(<span class="string">&quot;update:modelValue&quot;</span>, <span class="number">999</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>和input元素不同的只是属性的名称和事件触发的名称而已；</p><h4 id="2-绑定多个属性"><a href="#2-绑定多个属性" class="headerlink" title="2.绑定多个属性"></a>2.绑定多个属性</h4><p>通过v-model是直接绑定了一个属性，如果想要绑定多个属性呢？也就是在一个组件上使用多个v-model是否可以实现呢？</p><ul><li><p>默认情况下的v-model其实是绑定了 modelValue 属性和 @update:modelValue的事件</p></li><li><p>如果希望绑定更多，可以给 v-model 传入一个参数，那么这个参数的名称就是我们绑定属性的名称</p></li></ul><p>v-model:why 相当于做了两件事：</p><ul><li><p>绑定了message 属性</p></li><li><p>监听了 @update:message 的事件</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- <span class="number">3.</span>组件的v-model：自定义名称counter --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">counter2</span> <span class="attr">v-model:counter</span>=<span class="string">&quot;appCounter&quot;</span> <span class="attr">v-model:why</span>=<span class="string">&quot;appWhy&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">counter2</span>&gt;</span></span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">props</span>: &#123;</span><br><span class="line">  <span class="attr">why</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="title class_">String</span>,</span><br><span class="line">    <span class="attr">default</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">emits</span>: [<span class="string">&quot;update:counter&quot;</span>, <span class="string">&quot;update:why&quot;</span>],</span><br><span class="line"><span class="attr">methods</span>: &#123;</span><br><span class="line">  <span class="title function_">changeCounter</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.$emit(<span class="string">&quot;update:counter&quot;</span>, <span class="number">999</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">changeWhy</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.$emit(<span class="string">&quot;update:why&quot;</span>, <span class="string">&quot;kobe&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7、组件的混入"><a href="#7、组件的混入" class="headerlink" title="7、组件的混入"></a>7、组件的混入</h3><h4 id="1-认识-Mixin"><a href="#1-认识-Mixin" class="headerlink" title="1.认识 Mixin"></a>1.认识 Mixin</h4><p>目前我们是使用组件化的方式在开发整个Vue的应用程序，但是组件和组件之间有时候会存在相同的代码逻辑，我们希望对相同的代码逻辑进行抽取</p><p>在 Vue2 和 Vue3 中都支持的一种方式就是使用Mixin来完成：</p><ul><li><p>Mixin提供了一种非常灵活的方式，来分发Vue组件中的可复用功能</p></li><li><p>一个Mixin对象可以包含任何组件选项</p></li><li><p>当组件使用 Mixin 对象时，所有 Mixin 对象的选项将被混合进入该组件本身的选项中</p></li></ul><h4 id="2-基本使用"><a href="#2-基本使用" class="headerlink" title="2.基本使用"></a>2.基本使用</h4><p>将重复的对象抽入一个 js 文件中：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">message</span>: <span class="string">&quot;hello world&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">created</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;message&quot;</span>, <span class="variable language_">this</span>.<span class="property">message</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在需要使用的地方引入</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> messageMixin <span class="keyword">from</span> <span class="string">&#x27;../mixins/message-mixin.js&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">mixins</span>: [messageMixin]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-合并规则"><a href="#3-合并规则" class="headerlink" title="3.合并规则"></a>3.合并规则</h4><p>如果Mixin对象中的选项和组件对象中的选项发生了冲突，那么Vue会如何操作呢？</p><p>这里分成不同的情况来进行处理</p><p>情况一：如果是data函数的返回值对象</p><ul><li><p>返回值对象默认情况下会进行合并</p></li><li><p>如果data返回值对象的属性发生了冲突，那么会保留组件自身的数据</p></li></ul><p>情况二：如何生命周期钩子函数</p><ul><li>生命周期的钩子函数会被合并到数组中，都会被调用</li></ul><p>情况三：值为对象的选项，例如 methods、components 和 directives，将被合并为同一个对象</p><ul><li><p>比如都有methods选项，并且都定义了方法，那么它们都会生效</p></li><li><p>但是如果对象的key相同，那么会取组件对象的键值对</p></li></ul><h4 id="4-全局混入-Mixin"><a href="#4-全局混入-Mixin" class="headerlink" title="4.全局混入 Mixin"></a>4.全局混入 Mixin</h4><p>如果组件中的某些选项，是所有的组件都需要拥有的，那这时可以使用全局的mixin</p><ul><li><p>全局的Mixin可以使用应用app的方法 mixin 来完成注册</p></li><li><p>一旦注册，那么全局混入的选项将会影响每一个组件</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(<span class="title class_">App</span>)</span><br><span class="line">app.<span class="title function_">mixin</span>(&#123;</span><br><span class="line">  <span class="title function_">created</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;mixin created&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">app.<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="9-Composition-API"><a href="#9-Composition-API" class="headerlink" title="9.Composition API"></a>9.Composition API</h2><h3 id="1、认识-CompositionAPI"><a href="#1、认识-CompositionAPI" class="headerlink" title="1、认识 CompositionAPI"></a>1、认识 CompositionAPI</h3><h4 id="1-Options-API的弊端"><a href="#1-Options-API的弊端" class="headerlink" title="1.Options API的弊端"></a>1.Options API的弊端</h4><ul><li><p>Options API的一大特点就是在对应的属性中编写对应的功能模块</p></li><li><p>比如data定义数据、methods中定义方法、computed中定义计算属性、watch中监听属性改变，也包括生命周期钩子</p></li></ul><p>但是这种代码有一个很大的弊端：</p><ul><li><p>当我们实现某一个功能时，这个功能对应的代码逻辑会被拆分到各个属性中</p></li><li><p>当我们组件变得更大、更复杂时，逻辑关注点的列表就会增长，那么同一个功能的逻辑就会被拆分的很分散</p></li><li><p>尤其对于那些一开始没有编写这些组件的人来说，这个组件的代码是难以阅读和理解的（阅读组件的其他人）</p></li></ul><p>对于非常大的组件</p><ul><li>这种碎片化的代码使用理解和维护这个复杂的组件变得异常困难，并且隐藏了潜在的逻辑问题</li><li>并且当我们处理单个逻辑关注点时，需要不断的跳到相应的代码块中</li></ul><p>如果我们能将同一个逻辑关注点相关的代码收集在一起会更好</p><p>这就是Composition API想要做的事情，以及可以帮助我们完成的事情</p><p>也有人把Vue Composition API简称为VCA</p><h4 id="2-认识-Composition-API"><a href="#2-认识-Composition-API" class="headerlink" title="2.认识 Composition API"></a>2.认识 Composition API</h4><p>编写位置：在Vue组件中，这个位置是 setup 函数</p><p>setup其实就是组件的另外一个选项：</p><ul><li><p>只不过这个选项强大到我们可以用它来替代之前所编写的大部分其他选项</p></li><li><p>比如methods、computed、watch、data、生命周期等等</p></li></ul><h3 id="2、Setup-函数的基本使用"><a href="#2、Setup-函数的基本使用" class="headerlink" title="2、Setup 函数的基本使用"></a>2、Setup 函数的基本使用</h3><h4 id="setup-函数的使用"><a href="#setup-函数的使用" class="headerlink" title="setup 函数的使用"></a>setup 函数的使用</h4><h5 id="1、setup-函数的参数"><a href="#1、setup-函数的参数" class="headerlink" title="1、setup 函数的参数"></a>1、setup 函数的参数</h5><p>它主要有两个参数：第一个参数：props；第二个参数：context</p><p>props 就是父组件传递过来的属性会被放到 props 对象中，我们在setup中如果需要使用，那么就可以直接通过props参数获取：</p><ul><li><p>对于定义props的类型，还是和之前的规则是一样的，在props选项中定义</p></li><li><p>并且在template中依然是可以正常去使用props中的属性，比如message</p></li><li><p>如果在setup函数中想要使用props，那么不可以通过 this 去获取</p></li><li><p>因为props有直接作为参数传递到setup函数中，所以可以直接通过参数来使用即可</p></li></ul><p>另一个参数：context，我们也称之为是一个SetupContext</p><p>它里面包含三个属性：</p><ul><li><p>attrs：所有的非prop的attribute</p></li><li><p>slots：父组件传递过来的插槽（这个在以渲染函数返回时会有作用）</p></li><li><p>emit：当我们组件内部需要发出事件时会用到emit（因为我们不能访问this，所以不可以通过 this.$emit发出事件）</p></li></ul><h5 id="2、setup-函数的返回值"><a href="#2、setup-函数的返回值" class="headerlink" title="2、setup 函数的返回值"></a>2、setup 函数的返回值</h5><p>setup既然是一个函数，那么它也可以有返回值</p><ul><li><p>setup的返回值可以在模板 template 中被使用</p></li><li><p>也就是说我们可以通过 setup 的返回值来替代data选项</p></li></ul><p>甚至是我们可以返回一个执行函数来代替在methods中定义的方法：</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230417193706344.png" alt="image-20230417193706344"></p><p>如果将 counter 在 increment 或者 decrement进行操作时，是否可以实现界面的响应式呢？</p><ul><li><p>答案是不可以</p></li><li><p>这是因为对于一个定义的变量来说，默认情况下，Vue并不会跟踪它的变化，来引起界面的响应式操作</p></li></ul><p>初体验：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">  &lt;div <span class="keyword">class</span>=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">    &lt;!-- 对于 template 中的 ref 对象会自动解包 不需要 .<span class="property">value</span>获取值 --&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>当前计数: &#123;&#123; counter &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;increment&quot;</span>&gt;</span>+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;decrement&quot;</span>&gt;</span>-1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">  &lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>  <span class="comment">// 数据只有在ref包裹来实现响应式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 1.定义counter的内容</span></span><br><span class="line">    <span class="comment">// 默认定义的数据都不是响应式数据</span></span><br><span class="line">    <span class="keyword">let</span> counter = <span class="title function_">ref</span>(<span class="number">100</span>)</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">increment</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">      counter.<span class="property">value</span>++</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(counter.<span class="property">value</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">decrement</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">      counter.<span class="property">value</span>--</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      counter, increment, decrement</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>抽取函数：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">抽取到 js 文件中：</span><br><span class="line">import &#123; ref &#125; from &quot;vue&quot;</span><br><span class="line"></span><br><span class="line">export default function useCounter() &#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">App</span>.<span class="property">vue</span>:</span><br><span class="line"><span class="keyword">import</span> useCounter <span class="keyword">from</span> <span class="string">&#x27;./hooks/useCounter.js&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> &#123; counter, increment, decrement &#125; = <span class="title function_">useCounter</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      ...<span class="title function_">useCounter</span>()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="3、Setup-中数据的响应式"><a href="#3、Setup-中数据的响应式" class="headerlink" title="3、Setup 中数据的响应式"></a>3、Setup 中数据的响应式</h3><h4 id="1-Reactive-API"><a href="#1-Reactive-API" class="headerlink" title="1.Reactive API"></a>1.Reactive API</h4><p>如果想为在 setup 中定义的数据提供响应式的特性，可以使用 reactive 的函数</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;h2&gt;<span class="attr">message</span>: &#123;&#123;message&#125;&#125;&lt;/h2&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>账号: &#123;&#123;account.username&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>密码: &#123;&#123;account.password&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 1.定义普通的数据：可以正常的被使用</span></span><br><span class="line">    <span class="comment">// 缺点：数据不是响应式的</span></span><br><span class="line">    <span class="keyword">let</span> message = <span class="string">&quot;hello world&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.定义响应式数据</span></span><br><span class="line">    <span class="comment">// 2.1 reactive函数：定义复杂类型的数据(数组、对象)</span></span><br><span class="line">    <span class="keyword">const</span> account = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">        <span class="attr">username</span>: <span class="string">&quot;coderwhy&quot;</span>,</span><br><span class="line">        <span class="attr">password</span>: <span class="string">&quot;123456&quot;</span></span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><p>原因：</p><ul><li><p>因为当使用reactive函数处理数据之后，数据再次被使用时就会进行依赖收集</p></li><li><p>当数据发生改变时，所有收集到的依赖都是进行对应的响应式操作（比如更新界面）</p></li><li><p>事实上，我们编写的data选项，也是在内部交给了reactive函数将其编程响应式对象的</p></li></ul><h4 id="2-Ref-API"><a href="#2-Ref-API" class="headerlink" title="2.Ref API"></a>2.Ref API</h4><p>reactive API对传入的类型是有限制的，它要求必须传入的是一个对象或者数组类型</p><p>如果传入一个基本数据类型（String、Number、Boolean）会报一个警告</p><p>Vue3 提供了另外一个API：ref API</p><ul><li><p>ref 会返回一个可变的响应式对象，该对象作为一个响应式的引用维护着它内部的值，这就是 ref 名称的来源</p></li><li><p>它内部的值是在 ref 的 value 属性中被维护的</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;h2&gt;当前计数: &#123;&#123;counter&#125;&#125;&lt;/h2&gt;</span><br><span class="line"><span class="comment">// 2.2 ref 函数：定义简单类型的数据（也可以定义复杂数据类型的数据）</span></span><br><span class="line"><span class="keyword">const</span> counter = <span class="title function_">ref</span>(<span class="number">0</span>)  <span class="comment">// 返回的是 ref 对象</span></span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>在模板中引入 ref 的值时，Vue 会自动帮助进行解包操作，所以并不需要在模板中通过 ref.value 的方式来使用</li><li>但是在 setup 函数内部，它依然是一个 ref 引用， 所以对其进行操作时依然需要使用 ref.value的方式</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- 默认情况下在template中使用ref时，vue会自动对其进行解包（取出value） --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>当前计数: &#123;&#123;counter&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;increment&quot;</span>&gt;</span>+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>  <span class="comment">// 调用函数</span></span><br><span class="line">&lt;!-- 也不需要写.<span class="property">value</span> --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;counter++&quot;</span>&gt;</span>+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">increment</span>(<span class="params"></span>) &#123;</span><br><span class="line">    counter.<span class="property">value</span>++  <span class="comment">// 在script中都需要写.value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-Ref-自动解包"><a href="#3-Ref-自动解包" class="headerlink" title="3.Ref 自动解包"></a>3.Ref 自动解包</h4><p>模板中的解包是浅层的解包</p><ul><li>在别的对象中引用 ref 对象时，如下</li><li>在以前是浅层解包（.value），现在是自动解包，除了在别的对象中引用 ref 对象且进行修改</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- vue3<span class="number">.1</span>之前需要添加value --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>当前计数: &#123;&#123; info.counter &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;!-- 这儿又必须加上.<span class="property">value</span> --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;info.counter.value++&quot;</span>&gt;</span>+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&lt;!-- 总结：使用时不需要使用.<span class="property">value</span>,修改时需要写上.<span class="property">value</span> --&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> counter = <span class="title function_">ref</span>(<span class="number">0</span>) </span><br><span class="line"><span class="keyword">const</span> info = &#123;</span><br><span class="line">    counter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果将 ref 放到一个 reactive 的属性当中，那么在模板中使用时，它会自动解包：</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230417200714193.png" alt="image-20230417200714193"></p><h4 id="4-reactive-和-ref-的使用总结"><a href="#4-reactive-和-ref-的使用总结" class="headerlink" title="4.reactive 和 ref 的使用总结"></a>4.reactive 和 ref 的使用总结</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">  <span class="comment">// 定义响应式数据：reactive/ref</span></span><br><span class="line">  <span class="comment">// 强调：ref也可以定义复杂的数据</span></span><br><span class="line">  <span class="keyword">const</span> info = <span class="title function_">ref</span>(&#123;&#125;)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(info.<span class="property">value</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1.reactive的应用场景</span></span><br><span class="line">  <span class="comment">// 1.1 条件一：reactive应用于本地的数据</span></span><br><span class="line">  <span class="comment">// 1.2 条件二：多个数据之间是有关系/联系（聚合的数据，组织在一起会有特定的作用）</span></span><br><span class="line">  <span class="keyword">const</span> account = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">      <span class="attr">username</span>: <span class="string">&#x27;coderwhy&#x27;</span>,</span><br><span class="line">      <span class="attr">password</span>: <span class="string">&#x27;123456&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> username = <span class="title function_">ref</span>(<span class="string">&quot;coderwhy&quot;</span>)</span><br><span class="line">  <span class="keyword">const</span> password = <span class="title function_">ref</span>(<span class="string">&quot;123456&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.ref 的应用场景：其他的场景基本都用ref（computed）</span></span><br><span class="line">  <span class="comment">// 2.1 定义本地的一些简单数据</span></span><br><span class="line">  <span class="keyword">const</span> message = <span class="title function_">ref</span>(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line">  <span class="keyword">const</span> counter = <span class="title function_">ref</span>(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">const</span> name = <span class="title function_">ref</span>(<span class="string">&#x27;why&#x27;</span>)</span><br><span class="line">  <span class="keyword">const</span> age = <span class="title function_">ref</span>(<span class="number">18</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.2 定义从网络中获取的数据也是使用ref</span></span><br><span class="line">  <span class="comment">// const musics = reactive([])</span></span><br><span class="line">  <span class="keyword">const</span> musics = <span class="title function_">ref</span>([])</span><br><span class="line">  <span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> serverMusics = [<span class="string">&quot;1s&quot;</span>, <span class="string">&quot;2s&quot;</span>, <span class="string">&quot;3s&quot;</span>]</span><br><span class="line">      musics.<span class="property">value</span> = serverMusics</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="5-认识-readonly"><a href="#5-认识-readonly" class="headerlink" title="5.认识 readonly"></a>5.认识 readonly</h4><p>通过reactive或者ref可以获取到一个响应式的对象，但是某些情况下，传入给其他地方（组件）的这个响应式对象希望在另外一个地方（组件）被使用，但是不能被修改，如何防止这种情况</p><ul><li><p>Vue3 提供了 readonly 的方法</p></li><li><p>readonly会返回原始对象的只读代理（也就是它依然是一个 Proxy，这是一个 proxy 的 set 方法被劫持，并且不能对其进行修改）</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">子组件接受数据并修改：可以修改的原因，这里父组件传来的是一个对象，即是一个对象的引用地址，所以可对其值进行修改</span><br><span class="line">&lt;h2&gt;<span class="title class_">ShowInfo</span>: &#123;&#123; info &#125;&#125;&lt;/h2&gt;</span><br><span class="line">&lt;!-- 代码没有错误，但是违背了规范(单向数据流) --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;info.name = &#x27;kobe&#x27;&quot;</span>&gt;</span>showinfo按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&lt;!-- 正确的做法: 通过emit向父组件发出事件，符合单向数据流 --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;showInfobtnClick&quot;</span>&gt;</span>showinfo按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>补充：单向数据流</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230417201301364.png" alt="image-20230417201301364"></p><h5 id="1、readonly-的使用"><a href="#1、readonly-的使用" class="headerlink" title="1、readonly 的使用"></a>1、readonly 的使用</h5><ul><li><p>readonly 返回的对象都是不允许修改的</p></li><li><p>但是经过 readonly 处理的原来的对象是允许被修改的</p><ul><li>比如 const info &#x3D; readonly(obj)，info对象是不允许被修改的</li><li>当 obj 被修改时，readonly 返回的 info 对象也会被修改</li><li>但是我们不能去修改 readonly 返回的对象 info</li></ul></li></ul><p>其实本质上就是 readonly 返回的对象的 setter 方法被劫持了而已</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- 使用readonly的数据 --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>readonly: &#123;&#123; roInfo &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">&lt;!-- 代码无效（报警告） --&gt;</span><br><span class="line">&lt;!-- <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;roInfo.name = &#x27;james&#x27;&quot;</span>&gt;</span>showinfo按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span> --&gt;</span><br><span class="line">&lt;!-- 正确的做法:使用emit向父组件发出修改事件 --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;roInfobtnClick&quot;</span>&gt;</span>roInfo按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h5 id="2、readonly-的应用"><a href="#2、readonly-的应用" class="headerlink" title="2、readonly 的应用"></a>2、readonly 的应用</h5><p>在传递给其他组件数据时，往往希望其他组件使用我们传递的内容，但是不允许它们修改时，就可以使用readonly了</p><h3 id="4、Reactive-知识点补充"><a href="#4、Reactive-知识点补充" class="headerlink" title="4、Reactive 知识点补充"></a>4、Reactive 知识点补充</h3><p>插件的使用：vue-devtools</p><h4 id="Reactive-判断的-API"><a href="#Reactive-判断的-API" class="headerlink" title="Reactive 判断的 API"></a>Reactive 判断的 API</h4><p>isProxy：检查对象是否是由 reactive 或 readonly创建的 proxy</p><p>isReactive</p><ul><li><p>检查对象是否是由 reactive创建的响应式代理</p></li><li><p>如果该代理是 readonly 建的，但包裹了由 reactive 创建的另一个代理，它也会返回 true</p></li></ul><p>isReadonly：检查对象是否是由 readonly 创建的只读代理</p><p>toRaw</p><ul><li>返回 reactive 或 readonly 代理的原始对象（不建议保留对原始对象的持久引用。请谨慎使用）</li></ul><p>shallowReactive</p><ul><li>创建一个响应式代理，它跟踪其自身 property 的响应性，但不执行嵌套对象的深层响应式转换 (深层还是原生对象)</li></ul><p>shallowReadonly</p><ul><li>创建一个 proxy，使其自身的 property 为只读，但不执行嵌套对象的深度只读转换（深层还是可读、可写的）</li></ul><h3 id="5、Ref-知识点补充"><a href="#5、Ref-知识点补充" class="headerlink" title="5、Ref 知识点补充"></a>5、Ref 知识点补充</h3><h4 id="1-toRefs"><a href="#1-toRefs" class="headerlink" title="1.toRefs"></a>1.toRefs</h4><p>如果使用ES6的解构语法，对 reactive 返回的对象进行解构获取值（有时解构是为了便于展示时书写），那么之后无论是修改结构后的变量，还是修改reactive 返回的state对象，数据都不再是响应式的</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;h2&gt;<span class="attr">info</span>: &#123;&#123;name&#125;&#125; - &#123;&#123;age&#125;&#125; - &#123;&#123;height&#125;&#125;&lt;/h2&gt;</span><br></pre></td></tr></table></figure><p>那么有没有办法让我们解构出来的属性是响应式的</p><ul><li><p>Vue为我们提供了一个toRefs的函数，可以将reactive返回的对象中的属性都转成ref</p></li><li><p>那么我们再次进行结构出来的 name 和 age 本身都是 ref的</p></li></ul><p>这种做法相当于已经在state.name和ref.value之间建立了 链接，任何一个修改都会引起另外一个变化</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// reactive 被解构后会变成普通的值，失去响应式</span></span><br><span class="line"><span class="comment">// const &#123; name, age &#125; = info</span></span><br><span class="line"><span class="keyword">const</span> &#123; name, age &#125; = <span class="title function_">toRefs</span>(info)</span><br><span class="line"><span class="keyword">return</span> &#123; name, age &#125;</span><br></pre></td></tr></table></figure><h4 id="2-toRef"><a href="#2-toRef" class="headerlink" title="2.toRef"></a>2.toRef</h4><p>如果我们只希望转换一个 reactive 对象中的属性为ref, 那么可以使用toRef的方法</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> height = <span class="title function_">toRef</span>(info, <span class="string">&quot;height&quot;</span>)  <span class="comment">// info 中的height属性</span></span><br><span class="line"><span class="keyword">return</span> &#123; height &#125;</span><br></pre></td></tr></table></figure><h4 id="3-ref-其他的-API"><a href="#3-ref-其他的-API" class="headerlink" title="3.ref 其他的 API"></a>3.ref 其他的 API</h4><p>unref：如果想要获取一个 ref 引用中的 value，那么也可以通过 unref 方法</p><ul><li>如果参数是一个 ref，则返回内部值，否则返回参数本身</li><li>这是 val &#x3D; isRef(val) ? val.value : val 的语法糖函数</li></ul><p>isRef：判断值是否是一个ref对象</p><p>shallowRef：创建一个浅层的ref对象</p><p>triggerRef：手动触发和 shallowRef 相关联的副作用</p><h3 id="6、setup-中禁用-this"><a href="#6、setup-中禁用-this" class="headerlink" title="6、setup 中禁用 this"></a>6、setup 中禁用 this</h3><p>官方关于 this 的描述：</p><ul><li>表达的含义是this并没有指向当前组件实例</li><li>并且在setup被调用之前，data、computed、methods等都没有被解析</li><li>所以无法在setup中获取this</li></ul><p>其实在之前的这段描述是和源码有出入的： </p><ul><li>之前的描述大概含义是不可以使用this是因为组件实例还没有被创建出来</li></ul><p>源码：</p><p>代码是按照如下顺序执行的：</p><ul><li><p>调用 createComponentInstance 创建组件实例</p></li><li><p>调用 setupComponent 初始化component内部的操作</p></li><li><p>调用 setupStatefulComponent 初始化有状态的组件</p></li><li><p>在 setupStatefulComponent 取出了 setup 函数</p></li><li><p>通过callWithErrorHandling 的函数执行 setup</p></li></ul><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230417203715822.png" alt="image-20230417203715822"></p><p>从上面的代码可以看出， 组件的instance肯定是在执行 setup 函数之前就创建出来的</p><h2 id="10-Composition-API"><a href="#10-Composition-API" class="headerlink" title="10.Composition API"></a>10.Composition API</h2><h3 id="1、computed"><a href="#1、computed" class="headerlink" title="1、computed"></a>1、computed</h3><p>在前面记录过计算属性computed：当某些属性是依赖其他状态时，可以使用计算属性来处理</p><ul><li><p>在前面的Options API中，是使用computed选项来完成的</p></li><li><p>在Composition API中，可以在 setup 函数中使用 computed 方法来编写一个计算属性</p></li></ul><p>如何使用 computed</p><ul><li><p>方式一：接收一个 getter 函数，并为 getter 函数返回的值，返回一个不变的 ref 对象</p></li><li><p>方式二：接收一个具有 get 和 set 的对象，返回一个可变的（可读写）ref 对象</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;h2&gt;&#123;&#123;fullName&#125;&#125;&lt;/h2&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;setFullName&quot;</span>&gt;</span>设置fullName<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> names = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">    <span class="attr">firstName</span>: <span class="string">&quot;kobe&quot;</span>,</span><br><span class="line">    <span class="attr">lastName</span>: <span class="string">&#x27;bryant&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">import</span> &#123; reactive, computed, ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">const</span> fullName = <span class="title function_">computed</span>(&#123;</span><br><span class="line">    <span class="attr">set</span>: <span class="keyword">function</span>(<span class="params">newValue</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> tempNmaes = newValue.<span class="title function_">split</span>(<span class="string">&quot; &quot;</span>)</span><br><span class="line">        names.<span class="property">firstName</span> = tempNmaes[<span class="number">0</span>]</span><br><span class="line">        names.<span class="property">lastName</span> = tempNmaes[<span class="number">1</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> names.<span class="property">firstName</span> + <span class="string">&quot; &quot;</span> + names.<span class="property">lastName</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">setFullName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    fullName.<span class="property">value</span> = <span class="string">&quot;coder why&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="setup中使用ref"><a href="#setup中使用ref" class="headerlink" title="setup中使用ref"></a>setup中使用ref</h4><p>只需要定义一个ref对象，绑定到元素或者组件的ref属性上即可</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;h2 ref=<span class="string">&quot;titleRef&quot;</span>&gt;我是标题&lt;/h2&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">ref</span>=<span class="string">&quot;btnRef&quot;</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="comment">// 先转换为ref对象</span></span><br><span class="line"><span class="keyword">const</span> titleRef = <span class="title function_">ref</span>()</span><br><span class="line"><span class="keyword">const</span> btnRef= <span class="title function_">ref</span>()</span><br><span class="line"><span class="keyword">const</span> showinfoRef= <span class="title function_">ref</span>()</span><br><span class="line"><span class="comment">// 直接获取的话是获取不到的，因为在解析时可能还没挂载便执行了获取代码，还没有元素</span></span><br><span class="line"><span class="comment">// 可以在页面渲染完成后，使用函数点击获取元素</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getElements</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(titleRef.<span class="property">value</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(btnRef.<span class="property">value</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(showinfoRef.<span class="property">value</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 也可以使用生命周期函数获取，等其挂载完成之后，所以选择onMounted</span></span><br><span class="line"><span class="comment">// onMounted 的生命周期函数</span></span><br><span class="line"><span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(titleRef.<span class="property">value</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(btnRef.<span class="property">value</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(showinfoRef.<span class="property">value</span>)</span><br><span class="line"></span><br><span class="line">    showinfoRef.<span class="property">value</span>.<span class="title function_">showinfofoo</span>()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="2、组件的生命周期函数"><a href="#2、组件的生命周期函数" class="headerlink" title="2、组件的生命周期函数"></a>2、组件的生命周期函数</h3><p>setup 可以用来替代 data 、 methods 、 computed 等等这些选项，也可以替代生命周期钩子</p><p>setup 中可以使用直接导入的 onX 函数注册生命周期钩子</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; onMounted, onUpdated, onUnmounted &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 在执行setup函数的过程中，你需要注册别的生命周期函数</span></span><br><span class="line">    <span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;onMounted&quot;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;onMounted&quot;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;onMounted&quot;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230417205134405.png" alt="image-20230417205134405"></p><h3 id="3、Provide-x2F-Inject-使用"><a href="#3、Provide-x2F-Inject-使用" class="headerlink" title="3、Provide&#x2F;Inject 使用"></a>3、Provide&#x2F;Inject 使用</h3><p>之前还学习过Provide和Inject，Composition API也可以替代之前的 Provide 和 Inject 的选项</p><h4 id="1-Provide-函数"><a href="#1-Provide-函数" class="headerlink" title="1.Provide 函数"></a>1.Provide 函数</h4><p>可以通过 provide来提供数据：可以通过 provide 方法来定义每个 Property</p><p>provide可以传入两个参数</p><ul><li><p>name：提供的属性名称</p></li><li><p>value：提供的属性值</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; provide, ref &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span></span><br><span class="line"><span class="title function_">provide</span>(<span class="string">&quot;name&quot;</span>, name)</span><br><span class="line"><span class="title function_">provide</span>(<span class="string">&quot;age&quot;</span>, <span class="number">18</span>)</span><br><span class="line"><span class="keyword">return</span> &#123; name &#125;</span><br></pre></td></tr></table></figure><h4 id="2-Inject函数"><a href="#2-Inject函数" class="headerlink" title="2.Inject函数"></a>2.Inject函数</h4><p>在后代组件中可以通过 inject 来注入需要的属性和对应的值</p><ul><li>可以通过 inject 来注入需要的内容</li></ul><p>inject可以传入两个参数</p><ul><li><p>要 inject 的 property 的 name</p></li><li><p>默认值</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以前的方法</span></span><br><span class="line"><span class="comment">// inject的options api注入，那么依然需要手动来解包，使用之后警告依旧存在</span></span><br><span class="line"><span class="comment">// inject: [&quot;name&quot;, &quot;age&quot;], </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 setup 不需要手动解包</span></span><br><span class="line"><span class="keyword">import</span> &#123; inject &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="title function_">inject</span>(<span class="string">&quot;name&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> age = <span class="title function_">inject</span>(<span class="string">&quot;age&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> &#123; name, age&#125;</span><br></pre></td></tr></table></figure><p>如果 Inject 接受的数据不存在，可以定义默认值</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> height = <span class="title function_">inject</span>(<span class="string">&quot;height&quot;</span>, <span class="number">1.58</span>)</span><br><span class="line"><span class="keyword">return</span> &#123; height &#125;</span><br></pre></td></tr></table></figure><h4 id="3-数据响应式"><a href="#3-数据响应式" class="headerlink" title="3.数据响应式"></a>3.数据响应式</h4><p>为了增加 provide 值和 inject 值之间的响应性，可以在 provide 值时使用 ref 和 reactive</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="title function_">ref</span>(<span class="string">&quot;why&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> info = <span class="title function_">reactive</span>(&#123;<span class="attr">name</span>: <span class="string">&quot;why&quot;</span>, <span class="attr">age</span>: <span class="number">15</span>&#125;)</span><br><span class="line"><span class="title function_">provide</span>(<span class="string">&quot;info&quot;</span>, info)</span><br></pre></td></tr></table></figure><h3 id="4、watch-x2F-watchEffect"><a href="#4、watch-x2F-watchEffect" class="headerlink" title="4、watch&#x2F;watchEffect"></a>4、watch&#x2F;watchEffect</h3><p>在Composition API中，可以使用watchEffect和watch来完成响应式数据的侦听</p><ul><li><p>watchEffect：用于自动收集响应式数据的依赖</p></li><li><p>watch：需要手动指定侦听的数据源</p></li></ul><h4 id="1-Watch-的使用"><a href="#1-Watch-的使用" class="headerlink" title="1.Watch 的使用"></a>1.Watch 的使用</h4><p>watch的API完全等同于组件watch选项的Property</p><ul><li>watch需要侦听特定的数据源，并且执行其回调函数</li><li>默认情况下它是惰性的，只有当被侦听的源发生变化时才会执行回调</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; reactive, ref, watch &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span></span><br><span class="line"><span class="title function_">watch</span>(message, <span class="function">(<span class="params">newValue, oldValue</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(newValue, oldValue)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="title function_">watch</span>(info, <span class="function">(<span class="params">newValue, oldValue</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(newValue, oldValue)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(newValue === oldValue)</span><br><span class="line">&#125;, &#123;</span><br><span class="line">    <span class="attr">immediate</span>: <span class="literal">true</span></span><br><span class="line">    <span class="comment">// 会默认有深度的监听</span></span><br><span class="line">&#125;) </span><br></pre></td></tr></table></figure><p>以上方法获取的是 proxy，要获取普通对象的话：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 3.侦听reactive数据变化后，获取普通对象</span></span><br><span class="line"><span class="title function_">watch</span>(<span class="function">() =&gt;</span> (&#123; ...info &#125;), <span class="function">(<span class="params">newValue, oldValue</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(newValue, oldValue)</span><br><span class="line">&#125;, &#123;</span><br><span class="line">    <span class="attr">immediate</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 需要打开 deep</span></span><br><span class="line">    <span class="attr">deep</span>: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>侦听多个数据源</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230417210813073.png" alt="image-20230417210813073"></p><p>watch 的选项</p><ul><li><p>如果希望侦听一个深层的侦听，那么依然需要设置 deep 为true</p></li><li><p>也可以传入 immediate 立即执行</p></li></ul><h4 id="2-WatchEffect"><a href="#2-WatchEffect" class="headerlink" title="2.WatchEffect"></a>2.WatchEffect</h4><p>当侦听到某些响应式数据变化时，希望执行某些操作，这个时候可以使用 watchEffect</p><p>案例：</p><ul><li>首先，watchEffect传入的函数会被立即执行一次，并且在执行的过程中会收集依赖</li><li>其次，只有收集的依赖发生变化时，watchEffect传入的函数才会再次执行</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; watchEffect, ref, watch &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="comment">// 1.watchEffect传入的函数默认会直接被执行</span></span><br><span class="line"><span class="comment">// 2.在执行的过程中，会自动的收集依赖（依赖哪些响应式的数据）</span></span><br><span class="line"><span class="title function_">watchEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;-------------&quot;</span>, counter.<span class="property">value</span>, name.<span class="property">value</span>)</span><br><span class="line">&#125;) </span><br></pre></td></tr></table></figure><h5 id="watchEffect-的停止侦听"><a href="#watchEffect-的停止侦听" class="headerlink" title="watchEffect 的停止侦听"></a>watchEffect 的停止侦听</h5><p>如果在发生某些情况下，希望停止侦听，这时可以获取watchEffect的返回值函数，调用该函数即可</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> stopWatch = <span class="title function_">watchEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;-------------&quot;</span>, counter.<span class="property">value</span>, name.<span class="property">value</span>)</span><br><span class="line">    <span class="comment">// 判断counter.value &gt; 10</span></span><br><span class="line">    <span class="keyword">if</span> (counter.<span class="property">value</span> &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="title function_">stopWatch</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="5、自定义-Hook-练习"><a href="#5、自定义-Hook-练习" class="headerlink" title="5、自定义 Hook 练习"></a>5、自定义 Hook 练习</h3><h4 id="1-useCounter-计数"><a href="#1-useCounter-计数" class="headerlink" title="1.useCounter 计数"></a>1.useCounter 计数</h4><p>见 composition api 9 初体验，抽取计数器 setup 中的函数至一个 js 文件，在需要使用的组件进行引入即可</p><h4 id="2-useTitle-切换title"><a href="#2-useTitle-切换title" class="headerlink" title="2.useTitle 切换title"></a>2.useTitle 切换title</h4><p>初使用：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref, watch &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">useTitle</span>(<span class="params">titleValue</span>) &#123;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">title</span> = title</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> useTitle <span class="keyword">from</span> <span class="string">&#x27;../hooks/useTitle.js&#x27;</span>;</span><br><span class="line"><span class="title function_">useTitle</span>(<span class="string">&quot;首页&quot;</span>)</span><br></pre></td></tr></table></figure><p>一般使用：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref, watch &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">useTitle</span>(<span class="params">titleValue</span>) &#123;</span><br><span class="line">  <span class="comment">// document.title = title</span></span><br><span class="line">  <span class="comment">// 定义ref应用的数据</span></span><br><span class="line">  <span class="keyword">const</span> title = <span class="title function_">ref</span>(titleValue)</span><br><span class="line"></span><br><span class="line">  <span class="title function_">watch</span>(title, <span class="function">(<span class="params">newValue</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">title</span> = newValue</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    <span class="attr">immediate</span>: <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 返回 ref 的值</span></span><br><span class="line">  <span class="keyword">return</span> title</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2.修改标题</span></span><br><span class="line"><span class="keyword">const</span> title = <span class="title function_">useTitle</span>(<span class="string">&quot;首页&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.监听按钮的点击</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">popularClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">    title.<span class="property">value</span> = <span class="string">&quot;首页-流行&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-useScrollPosition"><a href="#3-useScrollPosition" class="headerlink" title="3.useScrollPosition"></a>3.useScrollPosition</h4><p>监听界面的滚动位置</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> scrollPosition = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">y</span>: <span class="number">0</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.监听滚动</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;scroll&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    scrollPosition.<span class="property">x</span> = <span class="variable language_">window</span>.<span class="property">scrollX</span></span><br><span class="line">    scrollPosition.<span class="property">y</span> = <span class="variable language_">window</span>.<span class="property">scrollY</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.返回数据</span></span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">    scrollPosition</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div <span class="keyword">class</span>=<span class="string">&quot;scroll&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>x: &#123;&#123; scrollPosition.x &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>y: &#123;&#123; scrollPosition.y &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> useScrollPosition <span class="keyword">from</span> <span class="string">&quot;../hooks/useScrollPosition.js&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> &#123; scrollPosition &#125; = <span class="title function_">useScrollPosition</span>()</span><br><span class="line"><span class="keyword">return</span> &#123; scrollPosition &#125;</span><br></pre></td></tr></table></figure><h3 id="6、script-setup-语法糖"><a href="#6、script-setup-语法糖" class="headerlink" title="6、script setup 语法糖"></a>6、script setup 语法糖</h3><p><code>&lt;script setup&gt; </code>是在单文件组件 (SFC) 中使用组合式 API 的编译时语法糖，当同时使用 SFC 与组合式 API 时则推荐该语法</p><ul><li>更少的样板内容，更简洁的代码</li><li>能够使用纯 Typescript 声明 prop 和抛出事件</li><li>更好的运行时性能 </li><li>更好的 IDE 类型推断性能</li></ul><p>使用这个语法，需要将 setup attribute 添加到 <code>&lt;script&gt;&lt;/script&gt;</code>代码块上</p><p>里面的代码会被编译成组件 setup() 函数的内容</p><ul><li>这意味着与普通的<code>&lt;script&gt;</code>只在组件被首次引入的时候执行一次不同</li><li><code>&lt;script setup&gt;</code>中的代码会在每次组件实例被创建的时候执行</li></ul><h4 id="1-顶层的绑定会被暴露给模板"><a href="#1-顶层的绑定会被暴露给模板" class="headerlink" title="1.顶层的绑定会被暴露给模板"></a>1.顶层的绑定会被暴露给模板</h4><p>当使用 <code>&lt;script setup&gt;</code> 时，任何在<code>&lt;script setup&gt;</code>声明的顶层的绑定(包括变量，函数声明，以及 import 引入的内容) 都能在模板中直接使用</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.所有编写在顶层中的代码，都是默认暴露给template可以使用</span></span><br><span class="line"><span class="keyword">import</span> &#123; onMounted, ref &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span></span><br></pre></td></tr></table></figure><p>响应式数据需要通过ref、reactive来创建</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2.定义响应式数据</span></span><br><span class="line"><span class="keyword">const</span> message = <span class="title function_">ref</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="property">value</span>)</span><br></pre></td></tr></table></figure><h4 id="2-导入的组件直接使用"><a href="#2-导入的组件直接使用" class="headerlink" title="2.导入的组件直接使用"></a>2.导入的组件直接使用</h4><p><code>&lt;script setup&gt;</code>范围里的值也能被直接作为自定义组件的标签名使用</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">ShowInfo</span> <span class="keyword">from</span> <span class="string">&quot;./ShowInfo.vue&quot;</span> <span class="comment">// 不需要注册</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义绑定的函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">changeMessage</span>(<span class="params"></span>) &#123;</span><br><span class="line">    message.<span class="property">value</span> = <span class="string">&#x27;你好啊!&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-defineProps-和-defineEmits"><a href="#3-defineProps-和-defineEmits" class="headerlink" title="3.defineProps() 和 defineEmits()"></a>3.defineProps() 和 defineEmits()</h4><p>通过 props 传递给子组件时，子组件：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;<span class="title class_">ShowInfo</span>: &#123;&#123;name&#125;&#125; - &#123;&#123;age&#125;&#125;&lt;/div&gt;</span><br><span class="line"><span class="comment">// 定义props</span></span><br><span class="line"><span class="keyword">const</span> props = <span class="title function_">defineProps</span>(&#123;</span><br><span class="line">  <span class="attr">name</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="title class_">String</span>,</span><br><span class="line">    <span class="attr">default</span>: <span class="string">&quot;默认值&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">age</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="title class_">Number</span>,</span><br><span class="line">    <span class="attr">default</span>: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>子组件发出事件</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 子组件</span></span><br><span class="line"><span class="keyword">const</span> emits = <span class="title function_">defineEmits</span>([<span class="string">&quot;infoBtnClick&quot;</span>])</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">showInfoBtnClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">emits</span>(<span class="string">&quot;infoBtnClick&quot;</span>, <span class="string">&quot;showinfo内部发生了点击&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父组件：</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">infobtnclick</span>(<span class="params">payload</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;监听到showinfo内部的点击&quot;</span>, payload)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-defineExpose"><a href="#4-defineExpose" class="headerlink" title="4.defineExpose()"></a>4.defineExpose()</h4><p>使用语法糖的组件时默认关闭的：</p><ul><li>通过模板 ref 或者 $parent 链获取到的组件的公开实例，不会暴露任何在 <code>&lt;script setup&gt;</code> 中声明的绑定</li></ul><p>通过 defineExpose 编译器宏来显式指定在 <code>&lt;script setup&gt;</code> 组件中要暴露出去的 property</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 4.获取组件实例</span></span><br><span class="line"><span class="keyword">const</span> showInfoRef = <span class="title function_">ref</span>()  <span class="comment">// 获取子组件</span></span><br><span class="line"><span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">   showInfoRef.<span class="property">value</span>.<span class="title function_">foo</span>()  <span class="comment">// 获取子组件的foo函数</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 子组件定义foo的函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;这是showinfo的foo函数打印&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">defineExpose</span>(&#123;</span><br><span class="line">  foo</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="7、案例练习"><a href="#7、案例练习" class="headerlink" title="7、案例练习"></a>7、案例练习</h3><h4 id="1-创建项目获取数据"><a href="#1-创建项目获取数据" class="headerlink" title="1.创建项目获取数据"></a>1.创建项目获取数据</h4><p>按照区域划分相关的组件，对于整个也页面的重置，可以在 assets 中新建 reset.css 文件进行重置</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> assets <span class="keyword">from</span> <span class="string">&quot;./assets/reset.css&quot;</span></span><br></pre></td></tr></table></figure><p>获取数据：一般都是在 App 组件中获取，再传递给需要使用的组件</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> highScore <span class="keyword">from</span> <span class="string">&quot;./data/high_score.json&quot;</span></span><br></pre></td></tr></table></figure><h4 id="2-头部的封装与使用"><a href="#2-头部的封装与使用" class="headerlink" title="2.头部的封装与使用"></a>2.头部的封装与使用</h4><p>可以现在 App 中写出对应的效果，再将其抽取到独立的组件中，便于复用</p><p>传递数据与接受数据：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;area-header :title=<span class="string">&quot;areaData.title&quot;</span> :subtitle=<span class="string">&quot;areaData.subtitle&quot;</span>&gt;&lt;/area-header&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h3</span> <span class="attr">class</span>=<span class="string">&quot;title&quot;</span>&gt;</span>&#123;&#123; title &#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;subtitle&quot;</span>&gt;</span>&#123;&#123; subtitle &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="title function_">defineProps</span>(&#123;</span><br><span class="line">    <span class="attr">title</span>: &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="title class_">String</span>,</span><br><span class="line">        <span class="attr">default</span>: <span class="string">&quot;默认标题&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">subtitle</span>: &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="title class_">String</span>,</span><br><span class="line">        <span class="attr">default</span>: <span class="string">&quot;默认子标题&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="3-列表的展示"><a href="#3-列表的展示" class="headerlink" title="3.列表的展示"></a>3.列表的展示</h4><p>一样的做法，可以在 App 中完成之后再抽取，对于不便于展示的稍微复杂的数据可以先放着</p><p>在 style 样式调整中如果想要使用 less</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">先安装对应解析less的包： npm install less-loader</span><br><span class="line">再在标签中写入：&lt;style lang=<span class="string">&quot;less&quot;</span> scoped&gt;</span><br></pre></td></tr></table></figure><h4 id="4-组件的封装"><a href="#4-组件的封装" class="headerlink" title="4.组件的封装"></a>4.组件的封装</h4><p>一般可以将头部和 item 都各自抽离为一个组件使用，但是对于这两者合并的 area 也可能是一个可复用的模型，所以也可对其整体进行抽取，再从 App 中传递数据过来，再将此接受的数据向 header 和 item 发出（这两者需要的，此操作就是改个传出数据的名）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">defineProps</span>(&#123;</span><br><span class="line">  <span class="attr">areaData</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="title class_">Object</span>,</span><br><span class="line">    <span class="attr">default</span>: <span class="function">() =&gt;</span> (&#123;&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)  <span class="comment">// 接受数据名称是 areaData  原来是highScore传出，现在需在此组件中将其改正</span></span><br></pre></td></tr></table></figure><h4 id="5-组件中的数据"><a href="#5-组件中的数据" class="headerlink" title="5.组件中的数据"></a>5.组件中的数据</h4><p>对于不利于展示的数据，若是在标签中书写不利于代码阅读，可以使用计算属性</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// const titleText = computed(() =&gt; &#123;</span></span><br><span class="line"><span class="comment">//   return props.itemData.verify_info.messages.join(&quot; &quot;)</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br><span class="line"><span class="comment">// const titleColor = computed(() =&gt; &#123;</span></span><br><span class="line"><span class="comment">//   return props.itemData.verify_info.text_color</span></span><br><span class="line"><span class="comment">// &#125;) </span></span><br><span class="line"><span class="keyword">const</span> titleInfo = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">text</span>: props.<span class="property">itemData</span>.<span class="property">verify_info</span>.<span class="property">messages</span>.<span class="title function_">join</span>(<span class="string">&quot; &quot;</span>),</span><br><span class="line">        <span class="attr">color</span>: props.<span class="property">itemData</span>.<span class="property">verify_info</span>.<span class="property">text_color</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> bottomInfo = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">content</span>: props.<span class="property">itemData</span>.<span class="property">bottom_info</span>.<span class="property">content</span>,</span><br><span class="line">        <span class="attr">style</span>: &#123;</span><br><span class="line">            <span class="attr">color</span>: props.<span class="property">itemData</span>.<span class="property">bottom_info</span>.<span class="property">content_color</span>,</span><br><span class="line">            <span class="attr">fontSize</span>: props.<span class="property">itemData</span>.<span class="property">bottom_info</span>.<span class="property">font_size</span> + <span class="string">&quot;px&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="6-模拟网络请求"><a href="#6-模拟网络请求" class="headerlink" title="6.模拟网络请求"></a>6.模拟网络请求</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 刚开始传入的是空对象，页面会使用默认的数据进行展示</span></span><br><span class="line"><span class="keyword">const</span> highScore = <span class="title function_">ref</span>(&#123;&#125;)</span><br><span class="line"><span class="comment">// 在模拟请求完数据之后，页面会展示数据</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; </span><br><span class="line">  <span class="keyword">import</span>(<span class="string">&quot;./data/high_score.json&quot;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    highScore.<span class="property">value</span> = res.<span class="property">default</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, <span class="number">2000</span>)</span><br></pre></td></tr></table></figure><h2 id="11-Vue全家桶-Vue-Router"><a href="#11-Vue全家桶-Vue-Router" class="headerlink" title="11.Vue全家桶 - Vue-Router"></a>11.Vue全家桶 - Vue-Router</h2><p>Vue 全家桶</p><ul><li>vue 核心语法，又叫 vue core，在此之前学的语法包括 options api 和 composition api</li><li>插件：vue-router，路由管理前端页面切换</li><li>插件：vuex&#x2F;pinia，状态管理</li></ul><h3 id="1、前端路由的发展历程"><a href="#1、前端路由的发展历程" class="headerlink" title="1、前端路由的发展历程"></a>1、前端路由的发展历程</h3><p>路由是网络工程中的一个术语</p><ul><li><p>在架构一个网络时，非常重要的两个设备就是路由器和交换机</p></li><li><p>路由器主要维护的是一个映射表</p></li><li><p>映射表会决定数据的流向</p></li></ul><p>路由的概念在软件工程中出现，最早是在后端路由中实现的，web的发展主要经历</p><ul><li><p>后端路由阶段</p></li><li><p>前后端分离阶段</p></li><li><p>单页面富应用（SPA）</p></li></ul><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230418144437159.png" alt="image-20230418144437159"></p><h4 id="1-后端路由"><a href="#1-后端路由" class="headerlink" title="1.后端路由"></a>1.后端路由</h4><p>早期的网站开发整个HTML页面是由服务器来渲染的</p><ul><li>服务器直接生产渲染好对应的HTML页面, 返回给客户端进行展示</li></ul><p>但是, 一个网站, 这么多页面服务器如何处理呢</p><ul><li><p>一个页面有自己对应的网址, 也就是URL</p></li><li><p>URL会发送到服务器, 服务器会通过正则对该URL进行匹配, 并且最后交给一个Controller进行处理</p></li><li><p>Controller进行各种处理, 最终生成HTML或者数据, 返回给前端</p></li></ul><p>上面的这种操作, 就是后端路由</p><ul><li><p>当我们页面中需要请求不同的路径内容时, 交给服务器来进行处理, 服务器渲染好整个页面, 并且将页面返回给客户端</p></li><li><p>这种情况下渲染好的页面, 不需要单独加载任何的js和css, 可以直接交给浏览器展示, 这样也有利于SEO的优化</p></li></ul><p>后端路由的缺点</p><ul><li><p>一种情况是整个页面的模块由后端人员来编写和维护的</p></li><li><p>另一种情况是前端开发人员如果要开发页面, 需要通过PHP和Java等语言来编写页面代码</p></li><li><p>而且通常情况下HTML代码和数据以及对应的逻辑会混在一起，编写和维护都是非常糟糕的事情</p></li></ul><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230418144837435.png" alt="image-20230418144837435" style="zoom:50%;" /><h4 id="2-前后端分离阶段"><a href="#2-前后端分离阶段" class="headerlink" title="2.前后端分离阶段"></a>2.前后端分离阶段</h4><p>前端渲染的理解</p><ul><li><p>每次请求涉及到的静态资源都会从静态资源服务器获取，这些资源包括HTML+CSS+JS，然后在前端对这些请求回来的资源进行渲染</p></li><li><p>需要注意的是，客户端的每一次请求，都会从静态资源服务器请求文件</p></li><li><p>同时可以看到，和之前的后端路由不同，这时后端只是负责提供API了</p></li></ul><p>前后端分离阶段</p><ul><li><p>随着Ajax的出现, 有了前后端分离的开发模式</p></li><li><p>后端只提供API来返回数据，前端通过Ajax获取数据，并且可以通过JavaScript将数据渲染到页面中</p></li><li><p>这样做最大的优点就是前后端责任的清晰，后端专注于数据上，前端专注于交互和可视化上</p></li><li><p>并且当移动端(iOS&#x2F;Android)出现后，后端不需要进行任何处理，依然使用之前的一套API即可</p></li><li><p>目前比较少的网站采用这种模式开发</p></li></ul><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230418144935784.png" alt="image-20230418144935784" style="zoom:50%;" /><h4 id="3-前端路由"><a href="#3-前端路由" class="headerlink" title="3.前端路由"></a>3.前端路由</h4><p>单页面富应用阶段</p><ul><li><p>其实SPA最主要的特点就是在前后端分离的基础上加了一层前端路由</p></li><li><p>也就是前端来维护一套路由规则</p></li></ul><p>前端路由的核心是：改变URL，但是页面不进行整体的刷新</p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230418145207866.png" alt="image-20230418145207866" style="zoom: 33%;" /><h3 id="2、Vue-Router基本使用"><a href="#2、Vue-Router基本使用" class="headerlink" title="2、Vue-Router基本使用"></a>2、Vue-Router基本使用</h3><h4 id="1-URL-的-hash"><a href="#1-URL-的-hash" class="headerlink" title="1.URL 的 hash"></a>1.URL 的 hash</h4><p>前端路由是如何做到URL和内容进行映射呢？监听URL的改变</p><p>URL的hash</p><ul><li><p>URL的hash也就是锚点(#)，本质上是改变window.location的href属性</p></li><li><p>可以通过直接赋值location.hash来改变href，但是页面不发生刷新</p></li></ul><p>hash的优势就是兼容性更好，在老版IE中都可以运行，但是缺陷是有一个#，显得不像一个真实的路径</p><h4 id="2-HTML5-的-History"><a href="#2-HTML5-的-History" class="headerlink" title="2.HTML5 的 History"></a>2.HTML5 的 History</h4><p>history接口是HTML5新增的, 它有六种模式改变URL而不刷新页面</p><ul><li><p>replaceState：替换原来的路径</p></li><li><p>pushState：使用新的路径</p></li><li><p>popState：路径的回退</p></li><li><p>go：向前或向后改变路径</p></li><li><p>forward：向前改变路径</p></li><li><p>back：向后改变路径</p></li></ul><h4 id="3-认识-vue-router"><a href="#3-认识-vue-router" class="headerlink" title="3.认识 vue-router"></a>3.认识 vue-router</h4><p>目前前端流行的三大框架, 都有自己的路由实现</p><p>Angular 的 ngRouter、React 的 ReactRouter、Vue 的 vue-router</p><p>Vue Router 是 Vue.js 的官方路由</p><ul><li>它与 Vue.js 核心深度集成，让用 Vue.js 构建单页应用（SPA）变得非常容易</li></ul><p>vue-router 是基于路由和组件的</p><ul><li><p>路由用于设定访问路径, 将路径和组件映射起来</p></li><li><p>在 vue-router 的单页面应用中, 页面的路径的改变就是组件的切换</p></li></ul><p>安装 Vue Router：npm install vue-router</p><h4 id="4-使用步骤"><a href="#4-使用步骤" class="headerlink" title="4.使用步骤"></a>4.使用步骤</h4><p>使用 vue-router 的步骤</p><ul><li><p>第一步：创建路由需要映射的组件（打算显示的页面）</p></li><li><p>第二步：通过 createRouter 创建路由对象，并且传入 routes 和 history 模式</p><ul><li>配置路由映射：组件和路径映射关系的 routes 数组</li><li>创建基于 hash 或者 history 的模式</li></ul></li><li><p>第三步：使用 app 注册路由对象（use方法）</p></li><li><p>第四步：路由使用: 通过和<code>&lt;router-link&gt;</code>和<code>&lt;router-view&gt;</code></p></li></ul><p>详解：</p><p>1.创建路由对象（创建对应的 js 文件，引入 router 相关）</p><ul><li>routers：映射关系</li><li>history：修改 url 的模式（hash&#x2F;history）</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createRouter, createWebHashHistory, createWebHistory &#125; <span class="keyword">from</span> <span class="string">&quot;vue-router&quot;</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;</span><br><span class="line">  <span class="attr">history</span>: <span class="title function_">createWebHistory</span>(),</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&quot;/home&quot;</span>, <span class="attr">component</span>: <span class="title class_">Home</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&quot;/about&quot;</span>, <span class="attr">component</span>: <span class="title class_">About</span> &#125;,  ]</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure><p>2.让路由对象生效</p><ul><li>app.use(router)</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&quot;./router/index.js&quot;</span></span><br><span class="line">app.<span class="title function_">use</span>(router)</span><br></pre></td></tr></table></figure><p>3.router-view 占位</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;router-view&gt;&lt;/router-view&gt;</span><br></pre></td></tr></table></figure><p>4.router-link 进行路由的切换</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;router-link to=<span class="string">&quot;/home&quot;</span> replace active-<span class="keyword">class</span>=<span class="string">&quot;active&quot;</span>&gt;首页&lt;/router-link&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">&quot;&#123; path: &#x27;/about&#x27; &#125;&quot;</span> <span class="attr">replace</span> <span class="attr">active-class</span>=<span class="string">&quot;active&quot;</span>&gt;</span>关于<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230418151220193.png" alt="image-20230418151220193"></p><h4 id="5-路由的默认路径"><a href="#5-路由的默认路径" class="headerlink" title="5.路由的默认路径"></a>5.路由的默认路径</h4><p>默认情况下, 进入网站的首页, 希望渲染首页的内容</p><ul><li>但是在实现中, 默认没有显示首页组件, 必须让用户点击才可以</li></ul><p>routes中又配置了一个映射：</p><ul><li><p>path配置的是根路径: &#x2F;</p></li><li><p>redirect是重定向, 也就是我们将根路径重定向到&#x2F;home的路径下</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认路径</span></span><br><span class="line"><span class="comment">// &#123; path: &quot;/&quot;, component: Home&#125;,</span></span><br><span class="line">&#123; <span class="attr">path</span>: <span class="string">&quot;/&quot;</span>, <span class="attr">redirect</span>: <span class="string">&quot;/home&quot;</span> &#125;,</span><br></pre></td></tr></table></figure><h4 id="6-history-模式"><a href="#6-history-模式" class="headerlink" title="6.history 模式"></a>6.history 模式</h4><p>见上方代码块</p><h4 id="7-router-link"><a href="#7-router-link" class="headerlink" title="7.router-link"></a>7.router-link</h4><p>router-link事实上有很多属性可以配置</p><ul><li><p>to属性：是一个字符串，或者是一个对象</p></li><li><p>replace属性：设置 replace 属性的话，当点击时，会调用 router.replace()，而不是 router.push()，就是浏览器没有了缓存，返回上一级直接到了浏览器主页面</p></li><li><p>active-class属性：设置激活a元素后应用的class，默认是router-link-active</p><ul><li>可以对该值进行自定义命名：active-class&#x3D;”active”</li></ul></li><li><p>exact-active-class属性：链接精准激活时，应用于渲染的 <code>&lt;a&gt;</code>  的 class，默认是router-link-exact-active</p></li></ul><h3 id="3、路由懒加载分包处理"><a href="#3、路由懒加载分包处理" class="headerlink" title="3、路由懒加载分包处理"></a>3、路由懒加载分包处理</h3><p>当打包构建应用时，JavaScript 包会变得非常大，影响页面加载</p><ul><li><p>如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就会更加高效</p></li><li><p>也可以提高首屏的渲染效率</p></li></ul><p>通过 webpack 的分包知识，而 Vue Router 默认就支持动态来导入组件</p><ul><li><p>这是因为 component 可以传入一个组件，也可以接收一个函数，该函数需要返回一个Promise</p></li><li><p>而 import 函数就是返回一个 Promise</p></li></ul><p>在引入组件时</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 分包</span></span><br><span class="line"><span class="comment">// 路由的懒加载</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Home</span> = (<span class="params"></span>) =&gt; <span class="keyword">import</span>(<span class="string">&quot;../views/Home.vue&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">About</span> = (<span class="params"></span>) =&gt; <span class="keyword">import</span>(<span class="string">&quot;../views/About.vue&quot;</span>)</span><br></pre></td></tr></table></figure><p>也可以在使用组件时</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123; <span class="attr">path</span>: <span class="string">&quot;/home&quot;</span>, <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&quot;../views/Home.vue&quot;</span>)&#125;,</span><br></pre></td></tr></table></figure><p>打包效果分析</p><p>按以上方发进行引入组件可以实现分包，但是不能很直观的看出那一个包对应是那一个组件打包的</p><p>可以使用魔法注释来进行命名</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Home</span> = (<span class="params"></span>) =&gt; <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: &#x27;home&#x27; */</span><span class="string">&quot;../views/Home.vue&quot;</span>)</span><br></pre></td></tr></table></figure><p>路由的其他属性</p><ul><li><p>name属性：路由记录独一无二的名称</p></li><li><p>meta属性：自定义的数据</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">name</span>: <span class="string">&quot;home&quot;</span>,</span><br><span class="line">   <span class="attr">path</span>: <span class="string">&quot;/home&quot;</span>,</span><br><span class="line">   <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&quot;../views/Home.vue&quot;</span>),</span><br><span class="line">   <span class="attr">meta</span>: &#123;</span><br><span class="line">     <span class="attr">name</span>: <span class="string">&quot;why&quot;</span>,</span><br><span class="line">     <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h3 id="4、动态路由和路由嵌套"><a href="#4、动态路由和路由嵌套" class="headerlink" title="4、动态路由和路由嵌套"></a>4、动态路由和路由嵌套</h3><h4 id="1-路由动态的基本匹配"><a href="#1-路由动态的基本匹配" class="headerlink" title="1.路由动态的基本匹配"></a>1.路由动态的基本匹配</h4><p>很多时候需要将给定匹配模式的路由映射到同一个组件</p><ul><li><p>可能有一个 User 组件，它应该对所有用户进行渲染，但是用户的ID是不同的</p></li><li><p>在Vue Router中可以在路径中使用一个动态字段来实现，称之为路径参数</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 动态路由</span></span><br><span class="line"><span class="attr">path</span>: <span class="string">&quot;/user/:id&quot;</span>,</span><br><span class="line"><span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&quot;../views/User.vue&quot;</span>),</span><br></pre></td></tr></table></figure><p>在router-link中进行如下跳转：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;router-link to=<span class="string">&quot;/user/123&quot;</span>&gt;用户<span class="number">123</span>&lt;/router-link&gt;</span><br></pre></td></tr></table></figure><h4 id="2-获取动态路由的值"><a href="#2-获取动态路由的值" class="headerlink" title="2.获取动态路由的值"></a>2.获取动态路由的值</h4><p>在User中如何获取到对应的值</p><ul><li>在template中，直接通过 $route.params获取值</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- 在模板中获取id --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>user: &#123;&#123; $route.params.id &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br></pre></td></tr></table></figure><ul><li><p>在 created 中，通过 this.$route.params获取值</p></li><li><p>在setup中，我们要使用 vue-router库给我们提供的一个hook useRoute</p><ul><li>该 Hook 会返回一个Route对象，对象中保存着当前路由相关的值</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useRoute, onBeforeRouteUpdate &#125; <span class="keyword">from</span> <span class="string">&quot;vue-router&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 route 跳转 id</span></span><br><span class="line"><span class="keyword">const</span> route = <span class="title function_">useRoute</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;代码中拿到: &quot;</span>,route.<span class="property">params</span>.<span class="property">id</span>)</span><br><span class="line"><span class="title function_">onBeforeRouteUpdate</span>(<span class="function">(<span class="params">to, <span class="keyword">from</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;from &quot;</span>,<span class="keyword">from</span>.<span class="property">params</span>.<span class="property">id</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;to &quot;</span>,to.<span class="property">params</span>.<span class="property">id</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="3-NotFound"><a href="#3-NotFound" class="headerlink" title="3.NotFound"></a>3.NotFound</h4><p>对于哪些没有匹配到的路由，通常会匹配到固定的某个页面</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 如果匹配到任何一个不存在的路径，那么显示下面这个组件</span></span><br><span class="line">   <span class="attr">path</span>: <span class="string">&quot;/:pathMatch(.*)&quot;</span>,</span><br><span class="line">   <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&quot;../views/NotFound.vue&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以通过 $route.params.pathMatch 获取到传入的参数</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>NotFund: 您当前的路径&#123;&#123; $route.params.pathMatch &#125;&#125;不正确，请输入正确的路径<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>匹配规则加 *</p><p>在 &#x2F;:pathMatch(.*) 后面又加了一个 *</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">path</span>: <span class="string">&quot;/:pathMatch(.*)*&quot;</span></span><br></pre></td></tr></table></figure><p>区别：</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230418183914097.png" alt="image-20230418183914097"></p><h4 id="4-路由的嵌套"><a href="#4-路由的嵌套" class="headerlink" title="4.路由的嵌套"></a>4.路由的嵌套</h4><p>目前匹配的Home、About、User等都属于第一层路由，在它们之间可以来回进行切换</p><p>但是 Home 页面本身，也可能会在多个组件之间来回切换</p><ul><li><p>比如Home中包括Product、Message，它们可以在Home内部来回切换</p></li><li><p>这时就需要使用嵌套路由，在Home中也使用 router-view 来占位之后需要渲染的组件</p></li></ul><p>配置：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">children</span>: [</span><br><span class="line">  &#123;</span><br><span class="line">     <span class="attr">path</span>: <span class="string">&quot;/home&quot;</span>,</span><br><span class="line">     <span class="attr">redirect</span>: <span class="string">&quot;/home/recommend&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">     <span class="attr">path</span>: <span class="string">&quot;recommend&quot;</span>,  <span class="comment">//  /home/recommend</span></span><br><span class="line">     <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&quot;../views/HomeRecommend.vue&quot;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">     <span class="attr">path</span>: <span class="string">&quot;ranking&quot;</span>,  <span class="comment">//  /home/recommend</span></span><br><span class="line">     <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&quot;../views/HomeRanking.vue&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="5、路由的编程式导航"><a href="#5、路由的编程式导航" class="headerlink" title="5、路由的编程式导航"></a>5、路由的编程式导航</h3><h4 id="1-代码的页面跳转"><a href="#1-代码的页面跳转" class="headerlink" title="1.代码的页面跳转"></a>1.代码的页面跳转</h4><p>有时希望通过代码来完成页面的跳转，比如点击的是一个按钮</p><p>如果是在setup中编写的代码，可以通过 useRouter 来获取</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useRouter &#125; <span class="keyword">from</span> <span class="string">&quot;vue-router&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">useRouter</span>()</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">homeSpanClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">  router.<span class="title function_">push</span>(<span class="string">&quot;/home&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以传入一个对象</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">router.<span class="title function_">push</span>(&#123;</span><br><span class="line">    <span class="comment">// 使用 name 跳转的话不会做重定向</span></span><br><span class="line">    <span class="comment">// name: &quot;home&quot;,</span></span><br><span class="line">    <span class="attr">path</span>: <span class="string">&quot;/home&quot;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>methods的方法：</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230418185902226.png" alt="image-20230418185902226"></p><h4 id="2-query-方式的参数"><a href="#2-query-方式的参数" class="headerlink" title="2.query 方式的参数"></a>2.query 方式的参数</h4><p>可以通过query的方式来传递参数</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">router.<span class="title function_">push</span>(&#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&quot;/about&quot;</span>,</span><br><span class="line">    <span class="attr">query</span>: &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;whs&#x27;</span>,</span><br><span class="line">        <span class="attr">age</span>: <span class="number">25</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在 about 获取到 query 传的值</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;h2&gt;<span class="title class_">About</span>: &#123;&#123; $route.<span class="property">query</span> &#125;&#125;&lt;/h2&gt;</span><br></pre></td></tr></table></figure><h4 id="3-替换当前位置"><a href="#3-替换当前位置" class="headerlink" title="3.替换当前位置"></a>3.替换当前位置</h4><p>使用push的特点是压入一个新的页面，那么在用户点击返回时，上一个页面还可以回退，但是如果希望当前页面是一个替换操作，那么可以使用replace</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230418190206654.png" alt="image-20230418190206654"></p><h4 id="4-页面的前进后退"><a href="#4-页面的前进后退" class="headerlink" title="4.页面的前进后退"></a>4.页面的前进后退</h4><p>router 的 go 方法</p><p>router 也有 back</p><ul><li>通过调用 history.back() 回溯历史。相当于 router.go(-1)</li></ul><p>router 也有 forward</p><ul><li>通过调用 history.forward() 在历史中前进。相当于 router.go(1)</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useRouter &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">useRouter</span>()</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">backClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// router.back()</span></span><br><span class="line">  <span class="comment">// router.forward()</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// go(delta)</span></span><br><span class="line">  <span class="comment">// go(1) -&gt; forward()</span></span><br><span class="line">  <span class="comment">// go(-1) -&gt; back()</span></span><br><span class="line">  router.<span class="title function_">go</span>(-<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6、动态管理路由对象"><a href="#6、动态管理路由对象" class="headerlink" title="6、动态管理路由对象"></a>6、动态管理路由对象</h3><p>了解开发中的各种类别，数据来源与存放</p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230419155042718.png" alt="image-20230419155042718" style="zoom: 33%;" /><p>了解后台管理系统，对于不同的角色，能够使用系统中不同的功能</p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230419154915206.png" alt="image-20230419154915206" style="zoom: 67%;" /><h4 id="1-动态添加路由"><a href="#1-动态添加路由" class="headerlink" title="1.动态添加路由"></a>1.动态添加路由</h4><p>某些情况下可能需要动态的来添加路由</p><ul><li><p>比如根据用户不同的权限，注册不同的路由</p></li><li><p>可以使用一个方法 addRoute</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> isAdmin = <span class="literal">false</span>  <span class="comment">// 写死的</span></span><br><span class="line"><span class="keyword">if</span> (isAdmin) &#123;</span><br><span class="line">  <span class="comment">// 一级路由</span></span><br><span class="line">  router.<span class="title function_">addRoute</span>(&#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&quot;/admin&quot;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&quot;../views/Admin.vue&quot;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是为 route 添加一个 children 路由（二级路由），那么可以传入对应的 name</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">router.<span class="title function_">addRoute</span>(<span class="string">&quot;home&quot;</span>,&#123;</span><br><span class="line">  <span class="attr">path</span>: <span class="string">&quot;vip&quot;</span>,</span><br><span class="line">  <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&quot;../views/HomeSongs.vue&quot;</span>) </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="2-动态添加路由的其他方法"><a href="#2-动态添加路由的其他方法" class="headerlink" title="2.动态添加路由的其他方法"></a>2.动态添加路由的其他方法</h4><p>删除路由有以下三种方式</p><ul><li><p>方式一：添加一个 name 相同的路由（name 是唯一的，原理是覆盖上一个 name）</p></li><li><p>方式二：通过 removeRoute 方法，传入路由的名称</p></li><li><p>方式三：通过 addRoute 方法的返回值回调</p></li></ul><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230419160915567.png" alt="image-20230419160915567"></p><p>其他方法</p><ul><li>router.hasRoute()：检查路由是否存在</li><li>router.getRoutes()：获取一个包含所有路由记录的数组</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取router所有的映射路由对象</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(router.<span class="title function_">getRoutes</span>())</span><br></pre></td></tr></table></figure><h3 id="7、路由导航守卫钩子"><a href="#7、路由导航守卫钩子" class="headerlink" title="7、路由导航守卫钩子"></a>7、路由导航守卫钩子</h3><h4 id="1-基本使用-2"><a href="#1-基本使用-2" class="headerlink" title="1.基本使用"></a>1.基本使用</h4><p>在进入到某些页面时可能需要判断用户是否登录，如果没有登录则需要跳转到登录界面登录之后，才能进入到该页面</p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230419161510368.png" alt="image-20230419161510368" style="zoom: 67%;" /><p>vue-router 提供的导航守卫主要用来通过跳转或取消的方式守卫导航</p><p>全局的前置守卫 beforeEach 是在导航触发时会被回调的：</p><p>它有两个参数</p><ul><li><p>to：即将进入的路由Route对象</p></li><li><p>from：即将离开的路由Route对象</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 路由导航守卫</span></span><br><span class="line"><span class="comment">// 在进行任何的路由跳转之前，传入到beforeEach中的函数都会被回调</span></span><br><span class="line">router.<span class="title function_">beforeEach</span>(<span class="function">(<span class="params">to, <span class="keyword">from</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 1.进入到任何界面是都跳转到login页面</span></span><br><span class="line">  <span class="keyword">if</span> ( to.<span class="property">path</span> !== <span class="string">&quot;/login&quot;</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;/login&quot;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>它有返回值</p><ul><li>false：取消当前导航</li><li>不返回或者undefined：进行默认导航</li><li>返回一个路由地址<ul><li>可以是一个string类型的路径</li><li>可以是一个对象，对象中包含path、query、params等信息</li></ul></li></ul><p>可选的第三个参数：next（不推荐使用）</p><ul><li><p>在 Vue2 中是通过next函数来决定如何进行跳转的</p></li><li><p>但是在 Vue3 中是通过返回值来控制的，不再推荐使用 next 函数，这是因为开发中很容易调用多次 next</p></li></ul><h4 id="2-登录守卫功能"><a href="#2-登录守卫功能" class="headerlink" title="2.登录守卫功能"></a>2.登录守卫功能</h4><p>按需求：进入订单页面时进行判断登录</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 需求：进入到订单页面时，判断用是否登录（isLogin -&gt; LocalStorage保存token）</span></span><br><span class="line"><span class="comment">// 情况一：用户没有登录，那么跳转到登录页面，进行登录操作</span></span><br><span class="line"><span class="comment">// 情况二：用户已经登录，那么直接进入到订单页面</span></span><br><span class="line">router.<span class="title function_">beforeEach</span>(<span class="function">(<span class="params">to, <span class="keyword">from</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 2.进入到订单页面，判断是否登录</span></span><br><span class="line">  <span class="keyword">const</span> token = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&quot;token&quot;</span>)</span><br><span class="line">  <span class="keyword">if</span>(to.<span class="property">path</span> === <span class="string">&quot;/order&quot;</span> &amp;&amp; !token) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;/login&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>模拟在 login 登录之后进行跳转</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">loginClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// console.log(&quot;点击了登录操作&quot;)</span></span><br><span class="line">  <span class="comment">// 向服务器发送请求，服务器返回token</span></span><br><span class="line">  <span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&quot;token&quot;</span>, <span class="string">&quot;coderwhy&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 跳转到order页面</span></span><br><span class="line">  router.<span class="title function_">push</span>(<span class="string">&quot;/order&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模拟在别的页面退出登录（删除 token），测试登录功能</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">logoutClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">localStorage</span>.<span class="title function_">removeItem</span>(<span class="string">&quot;token&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-其他导航守卫"><a href="#3-其他导航守卫" class="headerlink" title="3.其他导航守卫"></a>3.其他导航守卫</h4><p>Vue-Router 还提供了很多的其他守卫函数，目的都是在某一个时刻给予我们回调，让我们可以更好的控制程序的流程或者功能</p><ul><li><a href="https://next.router.vuejs.org/zh/guide/advanced/navigation-guards.html">https://next.router.vuejs.org/zh/guide/advanced/navigation-guards.html</a></li></ul><p>完整的导航解析流程：</p><ul><li><p>导航被触发</p></li><li><p>在失活的组件里调用 beforeRouteLeave 守卫</p></li><li><p>调用全局的 beforeEach 守卫</p></li><li><p>在重用的组件里调用 beforeRouteUpdate 守卫(2.2+)</p></li><li><p>在路由配置里调用 beforeEnter</p></li><li><p>解析异步路由组件</p></li><li><p>在被激活的组件里调用 beforeRouteEnter</p></li><li><p>调用全局的 beforeResolve 守卫(2.5+)</p></li><li><p>导航被确认</p></li><li><p>调用全局的 afterEach 钩子</p></li><li><p>触发 DOM 更新</p></li><li><p>调用 beforeRouteEnter 守卫中传给 next 的回调函数，创建好的组件实例会作为回调函数的参数传入</p></li></ul><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230419163238823.png" alt="image-20230419163238823" style="zoom: 67%;" /><h2 id="12-Vue全家桶-Vuex状态管理"><a href="#12-Vue全家桶-Vuex状态管理" class="headerlink" title="12.Vue全家桶 - Vuex状态管理"></a>12.Vue全家桶 - Vuex状态管理</h2><h3 id="1、认识应用状态管理"><a href="#1、认识应用状态管理" class="headerlink" title="1、认识应用状态管理"></a>1、认识应用状态管理</h3><h4 id="1-什么是状态管理"><a href="#1-什么是状态管理" class="headerlink" title="1.什么是状态管理"></a>1.什么是状态管理</h4><p>在开发中，应用程序需要处理各种各样的数据，这些数据需要保存在应用程序中的某一个位置，对于这些数据的管理我们就称之为是状态管理</p><p>在前面的如何管理自己的状态方式</p><ul><li><p>在Vue开发中，使用组件化的开发方式</p></li><li><p>而在组件中定义 data 或者在 setup 中返回使用的数据，这些数据我们称之为 state</p></li><li><p>在模块 template 中可以使用这些数据，模块最终会被渲染成 DOM，称之为View</p></li><li><p>在模块中会产生一些行为事件，处理这些行为事件时，有可能会修改 state，这些行为事件称之为 actions</p></li></ul><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230419163423469.png" alt="image-20230419163423469" style="zoom:50%;" /><h4 id="2-复杂的状态管理"><a href="#2-复杂的状态管理" class="headerlink" title="2.复杂的状态管理"></a>2.复杂的状态管理</h4><p>JavaScript 开发的应用程序，已经变得越来越复杂</p><ul><li><p>JavaScript需要管理的状态越来越多，越来越复杂</p></li><li><p>这些状态包括服务器返回的数据、缓存数据、用户操作产生的数据等等</p></li><li><p>也包括一些UI的状态，比如某些元素是否被选中，是否显示加载动效，当前分页</p></li></ul><p>当应用遇到多个组件共享状态时，单向数据流的简洁性很容易被破坏</p><ul><li><p>多个视图依赖于同一状态</p></li><li><p>来自不同视图的行为需要变更同一状态</p></li></ul><p>是否可以通过组件数据的传递来完成</p><ul><li><p>对于一些简单的状态，可以通过props的传递或者Provide的方式来共享状态</p></li><li><p>但是对于复杂的状态管理来说，单纯通过传递和共享的方式是不足以解决问题的，比如兄弟组件共享数据</p></li></ul><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230419164257028.png" alt="image-20230419164257028" style="zoom: 33%;" /><h4 id="3-Vuex-的状态管理"><a href="#3-Vuex-的状态管理" class="headerlink" title="3.Vuex 的状态管理"></a>3.Vuex 的状态管理</h4><p>管理不断变化的state本身是非常困难的</p><ul><li>状态之间相互会存在依赖，一个状态的变化会引起另一个状态的变化，View页面也有可能会引起状态的变化</li><li>当应用程序复杂时，state在什么时候，因为什么原因而发生了变化，发生了怎么样的变化，会变得非常难以控制和追踪</li></ul><p>因此，需要考虑将组件的内部状态抽离出来，以一个全局单例的方式来管理</p><ul><li><p>在这种模式下，我们的组件树构成了一个巨大的 “试图View”</p></li><li><p>不管在树的哪个位置，任何组件都能获取状态或者触发行为</p></li><li><p>通过定义和隔离状态管理中的各个概念，并通过强制性的规则来维护视图和状态间的独立性，我们的代码边会变得更加结构化和易于维护、跟踪</p></li></ul><p>这就是Vuex背后的基本思想，它借鉴了Flux、Redux、Elm（纯函数语言，redux有借鉴它的思想）</p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230419164051648.png" alt="image-20230419164051648" style="zoom:67%;" /><h3 id="2、Vuex-的基本使用"><a href="#2、Vuex-的基本使用" class="headerlink" title="2、Vuex 的基本使用"></a>2、Vuex 的基本使用</h3><p>安装：npm install vuex</p><h4 id="1-创建-store"><a href="#1-创建-store" class="headerlink" title="1.创建 store"></a>1.创建 store</h4><p>每一个Vuex应用的核心就是store（仓库）</p><ul><li>store本质上是一个容器，它包含着你的应用中大部分的状态（state）</li></ul><p>Vuex和单纯的全局对象有什么区别</p><ul><li><p>第一：Vuex 的状态存储是响应式的</p><ul><li>当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会被更新</li></ul></li><li><p>第二：不能直接改变 store 中的状态</p><ul><li>改变 store 中的状态的唯一途径就显示提交 (commit) mutation</li><li>这样可以方便的跟踪每一个状态的变化，从而能够通过一些工具帮助更好的管理应用的状态</li></ul></li></ul><h4 id="2-基本使用-1"><a href="#2-基本使用-1" class="headerlink" title="2.基本使用"></a>2.基本使用</h4><p>使用步骤</p><ul><li>创建Store对象</li><li>在app中通过插件安装</li></ul><p>组件中使用 store</p><ul><li>在模板中使用</li><li>在options api中使用，比如computed</li><li>在setup中使用</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">创建store文件夹，写入 js 文件</span><br><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">&quot;vuex&quot;</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="title function_">createStore</span>(&#123;</span><br><span class="line">  <span class="comment">// state() &#123;</span></span><br><span class="line">  <span class="comment">//   return &#123;</span></span><br><span class="line">  <span class="comment">//   &#125;</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">    <span class="attr">state</span>: <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">        <span class="attr">counter</span>: <span class="number">100</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br><span class="line">                          </span><br><span class="line">在 main.<span class="property">js</span>中导入并使用：</span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&quot;./store&quot;</span>;</span><br><span class="line"><span class="title function_">createApp</span>(<span class="title class_">App</span>).<span class="title function_">use</span>(store).<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span><br><span class="line"></span><br><span class="line">在 template 中访问</span><br><span class="line">&lt;h2&gt;<span class="title class_">Home</span>页面计数：&#123;&#123; $store.<span class="property">state</span>.<span class="property">counter</span> &#125;&#125;&lt;/h2&gt;</span><br><span class="line"></span><br><span class="line">在 setup 中测试响应式</span><br><span class="line"><span class="keyword">import</span> &#123; useStore &#125; <span class="keyword">from</span> <span class="string">&quot;vuex&quot;</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="title function_">useStore</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">increment</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 也能修改，但是官发不建议并且说明了改变store的值的唯一方式是通过mutations</span></span><br><span class="line">  <span class="comment">// store.state.counter++</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 通过mutations  能够实时追踪更新 counter，不需要手动刷新，会自动刷新</span></span><br><span class="line">  store.<span class="title function_">commit</span>(<span class="string">&quot;increment&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// store 中的 mutations</span></span><br><span class="line"><span class="attr">mutations</span>: &#123;</span><br><span class="line">    <span class="title function_">increment</span>(<span class="params">state</span>) &#123;</span><br><span class="line">        state.<span class="property">counter</span>++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 options api 中使用</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">computed</span>: &#123;</span><br><span class="line">    <span class="title function_">storeCounter</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="property">state</span>.<span class="property">counter</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 setup 中使用注意</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> setupCounter = store.<span class="property">state</span>.<span class="property">counter</span>  <span class="comment">// 丢失响应式</span></span><br><span class="line"><span class="keyword">const</span> &#123; counter&#125;  = <span class="title function_">toRefs</span>(store.<span class="property">state</span>)  <span class="comment">// 不加 refs 也会丢失响应式</span></span><br></pre></td></tr></table></figure><h3 id="3、核心概念-State"><a href="#3、核心概念-State" class="headerlink" title="3、核心概念 State"></a>3、核心概念 State</h3><h4 id="1-单一状态树"><a href="#1-单一状态树" class="headerlink" title="1.单一状态树"></a>1.单一状态树</h4><p>Vuex 使用单一状态树</p><ul><li>用一个对象就包含了全部的应用层级的状态</li><li>采用的是SSOT，Single Source of Truth，也可以翻译成单一数据源</li></ul><p>这也意味着，每个应用将仅仅包含一个 store 实例</p><ul><li>单状态树和模块化并不冲突</li></ul><p>单一状态树的优势：</p><ul><li>如果你的状态信息是保存到多个Store对象中的，那么之后的管理和维护等等都会变得特别困难</li><li>所以Vuex也使用了单一状态树来管理应用层级的全部状态</li><li>单一状态树能够让我们最直接的方式找到某个状态的片段</li><li>而且在之后的维护和调试过程中，也可以非常方便的管理和维护</li></ul><h4 id="2-组件获取状态"><a href="#2-组件获取状态" class="headerlink" title="2.组件获取状态"></a>2.组件获取状态</h4><p>在前面已经学习过如何在组件中获取状态</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- <span class="number">1.</span>在模板中直接使用多个状态 --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>name: &#123;&#123; $store.state.name &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>level: &#123;&#123; $store.state.level &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span>  ... </span><br></pre></td></tr></table></figure><p>如果觉得有点繁琐（表达式过长），可以使用计算属性（opition api）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">    <span class="title function_">name</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="property">state</span>.<span class="property">name</span></span><br><span class="line">    &#125;,   <span class="comment">// 也是写多遍，还是繁琐</span></span><br></pre></td></tr></table></figure><p>但是，如果有很多个状态都需要获取，可以使用mapState的辅助函数</p><ul><li><p>mapState的方式一：数组类型</p></li><li><p>mapState的方式二：对象类型</p></li><li><p>也可以使用展开运算符和来原有的 computed 混合在一起</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- 计算属性（映射状态：数组写法） --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>name: &#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>level: &#123;&#123;level&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">&lt;!-- 计算属性（映射状态：对象写法） --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>name: &#123;&#123;sName&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>level: &#123;&#123;sLevel&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span> --&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; mapState &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">    <span class="comment">// 数组写法，可能会出现名称冲突</span></span><br><span class="line">    ...<span class="title function_">mapState</span>([<span class="string">&quot;counter&quot;</span>, <span class="string">&quot;level&quot;</span>, <span class="string">&quot;name&quot;</span>]),</span><br><span class="line">    <span class="comment">// 对象写法</span></span><br><span class="line">    ...<span class="title function_">mapState</span>(&#123;</span><br><span class="line">      <span class="attr">sName</span>: <span class="function"><span class="params">state</span> =&gt;</span> state.<span class="property">name</span>,</span><br><span class="line">      <span class="attr">sLevel</span>: <span class="function"><span class="params">state</span> =&gt;</span> state.<span class="property">level</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-在-setup-中使用-mapState"><a href="#3-在-setup-中使用-mapState" class="headerlink" title="3.在 setup 中使用 mapState"></a>3.在 setup 中使用 mapState</h4><p>在 setup 中如果单个获取装是非常简单的：通过useStore拿到store后去获取某个状态即可</p><p>但是如果需要使用 mapState 的功能</p><ul><li>默认情况下，Vuex并没有提供非常方便的使用mapState的方式，可以进行了一个函数的封装</li></ul><p>方法1：拿到函数，绑定 this</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; computed &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span></span><br><span class="line"><span class="keyword">import</span> &#123; mapState, useStore &#125; <span class="keyword">from</span> <span class="string">&quot;vuex&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法1.一步步完成</span></span><br><span class="line"><span class="keyword">const</span> &#123; name, level &#125; = <span class="title function_">mapState</span>([<span class="string">&quot;name&quot;</span>, <span class="string">&quot;level&quot;</span>])</span><br><span class="line"><span class="keyword">const</span> store = <span class="title function_">useStore</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cName = <span class="title function_">computed</span>(name.<span class="title function_">bind</span>(&#123; <span class="attr">$store</span>: store &#125;))</span><br><span class="line"><span class="keyword">const</span> cLevel = <span class="title function_">computed</span>(level.<span class="title function_">bind</span>(&#123; <span class="attr">$store</span>: store &#125;))</span><br></pre></td></tr></table></figure><p>方法2：封装函数</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> useState <span class="keyword">from</span> <span class="string">&quot;../hooks/useState&quot;</span></span><br><span class="line"><span class="keyword">const</span> &#123; name, level&#125; = <span class="title function_">useState</span>([<span class="string">&quot;name&quot;</span>, <span class="string">&quot;level&quot;</span>])</span><br></pre></td></tr></table></figure><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230419172451987.png" alt="image-20230419172451987" style="zoom: 67%;" /><p>对象写法：</p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230419173013463.png" alt="image-20230419173013463" style="zoom:67%;" /><p>方法3：解构再添加响应式</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 直接对store.state进行结构</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="title function_">useStore</span>()</span><br><span class="line"><span class="comment">// 可以起别名，防止重名</span></span><br><span class="line"><span class="keyword">const</span> &#123; name, level&#125; = <span class="title function_">toRefs</span>(store.<span class="property">state</span>)</span><br></pre></td></tr></table></figure><h3 id="4、核心概念-Getters"><a href="#4、核心概念-Getters" class="headerlink" title="4、核心概念 Getters"></a>4、核心概念 Getters</h3><h4 id="1-基本使用-3"><a href="#1-基本使用-3" class="headerlink" title="1.基本使用"></a>1.基本使用</h4><p>某些属性可能需要经过变化后来使用，这个时候可以使用getters</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">getters</span>: &#123;</span><br><span class="line">    <span class="title function_">doubleCounter</span>(<span class="params">state</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> state.<span class="property">counter</span> * <span class="number">2</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>在组件中获取</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;h2&gt;<span class="attr">doublecounter</span>: &#123;&#123; $store.<span class="property">getters</span>.<span class="property">doubleCounter</span> &#125;&#125;&lt;/h2&gt;</span><br></pre></td></tr></table></figure><p>稍微复杂一点的数据</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">users</span>: [</span><br><span class="line">    &#123;<span class="attr">id</span>:<span class="number">111</span>, <span class="attr">name</span>: <span class="string">&#x27;whd&#x27;</span>, <span class="attr">age</span>: <span class="number">23</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">id</span>:<span class="number">112</span>, <span class="attr">name</span>: <span class="string">&#x27;wh&#x27;</span>, <span class="attr">age</span>: <span class="number">21</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">id</span>:<span class="number">113</span>, <span class="attr">name</span>: <span class="string">&#x27;wd&#x27;</span>, <span class="attr">age</span>: <span class="number">13</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">id</span>:<span class="number">114</span>, <span class="attr">name</span>: <span class="string">&#x27;wds&#x27;</span>, <span class="attr">age</span>: <span class="number">22</span>&#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="title function_">totalAge</span>(<span class="params">state</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> state.<span class="property">users</span>.<span class="title function_">reduce</span>(<span class="function">(<span class="params">preValue,item</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> preValue + item.<span class="property">age</span></span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;,</span><br><span class="line">    </span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>usersTotalAge: &#123;&#123; $store.getters.totalAge &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h4 id="2-getters-第二个参数"><a href="#2-getters-第二个参数" class="headerlink" title="2.getters 第二个参数"></a>2.getters 第二个参数</h4><p>getters 可以接收第二个参数</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在该getters属性中，获取其他的getters</span></span><br><span class="line"><span class="title function_">message</span>(<span class="params">state, getters</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`name:<span class="subst">$&#123;state.name&#125;</span> level:<span class="subst">$&#123;state.level&#125;</span> friendAge: <span class="subst">$&#123;getters.totalAge&#125;</span>`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;h2&gt;<span class="attr">message</span>: &#123;&#123; $store.<span class="property">getters</span>.<span class="property">message</span> &#125;&#125;&lt;/h2&gt;</span><br></pre></td></tr></table></figure><h4 id="3-getter-的返回函数"><a href="#3-getter-的返回函数" class="headerlink" title="3.getter 的返回函数"></a>3.getter 的返回函数</h4><p>getters中的函数本身，可以返回一个函数，那么在使用的地方相当于可以调用这个函数</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- 根据id获取某一个用户的信息 --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>获取id为111的信息: &#123;&#123; $store.getters.getUserById(111)&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="title function_">getUserById</span>(<span class="params">state</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">id</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> user = state.<span class="property">users</span>.<span class="title function_">find</span>(<span class="function"><span class="params">item</span> =&gt;</span> item.<span class="property">id</span> === id)</span><br><span class="line">        <span class="keyword">return</span> user</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-mapGetters-的辅助函数"><a href="#4-mapGetters-的辅助函数" class="headerlink" title="4.mapGetters 的辅助函数"></a>4.mapGetters 的辅助函数</h4><p>映射</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;h2&gt;<span class="attr">doublecounter</span>: &#123;&#123; doubleCounter &#125;&#125;&lt;/h2&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>usersTotalAge: &#123;&#123; totalAge &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>message: &#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>id为111的用户信息: &#123;&#123; getUserById(111)&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span>  </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; mapGetters &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">computed</span>: &#123;</span><br><span class="line">        ...<span class="title function_">mapGetters</span>([<span class="string">&quot;doubleCounter&quot;</span>, <span class="string">&quot;totalAge&quot;</span>, <span class="string">&quot;message&quot;</span>]),</span><br><span class="line">        ...<span class="title function_">mapGetters</span>([<span class="string">&quot;getUserById&quot;</span>])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 setup 中使用</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">一般使用</span><br><span class="line"><span class="keyword">import</span> &#123; computed &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; mapGetters, useStore &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="title function_">useStore</span>()</span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">message</span>:messageFn&#125; = <span class="title function_">mapGetters</span>([<span class="string">&quot;message&quot;</span>])</span><br><span class="line"><span class="keyword">const</span> message = <span class="title function_">computed</span>(messageFn.<span class="title function_">bind</span>(&#123; <span class="attr">$store</span>:store&#125;))</span><br><span class="line"></span><br><span class="line">解构方法  </span><br><span class="line">报警告 <span class="title function_">toRefs</span>() expects a reactive object but received a plain one.</span><br><span class="line"><span class="keyword">const</span> &#123; message &#125; =  <span class="title function_">toRefs</span>(store.<span class="property">getters</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment">// 针对某一个getters属性使用computed</span></span><br><span class="line"><span class="keyword">const</span> message = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> store.<span class="property">getters</span>.<span class="property">message</span>)</span><br></pre></td></tr></table></figure><h3 id="5、核心概念-Mutations"><a href="#5、核心概念-Mutations" class="headerlink" title="5、核心概念 Mutations"></a>5、核心概念 Mutations</h3><h4 id="1-基本使用-4"><a href="#1-基本使用-4" class="headerlink" title="1.基本使用"></a>1.基本使用</h4><p>更改 Vuex 的 store 中的状态的唯一方法是提交 mutation</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">mutations</span>: &#123;</span><br><span class="line">    <span class="title function_">changeName</span>(<span class="params">state</span>) &#123;</span><br><span class="line">      state.<span class="property">name</span> = <span class="string">&quot;wangxiaobo&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="title function_">changeName</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// this.$store.state.name = &quot;李银河&quot;</span></span><br><span class="line">      <span class="comment">// 可以跟踪修改</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">commit</span>(<span class="string">&quot;changeName&quot;</span>)</span><br><span class="line">&#125;,&#125;</span><br></pre></td></tr></table></figure><h4 id="2-携带数据"><a href="#2-携带数据" class="headerlink" title="2.携带数据"></a>2.携带数据</h4><p>携带数据：简单数据</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">mutations</span>: &#123;</span><br><span class="line">  <span class="title function_">changeName</span>(<span class="params">state, payload</span>) &#123;</span><br><span class="line">    state.<span class="property">name</span> = payload</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">changeName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">commit</span>(<span class="string">&quot;changeName&quot;</span>, <span class="string">&quot;wxb&quot;</span>)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>携带数据：对象</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">changeInfo</span>(<span class="params">state, newInfo</span>) &#123;</span><br><span class="line">    state.<span class="property">name</span> = newInfo.<span class="property">name</span></span><br><span class="line">    state.<span class="property">level</span> = newInfo.<span class="property">level</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">changeInfo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">commit</span>(<span class="string">&quot;changeInfo&quot;</span>, &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&quot;网二&quot;</span>,</span><br><span class="line">        <span class="attr">level</span>: <span class="number">99</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对象风格的提交方式</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">incrementLevel</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">commit</span>(&#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&quot;incrementLevel&quot;</span>,</span><br><span class="line">        <span class="attr">counter</span>: <span class="number">100</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h4 id="3-常量类型"><a href="#3-常量类型" class="headerlink" title="3.常量类型"></a>3.常量类型</h4><p>目的：在组件中的提交名称与 mutation 中的方法的名称是需要保持一致的，担心名字写错，可以使用常量</p><p>方法：</p><ul><li>定义 muutation_type.js 文件存放常量</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">CHANGE_INFO</span> = <span class="string">&quot;CHANGE_INFO&quot;</span></span><br></pre></td></tr></table></figure><ul><li>在 store 中使用常量</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="variable constant_">CHANGE_INFO</span> &#125; <span class="keyword">from</span> <span class="string">&quot;./mutation_types&quot;</span></span><br><span class="line">[<span class="variable constant_">CHANGE_INFO</span>](state, newInfo) &#123;</span><br><span class="line">    state.<span class="property">name</span> = newInfo.<span class="property">name</span></span><br><span class="line">    state.<span class="property">level</span> = newInfo.<span class="property">level</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在组件中使用常量</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="variable constant_">CHANGE_INFO</span> &#125; <span class="keyword">from</span> <span class="string">&quot;../store/mutation_types&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">changeInfo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">commit</span>(<span class="variable constant_">CHANGE_INFO</span>, &#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&quot;网二&quot;</span>,</span><br><span class="line">      <span class="attr">level</span>: <span class="number">99</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-mapMutation-辅助函数"><a href="#4-mapMutation-辅助函数" class="headerlink" title="4.mapMutation 辅助函数"></a>4.mapMutation 辅助函数</h4><h5 id="1、options-api-中"><a href="#1、options-api-中" class="headerlink" title="1、options api 中"></a>1、options api 中</h5><p>不带参数</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapMutations &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">      ...<span class="title function_">mapMutations</span>([<span class="string">&quot;changeName&quot;</span>, <span class="string">&quot;incrementLevel&quot;</span>, <span class="variable constant_">CHANGE_INFO</span>])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;button @click=<span class="string">&quot;incrementLevel&quot;</span>&gt;递增level&lt;/button&gt;</span><br></pre></td></tr></table></figure><p>带普通参数</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;button @click=<span class="string">&quot;changeName(&#x27;王小波i&#x27;)&quot;</span>&gt;修改name&lt;/button&gt;</span><br></pre></td></tr></table></figure><p>带对象参数</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;button @click=<span class="string">&quot;changeInfo(&#123; name:&#x27;dws&#x27;, level: 105&#125;)&quot;</span>&gt;修改info&lt;/button&gt;</span><br></pre></td></tr></table></figure><p>带对象参数最好不要使用常量</p><p>可以修改一下常量</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">CHANGE_INFO</span> = <span class="string">&quot;changeInfo&quot;</span></span><br></pre></td></tr></table></figure><h5 id="2、在-setup-中"><a href="#2、在-setup-中" class="headerlink" title="2、在 setup() 中"></a>2、在 setup() 中</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapMutations,useStore &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="variable constant_">CHANGE_INFO</span>&#125; <span class="keyword">from</span> <span class="string">&quot;../store/mutation_types&quot;</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="title function_">useStore</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 手动的映射和绑定</span></span><br><span class="line"><span class="keyword">const</span> mutations = <span class="title function_">mapMutations</span>([<span class="string">&quot;changeName&quot;</span>, <span class="string">&quot;incrementLevel&quot;</span>, <span class="variable constant_">CHANGE_INFO</span>])</span><br><span class="line"><span class="keyword">const</span> newMutations = &#123;&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(mutations).<span class="title function_">forEach</span>(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">    newMutations[key] = mutations[key].<span class="title function_">bind</span>(&#123; <span class="attr">$store</span>: store&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> &#123; changeName, incrementLevel, changeInfo &#125; = newMutations</span><br></pre></td></tr></table></figure><h4 id="5-mutation-重要原则"><a href="#5-mutation-重要原则" class="headerlink" title="5.mutation 重要原则"></a>5.mutation 重要原则</h4><p>一条重要的原则就是要记住 mutation 必须是同步函数</p><ul><li>这是因为 devtool 工具会记录 mutation 的日记</li><li>每一条mutation被记录，devtools 都需要捕捉到前一状态和后一状态的快照</li><li>但是在 mutation 中执行异步操作，就无法追踪到数据的变化</li></ul><p>所以 Vuex 的重要原则中要求 mutation必须是同步函数</p><p>但是如果希望在 Vuex 中发送网络请求的话需要如何操作：Actions</p><h3 id="6、核心概念-Actions"><a href="#6、核心概念-Actions" class="headerlink" title="6、核心概念 Actions"></a>6、核心概念 Actions</h3><p>Action 类似于 mutation，不同在于：</p><ul><li><p>Action 提交的是 mutation，而不是直接变更状态</p></li><li><p>Action 可以包含任意异步操作</p></li></ul><p>这里有一个非常重要的参数 context：</p><ul><li><p>context 是一个和 store 实例均有相同方法和属性的 context 对象</p></li><li><p>所以我们可以从其中获取到 commit 方法来提交一个 mutation，或者通过 context.state 和 context.getters 来获取 state 和 getters</p></li></ul><p>但是为什么它不是store对象呢？等到 Modules 具体来说</p><h4 id="1-基本操作"><a href="#1-基本操作" class="headerlink" title="1.基本操作"></a>1.基本操作</h4><p>使用action 分发</p><ul><li>分发使用的是 store 上的dispatch函数</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">actions</span>: &#123;</span><br><span class="line">    <span class="title function_">incrementAction</span>(<span class="params">context</span>) &#123;</span><br><span class="line">        <span class="comment">// console.log(context.commit) // 用于提交mutation</span></span><br><span class="line">        <span class="comment">// console.log(context.getters) // getters</span></span><br><span class="line">        <span class="comment">// console.log(context.state)  // state</span></span><br><span class="line">    context.<span class="title function_">commit</span>(<span class="string">&quot;increment&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">methods中：</span><br><span class="line"><span class="title function_">counterBtnClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">dispatch</span>(<span class="string">&quot;incrementAction&quot;</span>)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>同样的，它也可以携带参数</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">changeNameAction</span>(<span class="params">context, payload</span>) &#123;</span><br><span class="line">    context.<span class="title function_">commit</span>(<span class="string">&quot;changeName&quot;</span>, payload)</span><br><span class="line">&#125;</span><br><span class="line">methods中:</span><br><span class="line"><span class="title function_">nameBtnClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">dispatch</span>(<span class="string">&quot;changeNameAction&quot;</span>, <span class="string">&quot;why&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以以对象的形式进行分发</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230420081706466.png" alt="image-20230420081706466"></p><h4 id="2-actions-辅助函数"><a href="#2-actions-辅助函数" class="headerlink" title="2.actions 辅助函数"></a>2.actions 辅助函数</h4><p>action 也有对应的辅助函数</p><ul><li>数组类型的写法</li></ul><p>options api</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">...<span class="title function_">mapActions</span>([<span class="string">&quot;incrementAction&quot;</span>, <span class="string">&quot;changeNameAction&quot;</span>])</span><br></pre></td></tr></table></figure><p>composition api</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapActions, useStore &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="title function_">useStore</span>()</span><br><span class="line"><span class="number">1.</span>在setup中使用mapactions辅助函数</span><br><span class="line"><span class="keyword">const</span> actions = <span class="title function_">mapActions</span>([<span class="string">&quot;incrementAction&quot;</span>, <span class="string">&quot;changeNameAction&quot;</span>])</span><br><span class="line"><span class="keyword">const</span> newActions = &#123;&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(actions).<span class="title function_">forEach</span>( <span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    newActions[key] = actions[key].<span class="title function_">bind</span>(&#123; <span class="attr">$store</span>: store&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> &#123; incrementAction, changeNameAction&#125; = newActions</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.默认做法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">increment</span>(<span class="params"></span>) &#123;</span><br><span class="line">    store.<span class="title function_">dispatch</span>(<span class="string">&quot;incrementAction&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>对象写法</li></ul><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230420081726099.png" alt="image-20230420081726099"></p><h4 id="3-actions-发起网络请求"><a href="#3-actions-发起网络请求" class="headerlink" title="3.actions 发起网络请求"></a>3.actions 发起网络请求</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="title function_">fetchHomeMultidataAction</span>(<span class="params">context</span>) &#123;</span><br><span class="line">    <span class="comment">// 1返回promise,给promise设置then</span></span><br><span class="line">    <span class="comment">// fetch(&quot;http://123.207.32.32:8000/home/multidata&quot;).then(res =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//   res.json().then(data =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//     console.log(data)</span></span><br><span class="line">    <span class="comment">//   &#125;)</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.promise的链式调用</span></span><br><span class="line">    <span class="comment">// fetch(&quot;http://123.207.32.32:8000/home/multidata&quot;).then(res =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//   return res.json()</span></span><br><span class="line">    <span class="comment">//   &#125;).then(data =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//     console.log(data)</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.awiat/async</span></span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&quot;http://123.207.32.32:8000/home/multidata&quot;</span>)</span><br><span class="line">    <span class="keyword">const</span> data = <span class="keyword">await</span> res.<span class="title function_">json</span>()</span><br><span class="line">    <span class="comment">// console.log(data)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改state数据</span></span><br><span class="line">    context.<span class="title function_">commit</span>(<span class="string">&quot;changeBanners&quot;</span>, data.<span class="property">data</span>.<span class="property">banner</span>.<span class="property">list</span>)</span><br><span class="line">    context.<span class="title function_">commit</span>(<span class="string">&quot;changeRecommends&quot;</span>, data.<span class="property">data</span>.<span class="property">recommend</span>.<span class="property">list</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">store.<span class="title function_">dispatch</span>(<span class="string">&quot;fetchHomeMultidataAction&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="title function_">changeBanners</span>(<span class="params">state, banners</span>) &#123;</span><br><span class="line">    state.<span class="property">banners</span> = banners</span><br><span class="line">&#125;,</span><br><span class="line"><span class="title function_">changeRecommends</span>(<span class="params">state, recommends</span>) &#123;</span><br><span class="line">    state.<span class="property">recommends</span> = recommends</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-actions-的异步操作"><a href="#4-actions-的异步操作" class="headerlink" title="4.actions 的异步操作"></a>4.actions 的异步操作</h4><p>Action 通常是异步的，如何知道 action 的结束</p><ul><li>可以通过让 action 返回 Promise，在 Promise 的 then 中来处理完成后的操作</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">fetchHomeMultidataAction</span>(<span class="params">context</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">async</span> (resolve, reject) =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&quot;http://123.207.32.32:8000/home/multidata&quot;</span>)</span><br><span class="line">        <span class="keyword">const</span> data = <span class="keyword">await</span> res.<span class="title function_">json</span>()</span><br><span class="line">        context.<span class="title function_">commit</span>(<span class="string">&quot;changeBanners&quot;</span>, data.<span class="property">data</span>.<span class="property">banner</span>.<span class="property">list</span>)</span><br><span class="line">        context.<span class="title function_">commit</span>(<span class="string">&quot;changeRecommends&quot;</span>, data.<span class="property">data</span>.<span class="property">recommend</span>.<span class="property">list</span>)</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="string">&quot;sdw&quot;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">store.<span class="title function_">dispatch</span>(<span class="string">&quot;fetchHomeMultidataAction&quot;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&quot;home中的then回调&quot;</span>, res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="7、核心概念-Modules"><a href="#7、核心概念-Modules" class="headerlink" title="7、核心概念 Modules"></a>7、核心概念 Modules</h3><h4 id="1-module-的基本使用"><a href="#1-module-的基本使用" class="headerlink" title="1.module 的基本使用"></a>1.module 的基本使用</h4><p>什么是Module</p><ul><li><p>由于使用单一状态树，应用的所有状态会集中到一个比较大的对象，当应用变得非常复杂时，store 对象就有可能变得相当臃肿</p></li><li><p>为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）</p></li><li><p>每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块</p></li></ul><p>做法：</p><ul><li>新建 modules 文件夹，将需要抽出的组件的数据抽离并导出</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">state</span>: <span class="function">() =&gt;</span> (&#123; &#125;),</span><br><span class="line">  <span class="attr">mutations</span>: &#123; &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在 store 中导入并放入 module 中</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> homeModule <span class="keyword">from</span> <span class="string">&quot;./modules/home&quot;</span></span><br><span class="line"><span class="attr">modules</span>: &#123;</span><br><span class="line">    <span class="attr">home</span>: homeModule</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在组件中获取 module 中的数据</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template v-<span class="keyword">for</span>=<span class="string">&quot;item in $store.state.home.banners&quot;</span> :key=<span class="string">&quot;item.acm&quot;</span>&gt;</span><br></pre></td></tr></table></figure><p>在抽离之前发起的 dispatch 形式暂时不需要修改</p><h4 id="2-module-的局部状态"><a href="#2-module-的局部状态" class="headerlink" title="2.module 的局部状态"></a>2.module 的局部状态</h4><p>对于模块内部的 mutation 和 getter，接收的第一个参数是模块的局部状态对象</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">counter模块中：</span><br><span class="line"><span class="attr">mutations</span>: &#123;</span><br><span class="line">    <span class="title function_">incrementCount</span>(<span class="params">state</span>) &#123;</span><br><span class="line">    state.<span class="property">count</span>++</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">getters</span>: &#123;</span><br><span class="line">    <span class="title function_">doubleCount</span>(<span class="params">state, getters, rootState</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> state.<span class="property">count</span> + rootState.<span class="property">rootCounter</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">actions</span>: &#123;</span><br><span class="line">    <span class="title function_">incrementCountAction</span>(<span class="params">context</span>) &#123;</span><br><span class="line">        context.<span class="title function_">commit</span>(<span class="string">&quot;incrementCount&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template 中：</span><br><span class="line">&lt;!-- <span class="number">1.</span>使用state时，是需要通过state.<span class="property">moduleName</span>.<span class="property">xxx</span> --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Counter模块中的count： &#123;&#123; $store.state.counter.count&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">&lt;!-- <span class="number">2.</span>使用getters时，是直接getters.<span class="property">xxx</span> --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Counter模块中的doubleCount： &#123;&#123; $store.getters.doubleCount&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">setup 中：</span><br><span class="line"><span class="comment">// 派发事件时，默认也是不需要根模块</span></span><br><span class="line"><span class="comment">// 提交mutation时，默认也是不需要模块名称</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">incrementCount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    store.<span class="title function_">dispatch</span>(<span class="string">&quot;incrementCountAction&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-module-的命名空间"><a href="#3-module-的命名空间" class="headerlink" title="3.module 的命名空间"></a>3.module 的命名空间</h4><p>默认情况下，模块内部的 action 和 mutation 仍然是注册在全局的命名空间中的</p><ul><li><p>这样使得多个模块能够对同一个 action 或 mutation 作出响应</p></li><li><p>Getter 同样也默认注册在全局命名空间</p></li></ul><p>如果我们希望模块具有更高的封装度和复用性，可以添加 namespaced: true 的方式使其成为带命名空间的模块</p><ul><li>当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">counter模块中:</span><br><span class="line"><span class="attr">namespaced</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要加上命名空间</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Counter模块中的doubleCount： &#123;&#123; $store.getters[&quot;counter/doubleCount&quot;] &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">incrementCount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    store.<span class="title function_">dispatch</span>(<span class="string">&quot;counter/incrementCountAction&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-module-修改或派发根组件"><a href="#4-module-修改或派发根组件" class="headerlink" title="4.module 修改或派发根组件"></a>4.module 修改或派发根组件</h4><p>如果希望在action中修改root中的state，那么有如下的方式</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230420104445571.png" alt="image-20230420104445571"></p><h2 id="13-Vue全家桶-Pinia状态管理"><a href="#13-Vue全家桶-Pinia状态管理" class="headerlink" title="13.Vue全家桶 - Pinia状态管理"></a>13.Vue全家桶 - Pinia状态管理</h2><h3 id="1、Pinia-和-Vuex-的对比"><a href="#1、Pinia-和-Vuex-的对比" class="headerlink" title="1、Pinia 和 Vuex 的对比"></a>1、Pinia 和 Vuex 的对比</h3><h4 id="1-什么是-Pinia"><a href="#1-什么是-Pinia" class="headerlink" title="1.什么是 Pinia"></a>1.什么是 Pinia</h4><ul><li><p>Pinia开始于大概2019年，最初是作为一个实验为Vue重新设计状态管理，让它用起来像组合式API（Composition API）</p></li><li><p>从那时到现在，最初的设计原则依然是相同的，并且目前同时兼容Vue2、Vue3，也并不要求你使用Composition API</p></li><li><p>Pinia本质上依然是一个状态管理的库，用于跨组件、页面进行状态共享（这点和Vuex、Redux一样）</p></li></ul><h4 id="2-Pinia-和-Vuex-的区别"><a href="#2-Pinia-和-Vuex-的区别" class="headerlink" title="2.Pinia 和 Vuex 的区别"></a>2.Pinia 和 Vuex 的区别</h4><p>有 Vuex 为什么还要用 Pinia</p><ul><li><p>Pinia 最初是为了探索 Vuex 的下一次迭代会是什么样子，结合了 Vuex 5 核心团队讨论中的许多想法</p></li><li><p>最终，团队意识到 Pinia 已经实现了 Vuex5 中大部分内容，所以最终决定用 Pinia 来替代 Vuex</p></li><li><p>与 Vuex 相比，Pinia 提供了一个更简单的 API，具有更少的仪式，提供了 Composition-API 风格的 API</p></li><li><p>最重要的是，在与 TypeScript 一起使用时具有可靠的类型推断支持</p></li></ul><p>和 Vuex 相比，Pinia 有很多的优势</p><ul><li><p>mutations 不再存在：</p><ul><li>他们经常被认为是非常冗长</li><li>他们最初带来了 devtools 集成，但这不再是问题</li></ul></li><li><p>更友好的 TypeScript 支持，Vuex 之前对 TS 的支持很不友好</p></li><li><p>不再有 modules 的嵌套结构：</p><ul><li>你可以灵活使用每一个 store，它们是通过扁平化的方式来相互使用的</li></ul></li><li><p>也不再有命名空间的概念，不需要记住它们的复杂关系</p></li></ul><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230420110608336.png" alt="image-20230420110608336" style="zoom:50%;" /><h3 id="2、创建-Pinia-的-Store"><a href="#2、创建-Pinia-的-Store" class="headerlink" title="2、创建 Pinia 的 Store"></a>2、创建 Pinia 的 Store</h3><h4 id="1-认识-store"><a href="#1-认识-store" class="headerlink" title="1.认识 store"></a>1.认识 store</h4><ul><li><p>一个 Store （如 Pinia）是一个实体，它会持有为绑定到你组件树的状态和业务逻辑，也就是保存了全局的状态</p></li><li><p>它有点像始终存在，并且每个人都可以读取和写入的组件</p></li><li><p>可以在你的应用程序中定义任意数量的Store来管理你的状态</p></li></ul><p> Store有三个核心概念：</p><ul><li>state、getters、actions</li><li>等同于组件的data、computed、methods</li><li>一旦 store 被实例化，就可以直接在 store 上访问 state、getters 和 actions 中定义的任何属性</li></ul><h4 id="2-基本使用-2"><a href="#2-基本使用-2" class="headerlink" title="2.基本使用"></a>2.基本使用</h4><ul><li><p>定义一个Store</p><ul><li>需要知道 Store 是使用 defineStore() 定义的</li><li>并且它需要一个唯一名称，作为第一个参数传递</li><li>这个 name，也称为 id，是必要的，Pinia 使用它来将 store 连接到 devtools</li><li>返回的函数统一使用useX作为命名方案，这是约定的规范</li></ul></li><li><p>使用定义的 Store</p><ul><li>Store 在它被使用之前是不会创建的，可以通过调用 use 函数来使用 Store</li><li>注意Store获取到后不能被解构，那么会失去响应式</li><li>为了从 Store 中提取属性同时保持其响应式，需要使用storeToRefs()。</li></ul></li></ul><p>安装：npm install pinia or yarn add pinia</p><h4 id="3-详细使用"><a href="#3-详细使用" class="headerlink" title="3.详细使用"></a>3.详细使用</h4><ul><li>创建一个 pinia，并且将其传递给应用程序</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">index.<span class="property">js</span>：</span><br><span class="line"><span class="keyword">import</span> &#123; createPinia &#125; <span class="keyword">from</span> <span class="string">&quot;pinia&quot;</span></span><br><span class="line"><span class="keyword">const</span> pinia = <span class="title function_">createPinia</span>()</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> pinia</span><br><span class="line"></span><br><span class="line">main.<span class="property">js</span>：</span><br><span class="line"><span class="keyword">import</span> pinia <span class="keyword">from</span> <span class="string">&#x27;./stores&#x27;</span></span><br><span class="line"><span class="title function_">createApp</span>(<span class="title class_">App</span>).<span class="title function_">use</span>(pinia).<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li>创建页面的 store</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义关于counter的store</span></span><br><span class="line"><span class="keyword">import</span> &#123; defineStore &#125; <span class="keyword">from</span> <span class="string">&quot;pinia&quot;</span></span><br><span class="line"><span class="keyword">const</span> useCounter = <span class="title function_">defineStore</span>(<span class="string">&quot;counter&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">state</span>: <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">99</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> useCounter</span><br></pre></td></tr></table></figure><ul><li>组件中使用数据</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;h2&gt;<span class="attr">count</span>: &#123;&#123; counterStore.<span class="property">count</span> &#125;&#125;&lt;/h2&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> useCounter <span class="keyword">from</span> <span class="string">&#x27;@/stores/counter&#x27;</span></span><br><span class="line"><span class="keyword">const</span> counterStore = <span class="title function_">useCounter</span>()</span><br></pre></td></tr></table></figure><p>解构之后失去响应式</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; count &#125; = counterStore</span><br><span class="line">&lt;h2&gt;<span class="attr">count</span>: &#123;&#123;count&#125;&#125;&lt;/h2&gt;</span><br></pre></td></tr></table></figure><p>获取响应式</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">方法<span class="number">1</span>：</span><br><span class="line"><span class="keyword">import</span> &#123; toRefs &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> &#123; count &#125; = <span class="title function_">toRefs</span>(counterStore)</span><br><span class="line"></span><br><span class="line">方法<span class="number">2</span>：</span><br><span class="line"><span class="keyword">import</span> &#123; storeToRefs &#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> &#123; count&#125; = <span class="title function_">storeToRefs</span>(counterStore)</span><br></pre></td></tr></table></figure><h3 id="3、Pinia-核心概念-State"><a href="#3、Pinia-核心概念-State" class="headerlink" title="3、Pinia 核心概念 State"></a>3、Pinia 核心概念 State</h3><p>state 是 store 的核心部分，因为store是用来帮助我们管理状态的</p><ul><li>在 Pinia 中，状态被定义为返回初始状态的函数</li></ul><h4 id="操作-State"><a href="#操作-State" class="headerlink" title="操作 State"></a>操作 State</h4><p>读取和写入 State</p><ul><li>默认情况下，可以通过 store 实例访问状态来直接读取和写入状态</li></ul><p>改变 State</p><ul><li>除了直接用 store.counter++ 修改 store，你还可以调用 $patch 方法</li><li>它允许您使用部分“state”对象同时应用多个更改</li></ul><p>替换 State</p><ul><li>可以通过将其 $state 属性设置为新对象来替换 Store 的整个状态</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">changeState</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 1.修改state(一个一个修改状态)</span></span><br><span class="line">  <span class="comment">// useStore.name = &#x27;kobe&#x27;</span></span><br><span class="line">  <span class="comment">// useStore.age = 30</span></span><br><span class="line">  <span class="comment">// useStore.level = 200</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.一次性修改多个状态</span></span><br><span class="line">  <span class="comment">// useStore.$patch(&#123;</span></span><br><span class="line">  <span class="comment">//   name: &quot;james&quot;,</span></span><br><span class="line">  <span class="comment">//   age: 35,</span></span><br><span class="line">  <span class="comment">// &#125;)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.替换state为新的对象</span></span><br><span class="line">  <span class="keyword">const</span> oldState = useStore.<span class="property">$state</span></span><br><span class="line">  useStore.<span class="property">$state</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;curry&quot;</span>,</span><br><span class="line">    <span class="attr">level</span>: <span class="number">199</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 并不是完全替换，应该是有劫持，发生了融合，指向同一个地址</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(oldState === useStore.<span class="property">$state</span>) <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重置 State</p><ul><li>你可以通过调用 store 上的 $reset() 方法将状态重置到其初始值</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">resetState</span>(<span class="params"></span>) &#123;</span><br><span class="line">  useStore.$reset()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、Pinia-核心概念-Getters"><a href="#4、Pinia-核心概念-Getters" class="headerlink" title="4、Pinia 核心概念 Getters"></a>4、Pinia 核心概念 Getters</h3><p>Getters 相当于 Store 的计算属性</p><ul><li>它们可以用 defineStore() 中的 getters 属性定义</li><li>getters 中可以定义接受一个 state 作为参数的函数</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">getters</span>: &#123;</span><br><span class="line">    <span class="title function_">doubleCount</span>(<span class="params">state</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> state.<span class="property">count</span> * <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在页面中访问 store 中的 getters</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;h2&gt;<span class="attr">doubleCount</span>: &#123;&#123; counterStore.<span class="property">doubleCount</span> &#125;&#125;&lt;/h2&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>doubleCountAddOne: &#123;&#123; counterStore.doubleCountAddOne &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>Getters 中访问自己的其他 Getters</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">doubleCountAddOne</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// this是store实例</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">doubleCount</span> + <span class="number">1</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>访问其他store的Getters</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> useUser <span class="keyword">from</span> <span class="string">&quot;./user&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">showMessage</span>(<span class="params">state</span>) &#123;</span><br><span class="line">    <span class="comment">// 1.获取user信息</span></span><br><span class="line">    <span class="keyword">const</span> userStore = <span class="title function_">useUser</span>()</span><br><span class="line">    <span class="comment">// 2.获取自己的信息</span></span><br><span class="line">    <span class="comment">// 3.拼接信息</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">`name:<span class="subst">$&#123;userStore.name&#125;</span>-count:<span class="subst">$&#123;state.count&#125;</span>`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;h2&gt;<span class="attr">showMessage</span>: &#123;&#123; counterStore.<span class="property">showMessage</span> &#125;&#125;&lt;/h2&gt;</span><br></pre></td></tr></table></figure><p>Getters也可以返回一个函数，这样就可以接受参数</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">getFriendById</span>(<span class="params">state</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">id</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; state.<span class="property">friends</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> friend = state.<span class="property">friends</span>[i]</span><br><span class="line">            <span class="keyword">if</span>(friend.<span class="property">id</span> === id) &#123;</span><br><span class="line">                <span class="keyword">return</span> friend</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">    </span><br><span class="line">在页面中使用：</span><br><span class="line"><span class="keyword">import</span> useCounter <span class="keyword">from</span> <span class="string">&quot;@/stores/counter&quot;</span></span><br><span class="line"><span class="keyword">const</span> counterStore = <span class="title function_">useCounter</span>()</span><br><span class="line"></span><br><span class="line">&lt;h2&gt;friend-<span class="number">112</span>: &#123;&#123; counterStore.<span class="title function_">getFriendById</span>(<span class="number">112</span>) &#125;&#125;&lt;/h2&gt;</span><br></pre></td></tr></table></figure><h3 id="5、Pinia-核心概念-Actions"><a href="#5、Pinia-核心概念-Actions" class="headerlink" title="5、Pinia 核心概念 Actions"></a>5、Pinia 核心概念 Actions</h3><p>Actions 相当于组件中的 methods</p><ul><li>可以使用 defineStore() 中的 actions 属性定义，并且它们非常适合定义业务逻辑</li></ul><p>和getters一样，在action中可以通过this访问整个store实例的所有操作</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">actions</span>: &#123;</span><br><span class="line">    <span class="title function_">increment</span>(<span class="params">num</span>) &#123;</span><br><span class="line">        <span class="comment">// console.log(state)</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">count</span> += num</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> useCounter <span class="keyword">from</span> <span class="string">&quot;@/stores/counter&quot;</span></span><br><span class="line"><span class="keyword">const</span> counterStore = <span class="title function_">useCounter</span>()</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">changeState</span>(<span class="params"></span>) &#123;</span><br><span class="line">    counterStore.<span class="title function_">increment</span>(<span class="number">10</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;button @click=<span class="string">&quot;changeState&quot;</span>&gt;修改state&lt;/button&gt;</span><br></pre></td></tr></table></figure><p>Action 执行异步操作</p><ul><li>可以编写异步函数，在函数中使用await</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> useHome = <span class="title function_">defineStore</span>(<span class="string">&quot;home&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">state</span>: <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">    <span class="attr">banners</span>: [],</span><br><span class="line">    <span class="attr">recommends</span>: []</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="attr">actions</span>: &#123;</span><br><span class="line">    <span class="keyword">async</span> <span class="title function_">fetchHomeMultidata</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&quot;http://123.207.32.32:8000/home/multidata&quot;</span>)</span><br><span class="line">      <span class="keyword">const</span> data = <span class="keyword">await</span> res.<span class="title function_">json</span>()</span><br><span class="line">      </span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">banners</span> = data.<span class="property">data</span>.<span class="property">banner</span>.<span class="property">list</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">recommends</span> = data.<span class="property">data</span>.<span class="property">recommend</span>.<span class="property">list</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;adsdw&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> useHome <span class="keyword">from</span> <span class="string">&quot;@/stores/home&quot;</span></span><br><span class="line"><span class="keyword">const</span> homeStore = <span class="title function_">useHome</span>()</span><br><span class="line">homeStore.<span class="title function_">fetchHomeMultidata</span>().<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;fetchHomeMultidata已经完成了&quot;</span>, res)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&lt;!-- 展示数据-------- --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-for</span>=<span class="string">&quot;item in homeStore.banners&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123;item.title&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="14-网络请求库-axios库"><a href="#14-网络请求库-axios库" class="headerlink" title="14.网络请求库 - axios库"></a>14.网络请求库 - axios库</h2><h3 id="1、认识-Axios-库"><a href="#1、认识-Axios-库" class="headerlink" title="1、认识 Axios 库"></a>1、认识 Axios 库</h3><p>安装：npm install axios</p><p>功能特点</p><ul><li><p>在浏览器中发送 XMLHttpRequests 请求</p></li><li><p>在 node.js 中发送 http请求</p></li><li><p>支持 Promise API</p></li><li><p>拦截请求和响应</p></li><li><p>转换请求和响应数据</p></li></ul><h3 id="2、axios-发送请求"><a href="#2、axios-发送请求" class="headerlink" title="2、axios 发送请求"></a>2、axios 发送请求</h3><h4 id="请求方式"><a href="#请求方式" class="headerlink" title="请求方式"></a>请求方式</h4><p>支持多种请求方式</p><ul><li>axios(config)</li><li>axios.request(config)</li><li>axios.get(url[, config])</li><li>axios.delete(url[, config])</li><li>axios.head(url[, config])</li><li>axios.post(url[, data[, config]])</li><li>axios.put(url[, data[, config]])</li><li>axios.patch(url[, data[, config]])</li></ul><p>有时候可能需求同时发送两个请求</p><ul><li>使用axios.all, 可以放入多个请求的数组</li><li>axios.all([]) 返回的结果是一个数组，使用 axios.spread 可将数组 [res1,res2] 展开为 res1, res2</li></ul><h4 id="常见配置"><a href="#常见配置" class="headerlink" title="常见配置"></a>常见配置</h4><p>请求地址</p><ul><li>url: ‘&#x2F;user’,</li></ul><p>请求类型</p><ul><li>method: ‘get’,</li></ul><p>请求根路径</p><ul><li>baseURL: ‘<a href="http://www.mt.com/api">http://www.mt.com/api</a>‘,</li></ul><p>请求前的数据处理</p><ul><li>transformRequest:[function(data){}],</li></ul><p>请求后的数据处理</p><ul><li>transformResponse: [function(data){}],</li></ul><p>自定义的请求头</p><ul><li>headers:{‘x-Requested-With’:’XMLHttpRequest’},</li></ul><p>URL查询对象</p><ul><li>params:{ id: 12 },</li></ul><p>查询对象序列化函数</p><ul><li>paramsSerializer: function(params){ }</li></ul><p>request body</p><ul><li>data: { key: ‘aa’},</li></ul><p>超时设置</p><ul><li>timeout: 1000</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">axios.<span class="title function_">post</span>(<span class="string">&quot;http://123.207.32.32:1888/02_param/postjson&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;coderwhy&quot;</span>,</span><br><span class="line">    <span class="attr">password</span>: <span class="string">&quot;123456&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;).<span class="title function_">then</span>( <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;res:&quot;</span>, res.<span class="property">data</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="额外补充"><a href="#额外补充" class="headerlink" title="额外补充"></a>额外补充</h4><p>baseURL</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.baseURL</span></span><br><span class="line"><span class="keyword">const</span> baseURL = <span class="string">&quot;http://123.207.32.32:8000&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 给axios实例配置公共的基础配置</span></span><br><span class="line">axios.<span class="property">defaults</span>.<span class="property">baseURL</span> = baseURL</span><br><span class="line">axios.<span class="property">defaults</span>.<span class="property">timeout</span> = <span class="number">10000</span></span><br><span class="line">axios.<span class="property">defaults</span>.<span class="property">headers</span> = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.1 get:/home/multidata</span></span><br><span class="line">axios.<span class="title function_">get</span>(<span class="string">&quot;/home/multidata&quot;</span>).<span class="title function_">then</span>( <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;res:&quot;</span>, res.<span class="property">data</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>发送多个请求</p><ul><li>所有的请求完成之后才会调用 then</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">axios.<span class="title function_">all</span>([</span><br><span class="line">  axios.<span class="title function_">get</span>(<span class="string">&quot;/home/multidata&quot;</span>),</span><br><span class="line">  axios.<span class="title function_">post</span>(<span class="string">&quot;http://123.207.32.32:1888/02_param/postjson&quot;</span>, &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;coderwhy&quot;</span>,</span><br><span class="line">    <span class="attr">password</span>: <span class="string">&quot;123456&quot;</span></span><br><span class="line">  &#125;)</span><br><span class="line">]).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;res&quot;</span>, res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="3、axios-创建实例"><a href="#3、axios-创建实例" class="headerlink" title="3、axios 创建实例"></a>3、axios 创建实例</h3><p>为什么要创建axios的实例</p><ul><li>当我们从axios模块中导入对象时, 使用的实例是默认的实例</li><li>当给该实例设置一些默认配置时, 这些配置就被固定下来了</li><li>但是后续开发中, 某些配置可能会不太一样</li><li>比如某些请求需要使用特定的baseURL或者timeout等</li><li>这个时候就可以创建新的实例, 并且传入属于该实例的配置信息</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// axios默认库提供给我们的实例对象</span></span><br><span class="line"><span class="comment">// axios.get(&quot;url&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建其他的实例发送网络请求</span></span><br><span class="line"><span class="keyword">const</span> instance1 = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">  <span class="attr">baseURL</span>: <span class="string">&quot;http://132.207.32.32:8000&quot;</span>,</span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">10000</span>,</span><br><span class="line">  <span class="attr">headers</span>: &#123;&#125;</span><br><span class="line">&#125;)</span><br><span class="line">instance1.<span class="title function_">get</span>(<span class="string">&quot;/lyric&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">params</span>: &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="number">500665346</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res.<span class="property">data</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> instance2 = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">  <span class="attr">baseURL</span>: <span class="string">&quot;http://132.207.32.32:9001&quot;</span>,</span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">1000</span>,</span><br><span class="line">  <span class="attr">headers</span>: &#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="4、axios-的拦截器"><a href="#4、axios-的拦截器" class="headerlink" title="4、axios 的拦截器"></a>4、axios 的拦截器</h3><p>axios的也可以设置拦截器：拦截每次请求和响应</p><ul><li><p>axios.interceptors.request.use(请求成功拦截, 请求失败拦截)</p></li><li><p>axios.interceptors.response.use(响应成功拦截, 响应失败拦截)</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对实例配置拦截器</span></span><br><span class="line">axios.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(<span class="function">(<span class="params">config</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 请求成功的拦截</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;请求成功&quot;</span>)</span><br><span class="line">  <span class="comment">// 开始loading动画</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对原来的配置文件进行修改</span></span><br><span class="line">  <span class="comment">// 2.1 heder</span></span><br><span class="line">  <span class="comment">// 2.2 认证登录：token/cookie</span></span><br><span class="line">  <span class="comment">// 2.3 请求参数进行某些转化</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// if (config.url === &quot;/user/info&quot;)&#123;</span></span><br><span class="line">  <span class="comment">//   config.header[&quot;token&quot;] = &quot;coderwhy&quot;</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> config</span><br><span class="line">&#125;, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;请求失败的拦截&quot;</span>)</span><br><span class="line">  <span class="keyword">return</span> err</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">axios.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 这里拦截之后返回res.data，在下方则不需要写为res.data了。这里已经做了转换</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;响应成功拦截&quot;</span>)</span><br><span class="line">  <span class="comment">// 结束loading动画</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对数据进行转化，再返回数据</span></span><br><span class="line">  <span class="keyword">return</span> res.<span class="property">data</span></span><br><span class="line">&#125;, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;响应失败的拦截:&quot;</span>, err)</span><br><span class="line">  <span class="keyword">return</span> err</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">axios.<span class="title function_">get</span>(<span class="string">&quot;http://123.207.32.32:8000/home/multidata&quot;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;res:&quot;</span>, res)</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;err:&quot;</span>, err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="5、axios-请求封装"><a href="#5、axios-请求封装" class="headerlink" title="5、axios 请求封装"></a>5、axios 请求封装</h3><p>封装的目的：为了防止 axios 突然不维护，而项目与 axios 的耦合度太高，以至于修改项目的成本太高与过于复杂</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HYRequest</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">baseURL, timeout=<span class="number">10000</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">instance</span> = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">      baseURL,</span><br><span class="line">      timeout</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">request</span>(<span class="params">config</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">instance</span>.<span class="title function_">request</span>(config).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(res.<span class="property">data</span>)</span><br><span class="line">      &#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">reject</span>(err)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">get</span>(<span class="params">config</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">request</span>(&#123;...config, <span class="attr">method</span>:<span class="string">&quot;get&quot;</span>&#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">post</span>(<span class="params">config</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">request</span>(&#123;...config, <span class="attr">method</span>: <span class="string">&quot;post&quot;</span>&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以创建多个实例</span></span><br><span class="line"><span class="comment">// const hyRequest1 = new HYRequest(&quot;&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置baseURL</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">HYRequest</span>(<span class="string">&quot;http://123.207.32.32:8000&quot;</span>)</span><br><span class="line"></span><br><span class="line">使用：</span><br><span class="line"><span class="keyword">import</span> hyRequest <span class="keyword">from</span> <span class="string">&quot;./service&quot;</span></span><br><span class="line">hyRequest.<span class="title function_">request</span>(&#123;</span><br><span class="line">  <span class="attr">url</span>: <span class="string">&quot;/home/multidata&quot;</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;res:&quot;</span>, res)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">hyRequest.<span class="title function_">get</span>(&#123;</span><br><span class="line">  <span class="attr">url</span>: <span class="string">&quot;/home/multidata&quot;</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;res:&quot;</span>, res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="15-项目实战"><a href="#15-项目实战" class="headerlink" title="15.项目实战"></a>15.项目实战</h2><h3 id="1、初始项目步骤"><a href="#1、初始项目步骤" class="headerlink" title="1、初始项目步骤"></a>1、初始项目步骤</h3><p>安装项目—&gt;npm install —&gt;npm run xx —&gt;去除默认样式—&gt;添加jsconfig（代码提示友好）—&gt;创建项目结构（目录）—&gt;CSS样式的重置（npm i normalize  main中引入）—&gt;创建路由—&gt;开发</p><p>修改第三方UI组件库的样式</p><p>1.插槽：插入自己的元素：那么可以在自己的作用域中直接修改这个元素</p><p>2.全局定义一个变量，覆盖它默认的值，但会修改全局</p><p>3.布局定义一个变量，覆盖它默认变量的值，优点：局部修改</p><p>4.直接查找对应的子组件选择器，进行修改</p><ul><li>:deep(子组件元素的选择器)进行修改</li><li>直接修改CSS</li></ul>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IT前端 </tag>
            
            <tag> Vue </tag>
            
            <tag> 前端框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端工程化</title>
      <link href="/archives/7db00131.html"/>
      <url>/archives/7db00131.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前端工程化"><a href="#前端工程化" class="headerlink" title="前端工程化"></a>前端工程化</h1><h2 id="1-邂逅-Node-js-开发"><a href="#1-邂逅-Node-js-开发" class="headerlink" title="1.邂逅 Node.js 开发"></a>1.邂逅 Node.js 开发</h2><h3 id="1、Node-js-是什么"><a href="#1、Node-js-是什么" class="headerlink" title="1、Node.js 是什么"></a>1、Node.js 是什么</h3><p>官方对 Node.js 的定义：</p><p>Node.js是一个基于V8 JavaScript引擎的JavaScript运行时环境</p><p>也就是说 Node.js 基于 V8 引擎来执行 JavaScript 的代码，但是不仅仅只有 V8 引擎：</p><ul><li><p>V8 可以嵌入到任何C ++应用程序中，无论是Chrome还是Node.js，事实上都是嵌入了V8引擎来执行JavaScript代码</p></li><li><p>但是在Chrome浏览器中，还需要解析、渲染HTML、CSS等相关渲染引擎，另外还需要提供支持浏览器操作的API、浏览器自己的事件循环等</p></li><li><p>另外，在Node.js中也需要进行一些额外的操作，比如文件系统读&#x2F;写、网络IO、加密、压缩解压文件等操作</p></li></ul><p>Node.js 和浏览器的差异：</p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230424132947218.png" alt="image-20230424132947218" style="zoom:50%;" /><p>单独的Node.js的架构图：</p><ul><li><p>JavaScript代码会经过V8引擎，再通过Node.js的Bindings，将任务放到Libuv的事件循环中</p></li><li><p>libuv（Unicorn Velociraptor—独角伶盗龙）是使用C语言编写的库</p></li><li><p>libuv 提供了事件循环、文件系统读写、网络IO、线程池等等内容</p></li></ul><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230424133049086.png" alt="image-20230424133049086" style="zoom:50%;" /><h3 id="2、Node-js-的应用场景"><a href="#2、Node-js-的应用场景" class="headerlink" title="2、Node.js 的应用场景"></a>2、Node.js 的应用场景</h3><p>应用一：目前前端开发的库都是以node包的形式进行管理</p><p>应用二：npm、yarn、pnpm工具成为前端开发使用最多的工具</p><p>应用三：越来越多的公司使用Node.js作为web服务器开发、中间件、代理服务器</p><p>应用四：大量项目需要借助Node.js完成前后端渲染的同构应用</p><p>应用五：资深前端工程师需要为项目编写脚本工具（前端工程师编写脚本通常会使用JavaScript，而不是Python或者shell）</p><p>应用六：很多企业在使用Electron来开发桌面应用程序</p><h3 id="3、Node-js-安装和管理"><a href="#3、Node-js-安装和管理" class="headerlink" title="3、Node.js 安装和管理"></a>3、Node.js 安装和管理</h3><p>Node.js是在2009年诞生的，版本分别是 LTS 以及 Current 18.4.0</p><ul><li><p>LTS版本：（Long-term support, 长期支持）相对稳定一些，推荐线上环境使用该版本</p></li><li><p>Current版本：最新的Node版本，包含很多新特性</p></li></ul><p>选择</p><ul><li><p>如果你是学习使用，可以选择current版本</p></li><li><p>如果你是公司开发，建议选择LTS版本（面向工作，选择LTS版本）</p></li></ul><p>Node的安装方式有很多：</p><ul><li><p>可以借助于一些操作系统上的软件管理工具，比如Mac上的homebrew，Linux上的yum、dnf等</p></li><li><p>也可以直接下载对应的安装包下载安装</p></li></ul><h4 id="1-下载安装"><a href="#1-下载安装" class="headerlink" title="1.下载安装"></a>1.下载安装</h4><ul><li><p>window选择.msi安装包，Mac选择.pkg安装包，Linux会在后续部署中讲解</p></li><li><p>安装过程中会配置环境变量（让我们可以在命令行使用）</p></li><li><p>并且会安装npm（Node Package Manager）工具</p></li></ul><h4 id="2-版本工具"><a href="#2-版本工具" class="headerlink" title="2.版本工具"></a>2.版本工具</h4><p>如果希望通过可以快速更新或切换多个版本时，可以借助于一些工具：</p><ul><li><p>nvm：Node Version Manager</p></li><li><p>n：Interactively Manage Your Node.js Versions（交互式管理你的Node.js版本）</p></li></ul><p>问题：这两个工具都不支持window</p><ul><li><p>n：n is not supported natively on Windows</p></li><li><p>nvm：nvm does not support Windows</p></li></ul><p>针对nvm，在GitHub上有提供对应的window版本：<a href="https://github.com/coreybutler/nvm-windows">https://github.com/coreybutler/nvm-windows</a></p><ul><li><p>通过 nvm install latest 安装最新的node版本</p></li><li><p>通过 nvm list 展示目前安装的所有版本</p></li><li><p>通过 nvm use 切换版本</p></li></ul><p>安装n：直接使用npm安装</p><ul><li><p>npm install -g n</p></li><li><p>n –version</p></li><li><p>安装最新的 lts 版本：n lts</p></li><li><p>前面添加的sudo是权限问题</p></li><li><p>可以两个版本都安装，之后我们可以通过n快速在两个版本间切换</p></li><li><p>安装最新的版本：n lastest</p></li><li><p>查看所有的版本：n</p></li></ul><h3 id="4、JavaScript-代码执行"><a href="#4、JavaScript-代码执行" class="headerlink" title="4、JavaScript 代码执行"></a>4、JavaScript 代码执行</h3><p>如果我们编写一个 js 文件，里面存放 JavaScript 代码，目前有两种方式可以执行：</p><ul><li><p>将代码交给浏览器执行</p></li><li><p>将代码载入到node环境中执行</p></li></ul><p>如果我们希望把代码交给浏览器执行</p><ul><li><p>需要通过让浏览器加载、解析html代码，所以我们需要创建一个html文件</p></li><li><p>在html中通过script标签，引入js文件</p></li><li><p>当浏览器遇到script标签时，就会根据src加载执行JavaScript代码</p></li></ul><p>如果希望把js文件交给node执行</p><ul><li><p>首先电脑上需要安装Node.js环境，安装过程中会自动配置环境变量</p></li><li><p>可以通过终端命令node js文件的方式来载入和执行对应的js文件</p></li></ul><h4 id="Node-的-REPL"><a href="#Node-的-REPL" class="headerlink" title="Node 的 REPL"></a>Node 的 REPL</h4><ul><li><p>REPL 是 Read-Eval-Print Loop的简称，翻译为“读取-求值-输出-循环”</p></li><li><p>REPL是一个简单的、交互式的编程环境</p></li><li><p>浏览器的console就可以看成一个REPL</p></li><li><p>Node也提供了一个REPL环境，可以在其中演练简单的代码</p></li></ul><h3 id="5、Node-的输入和输出"><a href="#5、Node-的输入和输出" class="headerlink" title="5、Node 的输入和输出"></a>5、Node 的输入和输出</h3><h4 id="1-node-的输入"><a href="#1-node-的输入" class="headerlink" title="1.node 的输入"></a>1.node 的输入</h4><p>正常情况下执行一个node程序，直接跟上对应的文件即可：node inde.js</p><p>但是，在某些情况下执行node程序的过程中，可能希望给node传递一些参数：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">node index.<span class="property">js</span> env=development coderwhy</span><br></pre></td></tr></table></figure><p>如果我们这样来使用程序，就意味着我们需要在程序中获取到传递的参数：</p><ul><li><p>获取参数其实是在process的内置对象中的</p></li><li><p>如果直接打印这个内置对象，它里面包含特别的信息：</p><ul><li>其他的一些信息，比如版本、操作系统等</li></ul></li></ul><p>其中的argv属性：</p><ul><li>它是一个数组，里面包含了我们需要的参数</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 给程序输入内容</span></span><br><span class="line"><span class="comment">// console.log(process.argv)</span></span><br><span class="line"><span class="keyword">const</span> arg1 = process.<span class="property">argv</span>[<span class="number">2</span>]</span><br><span class="line"><span class="keyword">const</span> arg2 = process.<span class="property">argv</span>[<span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>为什么叫argv</p><p>在C&#x2F;C++程序中的main函数中，实际上可以获取到两个参数：</p><ul><li><p>argc：argument counter的缩写，传递参数的个数</p></li><li><p>argv：argument vector（向量、矢量）的缩写，传入的具体参数</p><ul><li>vector翻译过来是矢量的意思，在程序中表示的是一种数据结构</li><li>在C++、Java中都有这种数据结构，是一种数组结构</li><li>在JavaScript中也是一个数组，里面存储一些参数信息</li></ul></li></ul><h4 id="2-node-的输出"><a href="#2-node-的输出" class="headerlink" title="2.node 的输出"></a>2.node 的输出</h4><p>console.log</p><ul><li>最常用的输入内容的方式：console.log</li></ul><p>console.clear</p><ul><li>清空控制台：console.clear</li></ul><p>console.trace</p><ul><li>打印函数的调用栈：console.trace</li></ul><p>其他的一些console方法：<a href="https://nodejs.org/dist/latest-v16.x/docs/api/console.html">https://nodejs.org/dist/latest-v16.x/docs/api/console.html</a></p><h3 id="6、Node-的全局对象"><a href="#6、Node-的全局对象" class="headerlink" title="6、Node 的全局对象"></a>6、Node 的全局对象</h3><p>类似于 window 的全局对象：global</p><h4 id="特殊的全局对象"><a href="#特殊的全局对象" class="headerlink" title="特殊的全局对象"></a>特殊的全局对象</h4><ul><li><p>这些全局对象实际上是模块中的变量，只是每个模块都有，看来像是全局变量</p></li><li><p>在命令行交互中是不可以使用的</p></li><li><p>包括：__dirname、__filename、exports、module、require()</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// __dirname当前文件所在的目录结构</span></span><br><span class="line"><span class="comment">// console.log(__dirname)</span></span><br><span class="line"><span class="comment">// __filename当前目录+文件名称</span></span><br><span class="line"><span class="comment">// console.log(__filename)</span></span><br></pre></td></tr></table></figure><h4 id="常见的全局对象"><a href="#常见的全局对象" class="headerlink" title="常见的全局对象"></a>常见的全局对象</h4><p>process对象：process提供了Node进程中相关的信息：</p><ul><li>比如Node的运行环境、参数信息等</li></ul><p>console对象：提供了简单的调试控制台，在前面讲解输入内容时已经学习过了</p><ul><li>更加详细的查看官网文档：<a href="https://nodejs.org/api/console.html">https://nodejs.org/api/console.html</a></li></ul><p>定时器函数：在Node中使用定时器有好几种方式：</p><ul><li><p>setTimeout(callback, delay[, …args])：callback在delay毫秒后执行一次</p></li><li><p>setInterval(callback, delay[, …args])：callback每delay毫秒重复执行一次</p></li><li><p>setImmediate(callback[, …args])：callbackI &#x2F; O事件后的回调的“立即”执行</p><ul><li>这里先不展开讨论它和setTimeout(callback, 0)之间的区别</li><li>它涉及到事件循环的阶段问题，后续详细讲解</li></ul></li></ul><p>pprocess.nextTick(callback[, …args])：添加到下一次tick队列中</p><h4 id="global对象"><a href="#global对象" class="headerlink" title="global对象"></a>global对象</h4><p>global是一个全局对象，事实上前面提到的process、console、setTimeout等都有被放到global中：</p><ul><li><p>之前讲过：在新的标准中还有一个globalThis，也是指向全局对象的</p></li><li><p>类似于浏览器中的window</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">在浏览器其中使用 <span class="variable language_">window</span>,node 中使用 <span class="variable language_">global</span>，可以统一使用 globalThis</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(globalThis === <span class="variable language_">global</span>)</span><br></pre></td></tr></table></figure><p>global 与 window 的区别</p><p>在浏览器中，全局变量都是在window上的，比如有document、setInterval、setTimeout、alert、console等等</p><p>在Node中，也有一个global属性，并且它里面有很多其他对象</p><ul><li><p>但是在浏览器中执行的JavaScript代码，如果在顶级范围内通过var定义的一个属性，默认会被添加到window对象上</p></li><li><p>但是在node中，通过var定义一个变量，它只是在当前模块中有一个变量，不会放到全局中</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;coderwhy&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">global</span>.<span class="property">name</span>)  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><h2 id="2-JavaScript-模块化开发"><a href="#2-JavaScript-模块化开发" class="headerlink" title="2.JavaScript 模块化开发"></a>2.JavaScript 模块化开发</h2><h3 id="1、认识模块化开发"><a href="#1、认识模块化开发" class="headerlink" title="1、认识模块化开发"></a>1、认识模块化开发</h3><h4 id="1-什么是模块化开发"><a href="#1-什么是模块化开发" class="headerlink" title="1.什么是模块化开发"></a>1.什么是模块化开发</h4><ul><li><p>事实上模块化开发最终的目的是将程序划分成一个个小的结构</p></li><li><p>这个结构中编写属于自己的逻辑代码，有自己的作用域，定义变量名词时不会影响到其他的结构</p></li><li><p>这个结构可以将自己希望暴露的变量、函数、对象等导出给其结构使用</p></li><li><p>也可以通过某种方式，导入另外结构中的变量、函数、对象等</p></li></ul><p>上面说提到的结构，就是模块；按照这种结构划分开发程序的过程，就是模块化开发的过程</p><h4 id="2-早期-JavaScript-的缺陷"><a href="#2-早期-JavaScript-的缺陷" class="headerlink" title="2.早期 JavaScript 的缺陷"></a>2.早期 JavaScript 的缺陷</h4><ul><li><p>比如var定义的变量作用域问题</p></li><li><p>比如JavaScript的面向对象并不能像常规面向对象语言一样使用class</p></li><li><p>比如JavaScript没有模块化的问题</p></li></ul><p>随着前端和JavaScript的快速发展，JavaScript代码变得越来越复杂</p><ul><li><p>ajax的出现，前后端开发分离，意味着后端返回数据后，需要通过JavaScript进行前端页面的渲染</p></li><li><p>SPA的出现，前端页面变得更加复杂：包括前端路由、状态管理等等一系列复杂的需求需要通过JavaScript来实现</p></li><li><p>包括Node的实现，JavaScript编写复杂的后端程序，没有模块化是致命的硬伤</p></li></ul><p>所以，模块化已经是JavaScript一个非常迫切的需求：</p><ul><li><p>但是JavaScript本身，直到ES6（2015）才推出了自己的模块化方案：ESModule</p></li><li><p>在此之前，为了让JavaScript支持模块化，涌现出了很多不同的模块化规范：AMD、CMD、CommonJS等</p></li></ul><h4 id="3-没有模块化带来的问题"><a href="#3-没有模块化带来的问题" class="headerlink" title="3.没有模块化带来的问题"></a>3.没有模块化带来的问题</h4><p>命名冲突的问题：使用立即函数调用表达式</p><p>新的问题：</p><ul><li><p>第一，必须记得每一个模块中返回对象的命名，才能在其他模块使用过程中正确的使用</p></li><li><p>第二，代码写起来混乱不堪，每个文件中的代码都需要包裹在一个匿名函数中来编写</p></li><li><p>第三，在没有合适的规范情况下，每个人、每个公司都可能会任意命名、甚至出现模块名称相同的情况</p></li></ul><p>所以，虽然实现了模块化，但是实现过于简单，并且是没有规范的</p><ul><li><p>需要制定一定的规范来约束每个人都按照这个规范去编写模块化的代码</p></li><li><p>这个规范中应该包括核心功能：模块本身可以导出暴露的属性，模块又可以导入自己需要的属性</p></li><li><p>JavaScript社区为了解决上面的问题，涌现出一系列好用的规范，接下来就学习具有代表性的一些规范</p></li></ul><h3 id="2、CommonJS和Node"><a href="#2、CommonJS和Node" class="headerlink" title="2、CommonJS和Node"></a>2、CommonJS和Node</h3><p>CommonJS是一个规范，最初提出来是在浏览器以外的地方使用，并且当时被命名为ServerJS，后来为了体现它的广泛性，修改为CommonJS，平时也会简称为CJS</p><ul><li><p>Node是CommonJS在服务器端一个具有代表性的实现</p></li><li><p>Browserify是CommonJS在浏览器中的一种实现</p></li><li><p>webpack打包工具具备对CommonJS的支持和转换</p></li></ul><p>Node中对CommonJS进行了支持和实现，使得在开发node的过程中可以方便的进行模块化开发</p><ul><li><p>在Node中每一个js文件都是一个单独的模块</p></li><li><p>这个模块中包括CommonJS规范的核心变量：exports、module.exports、require</p></li><li><p>可以使用这些变量来方便的进行模块化开发</p></li></ul><p>前面提到过模块化的核心是导出和导入，Node中对其进行了实现：</p><ul><li><p>exports和module.exports可以负责对模块中的内容进行导出</p></li><li><p>require函数可以帮助我们导入其他模块（自定义模块、系统模块、第三方库模块）中的内容</p></li></ul><h4 id="1-exports-导出（少用）"><a href="#1-exports-导出（少用）" class="headerlink" title="1.exports 导出（少用）"></a>1.exports 导出（少用）</h4><p>注意：exports是一个对象，我们可以在这个对象中添加很多个属性，添加的属性会导出</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">UTIL_NAME</span> = <span class="string">&quot;util_name&quot;</span></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">UTIL_NAME</span> = <span class="variable constant_">UTIL_NAME</span></span><br></pre></td></tr></table></figure><p>另外一个文件中可以导入</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> util = <span class="built_in">require</span>(<span class="string">&quot;./util.js&quot;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(util.<span class="property">UTIL_NAME</span>)</span><br></pre></td></tr></table></figure><p>完成了什么（require 的本质：引用赋值）？</p><ul><li><p>意味着 main 中的 bar 变量等于 exports 对象</p></li><li><p>也就是 require 通过各种查找方式，最终找到了 exports 这个对象</p></li><li><p>并且将这个 exports 对象赋值给了 bar 变量</p></li><li><p>bar 变量就是 exports 对象了</p></li></ul><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230501175035236.png" alt="image-20230501175035236" style="zoom: 33%;" /><h4 id="2-module-exports-导出"><a href="#2-module-exports-导出" class="headerlink" title="2.module.exports 导出"></a>2.module.exports 导出</h4><p>但是Node中经常导出东西的时候，又是通过module.exports导出的：</p><ul><li>module.exports和exports有什么关系或者区别呢？</li></ul><p>追根溯源，通过维基百科中对CommonJS规范的解析</p><ul><li><p>CommonJS中是没有module.exports的概念的</p></li><li><p>但是为了实现模块的导出，Node中使用的是Module的类，每一个模块都是Module的一个实例，也就是module</p></li><li><p>所以在Node中真正用于导出的其实根本不是exports，而是module.exports</p></li><li><p>因为module才是导出的真正实现者</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 结论：Node导出的本质是在导出module.exports对象</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>.<span class="property">name</span> = name</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>.<span class="property">age</span> = age</span><br></pre></td></tr></table></figure><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230501175130500.png" alt="image-20230501175130500" style="zoom:33%;" /><p>但是，为什么exports也可以导出呢？</p><ul><li><p>这是因为 module 对象的 exports 属性是 exports 对象的一个引用</p></li><li><p>也就是说 module.exports &#x3D; exports &#x3D; main 中的 bar</p></li></ul><h4 id="3-开发中常用写法"><a href="#3-开发中常用写法" class="headerlink" title="3.开发中常用写法"></a>3.开发中常用写法</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  name,</span><br><span class="line">  age,</span><br><span class="line">  sayHello</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// exports.name = &#x27;哈哈&#x27; // 无效了</span></span><br><span class="line"><span class="comment">// module.exports.name = &#x27;哈哈&#x27;  // 有效</span></span><br></pre></td></tr></table></figure><p>在这种写法中，就不再像上面两种方式（本质不同了）</p><p>上面两种方式实际是相同的，exports 对象指向的都是同一个内存地址（比如0x100），修改的都是这个对象中的属性</p><p>但是现在这种写法相当于添加了一个新的对象，exports 指向新的内存地址（比如0x200），就不再是原来的内存地址，通过 exports. 修改导出的属性不会生效了，需要通过 module.exports.X 才能找到正确的内存地址，才能对导出的数据进行修改</p><p>改变代码发生了什么？</p><p>1.在三者项目引用的情况下，修改 exports 中的 name 属性到底发生了什么？</p><p>2.在三者引用的情况下，修改了 main 中的 bar 的 name 属性，在 bar 模块中会发生什么？</p><p>3.如果 module.exports 不再引用 exports 对象了，那么修改 exports 还有意义吗？</p><h3 id="3、require函数解析"><a href="#3、require函数解析" class="headerlink" title="3、require函数解析"></a>3、require函数解析</h3><p>require是一个函数，可以帮助我们引入一个文件（模块）中导出的对象</p><p>require的查找规则，导入格式：require(X)</p><p>情况一：X是一个Node核心模块，比如path、http</p><ul><li>直接返回核心模块，并且停止查找</li></ul><p>情况二：X是以 .&#x2F; 或 ..&#x2F; 或 &#x2F;（根目录）开头的</p><ul><li><p>第一步：将X当做一个文件在对应的目录下查找</p><ul><li>1.如果有后缀名，按照后缀名的格式查找对应的文件</li><li>2.如果没有后缀名，会按照如下顺序：<ul><li>1&gt; 直接查找文件X</li><li>2&gt; 查找X.js文件</li><li>3&gt; 查找X.json文件</li><li>4&gt; 查找X.node文件</li></ul></li></ul></li><li><p>第二步：没有找到对应的文件，将X作为一个目录</p><ul><li>查找目录下面的index文件</li><li>1&gt; 查找X&#x2F;index.js文件</li><li>2&gt; 查找X&#x2F;index.json文件</li><li>3&gt; 查找X&#x2F;index.node文件</li></ul></li></ul><p>如果没有找到，那么报错：not found</p><p>情况三：直接是一个X（没有路径），并且X不是一个核心模块</p><ul><li><p>没有 node_modules 文件会往上层查找继续查找，找不到则报错</p></li><li><p>存在该文件，会在 node_modules 文件寻找对应的文件夹下的 index.js 文件</p></li></ul><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230501181302080.png" alt="image-20230501181302080" style="zoom:67%;" /><h4 id="模块的加载过程"><a href="#模块的加载过程" class="headerlink" title="模块的加载过程"></a>模块的加载过程</h4><p>结论一：模块在被第一次引入时，模块中的js代码会被运行一次</p><p>结论二：模块被多次引入时，会缓存，最终只加载（运行）一次</p><p>为什么只会加载运行一次呢？</p><ul><li><p>这是因为每个模块对象module都有一个属性：loaded</p></li><li><p>为false表示还没有加载，为true表示已经加载</p></li></ul><p>结论三：如果有循环引入，那么加载顺序是什么？</p><p>如果出现下图模块的引用关系，那么加载顺序是什么呢？</p><p>这个其实是一种数据结构：图结构</p><ul><li><p>图结构在遍历的过程中，有深度优先搜索（DFS, depth first search）和广度优先搜索（BFS, breadth first search）</p></li><li><p>Node采用的是深度优先算法：main -&gt; aaa -&gt; ccc -&gt; ddd -&gt; eee -&gt;bbb</p></li></ul><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230501180441881.png" alt="image-20230501180441881" style="zoom: 50%;" /><h3 id="4、AMD和CMD（了解）"><a href="#4、AMD和CMD（了解）" class="headerlink" title="4、AMD和CMD（了解）"></a>4、AMD和CMD（了解）</h3><h4 id="1-CommonJS规范缺点"><a href="#1-CommonJS规范缺点" class="headerlink" title="1.CommonJS规范缺点"></a>1.CommonJS规范缺点</h4><p>CommonJS加载模块是同步的：</p><ul><li><p>同步的意味着只有等到对应的模块加载完毕，当前模块中的内容才能被运行</p></li><li><p>这个在服务器不会有什么问题，因为服务器加载的js文件都是本地文件，加载速度非常快</p></li></ul><p>如果将它应用于浏览器</p><ul><li><p>浏览器加载js文件需要先从服务器将文件下载下来，之后再加载运行</p></li><li><p>那么采用同步的就意味着后续的js代码都无法正常运行，即使是一些简单的DOM操作</p></li></ul><p>所以在浏览器中，通常不使用CommonJS规范</p><ul><li><p>当然在webpack中使用CommonJS是另外一回事</p></li><li><p>因为它会将我们的代码转成浏览器可以直接执行的代码</p></li></ul><p>在早期为了可以在浏览器中使用模块化，通常会采用AMD或CMD</p><ul><li><p>但是目前一方面现代的浏览器已经支持ES Modules，另一方面借助于webpack等工具可以实现对CommonJS或者ES Module代码的转换</p></li><li><p>AMD和CMD已经使用非常少了</p></li></ul><h4 id="2-AMD-规范"><a href="#2-AMD-规范" class="headerlink" title="2.AMD 规范"></a>2.AMD 规范</h4><p>AMD主要是应用于浏览器的一种模块化规范：</p><ul><li><p>AMD是Asynchronous Module Definition（异步模块定义）的缩写</p></li><li><p>它采用的是异步加载模块</p></li><li><p>事实上AMD的规范还要早于CommonJS，但是CommonJS目前依然在被使用，而AMD使用的较少</p></li></ul><p>规范只是定义代码的应该如何去编写，只有有了具体的实现才能被应用：</p><ul><li>AMD实现的比较常用的库是require.js和curl.js</li></ul><p>require.js 的使用</p><ul><li><p>第一步：下载require.js</p><ul><li>下载地址：<a href="https://github.com/requirejs/requirejs">https://github.com/requirejs/requirejs</a></li><li>找到其中的require.js文件</li></ul></li><li><p>第二步：定义HTML的script标签引入require.js和定义入口文件</p><ul><li>data-main属性的作用是在加载完src的文件后会加载执行该文件</li></ul></li></ul><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230501181844399.png" alt="image-20230501181844399" style="zoom:67%;" /><h4 id="3-CMD-规范"><a href="#3-CMD-规范" class="headerlink" title="3.CMD 规范"></a>3.CMD 规范</h4><p>CMD规范也是应用于浏览器的一种模块化规范：</p><ul><li><p>CMD 是Common Module Definition（通用模块定义）的缩写</p></li><li><p>它也采用的也是异步加载模块，但是它将CommonJS的优点吸收了过来</p></li><li><p>但是目前CMD使用也非常少了</p></li></ul><p>CMD也有自己比较优秀的实现方案：SeaJS</p><p>SeaJS的使用</p><ul><li><p>第一步：下载SeaJS</p><ul><li>下载地址：<a href="https://github.com/seajs/seajs">https://github.com/seajs/seajs</a></li><li>找到dist文件夹下的sea.js</li></ul></li><li><p>第二步：引入sea.js和使用主入口文件</p><ul><li>seajs是指定主入口文件的</li></ul></li></ul><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230501182050054.png" alt="image-20230501182050054" style="zoom:67%;" /><h3 id="5、ESModule用法详解"><a href="#5、ESModule用法详解" class="headerlink" title="5、ESModule用法详解"></a>5、ESModule用法详解</h3><h4 id="1-前端使用模块化的方案"><a href="#1-前端使用模块化的方案" class="headerlink" title="1.前端使用模块化的方案"></a>1.前端使用模块化的方案</h4><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230507104204048.png" alt="image-20230507104204048" style="zoom:33%;" /><p>JavaScript没有模块化一直是它的痛点，所以才会产生我们前面学习的社区规范：CommonJS、AMD、CMD等，所以在ECMA推出自己的模块化系统时，大家也是兴奋异常</p><p>ES Module和CommonJS的模块化有一些不同之处：</p><ul><li><p>一方面它使用了import和export关键字</p></li><li><p>另一方面它采用编译期的静态分析，并且也加入了动态引用的方式</p></li></ul><p>ES Module模块采用export和import关键字来实现模块化</p><ul><li><p>export负责将模块内的内容导出</p></li><li><p>import负责从其他模块导入内容</p></li></ul><p>了解：采用ES Module将自动采用严格模式：use strict</p><h4 id="2-基本使用"><a href="#2-基本使用" class="headerlink" title="2.基本使用"></a>2.基本使用</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">引入js文件：</span><br><span class="line">&lt;!-- 注意：在我们打开对应的html时，如果html中有使用模块化的代码，必须通过开启本地服务打开 --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./foo.js&quot;</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./main.js&quot;</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>浏览器进行模块化编译需要使用特定的协议，默认打开html的话使用的是file协议，这个协议不支持模块化的加载解析。所以，直接在浏览器中运行代码会报错</p><p>这个在MDN上面有给出解释：</p><ul><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Modules">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Modules</a></p></li><li><p>需要注意本地测试 — 如果通过本地加载Html 文件 (比如一个 file:&#x2F;&#x2F; 路径的文件)，将会遇到 CORS 错误，因为Javascript 模块安全性需要</p></li><li><p>需要通过一个服务器来测试</p></li></ul><p>使用的VSCode插件：Live Server</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">导入导出：</span><br><span class="line">导出</span><br><span class="line"><span class="comment">// 导出的 &#123;&#125; 不是对象了，是特殊的语法</span></span><br><span class="line"><span class="comment">// export &#123; 标识符1, 标识符2, 标识符3 &#125;</span></span><br><span class="line"><span class="keyword">export</span> &#123; name, age, sayHello &#125;</span><br><span class="line">导入</span><br><span class="line"><span class="comment">// 导入 import</span></span><br><span class="line"><span class="comment">// 注意：在浏览器中使用esmodule时，必须在文件后面添加 .js 后缀名</span></span><br><span class="line"><span class="keyword">import</span> &#123; name, age, sayHello &#125; <span class="keyword">from</span> <span class="string">&quot;./foo.js&quot;</span></span><br></pre></td></tr></table></figure><p>问题：在导入的模块如果还是用name的话是不允许的，它已经被定义了，那导入模块怎么定义name</p><h4 id="3-export-关键字"><a href="#3-export-关键字" class="headerlink" title="3.export 关键字"></a>3.export 关键字</h4><p>export 关键字将一个模块中的变量、函数、类等导出</p><p>希望将其他中内容全部导出，它可以有如下的方式</p><ul><li><p>方式一：在语句声明的前面直接加上export关键字</p></li><li><p>方式二：将所有需要导出的标识符，放到export后面的 {}中</p><ul><li>注意：这里的 {}里面不是ES6的对象字面量的增强写法，{}也不是表示一个对象的</li><li>所以： export {name: name}，是错误的写法</li></ul></li><li><p>方式三：导出时给标识符起一个别名</p><ul><li>通过as关键字起别名</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导出方式1：</span></span><br><span class="line"><span class="comment">// export &#123; name, age, sayHello &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出方式2：导出时给我们的标识符起别名 as 关键字</span></span><br><span class="line"><span class="comment">// export &#123;</span></span><br><span class="line"><span class="comment">//   name as fname,</span></span><br><span class="line"><span class="comment">//   age,</span></span><br><span class="line"><span class="comment">//   sayHello</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出方式3：不能起别名</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> name = <span class="string">&quot;why&quot;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> age = <span class="number">18</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">sayHello</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;sayhello&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="4-import-关键字"><a href="#4-import-关键字" class="headerlink" title="4.import 关键字"></a>4.import 关键字</h4><p>import关键字负责从另外一个模块中导入内容</p><p>导入内容的方式也有多种</p><ul><li><p>方式一：import {标识符列表} from ‘模块’</p><ul><li>注意：这里的{}也不是一个对象，里面只是存放导入的标识符列表内容</li></ul></li><li><p>方式二：导入时给标识符起别名</p><ul><li>通过as关键字起别名</li></ul></li><li><p>方式三：通过 * 将模块功能放到一个模块功能对象（a module object）上</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入方式1:import</span></span><br><span class="line"><span class="keyword">import</span> &#123; name, age, sayHello &#125; <span class="keyword">from</span> <span class="string">&quot;./foo.js&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入方式2：导入时给我们的标识符起别名</span></span><br><span class="line"><span class="comment">// import &#123; name as fname, age, sayHello&#125; from &quot;./foo.js&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入方式3：导入时可以给整个模块起别名</span></span><br><span class="line"><span class="comment">// import * as foo from &quot;./foo.js&quot;</span></span><br><span class="line"><span class="comment">// console.log(foo.name)</span></span><br><span class="line"><span class="comment">// console.log(foo.age)</span></span><br><span class="line"><span class="comment">// foo.sayHello()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const name = &#x27;dws&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name)</span><br><span class="line"><span class="comment">// console.log(fname)</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(age)</span><br><span class="line"><span class="title function_">sayHello</span>()</span><br></pre></td></tr></table></figure><p>通过别名就可以在自己模块定义自己的 name</p><h4 id="5-export-与-import-结合使用"><a href="#5-export-与-import-结合使用" class="headerlink" title="5.export 与 import 结合使用"></a>5.export 与 import 结合使用</h4><p>补充：export和import可以结合使用</p><p>为什么要这样做</p><ul><li><p>在开发和封装一个功能库时，通常希望将暴露的所有接口放到一个文件中</p></li><li><p>这样方便指定统一的接口规范，也方便阅读</p></li><li><p>这个时候就可以使用export和import结合使用</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认在工具文件夹中新建index.js文件，将别的工具函数都进行导出</span></span><br><span class="line"><span class="comment">// 在index中进行导入，再导出</span></span><br><span class="line"><span class="comment">// 在使用时就直接从index中进行导入使用即可</span></span><br><span class="line"><span class="number">1.</span>默认导入导出</span><br><span class="line"><span class="comment">// import &#123; formatCount, formatData&#125; from &quot;./format&quot;</span></span><br><span class="line"><span class="comment">// import &#123; parseLyric &#125; from &quot;./parse&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// export &#123;</span></span><br><span class="line"><span class="comment">//   formatCount,</span></span><br><span class="line"><span class="comment">//   formatData,</span></span><br><span class="line"><span class="comment">//   parseLyric</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">优化<span class="number">1</span>：</span><br><span class="line"><span class="comment">// export &#123; formatCount, formatData &#125; from &quot;./format.js&quot;</span></span><br><span class="line"><span class="comment">// export &#123; parseLyric &#125; from &quot;./parse.js&quot;</span></span><br><span class="line"></span><br><span class="line">优化<span class="number">2</span>：</span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">&quot;./format.js&quot;</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">&quot;./parse.js&quot;</span></span><br><span class="line"></span><br><span class="line">使用时导入：</span><br><span class="line"><span class="keyword">import</span> &#123; formatCount, formatData, parseLyric &#125; <span class="keyword">from</span> <span class="string">&quot;./utils/index.js&quot;</span></span><br></pre></td></tr></table></figure><h4 id="6-default-用法"><a href="#6-default-用法" class="headerlink" title="6.default 用法"></a>6.default 用法</h4><p>前面我们学习的导出功能都是有名字的导出（named exports）</p><ul><li><p>在导出 export 时指定了名字</p></li><li><p>在导入 import 时需要知道具体的名字</p></li></ul><p>还有一种导出叫做默认导出（default export）</p><ul><li><p>默认导出 export 时可以不需要指定名字</p></li><li><p>在导入时不需要使用 {}，并且可以自己来指定名字</p></li><li><p>它也方便我们和现有的 CommonJS 等规范相互操作</p></li></ul><p>注意：在一个模块中，只能有一个默认导出（default export）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.1</span> 定义函数</span><br><span class="line"><span class="number">1.2</span> 默认导出定义的函数：</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> parseLyric</span><br><span class="line"><span class="number">2.</span>定义标识符直接作为默认导出</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="string">&quot;新的歌词&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注意事项：一个模块只能有一个默认导出</span></span><br><span class="line"></span><br><span class="line">对于默认导出使用默认导入：</span><br><span class="line"><span class="comment">// import &#123; parseLyric &#125; from &quot;./parseLyric.js&quot;;</span></span><br><span class="line">定义标识符直接默认导出的导入：</span><br><span class="line"><span class="comment">// 引用所使用的标识符是随便取的 parseLyric 这里是可以自己随便定义的，可以取为aaa</span></span><br><span class="line"><span class="keyword">import</span> aaa <span class="keyword">from</span> <span class="string">&quot;./parseLyric.js&quot;</span></span><br></pre></td></tr></table></figure><h4 id="7-import-函数、import-meta"><a href="#7-import-函数、import-meta" class="headerlink" title="7. import 函数、import meta"></a>7. import 函数、import meta</h4><p>通过import加载一个模块，是不可以在其放到逻辑代码中的，比如</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> flag = <span class="literal">true</span></span><br><span class="line"><span class="keyword">if</span>(flag) &#123;</span><br><span class="line">  <span class="comment">// 不允许在逻辑代码中编写import导入语法，只能写到js代码顶层</span></span><br><span class="line">  <span class="keyword">import</span> &#123; name, age, sayHello &#125; <span class="keyword">from</span> <span class="string">&quot;./foo.js&quot;</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(name,age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原因：</p><ul><li><p>这是因为ES Module在被JS引擎解析时，就必须知道它的依赖关系</p></li><li><p>由于这个时候js代码没有任何的运行，所以无法在进行类似于if判断中根据代码的执行情况</p></li><li><p>甚至拼接路径的写法也是错误的：因为我们必须到运行时能确定path的值</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不允许拼接路径</span></span><br><span class="line"><span class="comment">// import &#123; name, age, sayHello&#125; from (&quot;./foo&quot; + &quot;.js&quot;)</span></span><br></pre></td></tr></table></figure><p>但是某些情况下，确实希望动态的来加载某一个模块：</p><ul><li><p>如果根据不同的条件，动态来选择加载模块的路径</p></li><li><p>这个时候我们需要使用 import() 函数来动态加载</p><ul><li>import函数返回一个Promise，可以通过then获取结果</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> flag = <span class="literal">true</span></span><br><span class="line"><span class="keyword">if</span>(flag) &#123;</span><br><span class="line">  <span class="comment">// 如果确实是某些逻辑成立时，才需要导入某个模块</span></span><br><span class="line">  <span class="comment">// import 函数 返回值是一个Promise</span></span><br><span class="line">  <span class="keyword">const</span> importPromise = <span class="keyword">import</span>(<span class="string">&quot;./foo.js&quot;</span>)</span><br><span class="line">  importPromise.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res.<span class="property">name</span>, res.<span class="property">age</span>, res.<span class="title function_">sayHello</span>())</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// import(&quot;./foo.js&quot;).then( res =&gt; &#123;</span></span><br><span class="line">    <span class="comment">// console.log(res.name, res.age, res.sayHello())</span></span><br><span class="line">  <span class="comment">// &#125;)</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;==========&quot;</span>)</span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><p>import.meta是一个给JavaScript模块暴露特定上下文的元数据属性的对象</p><ul><li><p>它包含了这个模块的信息，比如说这个模块的URL</p></li><li><p>在ES11（ES2020）中新增的特性</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">在模块中：</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">import</span>.<span class="property">meta</span>)</span><br><span class="line"><span class="comment">// &#123;url: &#x27;http://127.0.0.1:5500/02-%E5%89%8D%E7%AB%AF%E6%A8%…%E5%8C%96%E5%BC%80%E5%8F%91/10-ESModule-05/foo.js&#x27;, resolve: ƒ&#125;</span></span><br></pre></td></tr></table></figure><h3 id="6、ESModule运行原理"><a href="#6、ESModule运行原理" class="headerlink" title="6、ESModule运行原理"></a>6、ESModule运行原理</h3><p>ES Module 是如何被浏览器解析并且让模块之间可以相互引用的</p><ul><li><a href="https://hacks.mozilla.org/2018/03/es-modules-a-cartoon-deep-dive/">https://hacks.mozilla.org/2018/03/es-modules-a-cartoon-deep-dive/</a></li></ul><p>ES Module的解析过程可以划分为三个阶段：</p><ul><li><p>阶段一：构建（Construction），根据地址查找js文件，并且下载，将其解析成模块记录（Module Record）</p></li><li><p>阶段二：实例化（Instantiation），对模块记录进行实例化，并且分配内存空间，解析模块的导入和导出语句，把模块指向对应的内存地址</p></li><li><p>阶段三：运行（Evaluation），运行代码，计算值，并且将值填充到内存地址中</p></li></ul><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230507104455586.png" alt="image-20230507104455586" style="zoom:50%;" /><p>完整流程</p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230507104522375.png" alt="image-20230507104522375" style="zoom:33%;" /><p>详细流程</p><ul><li>构建阶段</li></ul><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230507104606931.png" alt="image-20230507104606931" style="zoom:33%;" /><ul><li>实例化阶段—求值阶段</li></ul><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230507104654591.png" alt="image-20230507104654591" style="zoom: 25%;" /><h2 id="3-包管理工具详解"><a href="#3-包管理工具详解" class="headerlink" title="3.包管理工具详解"></a>3.包管理工具详解</h2><p>了解代码共享方案</p><p>已经学习了在JavaScript中可以通过模块化的方式将代码划分成一个个小的结构：</p><ul><li><p>在以后的开发中就可以通过模块化的方式来封装自己的代码，并且封装成一个工具</p></li><li><p>这个工具可以让同事通过导入的方式来使用，甚至可以分享给世界各地的程序员来使用</p></li></ul><p>如果分享给所有的程序员使用，有哪些方式</p><ul><li>方式一：上传到GitHub上、其他程序员通过GitHub下载我们的代码手动的引用<ul><li>缺点是大家必须知道你的代码GitHub的地址，并且从GitHub上手动下载</li><li>需要在自己的项目中手动的引用，并且管理相关的依赖</li><li>不需要使用的时候，需要手动来删除相关的依赖</li><li>当遇到版本升级或者切换时，需要重复上面的操作</li></ul></li></ul><p>显然，上面的方式是有效的，但是这种传统的方式非常麻烦，并且容易出错</p><ul><li>方式二：使用一个专业的工具来管理我们的代码<ul><li>通过工具将代码发布到特定的位置</li><li>其他程序员直接通过工具来安装、升级、删除我们的工具代码</li></ul></li></ul><p>通过第二种方式可以更好的管理自己的工具包，其他人也可以更好的使用我们的工具包</p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230507095403415.png" alt="image-20230507095403415" style="zoom: 33%;" /><h3 id="1、npm-包管理工具"><a href="#1、npm-包管理工具" class="headerlink" title="1、npm 包管理工具"></a>1、npm 包管理工具</h3><p>包管理工具npm</p><ul><li>Node Package Manager，也就是Node包管理器</li><li>但是目前已经不仅仅是Node包管理器了，在前端项目中我们也在使用它来管理依赖的包</li><li>比如vue、vue-router、vuex、express、koa、react、react-dom、axios、babel、webpack等</li></ul><p>下载和安装npm工具</p><ul><li>npm属于node的一个管理工具，所以需要先安装Node</li><li>node管理工具：<a href="https://nodejs.org/en/%EF%BC%8C%E5%AE%89%E8%A3%85Node%E7%9A%84%E8%BF%87%E7%A8%8B%E4%BC%9A%E8%87%AA%E5%8A%A8%E5%AE%89%E8%A3%85npm%E5%B7%A5%E5%85%B7">https://nodejs.org/en/，安装Node的过程会自动安装npm工具</a></li></ul><p>npm管理的包可以在哪里查看、搜索</p><ul><li>安装相关的npm包的官网：<a href="https://www.npmjs.org/">https://www.npmjs.org/</a></li></ul><p>npm管理的包存放在哪里</p><ul><li><p>我们发布自己的包其实是发布到 registry 上面的</p></li><li><p>当我们安装一个包时其实是从 registry 上面下载的包</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">安装对应的库：npm install dayjs</span><br><span class="line"><span class="comment">// 使用：</span></span><br><span class="line"><span class="keyword">const</span> dayjs = <span class="built_in">require</span>(<span class="string">&quot;dayjs&quot;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">dayjs</span>())</span><br></pre></td></tr></table></figure><h3 id="2、package-配置文件"><a href="#2、package-配置文件" class="headerlink" title="2、package 配置文件"></a>2、package 配置文件</h3><p>对于一个项目来说，如何使用npm来管理这么多包</p><ul><li><p>事实上，每一个项目都会有一个对应的配置文件，无论是前端项目（Vue、React）还是后端项目（Node）</p></li><li><p>这个配置文件会记录着项目的名称、版本号、项目描述等</p></li><li><p>也会记录着项目所依赖的其他库的信息和依赖库的版本号</p></li><li><p>这个配置文件就是package.json</p></li></ul><p>如何得到这个配置文件</p><ul><li>方式一：手动从零创建项目，npm init –y（-y 表示所有的选项都默认为 yes）</li><li>方式二：通过脚手架创建项目，脚手架会帮助我们生成package.json，并且里面有相关的配置</li></ul><h4 id="1-常见的属性"><a href="#1-常见的属性" class="headerlink" title="1.常见的属性"></a>1.常见的属性</h4><p>必须填写的属性：name、version</p><ul><li>name是项目的名称</li><li>version是当前项目的版本号</li><li>description是描述信息，很多时候是作为项目的基本描述</li><li>author是作者相关信息（发布时用到）</li><li>license是开源协议（发布时用到）</li></ul><p>private属性：</p><ul><li>private属性记录当前的项目是否是私有的</li><li>当值为true时，npm是不能发布它的，这是防止私有项目或模块发布出去的方式</li></ul><p>main属性：</p><ul><li>设置程序的入口<ul><li>比如我们使用axios模块 const axios &#x3D; require(‘axios’)</li><li>如果有main属性，实际上是找到对应的main属性查找文件的</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;main&quot;</span>: <span class="string">&quot;index.js&quot;</span>,</span><br></pre></td></tr></table></figure><p>scripts属性：</p><ul><li><p>scripts属性用于配置一些脚本命令，以键值对的形式存在</p></li><li><p>配置后可以通过 npm run 命令的key来执行这个命令</p></li><li><p>npm start和npm run start的区别是什么</p><ul><li>它们是等价的</li><li>对于常用的 start、 test、stop、restart可以省略掉run直接通过 npm start等方式运行</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;start&quot;</span>: <span class="string">&quot;node ./src/main.js&quot;</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>dependencies属性：</p><ul><li>dependencies属性是指定无论开发环境还是生成环境都需要依赖的包</li><li>通常是我们项目实际开发用到的一些库模块vue、vuex、vue-router、react、react-dom、axios等等</li><li>与之对应的是devDependencies</li><li>在给别人发送自己的代码时，就不需要加上 node_modules 文件夹，可以直接在这查看所需的依赖来进行安装，或者直接 npm install 即可自己安装对应的依赖</li></ul><p>devDependencies属性（开发依赖）：</p><ul><li>一些包在生成环境是不需要的，比如webpack、babel等</li><li>这个时候我们会通过 npm install webpack –save-dev，将它安装到devDependencies属性中</li><li>npm install xxx –save-dev 等价于 npm install xxx -D</li></ul><p>peerDependencies属性：</p><ul><li>还有一种项目依赖关系是对等依赖，也就是你依赖的一个包，它必须是以另外一个宿主包为前提的</li><li>比如element-plus是依赖于vue3的，ant design是依赖于react、react-dom</li></ul><p>engines属性：</p><ul><li><p>engines属性用于指定Node和NPM的版本号</p></li><li><p>在安装的过程中，会先检查对应的引擎版本，如果不符合就会报错</p></li><li><p>事实上也可以指定所在的操作系统 “os” : [ “darwin”, “linux” ]，只是很少用到</p></li></ul><p>browserslist属性：</p><ul><li>用于配置打包后的JavaScript浏览器的兼容情况，参考</li><li>否则我们需要手动的添加polyfills来让支持某些语法</li><li>也就是说它是为webpack等打包工具服务的一个属性</li></ul><h4 id="2-依赖的版本管理"><a href="#2-依赖的版本管理" class="headerlink" title="2.依赖的版本管理"></a>2.依赖的版本管理</h4><p>我们会发现安装的依赖版本出现：^2.0.3或~2.0.3，这是什么意思</p><p>npm的包通常需要遵从semver版本规范：</p><ul><li>semver：<a href="https://semver.org/lang/zh-CN/">https://semver.org/lang/zh-CN/</a></li><li>npm semver：<a href="https://www.npmjs.cn/misc/semver/">https://www.npmjs.cn/misc/semver/</a></li></ul><p>semver版本规范是X.Y.Z：</p><ul><li>X主版本号（major）：当你做了不兼容的 API 修改（可能不兼容之前的版本）</li><li>Y次版本号（minor）：当你做了向下兼容的功能性新增（新功能增加，但是兼容之前的版本）</li><li>Z修订号（patch）：当你做了向下兼容的问题修正（没有新功能，修复了之前版本的bug）</li></ul><p>^和~的区别：</p><ul><li>x.y.z：表示一个明确的版本号</li><li>^x.y.z：表示x是保持不变的，y和z永远安装最新的版本</li><li>~x.y.z：表示x和y保持不变的，z永远安装最新的版本</li></ul><h3 id="3、npm-install-原理"><a href="#3、npm-install-原理" class="headerlink" title="3、npm install 原理"></a>3、npm install 原理</h3><h4 id="1-npm-install-命令"><a href="#1-npm-install-命令" class="headerlink" title="1.npm install 命令"></a>1.npm install 命令</h4><p>安装npm包分两种情况：</p><ul><li>全局安装（global install）： npm install webpack -g</li><li>项目（局部）安装（local install）： npm install webpack</li></ul><p>全局安装</p><ul><li>全局安装是直接将某个包安装到全局</li><li>比如全局安装yarn</li></ul><p>但是很多人对全局安装有一些误会</p><ul><li>通常使用npm全局安装的包都是一些工具包：yarn、webpack等</li><li>并不是类似于 axios、express、koa等库文件</li><li>所以全局安装了之后并不能让我们在所有的项目中使用 axios 等库</li></ul><h4 id="2-项目安装"><a href="#2-项目安装" class="headerlink" title="2.项目安装"></a>2.项目安装</h4><p>项目安装会在当前目录下生成一个 node_modules 文件夹，之前讲解require查找顺序时有讲解过这个包在什么情况下被查找</p><p>局部安装分为开发时依赖和生产时依赖</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">项目安装</span><br><span class="line"># 默认安装开发和生产依赖</span><br><span class="line">npm install axios</span><br><span class="line">npm i axios</span><br><span class="line"># 开发依赖</span><br><span class="line">npm install webpack --save-dev</span><br><span class="line">npm install webpack -D</span><br><span class="line">npm i webpack –D</span><br><span class="line"># 根据package.<span class="property">json</span>中的依赖包</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><h4 id="3-npm-install-原理"><a href="#3-npm-install-原理" class="headerlink" title="3.npm install 原理"></a>3.npm install 原理</h4><p>执行 npm install 它背后帮助我们完成了什么操作？</p><p>我们会发现还有一个称之为 package-lock.json 的文件，它的作用是什么？</p><p>从 npm5 开始，npm 支持缓存策略（来自 yarn 的压力），缓存有什么作用呢？</p><p>npm install 原理图：</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230507152924931.png" alt="image-20230507152924931"></p><p>原理图解析：</p><p>npm install会检测是有package-lock.json文件：</p><ul><li><p>没有lock文件 </p><ul><li>分析依赖关系，这是因为我们可能包会依赖其他的包，并且多个包之间会产生相同依赖的情况</li><li>从registry仓库中下载压缩包（如果设置了镜像，那么会从镜像服务器下载压缩包）</li><li>获取到压缩包后会对压缩包进行缓存（从npm5开始有的）</li><li>将压缩包解压到项目的node_modules文件夹中（require的查找顺序会在该包下面查找）</li></ul></li><li><p>有lock文件</p><ul><li><p>检测lock中包的版本是否和package.json中一致（会按照semver版本规范检测）</p><ul><li>不一致，那么会重新构建依赖关系，直接会走顶层的流程</li></ul></li><li><p>一致的情况下，会去优先查找缓存</p><ul><li>没有找到，会从registry仓库下载，直接走顶层流程</li></ul></li><li><p>查找到，会获取缓存中的压缩文件，并且将压缩文件解压到node_modules文件夹中</p></li></ul></li></ul><h4 id="4-package-lock-json"><a href="#4-package-lock-json" class="headerlink" title="4.package-lock.json"></a>4.package-lock.json</h4><p>package-lock.json文件解析： </p><ul><li><p>name：项目的名称</p></li><li><p>version：项目的版本</p></li><li><p>lockfileVersion：lock文件的版本</p></li><li><p>requires：使用requires来跟踪模块的依赖关系</p></li><li><p>dependencies：项目的依赖</p><ul><li><p>当前项目依赖axios，但是axios依赖follow-redireacts</p></li><li><p>axios中的属性如下：</p><ul><li>version 表示实际安装的 axios 的版本</li><li>resolved 用来记录下载的地址，registry 仓库中的位置</li><li>requires&#x2F;dependencies 记录当前模块的依赖</li><li>integrity 用来从缓存中获取索引，再通过索引去获取压缩包文件</li></ul></li></ul></li></ul><h4 id="5-npm-其他命令"><a href="#5-npm-其他命令" class="headerlink" title="5.npm 其他命令"></a>5.npm 其他命令</h4><p>卸载某个依赖包：</p><ul><li><p>npm uninstall package</p></li><li><p>npm uninstall package –save-dev</p></li><li><p>npm uninstall package -D</p></li></ul><p>强制重新build：npm rebuild</p><p>查看缓存所在文件：npm config get cache</p><p>清除缓存：npm cache clean</p><p>npm的命令官网：</p><ul><li><a href="https://docs.npmjs.com/cli-documentation/cli">https://docs.npmjs.com/cli-documentation/cli</a></li></ul><h3 id="4、yarn、cnpm、npx"><a href="#4、yarn、cnpm、npx" class="headerlink" title="4、yarn、cnpm、npx"></a>4、yarn、cnpm、npx</h3><h4 id="1-yarn-工具"><a href="#1-yarn-工具" class="headerlink" title="1.yarn 工具"></a>1.yarn 工具</h4><p>另一个node包管理工具yarn</p><ul><li>yarn是由Facebook、Google、Exponent 和 Tilde 联合推出了一个新的 JS 包管理工具</li><li>yarn 是为了弥补 早期npm 的一些缺陷而出现的</li><li>早期的npm存在很多的缺陷，比如安装依赖速度很慢、版本依赖混乱等等一系列的问题</li><li>虽然从npm5版本开始，进行了很多的升级和改进，但是依然很多人喜欢使用yarn</li></ul><p>安装 yarn：npm install yarn -g</p><p>使用差异：</p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230507155916441.png" alt="image-20230507155916441" style="zoom: 80%;" /><h4 id="2-cnpm-工具"><a href="#2-cnpm-工具" class="headerlink" title="2.cnpm 工具"></a>2.cnpm 工具</h4><p>由于一些特殊的原因，某些情况下没办法很好的从 <a href="https://registry.npmjs.org下载一些需要的包/">https://registry.npmjs.org下载一些需要的包</a></p><p>查看npm镜像：</p><ul><li>npm config get registry</li></ul><p>可以直接设置npm的镜像：</p><ul><li>npm config set registry <a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a></li></ul><p>但是对于大多数人来说并不希望将 npm 镜像修改了</p><ul><li><p>第一，不太希望随意修改 npm 原本从官方下来包的渠道</p></li><li><p>第二，担心某天淘宝的镜像挂了或者不维护了，又要改来改去</p></li></ul><p>这个时候，可以使用 cnpm，并且将 cnpm 设置为淘宝的镜像：</p><ul><li><p>npm install -g cnpm –registry&#x3D;<a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a> </p></li><li><p>cnpm config get registry</p></li></ul><p>镜像服务器的作用：</p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230507162508281.png" alt="image-20230507162508281" style="zoom: 33%;" /><h4 id="3-npx-工具"><a href="#3-npx-工具" class="headerlink" title="3.npx 工具"></a>3.npx 工具</h4><p>npx是npm5.2之后自带的一个命令</p><ul><li>npx的作用非常多，但是比较常见的是使用它来调用项目中的某个模块的指令</li></ul><p>以webpack为例：</p><ul><li>全局安装的是 webpack5.1.3</li><li>项目安装的是 webpack3.6.0</li></ul><p>如果在终端执行 webpack –version使用的是哪一个命令呢？</p><ul><li>显示结果会是 webpack 5.1.3，事实上使用的是全局的，为什么呢？</li><li>原因非常简单，在当前目录下找不到 webpack 时，就会去全局找，并且执行命令</li></ul><p>当前版本现象：</p><ul><li>使用 cmd 查看 webpack –version 显示的是：全局版本</li><li>在当前项目指定安装的 webpack 查看：当前项目安装的版本</li><li>npx 似乎被集成了</li><li>而早期的时候直接使用 webpack –version 查找当前项目安装的版本时是查找不到的，必须进入当前 node_modules 文件才能查找到</li><li>后面就可以使用 npx 直接查找到 webpack 版本</li></ul><p>出现不同结果原因：</p><ul><li>webpack 包比较特殊</li><li>使用 babel&#x2F;yarn 测试是没有问题的，先在该文件目录下查找，没有则使用全局的</li></ul><p>局部命令的执行</p><p>使用项目（局部）的webpack，常见的是两种方式：</p><ul><li>方式一：明确查找到node_module下面的webpack</li><li>方式二：在 scripts定义脚本，来执行webpack</li></ul><p>方式一：在终端中使用如下命令（在项目根目录下）</p><ul><li>.&#x2F;node_modules&#x2F;.bin&#x2F;webpack –version</li></ul><p>方式二：修改package.json中的scripts</p><ul><li>“scripts”: { “webpack”: “webpack –version” }</li></ul><p>方式三：使用 npx</p><ul><li>npx webpack –version</li></ul><p>npx的原理非常简单，它会到当前目录的node_modules&#x2F;.bin目录下查找对应的命令</p><h3 id="5、发布自己的开发包"><a href="#5、发布自己的开发包" class="headerlink" title="5、发布自己的开发包"></a>5、发布自己的开发包</h3><p>注册npm账号：<a href="https://www.npmjs.com/">https://www.npmjs.com/</a></p><p>在命令行登录：npm login</p><p>修改package.json</p><p>发布到npm registry上：npm publish</p><p>更新仓库：</p><ul><li>1.修改版本号(最好符合semver规范)</li><li>2.重新发布</li></ul><p>删除发布的包：npm unpublish</p><p>让发布的包过期：npm deprecate</p><p>注意：使用命令行登录会跳转到网页，是因为npm的源的问题，需要进行修改，也有可能是node版本的问题(网上有说)</p><h3 id="6、pnpm-使用和原理"><a href="#6、pnpm-使用和原理" class="headerlink" title="6、pnpm 使用和原理"></a>6、pnpm 使用和原理</h3><h4 id="1-什么是-pnpm"><a href="#1-什么是-pnpm" class="headerlink" title="1.什么是 pnpm"></a>1.什么是 pnpm</h4><p>pnpm：可以理解成是performant npm缩写</p><p>特点：</p><ul><li>快速：pnpm 比其它包管理器快两倍</li><li>高效：node_modules 中的文件链接自特定的内容寻址存储库</li><li>支持 monorepos：pnpm 内置支持单仓多包</li><li>严格：pnpm 默认创建了一个非平铺的 node_modules，因此代码无法访问任意包</li></ul><p>包括Vue在内的很多公司或者开源项目的包管理工具都切换到了pnpm</p><h4 id="2-硬链接和软连接的概念"><a href="#2-硬链接和软连接的概念" class="headerlink" title="2.硬链接和软连接的概念"></a>2.硬链接和软连接的概念</h4><p>硬链接（hard link）</p><ul><li><p>硬链接（英语：hard link）是电脑文件系统中的多个文件平等地共享同一个文件存储单元</p></li><li><p>删除一个文件名字后，还可以用其它名字继续访问该文件</p></li></ul><p>符号链接（软链接soft link、Symbolic link）</p><ul><li><p>符号链接（软链接、Symbolic link）是一类特殊的文件</p></li><li><p>其包含有一条以绝对路径或者相对路径的形式指向其它文件或者目录的引用</p></li></ul><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230508095118780.png" alt="image-20230508095118780"></p><h4 id="3-硬链接和软连接的使用"><a href="#3-硬链接和软连接的使用" class="headerlink" title="3.硬链接和软连接的使用"></a>3.硬链接和软连接的使用</h4><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230508141006516.png" alt="image-20230508141006516" style="zoom:67%;" /><h4 id="4-pnpm的作用"><a href="#4-pnpm的作用" class="headerlink" title="4.pnpm的作用"></a>4.pnpm的作用</h4><p>当使用 npm 或 Yarn 时，如果有 100 个项目，并且所有项目都有一个相同的依赖包，那么，在硬盘上就需要保存 100 份该相同依赖包的副本</p><p>如果是使用 pnpm，依赖包将被 存放在一个统一的位置，因此：</p><ul><li>如果你对同一依赖包使用相同的版本，那么磁盘上只有这个依赖包的一份文件</li><li>如果你对同一依赖包需要使用不同的版本，则仅有 版本之间不同的文件会被存储起来</li><li>所有文件都保存在硬盘上的统一的位置：<ul><li>当安装软件包时， 其包含的所有文件都会硬链接到此位置，而不会占用额外的硬盘空间</li><li>这让你可以在项目之间方便地共享相同版本的依赖包</li></ul></li></ul><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230508141033817.png" alt="image-20230508141033817" style="zoom: 67%;" /><p>当使用 npm 或 Yarn Classic 安装依赖包时，所有软件包都将被提升到 node_modules 的 根目录下</p><ul><li>其结果是，源码可以访问本不属于当前项目所设定的依赖包</li></ul><p>pnpm 创建非扁平化的 node_modules 目录</p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230508140816573.png" alt="image-20230508140816573" style="zoom: 67%;" /><h4 id="5-pnpm-的安装和使用"><a href="#5-pnpm-的安装和使用" class="headerlink" title="5.pnpm 的安装和使用"></a>5.pnpm 的安装和使用</h4><p>官网提供了很多种方式来安装pnpm：<a href="https://www.pnpm.cn/installation">https://www.pnpm.cn/installation</a></p><p>因为都安装过Node，Node中有npm，所以通过npm安装即可</p><ul><li>npm install -g pnpm</li></ul><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230508140659540.png" alt="image-20230508140659540"></p><p>参考pnpm的官网：<a href="https://pnpm.io/zh/">https://pnpm.io/zh/</a></p><h4 id="6-pnpm-的存储-store"><a href="#6-pnpm-的存储-store" class="headerlink" title="6.pnpm 的存储 store"></a>6.pnpm 的存储 store</h4><p>在pnpm7.0之前，统一的存储位置是 ~&#x2F;.pnpm-store中的</p><p>在pnpm7.0之后，统一的存储位置进行了更改：<code>&lt;pnpm home directory&gt;</code>&#x2F;store</p><p>可以通过一些终端命令获取这个目录：获取当前活跃的store目录</p><ul><li>pnpm store path</li></ul><p>另外一个非常重要的store命令是prune（修剪）：从store中删除当前未被引用的包来释放store的空间</p><ul><li>pnpm store prune</li></ul><h2 id="4-邂逅Webpack和打包过程"><a href="#4-邂逅Webpack和打包过程" class="headerlink" title="4.邂逅Webpack和打包过程"></a>4.邂逅Webpack和打包过程</h2><p>前端开发的流程</p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230508142918317.png" alt="image-20230508142918317" style="zoom: 33%;" /><h3 id="1、内置模块path"><a href="#1、内置模块path" class="headerlink" title="1、内置模块path"></a>1、内置模块path</h3><p>path模块用于对路径和文件进行处理，提供了很多好用的方法</p><p>在Mac OS、Linux和window上的路径时不一样的</p><ul><li><p>window上会使用 \或者 \ 来作为文件路径的分隔符，目前也支持 &#x2F;</p></li><li><p>在Mac OS、Linux的Unix操作系统上使用 &#x2F; 来作为文件路径的分隔符</p></li></ul><p>那么如果在window上使用来作为分隔符开发了一个应用程序，要部署到Linux上面应该怎么办</p><ul><li><p>显示路径会出现一些问题</p></li><li><p>所以为了屏蔽他们之间的差异，在开发中对于路径的操作可以使用 path 模块</p></li></ul><p>可移植操作系统接口（英语：Portable Operating System Interface，缩写为POSIX）</p><ul><li><p>Linux和Mac OS都实现了POSIX接口</p></li><li><p>Window部分电脑实现了POSIX接口</p></li></ul><p>path常见的API</p><p>从路径中获取信息</p><ul><li><p>dirname：获取文件的父文件夹</p></li><li><p>basename：获取文件名</p></li><li><p>extname：获取文件扩展名</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> filepath = <span class="string">&quot;D://acs/sdx/ad.txt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.可以从一个路径来获取一些信息</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(path.<span class="title function_">extname</span>(filepath))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(path.<span class="title function_">basename</span>(filepath))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(path.<span class="title function_">dirname</span>(filepath))</span><br></pre></td></tr></table></figure><p>路径的拼接：path.join</p><ul><li><p>如果希望将多个路径进行拼接，但是不同的操作系统可能使用的是不同的分隔符</p></li><li><p>这时可以使用path.join函数</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2.将多个路径拼接在一起</span></span><br><span class="line"><span class="keyword">const</span> path1 = <span class="string">&quot;/acs/dsw&quot;</span></span><br><span class="line"><span class="keyword">const</span> path2 = <span class="string">&quot;../dd/wa/dx.txt&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(path.<span class="title function_">join</span>(path1, path2))</span><br></pre></td></tr></table></figure><p>拼接绝对路径：path.resolve</p><ul><li><p>path.resolve() 方法会把一个路径或路径片段的序列解析为一个绝对路径</p></li><li><p>给定的路径的序列是从右往左被处理的，后面每个 path 被依次解析，直到构造完成一个绝对路径</p></li><li><p>如果在处理完所有给定path的段之后，还没有生成绝对路径，则使用当前工作目录</p></li><li><p>生成的路径被规范化并删除尾部斜杠，零长度path段被忽略</p></li><li><p>如果没有path传递段，path.resolve()将返回当前工作目录的绝对路径</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 3.将多个路径拼接在一起，最终一定返回一个绝对路径：path.resolve</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;------------resolve---------------&quot;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(path.<span class="title function_">resolve</span>(path1,path2))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(path.<span class="title function_">resolve</span>(<span class="string">&quot;./sdw/sxx&quot;</span>, <span class="string">&quot; &quot;</span>, <span class="string">&quot;../dww/rwr&quot;</span>, <span class="string">&quot;./dff.txt/&quot;</span>))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(path.<span class="title function_">resolve</span>())</span><br></pre></td></tr></table></figure><p>在webpack中的使用：在webpack中获取路径或者起别名的地方也可以使用</p><h3 id="2、认识-webpack"><a href="#2、认识-webpack" class="headerlink" title="2、认识 webpack"></a>2、认识 webpack</h3><p>随着前端的快速发展，目前前端的开发已经变的越来越复杂了：</p><ul><li><p>比如开发过程中需要通过模块化的方式来开发</p></li><li><p>比如也会使用一些高级的特性来加快开发效率或者安全性，比如通过ES6+、TypeScript开发脚本逻辑，通过sass、less等方式来编写css样式代码</p></li><li><p>比如开发过程中，还希望实时的监听文件的变化来并且反映到浏览器上，提高开发的效率</p></li><li><p>比如开发完成后还需要将代码进行压缩、合并以及其他相关的优化</p></li><li><p>等等….</p></li></ul><p>但是对于很多的前端开发者来说，并不需要思考这些问题，日常的开发中根本就没有面临这些问题</p><ul><li><p>这是因为目前前端开发通常都会直接使用三大框架来开发：Vue、React、Angular</p></li><li><p>但是事实上，这三大框架的创建过程都是借助于脚手架（CLI）的</p></li><li><p>事实上Vue-CLI、create-react-app、Angular-CLI都是基于webpack来帮助我们支持模块化、less、TypeScript、打包优化等的</p></li></ul><p>脚手架依赖于 webpack</p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230508161909817.png" alt="image-20230508161909817" style="zoom:67%;" /><h4 id="1-什么是webpack"><a href="#1-什么是webpack" class="headerlink" title="1.什么是webpack"></a>1.什么是webpack</h4><p>官方解释：webpack is a static module bundler for modern JavaScript applications.</p><p>webpack是一个静态的模块化打包工具，为现代的JavaScript应用程序</p><p>对上面的解释进行拆解：</p><ul><li><p>打包bundler：webpack可以将帮助进行打包，所以它是一个打包工具</p></li><li><p>静态的static：这样表述的原因是最终可以将代码打包成最终的静态资源（部署到静态服务器）</p></li><li><p>模块化module：webpack默认支持各种模块化开发，ES Module、CommonJS、AMD等</p></li><li><p>现代的modern：正是因为现代前端开发面临各种各样的问题，才催生了webpack的出现和发展</p></li></ul><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230508162141066.png" alt="image-20230508162141066" style="zoom: 25%;" /><p>Vue项目加载的文件有哪些</p><ul><li><p>JavaScript的打包：</p><ul><li><p>将ES6转换成ES5的语法</p></li><li><p>TypeScript的处理，将其转换成JavaScript</p></li></ul></li><li><p>Css的处理：</p><ul><li>CSS文件模块的加载、提取</li><li>Less、Sass等预处理器的处理</li></ul></li><li><p>资源文件img、font：</p><ul><li>图片img文件的加载</li><li>字体font文件的加载</li></ul></li><li><p>HTML资源的处理</p><ul><li>打包HTML资源文件</li></ul></li><li><p>处理vue项目的SFC文件.vue文件</p></li></ul><h4 id="2-webpack-的安装"><a href="#2-webpack-的安装" class="headerlink" title="2.webpack 的安装"></a>2.webpack 的安装</h4><p>webpack的官方文档是<a href="https://webpack.js.org/">https://webpack.js.org/</a></p><ul><li><p>webpack的中文官方文档是<a href="https://webpack.docschina.org/">https://webpack.docschina.org/</a></p></li><li><p>DOCUMENTATION：文档详情，也是我们最关注的</p></li></ul><p>Webpack的运行是依赖Node环境的，所以必须有Node环境</p><ul><li>所以需要先安装Node.js，并且同时会安装npm</li></ul><p>Node官方网站：<a href="https://nodejs.org/">https://nodejs.org/</a></p><p>webpack的安装目前分为两个：webpack、webpack-cli（webpack4之后需要安装）</p><p>它们是什么关系</p><ul><li><p>执行webpack命令，会执行node_modules下的.bin目录下的webpack</p></li><li><p>webpack在执行时是依赖webpack-cli的，如果没有安装就会报错</p></li><li><p>而webpack-cli中代码执行时，才是真正利用webpack进行编译和打包的过程</p></li><li><p>所以在安装webpack时，需要同时安装webpack-cli（第三方的脚手架事实上是没有使用webpack-cli的，而是类似于自己的vue-service-cli的东西）</p></li></ul><p>全局安装：npm install webpack webpack-cli -g</p><p>局部安装：npm install webpack webpack-cli -D</p><p>使用最多的是局部安装，因为不同的项目（ts\vue）所依赖的webpack可能是不同的</p><h4 id="3-webpack的默认打包"><a href="#3-webpack的默认打包" class="headerlink" title="3.webpack的默认打包"></a>3.webpack的默认打包</h4><p>可以直接在目录通过webpack命令进行打包，通过html运行打包之后的代码</p><p>生成一个dist文件夹，里面存放一个main.js的文件，就是打包之后的文件：</p><ul><li><p>这个文件中的代码被压缩和丑化了</p></li><li><p>另外代码中依然存在ES6的语法，比如箭头函数、const等，这是因为默认情况下webpack并不清楚打包后的文件是否需要转成ES5之前的语法，后续需要通过babel来进行转换和设置</p></li></ul><p>webpack是如何确定我们的入口的</p><ul><li><p>事实上，当运行webpack时，webpack会查找当前目录下的 src&#x2F;index.js作为入口</p></li><li><p>所以，如果当前项目中没有存在src&#x2F;index.js文件，那么会报错</p></li></ul><p>也可以通过配置来指定入口和出口</p><ul><li>npx webpack –entry .&#x2F;src&#x2F;main.js –output-filename bundle.js –output-path .&#x2F;build</li></ul><p>创建局部的webpack：</p><ul><li>第一步：npm init -y</li><li>第二步：安装局部的webpack</li><li>第三步：使用局部的webpack</li><li>第四步：在package.json中创建script脚本，执行脚本进行打包即可</li></ul><h3 id="3、webpack配置文件"><a href="#3、webpack配置文件" class="headerlink" title="3、webpack配置文件"></a>3、webpack配置文件</h3><p>在通常情况下，webpack需要打包的项目是非常复杂的，并且需要一系列的配置来满足要求，默认配置必然是不可以的</p><p>可以在根目录下创建一个webpack.config.js文件，来作为webpack的配置文件</p><p>默认文件名是固定的：webpack.config.js</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">   <span class="attr">entry</span>: <span class="string">&quot;./src/main.js&quot;</span>,</span><br><span class="line">   <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&quot;bundle.js&quot;</span>,</span><br><span class="line">    <span class="comment">// path 的路径需为绝对路径 </span></span><br><span class="line">    <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&quot;./build&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时可以直接运行：npx webpack 即可</p><p>要是对文件名进行了修改，比如为 wk.config.js</p><p>则运行命令：npx webpack –config wk.config.js</p><p>每次都这么书写命令过于麻烦，可以将其添加到scripts中</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">   <span class="string">&quot;build&quot;</span>: <span class="string">&quot;webpack --config wk.config.js&quot;</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>只需运行：npm run build即可</p><h3 id="4、编写和打包CSS文件"><a href="#4、编写和打包CSS文件" class="headerlink" title="4、编写和打包CSS文件"></a>4、编写和打包CSS文件</h3><h3 id="5、编写和打包Less文件"><a href="#5、编写和打包Less文件" class="headerlink" title="5、编写和打包Less文件"></a>5、编写和打包Less文件</h3><h3 id="6、postcss工具处理CSS"><a href="#6、postcss工具处理CSS" class="headerlink" title="6、postcss工具处理CSS"></a>6、postcss工具处理CSS</h3>]]></content>
      
      
      <categories>
          
          <category> 前端工程化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IT前端 </tag>
            
            <tag> Node </tag>
            
            <tag> Webpack </tag>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法</title>
      <link href="/archives/0.html"/>
      <url>/archives/0.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="数据结构与算法结合-JavaScript"><a href="#数据结构与算法结合-JavaScript" class="headerlink" title="数据结构与算法结合 JavaScript"></a>数据结构与算法结合 JavaScript</h4><h4 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h4><p>数据结构与算法是什么？</p><p>数据结构：计算机存储、组织数据的方式，就像锅碗瓢盆。</p><p>算法：一系列解决问题的清晰指令，就像食谱。</p><p>程序 &#x3D; 数据结构 + 算法</p><p>数据结构为算法提供服务，算法围绕数据结构操作。</p><p>有序：栈、队列、链表</p><p>无需：集合、字典</p><p>树、堆、图</p><h4 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h4><h5 id="时间复杂度计算"><a href="#时间复杂度计算" class="headerlink" title="时间复杂度计算"></a>时间复杂度计算</h5><p>定性描述该算法的运行时间</p><h5 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h5><p>算法在运行过程中临时占用存储空间大小的量度</p><h4 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h4><h5 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h5><p>一个后进先出的数据结构</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> stack = [];</span><br><span class="line">stack.<span class="title function_">push</span>(<span class="number">1</span>);              <span class="comment">//[1]</span></span><br><span class="line">stack.<span class="title function_">push</span>(<span class="number">2</span>);              <span class="comment">//[1,2]</span></span><br><span class="line"><span class="keyword">const</span> item1 = stack.<span class="title function_">pop</span>();   <span class="comment">//[1]</span></span><br><span class="line"><span class="keyword">const</span> item2 = stack.<span class="title function_">pop</span>()    <span class="comment">//[]</span></span><br></pre></td></tr></table></figure><h5 id="栈的应用场景："><a href="#栈的应用场景：" class="headerlink" title="栈的应用场景："></a>栈的应用场景：</h5><p>需要后进先出的场景</p><p>比如：十进制转二进制、判断字符串的括号是否有效、函数调用堆栈…</p><p>例1: 判断括号是否有效：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isValid = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(s.<span class="property">length</span> % <span class="number">2</span> === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> stack = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i&lt;s.<span class="property">length</span>; i+=<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> c = s[i];</span><br><span class="line">        <span class="keyword">if</span>(c === <span class="string">&#x27;(&#x27;</span> || c===<span class="string">&#x27;&#123;&#x27;</span>|| c===<span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">            stack.<span class="title function_">push</span>(c);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> t = stack[stack.<span class="property">length</span> -<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(</span><br><span class="line">                (t === <span class="string">&#x27;(&#x27;</span> &amp;&amp; c ===<span class="string">&#x27;)&#x27;</span>) ||</span><br><span class="line">                (t === <span class="string">&#x27;&#123;&#x27;</span> &amp;&amp; c ===<span class="string">&#x27;&#125;&#x27;</span>) ||</span><br><span class="line">                (t === <span class="string">&#x27;[&#x27;</span> &amp;&amp; c ===<span class="string">&#x27;]&#x27;</span>)</span><br><span class="line">            )&#123;</span><br><span class="line">                stack.<span class="title function_">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.<span class="property">length</span> === <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>例2: 函数调用堆栈</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">func1</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line"><span class="title function_">func2</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">func2</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line"><span class="title function_">func3</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">func3</span> = (<span class="params"></span>) =&gt; &#123;&#125;</span><br><span class="line"><span class="title function_">func1</span>();</span><br></pre></td></tr></table></figure><h4 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h4><h5 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h5><p>一个先进先出的数据结构</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> queue = [];</span><br><span class="line">queue.<span class="title function_">push</span>(<span class="number">1</span>);   <span class="comment">//[1]</span></span><br><span class="line">queue.<span class="title function_">push</span>(<span class="number">2</span>);    <span class="comment">//[1,2]</span></span><br><span class="line"><span class="keyword">const</span> item1 = queue.<span class="title function_">shift</span>();  <span class="comment">//[2]</span></span><br><span class="line"><span class="keyword">const</span> item2 = queue.<span class="title function_">shift</span>();  <span class="comment">//[]</span></span><br></pre></td></tr></table></figure><h5 id="队列的应用场景"><a href="#队列的应用场景" class="headerlink" title="队列的应用场景"></a>队列的应用场景</h5><p>需要先进先出，保证有序性。</p><p>比如食堂买饭、js异步中的任务队列、计算最近请求次数。</p><p>例1：js异步中的任务队列</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>),<span class="number">0</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">先打印<span class="number">2</span> 再打印<span class="number">1</span></span><br></pre></td></tr></table></figure><p>例2:  计算最近请求次数</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">RecentCounter</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">q</span>=[];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">t</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">RecentCounter</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">ping</span> = <span class="keyword">function</span>(<span class="params">t</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">q</span>.<span class="title function_">push</span>(t);</span><br><span class="line">    <span class="keyword">while</span>(<span class="variable language_">this</span>.<span class="property">q</span>[<span class="number">0</span>] &lt; t-<span class="number">3000</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">q</span>.<span class="title function_">shift</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">q</span>.<span class="property">length</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your RecentCounter object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * var obj = new RecentCounter()</span></span><br><span class="line"><span class="comment"> * var param_1 = obj.ping(t)</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h4 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h4><h5 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h5><p>多个元素组成的列表</p><p>元素存储不连续，用 next 指针连在一起。</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20221011201543267.png" alt="image-20221011201543267"></p><h5 id="数组-vs-链表"><a href="#数组-vs-链表" class="headerlink" title="数组 vs 链表"></a>数组 vs 链表</h5><p>数组：增删非首尾元素时往往需要移动元素。</p><p>链表：增删非首尾元素，不需要移动元素，只需要更改 next 的指向即可。</p><p>javascript中没有链表，可以用object模仿。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;<span class="attr">val</span>:<span class="string">&#x27;a&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> b = &#123;<span class="attr">val</span>:<span class="string">&#x27;b&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> c = &#123;<span class="attr">val</span>:<span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> d = &#123;<span class="attr">val</span>:<span class="string">&#x27;d&#x27;</span>&#125;;</span><br><span class="line">a.<span class="property">next</span> = b;</span><br><span class="line">b.<span class="property">next</span> = c;</span><br><span class="line">c.<span class="property">next</span> = d;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历链表</span></span><br><span class="line"><span class="keyword">let</span> p = a;  <span class="comment">// 需声明一个指针指向表头</span></span><br><span class="line"><span class="keyword">while</span>(p)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">val</span>);</span><br><span class="line">p=p.<span class="property">next</span>;</span><br><span class="line">&#125;   <span class="comment">// a b c d</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入</span></span><br><span class="line"><span class="keyword">const</span> e = &#123;<span class="attr">val</span>:<span class="string">&#x27;e&#x27;</span>&#125;;</span><br><span class="line">c.<span class="property">next</span> = e;</span><br><span class="line">e.<span class="property">next</span> = d;    <span class="comment">// a b c e d</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除</span></span><br><span class="line">c.<span class="property">next</span> = d;</span><br></pre></td></tr></table></figure><p>反转链表（206）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">head</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">ListNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverseList = <span class="keyword">function</span>(<span class="params">head</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> p1 = head;</span><br><span class="line">    <span class="keyword">let</span> p2 = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(p1)&#123;</span><br><span class="line">        <span class="keyword">const</span> tmp = p1.<span class="property">next</span>;</span><br><span class="line">        p1.<span class="property">next</span> = p2;</span><br><span class="line">        p2=p1;</span><br><span class="line">        p1=p1.<span class="property">next</span>;</span><br><span class="line">        p1 = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>两数相加（2）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">l1</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">l2</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">ListNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> addTwoNumbers = <span class="keyword">function</span>(<span class="params">l1, l2</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> l3 = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> p1 = l1;</span><br><span class="line">    <span class="keyword">let</span> p2 = l2;</span><br><span class="line">    <span class="keyword">let</span> p3 = l3;</span><br><span class="line">    <span class="keyword">let</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p1 || p2)&#123;</span><br><span class="line">        <span class="keyword">const</span> v1 = p1 ? p1.<span class="property">val</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">const</span> v2 = p2 ? p2.<span class="property">val</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">const</span> val = v1 + v2 + carry;</span><br><span class="line">        carry = <span class="title class_">Math</span>.<span class="title function_">floor</span>(val/<span class="number">10</span>);</span><br><span class="line">        p3.<span class="property">next</span> = <span class="keyword">new</span> <span class="title class_">ListNode</span>(val % <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span>(p1) p1= p1.<span class="property">next</span>;</span><br><span class="line">        <span class="keyword">if</span>(p2) p2 = p2.<span class="property">next</span>;</span><br><span class="line">        p3 = p3.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(carry)&#123;</span><br><span class="line">        p3.<span class="property">next</span> = <span class="keyword">new</span> <span class="title class_">ListNode</span>(carry);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l3.<span class="property">next</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>删除排序链表中的重复元素（83）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">head</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">ListNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> deleteDuplicates = <span class="keyword">function</span>(<span class="params">head</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> p = head;</span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; p.<span class="property">next</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(p.<span class="property">val</span> === p.<span class="property">next</span>.<span class="property">val</span>) &#123;</span><br><span class="line">            p.<span class="property">next</span> = p.<span class="property">next</span>.<span class="property">next</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p = p.<span class="property">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>环形链表（141）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> * @param &#123;<span class="title class_">ListNode</span>&#125; head</span><br><span class="line"> * @<span class="keyword">return</span> &#123;boolean&#125;</span><br><span class="line"> */</span><br><span class="line"><span class="keyword">var</span> hasCycle = <span class="keyword">function</span>(<span class="params">head</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> p1 = head;  <span class="comment">// 快的指针</span></span><br><span class="line">    <span class="keyword">let</span> p2 = head;  <span class="comment">// 慢的指针</span></span><br><span class="line">    <span class="keyword">while</span>(p1 &amp;&amp; p2 &amp;&amp; p2.<span class="property">next</span>) &#123;</span><br><span class="line">        p1=p1.<span class="property">next</span>;</span><br><span class="line">        p2=p2.<span class="property">next</span>.<span class="property">next</span>;</span><br><span class="line">        <span class="keyword">if</span>(p1 === p2)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="前端与链表"><a href="#前端与链表" class="headerlink" title="前端与链表"></a>前端与链表</h5><h5 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h5><p>原型链的本质是链表。</p><p>原型链上的节点是各种原型对象，比如：Function。prototype、Object.prototype….</p><p>原型链通过_ proto_ 属性连接各种原型对象。（不是.next）</p><p>obj -&gt; Object.prototype -&gt; null</p><p>func -&gt; Function.prototype -&gt; Object.prototype -&gt; null</p><p>arr -&gt; Array.prototype -&gt; Object.prototype -&gt; null</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const obj = &#123;&#125;;</span><br><span class="line">const func = () =&gt; &#123;&#125;;</span><br><span class="line">const arr = [];</span><br></pre></td></tr></table></figure><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20221012152006352.png" alt="image-20221012152006352"></p><h5 id="原型链知识点"><a href="#原型链知识点" class="headerlink" title="原型链知识点"></a>原型链知识点</h5><p>如果 A 沿着原型链能找到 B.prototype，那么 A instanceof B 为true。</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20221012151915876.png" alt="image-20221012151915876"></p><p>如果在 A 对象上没有找到 x 属性，那么会沿着原型链找 x 属性。</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20221012152348319.png" alt="image-20221012152348319"></p><p>面试题1：instanceof 的原理，并用代码实现</p><p>知识点：如果A沿着原型链能找到 B.prototype，那么A instanceof B为 true。</p><p>解法：遍历A的原型链，如果找到 B.prototype，返回 true，否则返回 false。</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20221012153221227.png" alt="image-20221012153221227"></p><p>面试题2：</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20221012153435595.png" alt="image-20221012153435595"></p><p>知识点：如果在 A 对象上没有找到 x 属性，那么会沿着原型链找 x 属性。</p><p>解法：明确 foo 和 F 变量的原型链，沿着原型链找 a 属性和 b 属性。</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20221012153840827.png" alt="image-20221012153840827"></p><h5 id="使用链表指针获取-JSON-的节点值"><a href="#使用链表指针获取-JSON-的节点值" class="headerlink" title="使用链表指针获取 JSON 的节点值"></a>使用链表指针获取 JSON 的节点值</h5><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20221012154813607.png" alt="image-20221012154813607"></p><h5 id="技术要点"><a href="#技术要点" class="headerlink" title="技术要点"></a>技术要点</h5><p>链表里的元素存储不是连续的，之间通过 next 连接。</p><p>JavaScript 中没有链表，但可以用 Object 模拟链表。</p><p>链表常用操作：修改 next 、遍历链表。</p><h4 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h4><h5 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h5><p>一种无序且唯一的数据结构。</p><p>ES6中有集合，名为 set。</p><p>集合的常用操作：去重、判断某元素是否在集合中、求交集…</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20221012160819142.png" alt="image-20221012160819142"></p><p>两个数组的交集（349）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums1</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums2</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> intersection = <span class="keyword">function</span>(<span class="params">nums1, nums2</span>) &#123;</span><br><span class="line"><span class="comment">// return [...new Set(nums1)].filter(n =&gt; new Set(nums2).has(n))</span></span><br><span class="line">    <span class="keyword">return</span> [...<span class="keyword">new</span> <span class="title class_">Set</span>(nums1)].<span class="title function_">filter</span>(<span class="function"><span class="params">n</span> =&gt;</span> nums2.<span class="title function_">includes</span>(n))</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="set-操作"><a href="#set-操作" class="headerlink" title="set 操作"></a>set 操作</h5><p>使用 Set 对象：new、add、delete、has、size</p><p>迭代 Set：多种迭代方法、Set 与 Array 互转、求交集&#x2F;差集</p><p>add 方法</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20221012181036153.png" alt="image-20221012181036153"></p><p>has 方法</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20221012181331923.png" alt="image-20221012181331923"></p><p>delete 方法</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20221012181551547.png" alt="image-20221012181551547"></p><p>迭代对象：for_of 方法</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20221012181923579.png" alt="image-20221012181923579"></p><p>keys 方法</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20221012182037679.png" alt="image-20221012182037679"></p><p>value 方法</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20221012182110785.png" alt="image-20221012182110785"></p><p>entries 方法：key 和 value 的值是一样的。</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20221012182309636.png" alt="image-20221012182309636"></p><h5 id="set-和-arr-互转"><a href="#set-和-arr-互转" class="headerlink" title="set 和 arr 互转"></a>set 和 arr 互转</h5><p>set 转换为 arr：（1）</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20221012182518662.png" alt="image-20221012182518662"></p><p>（2）：Array 方法</p><p><img src="C:\Users\王邦辉\AppData\Roaming\Typora\typora-user-images\image-20221012182715677.png" alt="image-20221012182715677"></p><p>arr 转换为 set：</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20221012182949771.png" alt="image-20221012182949771"></p><h5 id="求交集和差集"><a href="#求交集和差集" class="headerlink" title="求交集和差集"></a>求交集和差集</h5><p>交集</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20221012183644381.png" alt="image-20221012183644381"></p><p>差集</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20221012183926481.png" alt="image-20221012183926481"></p><h5 id="技术要点-1"><a href="#技术要点-1" class="headerlink" title="技术要点"></a>技术要点</h5><p>集合是一种无序且唯一的数据结构。</p><p>ES6 中有集合，名为 Set。</p><h4 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h4><h5 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h5><p>与集合类似，字典也是一种存储唯一值的数据结构，但它是以键值对的形式来存储。</p><p>ES6 中有字典，名为 Map。</p><p>字典的常用操作：键值对的增删改查。</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20221012184824452.png" alt="image-20221012184824452"></p><p>删除</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20221012185106637.png" alt="image-20221012185106637"></p><p>改</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20221012185210902.png" alt="image-20221012185210902"></p><p>求数组交集（349）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> intersection = <span class="keyword">function</span>(<span class="params">nums1, nums2</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">    nums1.<span class="title function_">forEach</span>(<span class="function"><span class="params">n</span>=&gt;</span>&#123;</span><br><span class="line">    map.<span class="title function_">set</span>(n,<span class="literal">true</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">const</span> res = [];</span><br><span class="line">    nums2.<span class="title function_">forEach</span>(<span class="function"><span class="params">n</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(map.<span class="title function_">get</span>(n))&#123;</span><br><span class="line">    res.<span class="title function_">push</span>(n);</span><br><span class="line">    map.<span class="title function_">delete</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>有效地括号（优化）（20）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isValid = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(s.<span class="property">length</span> % <span class="number">2</span> === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> stack = [];</span><br><span class="line">    <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">    map.<span class="title function_">set</span>(<span class="string">&#x27;(&#x27;</span>,<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">    map.<span class="title function_">set</span>(<span class="string">&#x27;[&#x27;</span>,<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">    map.<span class="title function_">set</span>(<span class="string">&#x27;&#123;&#x27;</span>,<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i&lt;s.<span class="property">length</span>; i+=<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> c = s[i];</span><br><span class="line">        <span class="keyword">if</span>(map.<span class="title function_">has</span>(c)) &#123;</span><br><span class="line">            stack.<span class="title function_">push</span>(c);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> t = stack[stack.<span class="property">length</span> -<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(map.<span class="title function_">get</span>(t) === c)&#123;</span><br><span class="line">                stack.<span class="title function_">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.<span class="property">length</span> === <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>两数之和（1）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>无重复字符的最长子串（3）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> lengthOfLongestSubstring = <span class="keyword">function</span>(<span class="params">s</span>) &#123; <span class="comment">// 双指针滑动窗口</span></span><br><span class="line">    <span class="keyword">let</span> l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> r = <span class="number">0</span>; r&lt;s.<span class="property">length</span>;r++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(map.<span class="title function_">has</span>(s[r]) &amp;&amp; map.<span class="title function_">get</span>(s[r]) &gt;= l)&#123;</span><br><span class="line">            l = map.<span class="title function_">get</span>(s[r])+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="title class_">Math</span>.<span class="title function_">max</span>(res,r-l+<span class="number">1</span>);</span><br><span class="line">        map.<span class="title function_">set</span>(s[r],r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>最小覆盖子串（76）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">t</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">string</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> minWindow = <span class="keyword">function</span>(<span class="params">s, t</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span>(s.<span class="property">length</span> &lt; t.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> need = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> c <span class="keyword">of</span> t) &#123;</span><br><span class="line">        need.<span class="title function_">set</span>(c,need.<span class="title function_">has</span>(c) ? need.<span class="title function_">get</span>(c)+<span class="number">1</span> :<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> needType = need.<span class="property">size</span>;</span><br><span class="line">    <span class="keyword">while</span>(r &lt; s.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> c = s[r];</span><br><span class="line">        <span class="keyword">if</span>(need.<span class="title function_">has</span>(c))&#123;</span><br><span class="line">            need.<span class="title function_">set</span>(c,need.<span class="title function_">get</span>(c)-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(need.<span class="title function_">get</span>(c) === <span class="number">0</span>) needType--</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(needType === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> newRes = s.<span class="title function_">substring</span>(l,r+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(!res || newRes.<span class="property">length</span> &lt; res.<span class="property">length</span>) res=newRes</span><br><span class="line">            <span class="keyword">const</span>  c2 = s[l];</span><br><span class="line">            <span class="keyword">if</span>(need.<span class="title function_">has</span>(c2)) &#123;</span><br><span class="line">                need.<span class="title function_">set</span>(c2,need.<span class="title function_">get</span>(c2) + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(need.<span class="title function_">get</span>(c2) ===<span class="number">1</span>) needType++;</span><br><span class="line">            &#125;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        r++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="技术要点-2"><a href="#技术要点-2" class="headerlink" title="技术要点"></a>技术要点</h5><p>与集合类似，字典也是一种存储唯一值的数据结构， 但它是以键值对的形式来存储。</p><h4 id="第八章"><a href="#第八章" class="headerlink" title="第八章"></a>第八章</h4><h5 id="树"><a href="#树" class="headerlink" title="树"></a>树</h5><p>一种分层数据的抽象模型</p><p>前端工作中常见的树包括：DOM树、级联选择、树形控件……</p><p>JS中没有树，但是可以用Object和Array构建树</p><p>树的常用操作：深度&#x2F;广度优先遍历、先中后序遍历</p><h5 id="深度-x2F-广度优先遍历"><a href="#深度-x2F-广度优先遍历" class="headerlink" title="深度&#x2F;广度优先遍历"></a>深度&#x2F;广度优先遍历</h5><p>深度优先遍历：尽可能深的搜索树的分支（尽可能访问完每一个分支）</p><p>广度优先遍历：先访问离根节点最近的节点（每层每层的来）</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20221015183033642.png" alt="image-20221015183033642"></p><h5 id="深度优先遍历算法口诀（递归）"><a href="#深度优先遍历算法口诀（递归）" class="headerlink" title="深度优先遍历算法口诀（递归）"></a>深度优先遍历算法口诀（递归）</h5><p>（1）访问根节点</p><p>（2）对根节点的 children 挨个进行深度优先遍历</p><p>树节点：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> tree = &#123;</span><br><span class="line">  <span class="attr">val</span>:<span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">  <span class="attr">children</span>:[</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">val</span>:<span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">      <span class="attr">children</span>:[</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">val</span>:<span class="string">&#x27;d&#x27;</span>,</span><br><span class="line">          <span class="attr">children</span>:[]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">val</span>:<span class="string">&#x27;e&#x27;</span>,</span><br><span class="line">          <span class="attr">children</span>:[]</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">val</span>:<span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">      <span class="attr">children</span>:[</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">val</span>:<span class="string">&#x27;f&#x27;</span>,</span><br><span class="line">          <span class="attr">children</span>:[]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">val</span>:<span class="string">&#x27;g&#x27;</span>,</span><br><span class="line">          <span class="attr">children</span>:[]</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">dfs</span> = (<span class="params">root</span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(root.<span class="property">val</span>);</span><br><span class="line">  root.<span class="property">children</span>.<span class="title function_">forEach</span>(dfs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">dfs</span>(tree);</span><br></pre></td></tr></table></figure><h5 id="广度优先遍历算法口诀"><a href="#广度优先遍历算法口诀" class="headerlink" title="广度优先遍历算法口诀"></a>广度优先遍历算法口诀</h5><p>（1）新建一个队列，把根节点入队</p><p>（2）把队头出队并访问</p><p>（3）把队头的 children 挨个入队</p><p>（4）重复第二、三步，直到队列为空</p><p>代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">bfs</span> = (<span class="params">root</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> q = [root];</span><br><span class="line">  <span class="keyword">while</span>(q.<span class="property">length</span>&gt;<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> n = q.<span class="title function_">shift</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(n.<span class="property">val</span>);</span><br><span class="line">    n.<span class="property">children</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">child</span> =&gt;</span> &#123;</span><br><span class="line">      q.<span class="title function_">push</span>(child);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">bfs</span>(tree);</span><br></pre></td></tr></table></figure><h5 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h5><p>树中每个节点最多只能有两个子节点</p><p>在 JS 中通常用 Object 来模拟二叉树</p><h5 id="二叉树先序遍历算法口诀（递归）（根左右）"><a href="#二叉树先序遍历算法口诀（递归）（根左右）" class="headerlink" title="二叉树先序遍历算法口诀（递归）（根左右）"></a>二叉树先序遍历算法口诀（递归）（根左右）</h5><p>（1）访问根节点</p><p>（2）对根节点的左子树进行先序遍历</p><p>（3）对根节点的右子树进行先序遍历</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20221015185206420.png" alt="image-20221015185206420"></p><p>节点：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> bt = &#123;</span><br><span class="line">  <span class="attr">val</span>:<span class="number">1</span>,</span><br><span class="line">  <span class="attr">left</span>: &#123;</span><br><span class="line">    <span class="attr">val</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="attr">left</span>:&#123;</span><br><span class="line">      <span class="attr">val</span>:<span class="number">4</span>,</span><br><span class="line">      <span class="attr">left</span>:<span class="literal">null</span>,</span><br><span class="line">      <span class="attr">right</span>:<span class="literal">null</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">right</span>:&#123;</span><br><span class="line">      <span class="attr">val</span>:<span class="number">5</span>,</span><br><span class="line">      <span class="attr">left</span>:<span class="literal">null</span>,</span><br><span class="line">      <span class="attr">right</span>:<span class="literal">null</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">right</span>:&#123;</span><br><span class="line">    <span class="attr">val</span>:<span class="number">3</span>,</span><br><span class="line">    <span class="attr">left</span>:&#123;</span><br><span class="line">      <span class="attr">val</span>:<span class="number">6</span>,</span><br><span class="line">      <span class="attr">left</span>:<span class="literal">null</span>,</span><br><span class="line">      <span class="attr">right</span>:<span class="literal">null</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">right</span>:&#123;</span><br><span class="line">      <span class="attr">val</span>:<span class="number">7</span>,</span><br><span class="line">      <span class="attr">left</span>:<span class="literal">null</span>,</span><br><span class="line">      <span class="attr">right</span>:<span class="literal">null</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = bt;</span><br></pre></td></tr></table></figure><p>代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> bt = <span class="built_in">require</span>(<span class="string">&#x27;./bt&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">preorder</span> = (<span class="params">root</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span>(!root) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(root.<span class="property">val</span>);</span><br><span class="line">  <span class="title function_">preorder</span>(root.<span class="property">left</span>);</span><br><span class="line">  <span class="title function_">preorder</span>(root.<span class="property">right</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">preorder</span>(bt);</span><br></pre></td></tr></table></figure><h5 id="二叉树中序遍历算法口诀（递归）"><a href="#二叉树中序遍历算法口诀（递归）" class="headerlink" title="二叉树中序遍历算法口诀（递归）"></a>二叉树中序遍历算法口诀（递归）</h5><p>（1）对根节点的左子树进行中序遍历</p><p>（2）访问根节点</p><p>（3）对根节点的右子树进行中序遍历</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20221015193416827.png" alt="image-20221015193416827"></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> bt = <span class="built_in">require</span>(<span class="string">&#x27;./bt&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">inorder</span> = (<span class="params">root</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span>(!root) &#123;<span class="keyword">return</span>;&#125;</span><br><span class="line">  <span class="title function_">inorder</span>(root.<span class="property">left</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(root.<span class="property">val</span>);</span><br><span class="line">  <span class="title function_">inorder</span>(root.<span class="property">right</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">inorder</span>(bt);</span><br></pre></td></tr></table></figure><h5 id="二叉树后序遍历算法口诀（递归）（左右根）"><a href="#二叉树后序遍历算法口诀（递归）（左右根）" class="headerlink" title="二叉树后序遍历算法口诀（递归）（左右根）"></a>二叉树后序遍历算法口诀（递归）（左右根）</h5><p>（1）对根节点的左子树进行后序遍历</p><p>（2）对根节点的右子树进行后序遍历</p><p>（3）访问根节点</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20221016101116303.png" alt="image-20221016101116303"></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> bt = <span class="built_in">require</span>(<span class="string">&#x27;./bt&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">postorder</span> = (<span class="params">root</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span>(!root) &#123;<span class="keyword">return</span>;&#125;</span><br><span class="line">  <span class="title function_">postorder</span>(root.<span class="property">left</span>);</span><br><span class="line">  <span class="title function_">postorder</span>(root.<span class="property">right</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(root.<span class="property">val</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">postorder</span>(bt);</span><br></pre></td></tr></table></figure><h5 id="二叉树的先序遍历（非递归）"><a href="#二叉树的先序遍历（非递归）" class="headerlink" title="二叉树的先序遍历（非递归）"></a>二叉树的先序遍历（非递归）</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">preorder</span> = (<span class="params">root</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span>(!root) &#123;<span class="keyword">return</span>;&#125;</span><br><span class="line">  <span class="keyword">const</span> stack = [root];</span><br><span class="line">  <span class="keyword">while</span>(stack.<span class="property">length</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> n = stack.<span class="title function_">pop</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(n.<span class="property">val</span>);</span><br><span class="line">    <span class="keyword">if</span>(n.<span class="property">right</span>) stack.<span class="title function_">push</span>(n.<span class="property">right</span>);</span><br><span class="line">    <span class="keyword">if</span>(n.<span class="property">left</span>) stack.<span class="title function_">push</span>(n.<span class="property">left</span>);</span><br><span class="line">  &#125; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">preorder</span>(bt);</span><br></pre></td></tr></table></figure><h5 id="二叉树的中序遍历（非递归）"><a href="#二叉树的中序遍历（非递归）" class="headerlink" title="二叉树的中序遍历（非递归）"></a>二叉树的中序遍历（非递归）</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">inorder</span> = (<span class="params">root</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span>(!root) &#123;<span class="keyword">return</span>;&#125;</span><br><span class="line">  <span class="keyword">const</span> stack = [];</span><br><span class="line">  <span class="keyword">let</span> p = root;</span><br><span class="line">  <span class="keyword">while</span>(stack.<span class="property">length</span> || p) &#123;</span><br><span class="line">    <span class="keyword">while</span>(p) &#123;</span><br><span class="line">      stack.<span class="title function_">push</span>(p)</span><br><span class="line">      p = p.<span class="property">left</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> n = stack.<span class="title function_">pop</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(n.<span class="property">val</span>);</span><br><span class="line">    p = n.<span class="property">right</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">inorder</span>(bt);</span><br></pre></td></tr></table></figure><h5 id="二叉树的后序遍历（非递归）"><a href="#二叉树的后序遍历（非递归）" class="headerlink" title="二叉树的后序遍历（非递归）"></a>二叉树的后序遍历（非递归）</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">postorder</span> = (<span class="params">root</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span>(!root) &#123;<span class="keyword">return</span>;&#125;</span><br><span class="line">  <span class="keyword">const</span> stack = [root];</span><br><span class="line">  <span class="keyword">const</span> outputStack = [];</span><br><span class="line">  <span class="keyword">while</span>(stack.<span class="property">length</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> n = stack.<span class="title function_">pop</span>();</span><br><span class="line">    outputStack.<span class="title function_">push</span>(n)</span><br><span class="line">    <span class="keyword">if</span>(n.<span class="property">left</span>) stack.<span class="title function_">push</span>(n.<span class="property">left</span>);</span><br><span class="line">    <span class="keyword">if</span>(n.<span class="property">right</span>) stack.<span class="title function_">push</span>(n.<span class="property">right</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(outputStack.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> n = outputStack.<span class="title function_">pop</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(n.<span class="property">val</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">postorder</span>(bt);</span><br></pre></td></tr></table></figure><p>二叉树的最大深度（104）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxDepth = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">dfs</span> = (<span class="params">n,l</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span>(!n) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line">        <span class="keyword">if</span>(!n.<span class="property">left</span> &amp;&amp; !n.<span class="property">right</span>) &#123;</span><br><span class="line">            res = <span class="title class_">Math</span>.<span class="title function_">max</span>(res, l)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">dfs</span>(n.<span class="property">left</span>,l+<span class="number">1</span>);</span><br><span class="line">        <span class="title function_">dfs</span>(n.<span class="property">right</span>,l+<span class="number">1</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="title function_">dfs</span>(root,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>二叉树的最小深度（111）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IT前端 </tag>
            
            <tag> JavaScript </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git的基本使用</title>
      <link href="/archives/163a8691.html"/>
      <url>/archives/163a8691.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Github社区基本使用"><a href="#Github社区基本使用" class="headerlink" title="Github社区基本使用"></a>Github社区基本使用</h2><h3 id="Git基础概念"><a href="#Git基础概念" class="headerlink" title="Git基础概念"></a>Git基础概念</h3><h4 id="Git-的特性"><a href="#Git-的特性" class="headerlink" title="Git 的特性"></a>Git 的特性</h4><p>Git 是一个开源的分布式版本控制系统，是目前世界上最先进、最流行的版本控制系统。可以快速高效地处理从很小到非常大的项目版本管理。</p><p>特点：项目越大越复杂，协同开发者越多，越能体现出 Git 的高性能和高可用性！</p><h5 id="Git-之所以快速和高效，主要依赖于它的如下两个特性："><a href="#Git-之所以快速和高效，主要依赖于它的如下两个特性：" class="headerlink" title="Git 之所以快速和高效，主要依赖于它的如下两个特性："></a>Git 之所以快速和高效，主要依赖于它的如下两个特性：</h5><p>①直接记录快照，而非差异比较</p><p>②近乎所有操作都是本地执行</p><h5 id="SVN-的差异比较"><a href="#SVN-的差异比较" class="headerlink" title="SVN 的差异比较"></a>SVN 的差异比较</h5><p>传统的版本控制系统（例如 SVN）是基于差异的版本控制，它们存储的是一组基本文件和每个文件随时间逐步累积的差异。</p><p>好处：节省磁盘空间</p><p>缺点：耗时、效率低</p><p>​在每次切换版本的时候，都需要在基本文件的基础上，应用每个差异，从而生成目标版本对应的文件。</p><p><strong>Git</strong> <strong>的记录快照</strong></p><p>Git 快照是在原有文件版本的基础上重新生成一份新的文件，类似于备份。为了效率，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。</p><p>缺点：占用磁盘空间较大</p><p>优点：版本切换时非常快，因为每个版本都是完整的文件快照，切换版本时直接恢复目标版本的快照即可。</p><p>特点：空间换时间</p><h5 id="近乎所有操作都是本地执行"><a href="#近乎所有操作都是本地执行" class="headerlink" title="近乎所有操作都是本地执行"></a>近乎所有操作都是本地执行</h5><p>在 Git 中的绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其它计算机的信息。</p><p>特性：</p><p>①断网后依旧可以在本地对项目进行版本管理</p><p>②联网后，把本地修改的记录同步到云端服务器即可</p><h5 id="Git-中的三个区域"><a href="#Git-中的三个区域" class="headerlink" title="Git 中的三个区域"></a>Git 中的三个区域</h5><p>使用 Git 管理的项目，拥有三个区域，分别是工作区（处理工作的区域）、暂存区（已完成的工作的临时存放区域，等待被提交）、Git 仓库（最终的存放区域）。</p><h5 id="Git-中的三种状态"><a href="#Git-中的三种状态" class="headerlink" title="Git 中的三种状态"></a>Git 中的三种状态</h5><p>已修改：表示修改了文件，但还没将修改的结果放到暂存区</p><p>已暂存：表示对已修改文件的当前版本做了标记，使之包含在下次提交的列表中</p><p>已提交：表示文件已经安全地保存在本地的 Git 仓库中</p><p>注意：</p><p>工作区的文件被修改了，但还没有放到暂存区，就是已修改状态。</p><p>如果文件已修改并放入暂存区，就属于已暂存状态。</p><p>如果 Git 仓库中保存着特定版本的文件，就属于已提交状态。</p><h5 id="基本的-Git-工作流程如下"><a href="#基本的-Git-工作流程如下" class="headerlink" title="基本的 Git 工作流程如下"></a>基本的 Git 工作流程如下</h5><p>①在工作区中修改文件</p><p>②将你想要下次提交的更改进行暂存</p><p>③提交更新，找到暂存区的文件，将快照永久性存储到 Git 仓库</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>​在开始使用 Git 管理项目的版本之前，需要将它安装到计算机上。可以使用浏览器访问如下的网址，根据自己的操作系统，选择下载对应的 Git 安装包：</p><p><a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a></p><h4 id="配置用户信息"><a href="#配置用户信息" class="headerlink" title="配置用户信息"></a>配置用户信息</h4><p>​安装完 Git 之后，要做的第一件事就是设置自己的用户名和邮件地址。因为通过 Git 对项目进行版本管理的时候，Git 需要使用这些基本信息，来记录是谁对项目进行了操作：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;wangbanghui&quot;</span><br><span class="line">git config --global user.email &quot;546836216@qq.com&quot;</span><br></pre></td></tr></table></figure><p>注意：如果使用了 –global 选项，那么该命令只需要运行一次，即可永久生效。</p><p>​通过 git config –global user.name 和 git config –global user.email 配置的用户名和邮箱地址，会被写入到 C:&#x2F;Users&#x2F;用户名文件夹&#x2F;.gitconfig 文件中。这个文件是 Git 的全局配置文件，配置一次即可永久生效。</p><p>可以使用记事本打开此文件，从而查看自己曾经对 Git 做了哪些全局性的配置。</p><p>除了使用记事本查看全局的配置信息之外，还可以运行如下的终端命令，快速的查看 Git 的全局配置信息：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查看所有的全局配置项</span><br><span class="line">git config --list --global</span><br><span class="line"># 查看指定的全局配置项</span><br><span class="line">git config user.name</span><br><span class="line">git config user.email</span><br></pre></td></tr></table></figure><p>可以使用 git help <verb> 命令，无需联网即可在浏览器中打开帮助手册，例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 要想打开 git config 命令的帮助手册</span><br><span class="line">git help config</span><br></pre></td></tr></table></figure><p>如果不想查看完整的手册，那么可以用 -h 选项获得更简明的“help”输出：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config -h</span><br></pre></td></tr></table></figure><h4 id="Git-的基本操作"><a href="#Git-的基本操作" class="headerlink" title="Git 的基本操作"></a>Git 的基本操作</h4><h5 id="获取-Git-仓库的两种方式"><a href="#获取-Git-仓库的两种方式" class="headerlink" title="获取 Git 仓库的两种方式"></a>获取 Git 仓库的两种方式</h5><p>①将尚未进行版本控制的本地目录转换为 Git 仓库</p><p>②从其它服务器克隆一个已存在的 Git 仓库</p><p>以上两种方式都能够在自己的电脑上得到一个可用的 Git 仓库</p><h5 id="在现有目录中初始化仓库"><a href="#在现有目录中初始化仓库" class="headerlink" title="在现有目录中初始化仓库"></a>在现有目录中初始化仓库</h5><p>如果自己有一个尚未进行版本控制的项目目录，想要用 Git 来控制它，需要执行如下两个步骤：</p><p>①在项目目录中，通过鼠标右键打开“Git Bash”</p><p>②执行 git init 命令将当前的目录转化为 Git 仓库</p><p>git init 命令会创建一个名为 .git 的隐藏目录，这个 .git 目录就是当前项目的 Git 仓库，里面包含了初始的必要文件，这些文件是 Git 仓库的必要组成部分。</p><h5 id="工作区中文件的-4-种状态"><a href="#工作区中文件的-4-种状态" class="headerlink" title="工作区中文件的 4 种状态"></a>工作区中文件的 4 种状态</h5><p>工作区中的每一个文件可能有 4 种状态，这四种状态共分为两大类，</p><p>未跟踪（Untracked）：不被 Git 所管理的文件</p><p>未修改（Unmodified）：工作区中文件的内容和 Git 仓库中文件的内容保持一致</p><p>已修改（Modified）：工作区中文件的内容和 Git 仓库中文件的内容不一致</p><p>已暂存（Staged）：工作区中被修改的文件已被放到暂存区，准备将修改后的文件保存到 Git 仓库中</p><p>Git 操作的终极结果：让工作区中的文件都处于“未修改”的状态。</p><h5 id="检查文件的状态"><a href="#检查文件的状态" class="headerlink" title="检查文件的状态"></a>检查文件的状态</h5><p>可以使用 git status 命令查看文件处于什么状态</p><p>以精简的方式显示文件状态</p><p>使用 git status 输出的状态报告很详细，但有些繁琐。如果希望以精简的方式显示文件的状态，可以使用如下两条完全等价的命令，其中 <strong>-s</strong> 是 <strong>–short</strong> 的简写形式：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git status -s</span><br><span class="line">git status --short</span><br></pre></td></tr></table></figure><p>未跟踪文件前面有红色的 ?? 标记</p><h5 id="跟踪新文件"><a href="#跟踪新文件" class="headerlink" title="跟踪新文件"></a>跟踪新文件</h5><p>使用命令 git add 开始跟踪一个文件。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add index.html</span><br></pre></td></tr></table></figure><p>此时再运行 git status 命令，会看到 indegit sat.html 文件在 Changes to be committed 这行的下面，说明已被跟踪，并处于暂存状态。</p><p>以精简的方式显示文件的状态：新添加到暂存区中的文件前面有绿色的 A 标记</p><h5 id="提交更新"><a href="#提交更新" class="headerlink" title="提交更新"></a>提交更新</h5><p>现在暂存区中有一个 index.html 文件等待被提交到 Git 仓库中进行保存。可以执行 git commit 命令进行提交,其中 -m 选项后面是本次的提交消息，用来对提交的内容做进一步的描述。提交成功之后，会显示信息：新建了 index.html 文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit -m &quot;新建了index.html文件&quot;</span><br></pre></td></tr></table></figure><p>提交成之后，再次检查文件的状态：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">On branch master</span><br><span class="line">nothing to commit,working tree clean</span><br></pre></td></tr></table></figure><p>证明工作区中所有的文件都处于“未修改”的状态，没有任何文件需要被提交。</p><h5 id="对已提交的文件进行修改"><a href="#对已提交的文件进行修改" class="headerlink" title="对已提交的文件进行修改"></a>对已提交的文件进行修改</h5><p>目前，index.html 文件已经被 Git 跟踪，并且工作区和 Git 仓库中的 index.html 文件内容保持一致。当我们修改了工作区中 index.html 的内容之后，再次运行 git status 和 git status -s 命令，会看到如下的内容：</p><p>文件 index.html 出现在 Changes not staged for commit 这行下面，说明已跟踪文件的内容发生了变化，但还没有放到暂存区。</p><p>注意：修改过的、没有放入暂存区的文件前面有红色的 M 标记。</p><h5 id="暂存已修改的文件"><a href="#暂存已修改的文件" class="headerlink" title="暂存已修改的文件"></a>暂存已修改的文件</h5><p>目前，工作区中的 index.html 文件已被修改，如果要暂存这次修改，需要再次运行 git add 命令，这个命令是个多功能的命令，主要有如下 3 个功效：</p><p>① 可以用它开始跟踪新文件</p><p>② 把已跟踪的、且已修改的文件放到暂存区</p><p>③ 把有冲突的文件标记为已解决状态</p><h5 id="提交已暂存的文件"><a href="#提交已暂存的文件" class="headerlink" title="提交已暂存的文件"></a>提交已暂存的文件</h5><p>再次运行 git commit -m “提交消息” 命令，即可将暂存区中记录的 index.html 的快照，提交到 Git 仓库中进行保存：</p><h5 id="撤销对文件的修改"><a href="#撤销对文件的修改" class="headerlink" title="撤销对文件的修改"></a>撤销对文件的修改</h5><p>撤销对文件的修改指的是：把对工作区中对应文件的修改，还原成 Git 仓库中所保存的版本。</p><p>操作的结果：所有的修改会丢失，且无法恢复！危险性比较高，请慎重操作！</p><p>撤销操作的本质：用 Git 仓库中保存的文件，覆盖工作区中指定的文件。</p><h5 id="向暂存区中一次性添加多个文件"><a href="#向暂存区中一次性添加多个文件" class="headerlink" title="向暂存区中一次性添加多个文件"></a>向暂存区中一次性添加多个文件</h5><p>如果需要被暂存的文件个数比较多，可以使用如下的命令，一次性将所有的新增和修改过的文件加入暂存区：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure><p>今后在项目开发中，会经常使用这个命令，将新增和修改过后的文件加入暂存区。</p><h5 id="取消暂存的文件"><a href="#取消暂存的文件" class="headerlink" title="取消暂存的文件"></a>取消暂存的文件</h5><p>如果需要从暂存区中移除对应的文件，可以使用如下的命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git reset HEAD 要移除的文件名</span><br></pre></td></tr></table></figure><h5 id="跳过使用暂存区域"><a href="#跳过使用暂存区域" class="headerlink" title="跳过使用暂存区域"></a>跳过使用暂存区域</h5><p>Git 标准的工作流程是工作区 → 暂存区 → Git 仓库，但有时候这么做略显繁琐，此时可以跳过暂存区，直接将工作区中的修改提交到 Git 仓库，这时候 Git 工作的流程简化为了工作区 → Git 仓库。</p><p>Git 提供了一个跳过使用暂存区域的方式， 只要在提交的时候，给 git commit 加上 -a 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 git add 步骤：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git  commit -a -m &quot;描述信息&quot;</span><br></pre></td></tr></table></figure><h5 id="移除文件"><a href="#移除文件" class="headerlink" title="移除文件"></a>移除文件</h5><p>从 Git 仓库中移除文件的方式有两种：</p><p>①从 Git 仓库和工作区中同时移除对应的文件</p><p>②只从 Git 仓库中移除指定的文件，但保留工作区中对应的文件</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"># 从 Git 仓库和工作区中同时移除 index.js 文件</span><br><span class="line">git rm -f index.js</span><br><span class="line"># 只从 Git 仓库中移除 index.css 但保留工作区中的 index.css 文件</span><br><span class="line">git rm --cached index.css</span><br></pre></td></tr></table></figure><h5 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h5><p>一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。 在这种情况下，我们可以创建一个名为 .gitignore 的配置文件，列出要忽略的文件的匹配模式。</p><p>文件 .gitignore 的格式规范如下：</p><p>①以 # 开头的是注释</p><p>②以 &#x2F; 结尾的是目录</p><p>③以 &#x2F; 开头防止递归</p><p>④以 ! 开头表示取反</p><p>⑤可以使用 glob 模式进行文件和文件夹的匹配（glob 指简化了的正则表达式）</p><h5 id="glob-模式"><a href="#glob-模式" class="headerlink" title="glob 模式"></a>glob 模式</h5><p>所谓的 glob 模式是指简化了的正则表达式：</p><p>① <strong>星号 *</strong> 匹配零个或多个任意字符</p><p>② <strong>[abc]</strong> 匹配任何一个列在方括号中的字符 （此案例匹配一个 a 或匹配一个 b 或匹配一个 c）</p><p>③ <strong>问号</strong> <strong>?</strong> 只匹配一个任意字符</p><p>④ 在方括号中使用<strong>短划线</strong>分隔两个字符， 表示所有在这两个字符范围内的都可以匹配（比如 [0-9] 表示匹配所有 0 到 9 的数字）</p><p>⑤ <strong>两个星号 *</strong>* 表示匹配任意中间目录（比如 a&#x2F;**&#x2F;z 可以匹配 a&#x2F;z 、 a&#x2F;b&#x2F;z 或 a&#x2F;b&#x2F;c&#x2F;z 等）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 忽略所有的.a文件</span><br><span class="line">*.a</span><br><span class="line"># 但跟踪所有的lib.a, 即便你在前面忽略了.a文件</span><br><span class="line">!lib.a</span><br><span class="line"># 只忽略当前目录下的TODO文件，而不忽略subdir/TODO </span><br><span class="line">/TODO</span><br><span class="line"># 忽略任何目录下名为build的文件夹</span><br><span class="line">build/</span><br><span class="line"># 忽略doc/notes.txt,但不忽略doc/server/arch.txt</span><br><span class="line">doc/*.txt</span><br><span class="line"># 忽略doc/目录及其所有子目录下的.pdf文件</span><br><span class="line">doc/**/*.pdf</span><br></pre></td></tr></table></figure><h5 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h5><p>如果希望回顾项目的提交历史，可以使用 git log 这个简单且有效的命令</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 按时间先后顺序列出所有的提交历史，最近的提交排在最上面</span><br><span class="line">git log</span><br><span class="line"># 只展示最新的两条提交历史，数字可以按需进行填写</span><br><span class="line">git log -2</span><br><span class="line"># 在一行上展示最近两条提交历史的信息</span><br><span class="line">git log -2 --pretty=oneline</span><br><span class="line"># 在一行上展示最近两条提交历史的信息，并自定义输出的格式</span><br><span class="line"># %h提交的简写哈希值  %an作者名字  %ar作者修订日期，按多久以前的方式显示  %s提交说明</span><br><span class="line">git log -2 --pretty=format:&quot;%h | %an | %ar | %s&quot;</span><br></pre></td></tr></table></figure><h5 id="回退到指定的版本"><a href="#回退到指定的版本" class="headerlink" title="回退到指定的版本"></a>回退到指定的版本</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 在一行上展示所有的提交历史</span><br><span class="line">git log --pretty=oneline</span><br><span class="line"># 使用git reset --hard 命令，根据指定的提交ID回退到指定版本</span><br><span class="line">git reset --hard &lt;CommitID&gt; </span><br><span class="line"># 在旧版本中使用git reflog --pretty=oneline 命令，查看命令操作的历史</span><br><span class="line">git reflog --pretty=oneline</span><br><span class="line"># 再次根据最新的提交ID, 跳转到最新的版本</span><br><span class="line">git reset --hard &lt;CommitID&gt;</span><br></pre></td></tr></table></figure><h5 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h5><p>① 初始化 Git 仓库的命令</p><p>git init</p><p>② 查看文件状态的命令</p><p>git status 或 git status -s</p><p>③ 一次性将文件加入暂存区的命令</p><p>git add .</p><p>④ 将暂存区的文件提交到 Git 仓库的命令</p><p>git commit -m “提交消息”</p><h3 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h3><h5 id="开源许可协议"><a href="#开源许可协议" class="headerlink" title="开源许可协议"></a>开源许可协议</h5><p>开源并不意味着完全没有限制，为了限制使用者的使用范围和保护作者的权利，每个开源项目都应该遵守开源许可协议（ Open Source License ）。</p><p>常见的 5 种开源许可协议</p><p>① BSD（Berkeley Software Distribution）</p><p>② Apache Licence 2.0</p><p>③ <strong>GPL</strong>（GNU General Public License）</p><p>​具有传染性的一种开源协议，不允许修改后和衍生的代码做为闭源的商业软件发布和销售</p><p>​使用 GPL 的最著名的软件项目是：Linux</p><p>④ LGPL（GNU Lesser General Public License）</p><p>⑤ <strong>MIT</strong>（Massachusetts Institute of Technology, MIT）</p><p>​是目前限制最少的协议，唯一的条件：在修改后的代码或者发行包中，必须包含原作者的许可信息</p><p>​使用 MIT 的软件项目有：jquery、Node.js</p><p>关于更多开源许可协议的介绍，可以参考博客 <a href="https://www.runoob.com/w3cnote/open-source-license.html">https://www.runoob.com/w3cnote/open-source-license.html</a></p><p>专门用于免费存放开源项目源代码的网站，叫做<strong>开源项目托管平台</strong>。目前世界上比较出名的开源项目托管平台主要有以下 3 个：</p><p>​Github（全球最牛的开源项目托管平台，没有之一）</p><p>​Gitlab（对代码私有性支持较好，因此企业用户较多）</p><p>​Gitee（又叫做码云，是国产的开源项目托管平台。访问速度快、纯中文界面、使用友好）</p><p>注意：以上 3 个开源项目托管平台，只能托管以 Git 管理的项目源代码，因此，它们的名字都以 Git 开头。</p><p>Github 的官网首页 <a href="https://github.com/">https://github.com/</a></p><h5 id="远程仓库的两种访问方式"><a href="#远程仓库的两种访问方式" class="headerlink" title="远程仓库的两种访问方式"></a>远程仓库的两种访问方式</h5><p>Github 上的远程仓库，有两种访问方式，分别是 HTTPS 和 SSH。它们的区别是：</p><p>①HTTPS：零配置；但是每次访问仓库时，需要重复输入 Github 的账号和密码才能访问成功</p><p>②SSH：需要进行额外的配置；但是配置成功后，每次访问仓库时，不需重复输入 Github 的账号和密码</p><p>注意：在实际开发中，推荐使用 SSH 的方式访问远程仓库。</p><h5 id="SSH-key"><a href="#SSH-key" class="headerlink" title="SSH key"></a>SSH key</h5><p>SSH key 的<strong>作用</strong>：实现本地仓库和 Github 之间免登录的加密数据传输。</p><p>SSH key 的<strong>好处</strong>：免登录身份认证、数据加密传输。</p><p>SSH key 由<strong>两部分组成</strong>，分别是：</p><p>①id_rsa（私钥文件，存放于客户端的电脑中即可）</p><p>②id_rsa.pub（公钥文件，需要配置到 Github 中）</p><h6 id="生成-SSH-key"><a href="#生成-SSH-key" class="headerlink" title="生成 SSH key"></a>生成 SSH key</h6><p>①打开 Git Bash</p><p>②粘贴如下的命令，并将 <a href="mailto:&#121;&#x6f;&#117;&#x72;&#x5f;&#101;&#109;&#x61;&#x69;&#x6c;&#x40;&#x65;&#x78;&#x61;&#109;&#112;&#x6c;&#101;&#46;&#99;&#111;&#109;">&#121;&#x6f;&#117;&#x72;&#x5f;&#101;&#109;&#x61;&#x69;&#x6c;&#x40;&#x65;&#x78;&#x61;&#109;&#112;&#x6c;&#101;&#46;&#99;&#111;&#109;</a> 替换为注册 Github 账号时填写的邮箱：</p><p>l ssh-keygen -t rsa -b 4096 -C “<a href="mailto:&#121;&#x6f;&#117;&#x72;&#x5f;&#x65;&#109;&#97;&#x69;&#x6c;&#x40;&#101;&#120;&#x61;&#x6d;&#112;&#x6c;&#101;&#46;&#x63;&#111;&#x6d;">&#121;&#x6f;&#117;&#x72;&#x5f;&#x65;&#109;&#97;&#x69;&#x6c;&#x40;&#101;&#120;&#x61;&#x6d;&#112;&#x6c;&#101;&#46;&#x63;&#111;&#x6d;</a>“</p><p>③连续敲击 3 次回车，即可在 C:\Users\用户名文件夹.ssh 目录中生成 id_rsa 和 id_rsa.pub 两个文件</p><h6 id="配置-SSH-key"><a href="#配置-SSH-key" class="headerlink" title="配置 SSH key"></a><strong>配置</strong> SSH key</h6><p>①使用记事本打开 id_rsa.pub 文件，复制里面的文本内容</p><p>②在浏览器中登录 Github，点击头像 -&gt; Settings -&gt; SSH and GPG Keys -&gt; New SSH key</p><p>③将 id_rsa.pub 文件中的内容，粘贴到 Key 对应的文本框中</p><p>④在 Title 文本框中任意填写一个名称，来标识这个 Key 从何而来</p><h6 id="检测-Github-的-SSH-key-是否配置成功"><a href="#检测-Github-的-SSH-key-是否配置成功" class="headerlink" title="检测 Github 的 SSH key 是否配置成功"></a><strong>检测</strong> <strong>Github</strong> <strong>的</strong> <strong>SSH key</strong> 是否配置成功</h6><p>打开 Git Bash，输入如下的命令并回车执行：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br><span class="line">The authenticity of host &#x27; github.com (IP ADDRESS)&#x27;</span><br><span class="line">can&#x27;t be established. </span><br><span class="line">RSA key fingerprint is SHA256: nThbg6kXUpJWG17E1 IGOCspRomTxdCARLvi KW6E5SY8</span><br><span class="line">Are you sure you want to continue connecting (yes/no)?  输入 yes</span><br><span class="line">输入 yes 之后，如果能看到类似于下面的提示消息，证明 SSH key 已经配置成功了：</span><br><span class="line">Hi wangabnghui! You&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure><p>便可以基于 ssh 将本地仓库上传到Github</p><h6 id="将远程仓库克隆到本地"><a href="#将远程仓库克隆到本地" class="headerlink" title="将远程仓库克隆到本地"></a><strong>将远程仓库克隆到本地</strong></h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone 远程仓库的地址</span><br></pre></td></tr></table></figure><h3 id="Git-分支"><a href="#Git-分支" class="headerlink" title="Git 分支"></a>Git 分支</h3><h4 id="master-主分支"><a href="#master-主分支" class="headerlink" title="master 主分支"></a>master 主分支</h4><p>在初始化本地 Git 仓库的时候，Git 默认已经帮我们创建了一个名字叫做 master 的分支。通常我们把这个 master 分支叫做主分支。</p><p>在实际工作中，master 主分支的作用是：<strong>用来保存和记录整个项目已完成的功能代码</strong>。</p><p>因此，不允许程序员直接在 master 分支上修改代码，因为这样做的风险太高，容易导致整个项目崩溃。</p><p>由于程序员不能直接在 master 分支上进行功能的开发，所以就有了功能分支的概念。</p><p><strong>功能分支</strong>指的是专门用来开发新功能的分支，它是临时从 master 主分支上分叉出来的，当新功能开发且测试完毕后，最终需要合并到 master 主分支上。</p><h5 id="查看分支列表"><a href="#查看分支列表" class="headerlink" title="查看分支列表"></a>查看分支列表</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure><p>注意：分支名字前面的 ***** 号表示当前所处的分支。</p><h5 id="创建新分支"><a href="#创建新分支" class="headerlink" title="创建新分支"></a>创建新分支</h5><p>使用如下的命令，可以基于当前分支，创建一个新的分支，此时，新分支中的代码和当前分支完全一样：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch 分支名称</span><br></pre></td></tr></table></figure><h5 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout login # 切换到 login 上</span><br></pre></td></tr></table></figure><h5 id="分支的快速创建和切换"><a href="#分支的快速创建和切换" class="headerlink" title="分支的快速创建和切换"></a>分支的快速创建和切换</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout -b 分支名称</span><br></pre></td></tr></table></figure><p>注意：</p><p>“git checkout -b 分支名称” 是下面两条命令的简写形式：</p><p>①git branch 分支名称</p><p>②git checkout 分支名称</p><h5 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h5><p>功能分支的代码开发测试完毕之后，可以使用如下的命令，将完成后的代码合并到 master 主分支上：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout master  # 先切换值主分支</span><br><span class="line">git merge login   #合并</span><br></pre></td></tr></table></figure><p>合并分支时的注意点：</p><p>假设要把 C 分支的代码合并到 A 分支，则必须<strong>先切换到</strong> <strong>A</strong> <strong>分支</strong>上，<strong>再运行</strong> <strong>git merge</strong> <strong>命令</strong>，来合并 C 分支！</p><h5 id="遇到冲突时的分支合并"><a href="#遇到冲突时的分支合并" class="headerlink" title="遇到冲突时的分支合并"></a>遇到冲突时的分支合并</h5><p>如果在两个不同的分支中，对同一个文件进行了不同的修改，Git 就没法干净的合并它们。 此时，我们需要打开这些包含冲突的文件然后<strong>手动解决冲突</strong>。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 假设:在把reg分支合并到 master 分支期间，代码发生了冲突</span><br><span class="line">git checkout master</span><br><span class="line">git merge reg</span><br><span class="line"># 打开包含冲突的文件，手动解决冲突之后，再执行如下的命令</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;解决了分支合并冲突的问题”</span><br></pre></td></tr></table></figure><h5 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h5><p>当把功能分支的代码合并到 master 主分支上以后，就可以使用如下的命令，删除对应的功能分支：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch -d 分支名称</span><br></pre></td></tr></table></figure><h4 id="远程分支操作"><a href="#远程分支操作" class="headerlink" title="远程分支操作"></a>远程分支操作</h4><p>将本地分支推送到远程仓库</p><p>如果是<strong>第一次</strong>将本地分支推送到远程仓库，需要运行如下的命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># -u 表示把本地分支和远程分支进行关联，只在第一次推送的时候需要带 -u 参数</span><br><span class="line">git push -u 远程仓库的别名本地分支名称:远程分支名称</span><br><span class="line"># 实际案例:</span><br><span class="line">git push -u origin payment:pay</span><br><span class="line"># 如果希望远程分支的名称和本地分支名称保持一致，可以对命令进行简化:</span><br><span class="line">git push -u origin payment</span><br></pre></td></tr></table></figure><p>注意：第一次推送分支需要带 -u 参数，此后可以直接使用 git push 推送代码到远程分支。</p><h5 id="查看远程仓库中所有的分支列表"><a href="#查看远程仓库中所有的分支列表" class="headerlink" title="查看远程仓库中所有的分支列表"></a>查看远程仓库中所有的分支列表</h5><p>通过如下的命令，可以查看远程仓库中，所有的分支列表的信息：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote show 远程仓库名称</span><br></pre></td></tr></table></figure><h5 id="跟踪分支"><a href="#跟踪分支" class="headerlink" title="跟踪分支"></a>跟踪分支</h5><p>跟踪分支指的是：从远程仓库中，把远程分支下载到本地仓库中。需要运行的命令如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 从远程仓库中，把对应的远程分支下载到本地仓库，保持本地分支和远程分支名称相同</span><br><span class="line">git checkout 远程分支的名称</span><br><span class="line"># 示例:</span><br><span class="line">git checkout pay</span><br><span class="line"># 从远程仓库中，把对应的远程分支下载到本地仓库，并把下载的本地分支进行重命名</span><br><span class="line">git checkout -b 本地分支名称 远程仓库名称/远程分支名称</span><br><span class="line"># 示例:</span><br><span class="line">git checkout -b payment origin/pay</span><br></pre></td></tr></table></figure><h5 id="拉取远程分支的最新的代码"><a href="#拉取远程分支的最新的代码" class="headerlink" title="拉取远程分支的最新的代码"></a>拉取远程分支的最新的代码</h5><p>可以使用如下的命令，把远程分支最新的代码下载到本地对应的分支中：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure><h5 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h5><p>可以使用如下的命令，删除远程仓库中指定的分支：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#删除远程仓库中，指定名称的远程分支</span><br><span class="line">git push 远程仓库名称 --delete 远程分支名称</span><br><span class="line">#示例:</span><br><span class="line">git push origin --delete pay</span><br></pre></td></tr></table></figure><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>①能够掌握 Git 中基本命令的使用</p><p>git init</p><p>git add .</p><p>git commit –m “提交消息”</p><p>git status 和 git status -s</p><p>②能够使用 Github 创建和维护远程仓库</p><p>能够配置 Github 的 SSH 访问</p><p>能够将本地仓库上传到 Github</p><p>③能够掌握 Git 分支的基本使用</p><p>git checkout -b 新分支名称</p><p>git push -u origin 新分支名称</p><p>git checkout 分支名称</p><p>git branch</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发工具 </tag>
            
            <tag> IT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络规划与设计</title>
      <link href="/archives/974a452e.html"/>
      <url>/archives/974a452e.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
      
      <categories>
          
          <category> 网络设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IT </tag>
            
            <tag> 网络设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript基础</title>
      <link href="/archives/4b0178e0.html"/>
      <url>/archives/4b0178e0.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><h2 id="1-邂逅JavaScript"><a href="#1-邂逅JavaScript" class="headerlink" title="1.邂逅JavaScript"></a>1.邂逅JavaScript</h2><h3 id="1、认识编程语言"><a href="#1、认识编程语言" class="headerlink" title="1、认识编程语言"></a>1、认识编程语言</h3><p>计算机语言就是我们人和计算机进行交流要学习的语言</p><p>HTML：标记语言；CSS：样式语言；都属于计算机语言</p><p>JavaScript也是计算机语言，更精确来说是一门编程语言</p><p><strong>计算机语言：</strong>人与计算机之间通讯的语言，是人与计算机之间传递信息的介质，其概念比通用的编程语言要更广泛；</p><p><strong>编程语言</strong>：用来定义计算机程序的形式语言。它是一种被标准化的交流技巧，用来向计算机发出指令，一种能让程序员准确定义计算机所需使用数据的计算机语言，并准确的定义在不同情况下所应采取的行动。</p><p><strong>编程语言特点</strong>：</p><ul><li>数据和数据结构</li><li>指令及流程控制</li><li>引用机制和重用机制</li><li>设计哲学</li></ul><h3 id="2、编程语言发展史"><a href="#2、编程语言发展史" class="headerlink" title="2、编程语言发展史"></a>2、编程语言发展史</h3><p><strong>阶段一：</strong>机器语言，只由0和1组成 </p><p><strong>阶段二：</strong>汇编语言，用符号来代替冗长的、难以记忆的0和1代码，经过汇编器转化为0和1</p><p><strong>阶段三：</strong>高级语言，接近自然语言，更符合人类的思维方式</p><h3 id="3、JavaScript的历史"><a href="#3、JavaScript的历史" class="headerlink" title="3、JavaScript的历史"></a>3、JavaScript的历史</h3><p>javascript是一门高级的、解释型的编程语言</p><p>是一门基于原型的、头等函数的语言，是一门多范式的语言，支持面向对象程序设计、指令式编程、以及函数式编程</p><p>94年网景公司发布navigator浏览器0.9版，但是只能用于浏览，不具备与用户的交互能力。</p><p>95年招募Brendan Eich，希望将scheme语言作为网页脚本语言的可能性</p><p>同时，sun公司将oak语言更名为Java，管理层倾向于java，希望能简化java来适应脚本的需求</p><p>brendan eich不感兴趣并且用了十天设计了js，最初叫做mocha，在navigator2.0 beta更名为livescript，在navigator3.0beta 3 改名为javascript，为了搭上java热度</p><p>95年微软首推IE，并对navigator进行逆向发明了jscript</p><p>96.11月，网景正式向ECMA提交了语言规范</p><ul><li>97.6月，ECMA为javascript制定了ECMAScript标准规范</li></ul><p>所以，ecmascript是一种规范，而javascript是这种规范的一种实现</p><h3 id="4、JavaScript的组成"><a href="#4、JavaScript的组成" class="headerlink" title="4、JavaScript的组成"></a>4、JavaScript的组成</h3><p>定义语言规范：ECMAScript</p><p>DOM：用于操作文档的API</p><p>BOM：用于操作浏览器的API</p><h3 id="5、JavaScript运行引擎"><a href="#5、JavaScript运行引擎" class="headerlink" title="5、JavaScript运行引擎"></a>5、JavaScript运行引擎</h3><p>常见的js引擎：</p><ul><li>javascriptCore：webkit中的js引擎，apple公司开发</li><li>v8：Goole开发的强大的js引擎</li></ul><p>浏览器内核与js引擎的关系</p><p>webkit为例：</p><ul><li>webcore：负责html的解析、布局、渲染等相关工作（渲染层）</li><li>javascriptcore：解析、执行js代码（逻辑层）</li></ul><h3 id="6、JavaScript应用场景"><a href="#6、JavaScript应用场景" class="headerlink" title="6、JavaScript应用场景"></a>6、JavaScript应用场景</h3><p>web开发、移动端开发、小程序端开发、桌面应用开发、后端开发</p><h2 id="2-JavaScript的基本语法"><a href="#2-JavaScript的基本语法" class="headerlink" title="2.JavaScript的基本语法"></a>2.JavaScript的基本语法</h2><h3 id="1、javascript编写方式"><a href="#1、javascript编写方式" class="headerlink" title="1、javascript编写方式"></a>1、javascript编写方式</h3><ul><li>HTML代码内</li><li>script标签内</li><li>外部的js文件</li></ul><h3 id="2、noscript元素的使用"><a href="#2、noscript元素的使用" class="headerlink" title="2、noscript元素的使用"></a>2、noscript元素的使用</h3><p>如果运行的浏览器不支持js，需要一直优雅的处理方式</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;noscript&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>您的浏览器不支持js<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">&lt;/noscript&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">alert</span>(<span class="string">&#x27;您的浏览器正在运行js代码&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="3、javascript注意事项"><a href="#3、javascript注意事项" class="headerlink" title="3、javascript注意事项"></a>3、javascript注意事项</h3><ul><li>script元素不能写成单标签，在外联引用js文件时，script标签内不能编写js代码</li><li>省略type属性，以前的script标签中：type&#x3D;”text&#x2F;javascrpit”</li><li>加载顺序：自上而下，推荐放在body子元素的最后一行</li><li>js代码严格区分大小写</li></ul><h3 id="4、javascript交互方式"><a href="#4、javascript交互方式" class="headerlink" title="4、javascript交互方式"></a>4、javascript交互方式</h3><p>alert：接受一个参数，弹窗查看</p><p>console.log：接收多个参数，在浏览器控制台查看</p><p>document.write：接受多个字符串，在浏览器页面查看</p><p>prompt：接受一个参数，在浏览器接受用户输入</p><ul><li>代码出错可以再控制台console查看</li><li>控制台 &gt; 可以直接编写js代码，回车执行代码，shift+enter可以写多行代码</li><li>debug进行调试，查看代码的执行流程</li></ul><h3 id="5、javascript语句和分号"><a href="#5、javascript语句和分号" class="headerlink" title="5、javascript语句和分号"></a>5、javascript语句和分号</h3><p>语句是向浏览器发出的指令，通常表达为一个操作或行为</p><p>通常情况下每条语句的后面会添一个分号，表示语句的结束：</p><ul><li>当存在换行符时，在大多数情况下可以省略分号</li><li>js将换行理解为”隐式”分号</li><li>也称之为自动插入分号</li></ul><p>注释方式：&#x2F;*  … *&#x2F;：多行注释      &#x2F;&#x2F;：单行注释</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">文档注释  <span class="comment">// js文件中</span></span><br><span class="line"><span class="comment">/**.....*/</span></span><br></pre></td></tr></table></figure><p>Js中不支持注释的嵌套</p><p>插件：</p><p>log快速：react：clg</p><p>括号范围：bracket pair colorizer，里面配置设置.json</p><h2 id="3-JavaScript的变量和数据结构"><a href="#3-JavaScript的变量和数据结构" class="headerlink" title="3.JavaScript的变量和数据结构"></a>3.JavaScript的变量和数据结构</h2><h3 id="1、认识JavaScript变量"><a href="#1、认识JavaScript变量" class="headerlink" title="1、认识JavaScript变量"></a>1、认识JavaScript变量</h3><p>程序中变量的数据：</p><ul><li>购物车商品的数量、价格</li><li>游戏技能时间的冷却、血量</li></ul><h4 id="1-变化数据的记录—变量"><a href="#1-变化数据的记录—变量" class="headerlink" title="1.变化数据的记录—变量"></a>1.变化数据的记录—变量</h4><ul><li>一个变量就是用于存放数值的容器</li><li>这个数字可能是一个用于计算的数字，或字符串，或其他的任意数据</li><li>变量的独特之处在于它存放的数量是可以改变的</li></ul><p>可以把变量看做一个盒子，盒子里面装着我们的数据</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var message = &#x27;hello&#x27;</span><br><span class="line">message = &#x27;why&#x27;</span><br></pre></td></tr></table></figure><h4 id="2-变量的命名格式"><a href="#2-变量的命名格式" class="headerlink" title="2.变量的命名格式"></a>2.变量的命名格式</h4><p>定义一个变量包含两部分</p><ul><li>变量的声明：告诉js引擎接下来我要定一个变量</li><li>变量的赋值：使用  &#x3D;  给变量进行赋值</li></ul><p>可以同时声明多个变量</p><h3 id="2、变量的定义、规范"><a href="#2、变量的定义、规范" class="headerlink" title="2、变量的定义、规范"></a>2、变量的定义、规范</h3><p><strong>变量命名规则：</strong>必须遵守</p><ul><li>第一个字符必须是一个英文字母、下划线（_）、$符号</li><li>其他字符可以是字母、下划线、美元符号或数字</li><li>不能使用关键字和保留字命名</li><li>变量严格区分大小写</li></ul><p><strong>规范：</strong></p><ul><li>多个单词，驼峰命名法</li><li>推荐等号两边添加一个空格，结构清晰</li><li>语句结束加上分号</li><li>变量名字尽量见名知意</li></ul><p>如果变量未声明就使用，会直接报错  not defined</p><p>如果一个变量有声明但是没有赋值，会打印undefined</p><p>在js中也可以不使用var在全局声明一个变量（不推荐），如果不使用var来声明一个变量，也是可以声明成功的，而且这个变量会被加入到window对象中</p><h3 id="3、数据类型和typeof"><a href="#3、数据类型和typeof" class="headerlink" title="3、数据类型和typeof"></a>3、数据类型和typeof</h3><p>js中的值都有特定的类型，将值赋值给一个变量，那这么变量就具备了特定的类型</p><p>一个变量可以在前一刻是个字符串，下一刻就存储一个数字</p><p>允许这种操作的编程语言，比如js，称之为动态类型的编程语言</p><p>在js中有八种基本的数据类型（7中原始类型和一种复杂类型）</p><ul><li>Number（包括小数）</li><li>String</li><li>Boolean</li><li>Undefined</li><li>Null</li><li>Object</li><li>Bigint</li><li>Symbol</li></ul><p>因为ECMAScript的类型系统是松散的，所以需要一种手段来确定任意变量的数据类型</p><p>typeof应运而生，返回值：</p><p>“undefined”表示值未定义；</p><p>“boolean”表示值为布尔值；</p><p>“string”表示值为字符串；</p><p>“number”表示值为数值；</p><p>“object”表示值为对象（而不是函数）或null；</p><p>“function”表示值为函数；</p><p>“symbol”表示值为符号；</p><p>typeof(x)  它与typeof x 相同</p><p>typeof是一个操作符，它并非是一个函数，()只是将后续的内容当作一个整体而已</p><h3 id="4、常见的数据类型"><a href="#4、常见的数据类型" class="headerlink" title="4、常见的数据类型"></a>4、常见的数据类型</h3><h4 id="number类型"><a href="#number类型" class="headerlink" title="number类型"></a>number类型</h4><p>代表整数和浮点数，可以进行加减乘除，除了常规的数字，还包括特殊数值也属于number类型</p><ul><li>Infinity：代表无穷大，负无穷大：1&#x2F;0</li><li>NaN：代表一个计算错误，比如数字乘字符串</li></ul><p>最大的数字：Number.MAX_VALUE</p><p>最小的数字：Number.MIN_VALUE，小于这个数字会被转化为0</p><p>isNaN()来判断一个数字是不是数字，不是数字返回true</p><h4 id="string类型：字符串类型"><a href="#string类型：字符串类型" class="headerlink" title="string类型：字符串类型"></a>string类型：字符串类型</h4><p>在开发中我们经常会有一些文本需要表示，这个时候我们会使用字符串String：</p><ul><li>比如人的姓名：coderwhy。地址：广州市。简介：认真是一种可怕的力量</li></ul><p>JavaScript 中的字符串必须被括在引号里，有三种包含字符串的方式</p><ul><li><p>双引号：”Hello”</p></li><li><p>单引号：’Hello’</p></li><li><p>反引号：<code>Hello</code></p></li></ul><p>前后的引号类型必须一致：</p><ul><li><p>如果在字符串里面本身包括单引号，可以使用双引号</p></li><li><p>如果在字符串里面本身包括双引号，可以使用单引号</p></li></ul><p>引号：单引号、双引号、反引号（支持${表达式&#x2F;变量}）</p><p>前后的引号必须一致</p><p>转义字符：除了普通可打印的字符，一些特殊的字符可以通过转义字符的形式放在字符串中</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230227141333739.png" alt="image-20230227141333739"></p><p>字符串的操作：</p><ul><li>字符串拼接（+）</li><li>获取字符串长度（.length）</li></ul><h4 id="Boolean类型：用于表示真假"><a href="#Boolean类型：用于表示真假" class="headerlink" title="Boolean类型：用于表示真假"></a>Boolean类型：用于表示真假</h4><p>包含两个值：true；false</p><h4 id="Undefined类型"><a href="#Undefined类型" class="headerlink" title="Undefined类型"></a>Undefined类型</h4><p>只有一个值，undefined：声明了变量未赋值（未进行初始化）</p><ul><li>定义变量时候最好进行赋值，而不是只是声明</li><li>不要显示的将一个变量赋值为undefined<ul><li>可以初始化为0\null\空字符串等值</li></ul></li></ul><h4 id="Object类型"><a href="#Object类型" class="headerlink" title="Object类型"></a>Object类型</h4><p>是一个特殊的类型，通常称之为引用类型或者复杂类型</p><p>其他的数据类型我们称之为原始类型，因为它们的值只包含一个单独的内容</p><p>Object往往可以表示一组数据，是其他数据的一个集合，用{}表示一个对象</p><h4 id="Null类型"><a href="#Null类型" class="headerlink" title="Null类型"></a>Null类型</h4><p>只有一个值：null</p><p>通常用来表示一个对象为空，所以我们通常再给一个对象进行初始化时，会赋值为null</p><p>typeof识别为object</p><p>null与undefined的关系：</p><ul><li>undefined通常只有在一个变量声明但是未初始化时，默认为undefined才使用</li><li>并且我们不推荐给一个变量直接赋值为undefined，所以很少使用</li><li>null值非常常用，当一个变量准备保存一个对象，但是这个对象不确定时，可以先赋值为null</li></ul><h4 id="数据类型总结"><a href="#数据类型总结" class="headerlink" title="数据类型总结"></a>数据类型总结</h4><p>JavaScript 中有八种基本的数据类型（前七种为基本数据类型，也称为原始类型，而 object 为复杂数据类型，也称为引用类型）</p><ul><li>number 用于任何类型的数字：整数或浮点数</li><li>string 用于字符串：一个字符串可以包含 0 个或多个字符，所以没有单独的单字符类型</li><li>boolean 用于 true 和 false</li><li>undefined 用于未定义的值 —— 只有一个 undefined 值的独立类型</li><li>object 用于更复杂的数据结构</li><li>null 用于未知的值 —— 只有一个 null 值的独立类型</li><li>symbol 用于唯一的标识符</li><li>bigint 用于任意长度的整数。</li></ul><h3 id="5、数据类型的转换"><a href="#5、数据类型的转换" class="headerlink" title="5、数据类型的转换"></a>5、数据类型的转换</h3><p>在大多数情况下，运算符和函数会自动将赋予它们的值转换为正确的类型，这是一种隐式转换</p><p>我们也可通过显式的方式来对数据进行类型转换</p><h4 id="1-字符串String的转换"><a href="#1-字符串String的转换" class="headerlink" title="1.字符串String的转换"></a>1.字符串String的转换</h4><p>方式1：隐式转换</p><ul><li>一个字符串和其他类型进行+操作<ul><li>+运算符左右两边有一个是字符串，那么另一边会自动转换为字符串再进行拼接操作</li></ul></li><li>某些函数的执行也会自动将参数转为字符串类型<ul><li>比如log函数</li></ul></li></ul><p>方式2：显式转换</p><ul><li>调用String()函数</li><li>调用toString方法</li></ul><h4 id="2-数字类型Number的转换"><a href="#2-数字类型Number的转换" class="headerlink" title="2.数字类型Number的转换"></a>2.数字类型Number的转换</h4><p>方式1：隐式转换</p><ul><li>在算数运算中，通常会将其他类型转换为数字类型来进行计算<ul><li>比如：“6”&#x2F;“2”</li><li>但是如果是+运算，并且其中一边有字符串，那么还是按照字符串来连接的</li></ul></li></ul><p>方式2：显示转换</p><ul><li>Numbe() 函数</li></ul><h5 id="其他类型转换数字的规则"><a href="#其他类型转换数字的规则" class="headerlink" title="其他类型转换数字的规则"></a>其他类型转换数字的规则</h5><p>undefined—&gt;NaN</p><p>null—&gt;0</p><p>true和false—&gt;1and0</p><p>string—&gt;去掉首尾空格后的纯数字字符串中含有的数字；如果剩余字符串为空，则转换为0；否则，将会从剩余字符串中“读取”数字；当类型转换出现error时返回NaN</p><h4 id="3-布尔类型Boolean的转换"><a href="#3-布尔类型Boolean的转换" class="headerlink" title="3.布尔类型Boolean的转换"></a>3.布尔类型Boolean的转换</h4><p> 隐式转换的规则：</p><p>1.直观上为空的值转换成boolean类型都是false</p><ul><li><p>直观上空的值：0&#x2F;“”&#x2F;undefined&#x2F;null&#x2F;NaN -&gt; false</p></li><li><p>其他值：true</p></li></ul><p>2.显示转换</p><ul><li>Boolean()</li></ul><p>包含0的字符串转化是true</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Boolean</span>(<span class="string">&quot;&quot;</span>));  <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Boolean</span>(<span class="string">&quot;0&quot;</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="4-JavaScript基础运算符"><a href="#4-JavaScript基础运算符" class="headerlink" title="4.JavaScript基础运算符"></a>4.JavaScript基础运算符</h2><h3 id="1、运算符和运算元"><a href="#1、运算符和运算元" class="headerlink" title="1、运算符和运算元"></a>1、运算符和运算元</h3><p>认识运算符（operators）：加（+）、减（-）、乘（*）、除（&#x2F;）</p><p>运算元：运算符应用的对象</p><ul><li>5*2: 5 和 2 就是运算元</li></ul><p>如果一个运算符对应的只有一个运算元，那么它是一元运算符</p><ul><li>-10</li></ul><p>如果一个运算符拥有两个运算元，那么就是二元运算符</p><h3 id="2、算术运算符"><a href="#2、算术运算符" class="headerlink" title="2、算术运算符"></a>2、算术运算符</h3><p>用在数学表达式中，与数学方法一致</p><p>算术运算符是对数据进行计算的符号</p><p>Math.pow(2,3)  表示 2 的3次幂（es6）；   **  也是幂（es7）</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230405151813539.png" alt="image-20230405151813539"></p><h3 id="3、赋值运算符"><a href="#3、赋值运算符" class="headerlink" title="3、赋值运算符"></a>3、赋值运算符</h3><p>使用的 &#x3D; 就是赋值运算符</p><p>语句 x &#x3D; value 将value写入 x 然后返回 x</p><p>链式赋值（不推荐）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 = num2 = num3 = <span class="number">321</span></span><br></pre></td></tr></table></figure><ul><li>链式赋值从右往左计算</li><li>所有的变量共享一个值</li></ul><h5 id="原地修改"><a href="#原地修改" class="headerlink" title="原地修改"></a>原地修改</h5><p>我们经常需要对变量做运算，并将新的结果存放在同一变量中</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">100</span></span><br><span class="line">num = num + <span class="number">10</span></span><br></pre></td></tr></table></figure><ul><li>可以使用 +&#x3D;  *&#x3D; 来缩写</li></ul><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230227165921852.png" alt="image-20230227165921852"></p><p>所有的算术运算符都有简短的“修改并赋值”运算符：&#x2F;&#x3D; 和 -&#x3D; 等</p><h3 id="4、自增和自减"><a href="#4、自增和自减" class="headerlink" title="4、自增和自减"></a>4、自增和自减</h3><p>对一个数进行加一、减一是最常见的数学运算符之一</p><p>自增 ++ 将变量加一</p><p>自减 – 将变量减一</p><p>自增&#x2F;自减只能用于变量</p><ul><li>用在数值（5–）则会报错</li></ul><h5 id="和–的位置"><a href="#和–的位置" class="headerlink" title="++和–的位置"></a>++和–的位置</h5><p>独立使用的话++、–放在前后无所谓，放在后面称之为后置形式，放在前面称之为前置形式</p><p>都是+1，单独使用是看不到区别</p><p>如果我们要对变量进行自增操作时，并且需要立即使用自增后的值，那么需要使用前置形式</p><p>前置形式返回一个新的值，但后置返回原来的值</p><h3 id="5、运算符优先级"><a href="#5、运算符优先级" class="headerlink" title="5、运算符优先级"></a>5、运算符优先级</h3><p>运算符放在一起使用时会有一定的优先级</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence</a></p><h3 id="6、比较运算符"><a href="#6、比较运算符" class="headerlink" title="6、比较运算符"></a>6、比较运算符</h3><p>比大小的运算符</p><p>大于&#x2F;小于： &gt;   &lt;</p><p>大于等于：&gt;&#x3D;</p><p>相等：&#x3D;&#x3D;</p><p>不相等：！&#x3D;</p><p>比较运算符的结果都是boolean类型</p><h3 id="额外知识补充"><a href="#额外知识补充" class="headerlink" title="额外知识补充"></a>额外知识补充</h3><h4 id="x3D-x3D-和-x3D-x3D-x3D-的区别"><a href="#x3D-x3D-和-x3D-x3D-x3D-的区别" class="headerlink" title="&#x3D;&#x3D;和&#x3D;&#x3D;&#x3D;的区别"></a>&#x3D;&#x3D;和&#x3D;&#x3D;&#x3D;的区别</h4><p>&#x3D;&#x3D; 普通相等运算符，在类型不相同的情况下，会将运算元先转成Number类型的值，再进行比较</p><p>空字符串和false也是如此，会进行隐式转换</p><p>null比较特殊，内存地址：0X0，应该会被当成一个对象与原生类型进行比较</p><p>&#x3D;&#x3D;&#x3D; 严格相等运算符，在类型不相同的情况下，直接返回false</p><p>不相等：!&#x3D;；  严格不相等：!&#x3D;&#x3D;</p><p>严格代码稍长，但是能体现代码的意图</p><h2 id="5-JavaScript分支语句"><a href="#5-JavaScript分支语句" class="headerlink" title="5.JavaScript分支语句"></a>5.JavaScript分支语句</h2><h3 id="1、if分支语句"><a href="#1、if分支语句" class="headerlink" title="1、if分支语句"></a>1、if分支语句</h3><p>程序的三种执行方式</p><ul><li>顺序：从上到下，顺序执行</li><li>分支：根据条件判断，决定执行代码的分支</li><li>循环：让特定代码重复执行</li></ul><p>代码块：是多行执行代码的集合，通过一个{}放在一起</p><ul><li>在开发中，一行代码很难完成某一个特定的功能，我们将这些代码放在一个代码块中</li></ul><p>在js中，我们通过流程控制语句来决定如何执行一段代码块</p><ul><li>关键字</li><li>分支语句、循环语句</li></ul><p>分支结构</p><ul><li>根据条件来决定代码的执行</li><li>也称为判断结构或选择结构</li><li>几乎所有的编程语言都有分支结构</li></ul><p>js常见的分支结构</p><ul><li>if分支结构<ul><li>单分支结构<ul><li>if…</li></ul></li><li>多分支结构<ul><li>if…else…</li><li>if…esle if…else…</li></ul></li></ul></li><li>switch分支结构</li></ul><p>if 单分支结构</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件判断) &#123; 执行代码块 &#125; <span class="comment">// 条件判断为true就执行代码块</span></span><br></pre></td></tr></table></figure><p>如果代码块中只有一行代码，那么可以省略花括号，写在一排</p><p>if(…)语句会计算圆括号中的表达式，并将计算结果转换为布尔值，规则同Boolean函数</p><h3 id="2、if…else…语句"><a href="#2、if…else…语句" class="headerlink" title="2、if…else…语句"></a>2、if…else…语句</h3><p>多分支语句，if 语句有时会包含可选的else模块</p><p>如果判断条件不成立，就会执行它内部的代码</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件成立) &#123;成立的代码块&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;不成立的代码块&#125;</span><br></pre></td></tr></table></figure><h3 id="3、if…else-if…else语句"><a href="#3、if…else-if…else语句" class="headerlink" title="3、if…else if…else语句"></a>3、if…else if…else语句</h3><p>判断多个条件，可以使用 else if 实现</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件<span class="number">1</span>) &#123;代码块&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(条件<span class="number">2</span>) &#123;代码块&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;前面所有条件不成立&#125;</span><br></pre></td></tr></table></figure><h3 id="4、三元运算符"><a href="#4、三元运算符" class="headerlink" title="4、三元运算符"></a>4、三元运算符</h3><p>只是用if else语句可能会导致代码臃肿</p><p>三元运算符通过<code>？</code>表示</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> result = condition ? value1 : value2</span><br><span class="line"><span class="keyword">var</span> result = num1 &gt; num2 ? num1 : num2  <span class="comment">// 比较大小</span></span><br></pre></td></tr></table></figure><h3 id="5、逻辑运算符"><a href="#5、逻辑运算符" class="headerlink" title="5、逻辑运算符"></a>5、逻辑运算符</h3><p>主要有三个：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">||(或)：一个为真   &amp;&amp;(与)：同时为真    ！(非)：取反</span><br></pre></td></tr></table></figure><p>可以将多个表达式或值放在一起来获取到一个最终的结果</p><h5 id="逻辑-的本质"><a href="#逻辑-的本质" class="headerlink" title="逻辑||的本质"></a>逻辑||的本质</h5><ul><li>也称之为短路或</li><li>从左到右依次计算操作数</li><li>处理每一个操作数时，都会将其转化为布尔值</li><li>如果结果是true，就停止计算，返回这个<strong>操作数的初始值</strong></li><li>如果所有操作数都被计算过(也就是，转换结果都是false)，则返回最后一个<strong>操作数</strong></li></ul><p>返回的值是操作数的初始形式，不会转换为boolean类型</p><p>换句话说，一个或运算的链，将返回第一个真值，如果不存在真值，就返回该链的最后一个值</p><h5 id="逻辑-amp-amp-的本质"><a href="#逻辑-amp-amp-的本质" class="headerlink" title="逻辑&amp;&amp;的本质"></a>逻辑&amp;&amp;的本质</h5><ul><li>也称之为短路与</li><li>从左到右依次计算操作数</li><li>处理每一个操作数时，都会将其转化为布尔值</li><li>如果结果是false，就停止计算，返回这个<strong>操作数的原始值</strong></li><li>如果所有操作数都被计算过(都是真值)，则返回最后一个<strong>操作数</strong></li></ul><p>换句话说，与运算返回第一个假值，如果没有假值就返回最后一个值</p><h5 id="逻辑非的补充"><a href="#逻辑非的补充" class="headerlink" title="逻辑非的补充"></a>逻辑非的补充</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> message = <span class="string">&#x27;hello world&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Boolean</span>(message))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(!!message)</span><br></pre></td></tr></table></figure><p>逻辑非运算符接受一个参数，并按如下运算：</p><ul><li><p>步骤一：将操作数转化为布尔类型：true&#x2F;false</p></li><li><p>步骤二：返回相反的值；</p></li></ul><p>两个非运算 !! 有时候用来将某个值转化为布尔类型</p><ul><li><p>也就是，第一个非运算将该值转化为布尔类型并取反，第二个非运算再次取反</p></li><li><p>最后我们就得到了一个任意值到布尔值的转化。</p></li></ul><h3 id="6、switch语句"><a href="#6、switch语句" class="headerlink" title="6、switch语句"></a>6、switch语句</h3><p>switch 是分支结构的一种语句</p><ul><li>通过判断表达式的结果（或者变量）是否等于case语句的常量，来执行相应的分支体的</li></ul><p>与if不同的是，switch语句只能做值的严格相等判断（&#x3D;&#x3D;&#x3D;），而 if 语句可以做值的范围判断</p><ul><li><p>switch语句至少一个 case 代码块和一个可选的 default 代码块</p></li><li><p>默认情况下会有 case 穿透，case语句结束后会执行下一条case语句，添加break会跳出 switch，不执行后续代码</p></li></ul><h2 id="6-JavaScript循环语句"><a href="#6-JavaScript循环语句" class="headerlink" title="6.JavaScript循环语句"></a>6.JavaScript循环语句</h2><h3 id="1、认识循环语句"><a href="#1、认识循环语句" class="headerlink" title="1、认识循环语句"></a>1、认识循环语句</h3><p>生活中：对一个列表进行累加、将1到10数字逐个输出等等</p><p>循环是一种重复运行同一代码的方法</p><ul><li>如果是对某一列表进行循环操作，我们通常称之为遍历或者迭代</li></ul><p>三种循环方式：</p><ul><li>while循环</li><li>do…while循环</li><li>for循环</li></ul><h3 id="2、while-循环"><a href="#2、while-循环" class="headerlink" title="2、while 循环"></a>2、while 循环</h3><p>当条件成立时，执行代码块</p><p>当条件不成立时，跳出代码块</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(循环条件) &#123;</span><br><span class="line">    <span class="comment">// 循环代码块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果条件一直成立，那么会产生死循环</p><ul><li><p>这时候必须通过关闭网页来停止死循环</p></li><li><p>开发中一定要避免死循环的产生</p></li></ul><h3 id="3、do…while-循环"><a href="#3、do…while-循环" class="headerlink" title="3、do…while 循环"></a>3、do…while 循环</h3><p>do…while 循环与while循环非常像，二者经常可以相互替代</p><p>但是do…while的特点是不管条件成不成立，do循环都会先执行一次</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    <span class="comment">//循环代码块</span></span><br><span class="line">&#125; <span class="keyword">while</span>(循环条件)</span><br></pre></td></tr></table></figure><h3 id="4、for-循环"><a href="#4、for-循环" class="headerlink" title="4、for 循环"></a>4、for 循环</h3><p>for循环更加复杂，但它是最常用的循环形式</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(begin;condition;step)&#123;</span><br><span class="line">    <span class="comment">//循环代码块body</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>begin：进入循环时执行一次</li><li>condition：在每次循环迭代之前检查：如果为false，停止循环</li><li>循环体：条件为真时，重复运行</li><li>step：在每次循环迭代后执行</li></ul><p>begin执行一次，然后进行迭代：每次检查condition后，执行body和step</p><p><strong>for循环的嵌套</strong></p><ul><li>在开发中，某下情况下一次循环是无法达到目的的，需要使用循环的嵌套</li></ul><p>for循环的嵌套：循环中执行体又嵌套了循环</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">九九乘法表</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&#x27;&lt;table&gt;&#x27;</span>)</span><br><span class="line"><span class="comment">// 九九乘法表</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&quot;&lt;tr&gt;&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>;j &lt; i + <span class="number">1</span>; j++)&#123;</span><br><span class="line">        <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">`&lt;td&gt;<span class="subst">$&#123;j+<span class="number">1</span>&#125;</span>×<span class="subst">$&#123;i+<span class="number">1</span>&#125;</span>=<span class="subst">$&#123;(j+<span class="number">1</span>)*(i+<span class="number">1</span>)&#125;</span>&lt;/td&gt;`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&quot;&lt;/tr&gt;&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&#x27;&lt;/table&gt;&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="5、循环控制—break、continue"><a href="#5、循环控制—break、continue" class="headerlink" title="5、循环控制—break、continue"></a>5、循环控制—break、continue</h3><p>在执行循环过程中，遇到某一个条件时</p><ul><li>循环体不再执行(即使没有执行完)，跳出循环</li><li>本次循环体不再执行，执行下一次的循环体</li></ul><p>break：直接跳出循环，循环结束</p><ul><li>break在某一条件满足时，退出循环，不再执行后续重复的代码</li></ul><p>continue：跳过本次循环次，执行下一次循环体</p><ul><li>continue是break的”轻量版”</li><li>continue 在满足某一条件时，不执行后续重复的代码</li></ul><h3 id="6、案例练习"><a href="#6、案例练习" class="headerlink" title="6、案例练习"></a>6、案例练习</h3><p>随机数的生成</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">100</span>)    <span class="comment">// [0,1)</span></span><br></pre></td></tr></table></figure><h2 id="7-JavaScript函数"><a href="#7-JavaScript函数" class="headerlink" title="7.JavaScript函数"></a>7.JavaScript函数</h2><h3 id="1、认识-JavaScript-函数"><a href="#1、认识-JavaScript-函数" class="headerlink" title="1、认识 JavaScript 函数"></a>1、认识 JavaScript 函数</h3><p>foo、bar、baz：通常被用做函数、变量、文件的名词，计算机编程术语的一部分，本身没有别的用途和意义，被称为“伪变量”</p><p>什么是函数呢？</p><p>alert函数、prompt函数、log函数、String&#x2F;Number&#x2F;Boolean函数</p><p>函数是某种特定功能的代码的封装，帮助我们完成特定的功能</p><p>函数的使用</p><ul><li>声明函数—封装独立的功能</li><li>调用函数—享受封装的成果</li></ul><p>函数的作用：在开发程序时，使用函数可以提高编写的效率以及代码的重用</p><h3 id="2、函数的声明和调用"><a href="#2、函数的声明和调用" class="headerlink" title="2、函数的声明和调用"></a>2、函数的声明和调用</h3><p>声明函数使用function关键字：这种写法称之为函数的定义</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> 函数名() &#123; 函数封装的代码块 &#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>函数名的命名规则和前面变量名的命名规则是相同的</li><li>函数要尽量做到见名知意（一般是动词）</li><li>函数定义完后里面的代码是不会执行的，函数必须调用才会执行</li></ul><p>函数的参数：增加函数的通用性，针对相同的数据处理逻辑，能够适应更多的数据</p><ul><li>在函数内部，把参数当做变量使用，进行需要的数据处理</li><li>在函数调用时，按照函数定义的参数顺序，把希望在函数内部处理的数据，通过参数传递</li></ul><p>形参和实参</p><ul><li>形参（parameters）：定义函数时，小括号中的参数，是用来接收参数用的，在函数内部作为变量使用</li><li>实参（arguments）：调用函数时，小括号里的参数，是用来把数据传递到函数内部用的</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// name 称之为函数的参数（形参，形式参数）</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printInfo</span>(<span class="params">name</span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`my name is <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &#x27;wbh&#x27; 称之为函数的参数（实参，实际参数）</span></span><br><span class="line"><span class="title function_">printInfo</span>(<span class="string">&#x27;wbh&#x27;</span>)</span><br></pre></td></tr></table></figure><p>函数的返回值</p><p>函数不仅可以有参数，还可以有返回值</p><ul><li>使用return关键字来返回结果</li><li>一旦函数中执行returan操作，那么当前函数会终止</li><li>如果函数中没有使用return语句，那么函数会有默认的返回值：undefined</li><li>如果函数使用return语句，但是return后面没有任何值，那么函数的返回值也是undefined</li></ul><p>事实上在函数中有一个特别的对象：arguments对象</p><ul><li>默认情况下，arguments对象是所有(非箭头)函数中都可用的局部变量</li><li>该对象中存放着所有调用者传入的参数，从0位置开始，依次存放</li><li>arguments变量的类型是一个object类型(array-like)，不是一个数组，但是和数组的用法看起来很像</li><li>如果调用者传入的参数多于函数接收的参数，可以通过arguments去获取所有的参数</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(name)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>)</span><br><span class="line">    <span class="comment">// arguments是一个对象</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="variable language_">arguments</span>) </span><br><span class="line">    <span class="comment">// 对arguments进行遍历</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;<span class="variable language_">arguments</span>.<span class="property">length</span>;i++) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>[i])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>(<span class="string">&#x27;why&#x27;</span>,<span class="number">23</span>,<span class="number">445</span>,<span class="string">&quot;大连市&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="3、函数的递归调用"><a href="#3、函数的递归调用" class="headerlink" title="3、函数的递归调用"></a>3、函数的递归调用</h3><p>在开发中，函数内部是可以调用另外一个函数的</p><p>那么可以调用自己吗？</p><ul><li>可以的</li><li>但是必须有结束条件，否则会产生无限调用，造成报错</li></ul><p>函数调用自己—递归（recursion）</p><p>编程的递归调用</p><ul><li>将一个复杂的任务，转化成可以重复执行的相同任务</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">pow</span>(<span class="params">x,n</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(n=<span class="number">1</span>) <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">return</span> x*<span class="title function_">pow</span>(x,n-<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、局部和全局变量"><a href="#4、局部和全局变量" class="headerlink" title="4、局部和全局变量"></a>4、局部和全局变量</h3><p>在 javascript（es5之前）中没有块级作用域的概念，var 定义的变量是没有块级作用域</p><p>但是函数可以定义自己的作用域（scope）</p><p>作用域：表示一些标识符的作用有效范围</p><p>函数的作用域表示在函数内部定义的变量，只有在函数内部可以被访问到</p><ul><li><p>es5 之前函数代码块是会形成自己的作用域的</p></li><li><p>在函数内部定义的变量在外面是拿不到的</p></li></ul><p>全局变量：在全局（script元素中）定义一个变量，那么这个变量是可以在定义之后的任何范围内被访问到，那么称这个变量为全局变量，在任何函数中可见，通过var定义的变量会被添加到window中</p><p>内部变量：局部变量，在函数内部定义的变量，只有在函数的内部才能访问，称之为局部变量</p><p>外部变量：在函数内部去访问函数之外的变量，被访问的变量称之为外部变量，（定义在函数外部的变量）</p><p>在函数中，访问变量的顺序</p><ul><li>优先访问自己函数中的变量，没有找到时，在外部中访问</li></ul><h3 id="5、函数表达式的写法"><a href="#5、函数表达式的写法" class="headerlink" title="5、函数表达式的写法"></a>5、函数表达式的写法</h3><p>在js中，函数并不是一种神奇的语法结构，而是一种特殊的值</p><ul><li>前面定义函数的方式，我们称之为函数的声明</li></ul><p>函数表达式写法：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> bar = <span class="keyword">function</span>(<span class="params"></span>) &#123; &#125;</span><br></pre></td></tr></table></figure><p>function关键字后面没有函数名</p><ul><li>函数表达式允许省略函数名</li></ul><p>无论函数是如何创建的，函数都是一个值</p><p>在js开发中，我们可以将函数作为头等公民</p><h5 id="声明-vs-表达式"><a href="#声明-vs-表达式" class="headerlink" title="声明 vs 表达式"></a>声明 vs 表达式</h5><ul><li>语法不同<ul><li>函数声明：在主代码流中声明为单独的语句的函数</li><li>函数表达式：在一个表达式中或另一个语法结构中创建的函数</li></ul></li><li>创建函数的时机不同<ul><li>函数表达式是在代码执行到达时被创建，并且仅在那一刻起可用</li><li>在函数声明被定义之前，它就可以被调用<ul><li>这是内部算法的缘故</li><li>当javascript准备运行脚本时，首先会在脚本中寻找全局函数声明，并创建这些函数</li></ul></li></ul></li></ul><h5 id="开发中如何选择"><a href="#开发中如何选择" class="headerlink" title="开发中如何选择"></a>开发中如何选择</h5><p>首选考虑函数声明语法</p><p>它能够为组织代码提供更多的灵活性，因为我们可以在声明这些函数之前调用这些函数</p><h3 id="6、函数的头等公民"><a href="#6、函数的头等公民" class="headerlink" title="6、函数的头等公民"></a>6、函数的头等公民</h3><p>头等函数（第一等函数）：是指在程序设计语言中，函数被当做头等公民</p><ul><li>这意味着，函数可以作为别的函数的参数、函数的返回值，赋值给变量或存储在数据结构中</li><li>有人主张也应包括支持匿名函数</li></ul><p>通常对作为头等公民的编程方式，称之为函数式编程</p><ul><li>JavaScript 就是符合函数式编程的语言，这也是 js 的一大特点</li></ul><h5 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h5><p>既然一个函数可以在变量中来回传递，那么也可以传递给另外一个函数</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">fn</span>)&#123;</span><br><span class="line">    <span class="title function_">fn</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;执行了bar函数&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>(bar)</span><br></pre></td></tr></table></figure><p>foo这种函数我们也可以称之为高阶函数</p><h5 id="高阶函数必须满足两个条件之一"><a href="#高阶函数必须满足两个条件之一" class="headerlink" title="高阶函数必须满足两个条件之一"></a>高阶函数必须满足两个条件之一</h5><ul><li>接受一个或者多个函数作为输入</li><li>输出一个函数</li></ul><h5 id="匿名函数的理解"><a href="#匿名函数的理解" class="headerlink" title="匿名函数的理解"></a>匿名函数的理解</h5><p>如果在传入一个函数时，我们没有指定这个函数的名称或者通过函数表达式指定函数对应的变量，那么这个函数称之为匿名函数</p><h3 id="7、立即执行函数"><a href="#7、立即执行函数" class="headerlink" title="7、立即执行函数"></a>7、立即执行函数</h3><p>一个函数定义完后被立即执行</p><ul><li>第一部分是定义了一个匿名函数，这个函数有自己独立的作用域</li><li>第二部分是后面的()，表示这个函数被执行了</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>)&#123;  <span class="comment">// 函数名可以删除</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;bar函数被立刻执行&#x27;</span>)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p>会创建一个独立的执行上下文环境，可以避免外界访问或修改内部的变量，也避免了对内部变量的修改</p><h5 id="立即执行函数的其他写法"><a href="#立即执行函数的其他写法" class="headerlink" title="立即执行函数的其他写法"></a>立即执行函数的其他写法</h5><p>立即执行函数必须是一个表达式，不能是函数声明</p><p>当圆括号出现在匿名函数的末尾想要调用函数时，会默认将函数当成是函数声明</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="title function_">clg</span>(<span class="string">&quot;立即执行函数&quot;</span>) </span><br><span class="line">&#125;()  <span class="comment">// 错误写法</span></span><br></pre></td></tr></table></figure><p>当圆括号包裹函数时，会默认将函数作为表达式去解析，而不是函数声明</p><p>下面方法也可</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 3.其他写法</span></span><br><span class="line"><span class="comment">// 匿名函数</span></span><br><span class="line"><span class="comment">// (function(fn) &#123;</span></span><br><span class="line"><span class="comment">//   console.log(&#x27;立即执行函数被调用&#x27;)</span></span><br><span class="line"><span class="comment">// &#125;())</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// + - !</span></span><br><span class="line">+<span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;立即执行函数&#x27;</span>)</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><h3 id="8、代码规范"><a href="#8、代码规范" class="headerlink" title="8、代码规范"></a>8、代码规范</h3><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230302102120792.png" alt="image-20230302102120792"></p><h2 id="8-JavaScript的面向对象"><a href="#8-JavaScript的面向对象" class="headerlink" title="8.JavaScript的面向对象"></a>8.JavaScript的面向对象</h2><h3 id="1、对象类型的使用"><a href="#1、对象类型的使用" class="headerlink" title="1、对象类型的使用"></a>1、对象类型的使用</h3><p>对象类型是一种存储键值对（key-value）的更复杂的数据类型</p><ul><li>键值对可以是属性和方法</li><li>其中key是字符串<ul><li>key是字符串类型，但是在定义对象的属性名时，大部分情况下引号都是可以省略的</li></ul></li><li>value可以是任意类型，包括基本数据类型、函数类型、对象类型等</li></ul><p>两个术语：函数&#x2F;方法</p><p>​    函数（function）：如果在js中通过function默认定义一个结构，称之为函数</p><p>​    方法(method)：如果将一个函数放到对象中，并作为对象的一个属性，那么这个函数称之为方法</p><h5 id="创建对象和使用对象"><a href="#创建对象和使用对象" class="headerlink" title="创建对象和使用对象"></a>创建对象和使用对象</h5><p>创建对象的方式很多，包括三种：</p><ul><li>对象字面量：通过{}</li><li>new Object + 动态添加属性</li><li>new 其他类</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.字面量创建</span></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;why&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2.new object</span></span><br><span class="line"><span class="comment">// Object 构造函数</span></span><br><span class="line"><span class="keyword">var</span> obj2 = <span class="keyword">new</span> <span class="title class_">Object</span>()</span><br><span class="line">obj2.<span class="property">name</span> = <span class="string">&#x27;kobe&#x27;</span></span><br><span class="line"><span class="comment">// 3.new 其他类()</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> obj3 = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj3)</span><br></pre></td></tr></table></figure><p>属性之间是以逗号分割的</p><p>对象的使用：</p><ul><li>访问对象的属性</li><li>修改对象的属性</li><li>添加对象的属性</li><li>删除对象的属性：delete 关键字</li></ul><h5 id="方括号和引用的使用"><a href="#方括号和引用的使用" class="headerlink" title="方括号和引用的使用"></a>方括号和引用的使用</h5><p>对于多词属性来说，js是无法理解的</p><p>而点符号要求key是有效的变量标识符</p><ul><li>不包含空格、不以数字开头、也不包含特殊字符(允许使用$和_)</li></ul><p>这时候可以使用方括号来获取对象的属性 </p><h5 id="对象的遍历"><a href="#对象的遍历" class="headerlink" title="对象的遍历"></a>对象的遍历</h5><p>表示获取对象中所有的属性和方法</p><p>Object.keys() 方法会返回一个由一个给定对象的自身可枚举属性组成的数组</p><ul><li>普通的for循环</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> userKeys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(user)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; userKeys.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> key = userKeys[i]</span><br><span class="line">  <span class="keyword">var</span> value = user[key]</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`key: <span class="subst">$&#123;key&#125;</span>, value: <span class="subst">$&#123;value&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>for…in…遍历，key 即是属性，user[key] 这是对应的值</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> user) &#123;</span><br><span class="line">  <span class="keyword">var</span> value = user[key]</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`key: <span class="subst">$&#123;key&#125;</span>, value: <span class="subst">$&#123;value&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>for…of..不能遍历，因为对象默认是不可迭代的，for of 对数组有效</li></ul><h5 id="栈内存和堆内存"><a href="#栈内存和堆内存" class="headerlink" title="栈内存和堆内存"></a>栈内存和堆内存</h5><p>程序是需要加载到内存中执行的，我们可以将内存划分为两个区域，栈内存和堆内存</p><p>原始类型占据的空间是在栈内存中分配的</p><p>对象类型占据的空间是在堆内存中分配的</p><h3 id="2、值类型和引用类型"><a href="#2、值类型和引用类型" class="headerlink" title="2、值类型和引用类型"></a>2、值类型和引用类型</h3><p>原始类型的保存方式：在变量中保存的是值本身</p><ul><li>所以原始类型也被称之为值类型</li></ul><p>对象类型的保存方式：在变量中保存的是对象的“引用”</p><ul><li>所以对象类型也被称之为引用类型</li></ul><h3 id="3、函数的-this-指向"><a href="#3、函数的-this-指向" class="headerlink" title="3、函数的 this 指向"></a>3、函数的 this 指向</h3><p>函数中是有一个this的变量，this变量在大多数情况下会指向一个对象</p><p>使用 this 方便在一个方法中，拿到当前对象的一些属性</p><p>情况一：如果普通的函数被默认调用，即全局环境下默认调用一个函数，那么this指向的是window</p><p>情况二：如果函数它是被某一个对象来引用并且调用它，即通过对象调用，那么this对指向这个对象(调用的那个对象)</p><p>this代表的是当前调用对象</p><h3 id="4、工厂方法创建类"><a href="#4、工厂方法创建类" class="headerlink" title="4、工厂方法创建类"></a>4、工厂方法创建类</h3><h5 id="1-类和对象的思维方式"><a href="#1-类和对象的思维方式" class="headerlink" title="1.类和对象的思维方式"></a>1.类和对象的思维方式</h5><p>创建一些列类似的对象，比如学生、游戏英雄，都具有姓名学号，但是具体的值不同</p><p>方法1：手动创建，但是重复代码很多</p><p>方法2：for循环，但是不能修改具体的值</p><p>方法3：工厂函数，一种常见的设计模式，但在js中大可不必这样做</p><p>工厂方法创建对象有一个比较大的问题：我们在打印对象时，对象的类型都是Object类型</p><ul><li>但是从某些角度来说，这些对象应该有一个他们共同的类型</li></ul><h5 id="2-构造函数的方式：使用new关键词（操作符）"><a href="#2-构造函数的方式：使用new关键词（操作符）" class="headerlink" title="2.构造函数的方式：使用new关键词（操作符）"></a>2.构造函数的方式：使用new关键词（操作符）</h5><ul><li>构造函数也被称之为构造器，通常我们在创建对象时会调用的函数</li><li>在其他编程语言，构造函数存在于类中的一个方法，称为构造方法</li><li>但在js中，构造函数扮演了其他语言中类的角色</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">coder</span>(<span class="params">name, age, height</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">height</span> = height</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">running</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;running&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在函数调用的前面加上 new 关键字(操作符)</span></span><br><span class="line"><span class="keyword">var</span> stu1 = <span class="keyword">new</span> <span class="title function_">coder</span>(<span class="string">&quot;why&quot;</span>, <span class="number">21</span>, <span class="number">157</span>)</span><br></pre></td></tr></table></figure><p>也就是在 JavaScript 中，构造函数其实就是类的扮演者：</p><p>比如系统默认给我们提供的 Date 就是一个构造函数，也可以看成是一个类</p><p>在ES5之前，我们都是通过 function 来声明一个构造函数（类）的，之后通过 new 关键字来对其进行调用</p><p>在ES6之后，JavaScript 可以像别的语言一样，通过 class 来声明一个类</p><h3 id="5、构造函数和类"><a href="#5、构造函数和类" class="headerlink" title="5、构造函数和类"></a>5、构造函数和类</h3><h5 id="1-什么是类（构造函数）"><a href="#1-什么是类（构造函数）" class="headerlink" title="1.什么是类（构造函数）"></a>1.什么是类（构造函数）</h5><ul><li><p>现实生活中往往是根据一份描述&#x2F;一个模板来创建一个实体对象的</p></li><li><p>编程语言也是一样, 也必须先有一份描述, 在这份描述中说明将来创建出来的对象有哪些属性(成员变量)和行为(成员方法)</p></li></ul><p>比如现实生活中，我们会如此来描述一些事物：</p><ul><li><p>比如水果fruits是一类事物的统称，苹果、橘子、葡萄等是具体的对象；</p></li><li><p>比如人person是一类事物的统称，而Jim、Lucy、Lily、李雷、韩梅梅是具体的对象；</p></li></ul><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230303155836052.png" alt="image-20230303155836052"></p><p>对象是由类创建出来的，类相当于设计图纸，用于描述对象的内容(属性)</p><p>类在没有调用的情况下是没有在内存中创建的，使用需要new操作符</p><p>JavaScript中类的表示形式就是构造函数。</p><h5 id="2-JavaScript中的构造函数是怎么样的？"><a href="#2-JavaScript中的构造函数是怎么样的？" class="headerlink" title="2.JavaScript中的构造函数是怎么样的？"></a>2.JavaScript中的构造函数是怎么样的？</h5><p>构造函数也是一个普通的函数，从表现形式来说，和千千万万个普通的函数没有任何区别；</p><p>那么如果这么一个普通的函数被使用new操作符来调用了，那么这个函数就称之为是一个构造函数；</p><p>如果一个函数被使用new操作符调用了，那么它会执行如下操作：</p><ol><li><p>在内存中创建一个新的对象（空对象）；</p></li><li><p>这个对象内部的[[prototype]]属性会被赋值为该构造函数的prototype属性；</p></li><li><p>构造函数内部的this，会指向创建出来的新对象；</p></li><li><p>执行函数的内部代码（函数体代码）；</p></li><li><p>如果构造函数没有返回非空对象，则返回创建出来的新对象；</p></li></ol><p>构造函数可以确保我们的对象是有我们定义的类型的（例如：student）</p><h5 id="3-全局对象window了解"><a href="#3-全局对象window了解" class="headerlink" title="3.全局对象window了解"></a>3.全局对象window了解</h5><p>浏览器中存在一个全局对象 Object —&gt; window</p><p>作用1：查找变量时，最终会查到 window 头上</p><p>作用2：将我们一些浏览器全局提供给我们的变量&#x2F;函数&#x2F;对象，放在 window 对象上</p><p>作用3：使用 var 定义的变量会被默认添加到 window 上面(设计缺陷)</p><p>浏览器看到后面添加了<strong>var</strong> message 信息，会对前方 clg.window 进行刷新，所以前方打印的window对象中可以查看到 message定义的信息</p><p>函数也是对象</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义对象类型的变量</span></span><br><span class="line"><span class="comment">// 地址 -&gt; 指针 -&gt; 引用</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125; <span class="comment">// 堆内存</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125; <span class="comment">// 堆内存</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;&#125;  <span class="comment">// 堆内存</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// console.log(typeof obj)  //Object</span></span><br><span class="line"><span class="comment">// console.log(typeof foo)  // function -&gt; object</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Dog</span>(<span class="params"></span>) &#123; &#125;</span><br><span class="line"><span class="comment">// 构造函数上(类上面) 添加的函数，称之为类方法</span></span><br><span class="line"><span class="title class_">Dog</span>.<span class="property">running</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="title class_">Dog</span>.<span class="title function_">running</span>()</span><br></pre></td></tr></table></figure><h2 id="9-JavaScript常见的内置类"><a href="#9-JavaScript常见的内置类" class="headerlink" title="9.JavaScript常见的内置类"></a>9.JavaScript常见的内置类</h2><h3 id="1、认识包装类型"><a href="#1、认识包装类型" class="headerlink" title="1、认识包装类型"></a>1、认识包装类型</h3><p>原始类型的包装类</p><p>js的原始类型并非对象类型，所以理论上，他们是没法获取属性或调用方法的</p><p>那么出现这样的现象，是因为js为了使其可以获取属性和调用方法，对其封装了对应的包装类型</p><p>常见的包装类型：String、Number、Boolean、Symbol、Bigint类型</p><p>包装类型的使用过程，当我们使用原始类型的属性或者方法时</p><ul><li><p>根据原始值，创建一个原始类型对应的包装类型对象</p></li><li><p>调用对应的属性或者方法，返回一个新的值</p></li><li><p>创建的包装类对象被销毁</p></li><li><p>通常JavaScript引擎会进行很多的优化，它可以跳过创建包装类的过程在内部直接完成属性的获取或者方法的调用</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;why&quot;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> num1)  <span class="comment">// object</span></span><br></pre></td></tr></table></figure><p>注意事项：null、undefined 没有任何的方法，也没有对应的 “ 对象包装型 ”</p><h3 id="2、数字类型Number"><a href="#2、数字类型Number" class="headerlink" title="2、数字类型Number"></a>2、数字类型Number</h3><h4 id="1-属性补充："><a href="#1-属性补充：" class="headerlink" title="1.属性补充："></a>1.属性补充：</h4><ul><li>Number.MAX_SAFE_INTEGER：JavaScript 中最大的安全整数 (2^53 - 1) </li><li>Number.MIN_SAFE_INTEGER：JavaScript 中最小的安全整数 -(2^53 - 1)</li></ul><h4 id="2-实例方法补充"><a href="#2-实例方法补充" class="headerlink" title="2.实例方法补充"></a>2.实例方法补充</h4><p> 方法一：toString(base)，将数字转成字符串，并且按照base进制进行转化</p><ul><li><p>base 的范围可以从 2 到 36，默认情况下是 10； </p></li><li><p>注意：如果是直接对一个数字操作，需要使用..运算符；</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num1.<span class="title function_">toString</span>(<span class="number">2</span>))  <span class="comment">// 转成2进制</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1000.</span>.<span class="title function_">toString</span>(<span class="number">2</span>))</span><br></pre></td></tr></table></figure><p>方法二：toFixed(digits)，格式化一个数字，保留digits位的小数，返回值是string类型； </p><ul><li><p>digits的范围是0到20（包含）之间；</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类方法：</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">parseInt</span>()  通过类名调用</span><br><span class="line"><span class="comment">// 实例方法：</span></span><br><span class="line"><span class="number">123.</span>.<span class="title function_">toFixed</span>(<span class="number">2</span>) 通过具体的对象调用</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-类方法补充"><a href="#3-类方法补充" class="headerlink" title="3.类方法补充"></a>3.类方法补充</h4><p>方法一：Number.parseInt(string[, radix])，将字符串解析成整数，也有对应的全局方法parseInt，不会四舍五入</p><p>方法二：Number. parseFloat(string)，将字符串解析成浮点数，也有对应的全局方法parseFloat</p><h3 id="3、数字对象Math"><a href="#3、数字对象Math" class="headerlink" title="3、数字对象Math"></a>3、数字对象Math</h3><p>Math 是一个内置对象（不是一个构造函数），它拥有一些数学常数属性和数学函数方法</p><p>常见的属性</p><ul><li>Math.PI：圆周率</li><li>Math.ceil：向上舍入取整 </li><li>Math.round：四舍五入取整 </li><li>Math.random：生成0~1的随机数（包含0，不包含1）</li><li>Math.pow(x, y)：返回x的y次幂</li></ul><h3 id="4、字符串类型String"><a href="#4、字符串类型String" class="headerlink" title="4、字符串类型String"></a>4、字符串类型String</h3><p>String 类提供了我们对于字符串各种操作的属性和方法</p><h4 id="1-常见的属性"><a href="#1-常见的属性" class="headerlink" title="1.常见的属性"></a>1.常见的属性</h4><ul><li>length：获取字符串的长度</li></ul><p>操作一：访问字符串的字符 </p><p>使用方法一：通过字符串的索引 str[0] </p><p>使用方法二：通过str.charAt(pos)方法 </p><p>它们的区别是索引的方式没有找到会返回undefined，而charAt没有找到会返回空字符串； </p><p>练习：字符串的遍历 </p><p>方式一：普通for循环</p><p>方式二：for..of..遍历</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// for...of...的遍历 -&gt; 迭代器</span></span><br><span class="line"><span class="comment">// 目前的可迭代对象：字符串/数组</span></span><br><span class="line"><span class="comment">// 对象不支持 for  of</span></span><br><span class="line"><span class="comment">// string 对象内部是将字符串变成了一个可迭代对象</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> char <span class="keyword">of</span> message) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(char)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-修改字符串"><a href="#2-修改字符串" class="headerlink" title="2.修改字符串"></a>2.修改字符串</h4><p>字符串的不可变性</p><ul><li>字符串在定义后是不可修改的</li></ul><p>在我们改变很多字符串的操作中，都是生成了一个新的字符串</p><p>比如改变字符串大小的两个方法 </p><ul><li><p>toLowerCase()：将所有的字符转成小写； </p></li><li><p>toUpperCase()：将所有的字符转成大写；</p></li></ul><h4 id="3-查找字符串"><a href="#3-查找字符串" class="headerlink" title="3.查找字符串"></a>3.查找字符串</h4><p>方法1：str.indexOf(searchValue[, fromIndex])</p><ul><li>从fromIndex开始，查找searchValue的索引</li><li>没有找到则返回-1</li><li>类似的方法 lastIndexOf，从最后开始查找（用的较少）</li></ul><p>方法2：是否包含字符串 str.includes(searchString[, position])</p><ul><li>position位置开始查找searchString， 根据情况返回 true 或 false</li><li>这是ES6新增的方法</li></ul><p>方法3：以xxx开头 str.startWith(searchString[, position])</p><ul><li>从position位置开始，判断字符串是否以searchString开头</li><li>这是ES6新增的方法，下面的方法也一样</li></ul><p>方法4：以xxx结尾 str.endWith(searchString[, length])</p><ul><li>length长度内，判断字符串是否以searchString结尾</li></ul><p>方法5：替换字符串 str.replace(regexp|substr,newSubStr|function)</p><ul><li>查找到对应的字符串，并且使用新的字符串进行替代</li><li>也可以传入一个正则表达式来查找，也可以传入一个函数来替换</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> message = <span class="string">&quot;my name is why.&quot;</span></span><br><span class="line">   <span class="keyword">var</span> name = <span class="string">&#x27;why&#x27;</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 判断一个字符串中是否有另外一个字符串</span></span><br><span class="line">   <span class="comment">// 1.indexOf(searchString, fromIndex)</span></span><br><span class="line">   <span class="comment">// 返回的结果是一个索引值</span></span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">     index:</span></span><br><span class="line"><span class="comment">       情况1：搜索到：搜索字符串所在的索引位置</span></span><br><span class="line"><span class="comment">       情况2：没有搜索到，返回-1</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"> <span class="comment">//  var index = message.indexOf(name)</span></span><br><span class="line"> <span class="comment">//  if (message.indexOf(name) !== -1) &#123;</span></span><br><span class="line"> <span class="comment">//   console.log(&quot;message中包含name&quot;)</span></span><br><span class="line"> <span class="comment">//  &#125; else &#123;</span></span><br><span class="line"> <span class="comment">//   console.log(&quot;message中不包含name&quot;)</span></span><br><span class="line"> <span class="comment">//  &#125;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 方法2：es6中新增一个方法，来判断包含关系</span></span><br><span class="line"> <span class="comment">// if (message.includes(name)) &#123;</span></span><br><span class="line"> <span class="comment">//   console.log(&quot;message中包含name&quot;)</span></span><br><span class="line"> <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 3.startWith:是否以xxx开头</span></span><br><span class="line"> <span class="comment">// if (message.startsWith(&quot;my&quot;)) &#123;</span></span><br><span class="line"> <span class="comment">//   console.log(&quot;message以my开头&quot;)</span></span><br><span class="line"> <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 4.endWith:是否以xxx结尾</span></span><br><span class="line"> <span class="comment">// if (message.endsWith(&#x27;why&#x27;)) &#123;</span></span><br><span class="line"> <span class="comment">//   console.log(&quot;message以why结尾&quot;)</span></span><br><span class="line"> <span class="comment">// &#125; else &#123;</span></span><br><span class="line"> <span class="comment">//   console.log(&quot;no&quot;)</span></span><br><span class="line"> <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 5.替换字符串 replace</span></span><br><span class="line"> <span class="comment">// var newMessage = message.replace(&quot;why&quot;, &quot;kobe&quot;)</span></span><br><span class="line"> <span class="comment">// console.log(newMessage)</span></span><br><span class="line"> <span class="keyword">var</span> newName = <span class="string">&quot;kobe&quot;</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">var</span> newMessage = message.<span class="title function_">replace</span>(<span class="string">&quot;why&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> newName.<span class="title function_">toUpperCase</span>()</span><br><span class="line"> &#125;)</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(newMessage)</span><br></pre></td></tr></table></figure><p>获取子字符串</p><table><thead><tr><th>方法</th><th>选择方式</th><th>负值参数</th></tr></thead><tbody><tr><td>slice(start,end)</td><td>从start到end（不含end）</td><td>允许</td></tr><tr><td>substring(start,end)</td><td>从start到end（不含end）</td><td>负值代表0</td></tr><tr><td>substr(start,length)</td><td>从start开始获取长为 length 的字符串</td><td>允许start为负数</td></tr></tbody></table><p>substr 方法可能有的浏览器不支持，推荐slcie，负值：-1表示为最后一位</p><h4 id="4-字符串的拼接"><a href="#4-字符串的拼接" class="headerlink" title="4.字符串的拼接"></a>4.字符串的拼接</h4><p>方法：</p><ul><li><p>运用 + 运算符</p></li><li><p>str1.concat(str2)   括号中的是可变参数，支持链式编程</p></li></ul><p>删除首尾空格：str.trim()</p><h4 id="6-字符串切割与改变连接方式"><a href="#6-字符串切割与改变连接方式" class="headerlink" title="6.字符串切割与改变连接方式"></a>6.字符串切割与改变连接方式</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> message = <span class="string">&quot;223-423-422-122-352&quot;</span></span><br><span class="line">   <span class="keyword">var</span> items = message.<span class="title function_">split</span>(<span class="string">&quot;-&quot;</span>)  <span class="comment">// 返回值是一个string类型的数组</span></span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(items)</span><br><span class="line">   <span class="comment">// 将此数组改为以 * 连接的字符串</span></span><br><span class="line">   <span class="keyword">var</span> newMessage = items.<span class="title function_">join</span>(<span class="string">&quot;*&quot;</span>)</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(newMessage)</span><br></pre></td></tr></table></figure><p>补充 string 方法</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;124&quot;</span></span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">padStart</span>(<span class="number">4</span>, <span class="string">&quot;0&quot;</span>))   <span class="comment">// 0124</span></span><br></pre></td></tr></table></figure><h3 id="5、数组Array使用详解"><a href="#5、数组Array使用详解" class="headerlink" title="5、数组Array使用详解"></a>5、数组Array使用详解</h3><h4 id="1-什么是数组"><a href="#1-什么是数组" class="headerlink" title="1.什么是数组"></a>1.什么是数组</h4><p>是一种有序的组合，里面的元素是按照一定顺序来排列的，可以通过索引查找</p><p>数组和对象都是一种保存多个数据的数据结构</p><p>通过 [ ] 创建</p><ul><li>数组是一种特殊的对象类型</li></ul><p>通过构造函数 Array 创建</p><ul><li>new Array()  &#x2F;&#x2F; () 里面可以传入数据  “ ”  ，但是如果传入一个数字类型，会默认当成我们要创建一个对应长度的数组</li></ul><p>数组元素从0开始索引</p><ul><li>一些编程语言可以通过 arr[-1] 来访问最后一个元素</li><li>js并不支持这种写法，访问最后一个元素：arr[arr.length-1]</li></ul><h4 id="2-数组的基本操作"><a href="#2-数组的基本操作" class="headerlink" title="2.数组的基本操作"></a>2.数组的基本操作</h4><h5 id="1、访问数组中的元素"><a href="#1、访问数组中的元素" class="headerlink" title="1、访问数组中的元素"></a>1、访问数组中的元素</h5><ul><li>arr[index]</li><li>arr.at(index)<ul><li>如果index &gt;&#x3D; 0，则与arr[index] 的情况相同</li><li>对于index为负数的情况，它则从数组的尾部向前数</li></ul></li></ul><h5 id="2、修改数组中的元素"><a href="#2、修改数组中的元素" class="headerlink" title="2、修改数组中的元素"></a>2、修改数组中的元素</h5><p>arr[index] &#x3D; “coderwhy”</p><h5 id="3、删除"><a href="#3、删除" class="headerlink" title="3、删除"></a>3、删除</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">delete</span> names[<span class="number">2</span>] </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(names)  <span class="comment">// 索引为2的位置为empty</span></span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(names[<span class="number">2</span>])  <span class="comment">// 查询结果为undefined</span></span><br></pre></td></tr></table></figure><p>删除和添加元素虽然也可以通过索引来直接操作，但是开发中很少这样操作。</p><p>具体的操作方法</p><ul><li>添加&#x2F;删除尾部<ul><li>push()：在尾部添加元素，为可变参数</li><li>pop()：在尾部删除元素，一次只能删除一个元素</li></ul></li><li>添加&#x2F;删除首部<ul><li>unshift()：在首部添加元素，为可变参数， 在首端添加元素，整个其他数组元素向后移动</li><li>shift()：在首部删除元素，一次只能删除一个元素， 取出队列首端的一个元素，整个数组元素向前前移动</li></ul></li></ul><p>相对来说，push和pop的运行比较快</p><p>删除方法2：</p><ul><li>arr.splice</li></ul><p>语法结构：arr.splice(start, deleteCount, [, item1[, item2[,item3]…]])</p><p>从start位置开始，删除deleteCount（0代表不删除)个元素，后面的则为添加items</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除元素</span></span><br><span class="line">names.<span class="title function_">splice</span>(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(names)</span><br><span class="line"><span class="comment">// 新增元素</span></span><br><span class="line">names.<span class="title function_">splice</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="string">&quot;ssx&quot;</span>, <span class="string">&quot;ccg&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(names)</span><br><span class="line"><span class="comment">// 替换元素</span></span><br><span class="line">names.<span class="title function_">splice</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;vc&quot;</span>, <span class="string">&quot;ccc&quot;</span>, <span class="string">&quot;kobe&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(names)</span><br></pre></td></tr></table></figure><p>这个方法会修改原数组</p><p>length 属性：用于获取数组的长</p><ul><li>当我们修改出租的时候，length 属性会自动更新</li></ul><p>length属性是可写的</p><ul><li>如果我们手动增加一个默认大于length的数值，那么会增加数组的长度</li><li>但是如果我们减少它，数组会被截断</li></ul><p>清空数组的最简单的方法就是：arr.length &#x3D; 0</p><h5 id="4、数组的遍历"><a href="#4、数组的遍历" class="headerlink" title="4、数组的遍历"></a>4、数组的遍历</h5><ul><li>普通的 for 循环</li><li>for..in 遍历：获取到的 index 为索引值，arr[index] 为 value 值</li><li>for..of 遍历：获取不到索引值，能获取到每一个元素</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2.1 普通的for 循环</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; names.<span class="property">length</span>; i++) &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(names[i])</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 2.2 for...in</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">var</span> index <span class="keyword">in</span> names) &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(index, names[index])  <span class="comment">// 索引</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 2.3 for...of</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">var</span> items <span class="keyword">of</span> names) &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(items)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h5 id="5、数组方法"><a href="#5、数组方法" class="headerlink" title="5、数组方法"></a>5、数组方法</h5><ul><li>arr.slice 方法：用于对数组进行截取，不会修改原数组，类似于字符串的slice方法<ul><li>arr.slice(start, end) 截取到的元素包含strat，但不包含end 元素</li></ul></li><li>arr.concat 方法：创建一个新的数组，其中包含来自于其他数组和其他项的值<ul><li>var newArr &#x3D; arr.concat(“ssd”, “ssx”, “ccc”)</li></ul></li><li>arr.join 方法：将一个数组的所有元素连接成一个字符串并返回这个字符串<ul><li>console.log(arr.join(“-“))</li></ul></li></ul><h5 id="6、查找元素"><a href="#6、查找元素" class="headerlink" title="6、查找元素"></a>6、查找元素</h5><ul><li>arr.indexOf(searchElement[, fromIndex]) 方法，查找某个元素的索引<ul><li>从 fromIndex 开始查找，如果找到则返回索引，没找到返回-1</li><li>也有对应的从最后位置开始查找的 lastIndexOf 方法</li><li>对于复杂数据类型的不便于查找，使用 for 循环也可以实现</li></ul></li><li>arr.includes 方法：判断数组是否包含某个元素<ul><li>arr.includes(valueToFind[, fromIndex])</li><li>从索引from开始查找item，找到则返回true，找不到返回false</li></ul></li><li>find 和 findIndex 直接查找元素或者元素的索引（es6之后）</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> findStu = students.<span class="title function_">find</span>(<span class="keyword">function</span>(<span class="params">item</span>)&#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(item)</span><br><span class="line">     <span class="keyword">return</span> item.<span class="property">id</span> = <span class="number">101</span></span><br><span class="line">   &#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(findStu)</span><br></pre></td></tr></table></figure><h5 id="7、排序和反转"><a href="#7、排序和反转" class="headerlink" title="7、排序和反转"></a>7、排序和反转</h5><p>方法1：算法实现排序</p><p>方法2：使用 sort 高级函数，排序之后生成一个新的数组，可用于复杂类型的数组</p><ul><li><p>如果 compareFunction(a, b) 小于 0 ，那么 a 会被排列到 b 前面； </p></li><li><p>如果 compareFunction(a, b) 等于 0 ， a 和 b 的相对位置不变； </p></li><li><p>如果 compareFunction(a, b) 大于 0 ， b 会被排列到 a 前面； </p></li><li><p>也就是说，谁小谁排在前面；</p></li></ul><p> reverse() 方法将数组中元素的位置颠倒，并返回该数组</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">num.<span class="title function_">sort</span>(<span class="keyword">function</span>(<span class="params">item1, item2</span>) &#123;</span><br><span class="line">     <span class="comment">// item1 和 item2 进行比较</span></span><br><span class="line">     <span class="comment">// 返回的是 正数</span></span><br><span class="line">     <span class="comment">// 谁小谁在前</span></span><br><span class="line">     <span class="keyword">return</span> item1 - item2  <span class="comment">//升序</span></span><br><span class="line">     <span class="comment">// return item2 - item1  //降序</span></span><br><span class="line">   &#125;)</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(num)</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(num.<span class="title function_">reverse</span>())  <span class="comment">// 反转</span></span><br></pre></td></tr></table></figure><h5 id="8、数组的其他高阶函数"><a href="#8、数组的其他高阶函数" class="headerlink" title="8、数组的其他高阶函数"></a>8、数组的其他高阶函数</h5><p>arr.forEach  参数（item,index,arr）</p><ul><li>遍历数组，并且让数组中每一个元素都执行一次对应的方法</li></ul><p>arr.map   参数（item,index,arr）</p><ul><li>map() 方法创建一个新数组</li><li>这个新数组由原数组中的每个元素都调用一次提供的函数后的返回值组成</li></ul><p>arr.filter   参数（item,index,arr）</p><ul><li>filter() 方法创建一个新数组</li><li>新数组中只包含每个元素调用函数返回为true的元素</li></ul><p>arr.reduce  参数（preValue, item） preValue 可以传入一个0  作为第一次执行的preValue</p><ul><li>用于计算数组中所有元素的总和</li><li>对数组中的每个元素按序执行一个由您提供的 reducer 函数</li><li>每一次运行 reducer 会将先前元素的计算结果作为参数传入，最后将其结果汇总为单个返回值</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">综合练习：过滤所有的偶数 计算偶数的平方 再求和</span><br><span class="line">    <span class="keyword">var</span> total = num.<span class="title function_">filter</span>(<span class="keyword">function</span>(<span class="params">item</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> item % <span class="number">2</span> === <span class="number">0</span></span><br><span class="line">    &#125;).<span class="title function_">map</span>(<span class="keyword">function</span>(<span class="params">item</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> item * item</span><br><span class="line">    &#125;).<span class="title function_">reduce</span>(<span class="keyword">function</span>(<span class="params">preValue, item</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> preValue + item</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(total)</span><br></pre></td></tr></table></figure><h3 id="6、Date类型的使用"><a href="#6、Date类型的使用" class="headerlink" title="6、Date类型的使用"></a>6、Date类型的使用</h3><h4 id="1-创建Date对象"><a href="#1-创建Date对象" class="headerlink" title="1.创建Date对象"></a>1.创建Date对象</h4><p>在 js 中使用 Date 来表示和处理时间</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Date 构造函数的以下用法</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>()  <span class="comment">// 当前时间</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&quot;2022-08-08&quot;</span>)   <span class="comment">// 传入参数，时间字符串</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">2022</span>, <span class="number">02</span>, <span class="number">03</span>, <span class="number">06</span>, <span class="number">15</span>, <span class="number">06</span>, <span class="number">33</span>) <span class="comment">// 传入具体的年月日时分秒毫秒</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">1000267496623</span>) <span class="comment">// 传入一个Unix时间戳  1s -&gt; 1000ms</span></span><br></pre></td></tr></table></figure><h4 id="2-dateString-时间的表示方式"><a href="#2-dateString-时间的表示方式" class="headerlink" title="2. dateString 时间的表示方式"></a>2. dateString 时间的表示方式</h4><p>日期的表示方式有两种：RFC 2822 标准 或者 ISO 8601 标准</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date)  <span class="comment">//  Wed Mar 08 2023 09:52:44 GMT+0800 (中国标准时间) </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date.<span class="title function_">toDateString</span>())  <span class="comment">// Wed Mar 08 2023</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date.<span class="title function_">toISOString</span>())  <span class="comment">// 2023-03-08T01:52:44.254Z 标准时间 不是北京时间</span></span><br></pre></td></tr></table></figure><p>可以将其转化成ISO 8601标准的：  </p><p>YYYY：年份，0000 ~ 9999</p><p>MM：月份，01 ~ 12</p><p>DD：日，01 ~ 31</p><p>T：分隔日期和时间，没有特殊含义，可以省略</p><p>HH：小时，00 ~ 24 </p><p>mm：分钟，00 ~ 59 </p><p>ss：秒，00 ~ 59</p><p>.sss：毫秒  Z：时区</p><h4 id="3-Date-对象的方法"><a href="#3-Date-对象的方法" class="headerlink" title="3.Date 对象的方法"></a>3.Date 对象的方法</h4><p>我们可以从Date对象中获取各种详细的信息： </p><ul><li><p>getFullYear()：获取年份（4 位数）</p></li><li><p>getMonth()：获取月份，从 0 到 11</p></li><li><p>getDate()：获取当月的具体日期，从 1 到 31（方法名字有点迷）</p></li><li><p>getHours()：获取小时</p></li><li><p>getMinutes()：获取分钟</p></li><li><p>getSeconds()：获取秒钟</p></li><li><p>getMilliseconds()：获取毫秒</p></li><li><p>getDay()：获取一周中的第几天，从 0（星期日）到 6（星期六）</p></li></ul><p>设置信息的方法</p><ul><li>setFullYear(year, [month], [date]) </li><li>setMonth(month, [date]) </li><li>setDate(date) </li><li>setHours(hour, [min], [sec], [ms]) </li><li>setMinutes(min, [sec], [ms]) </li><li>setSeconds(sec, [ms]) </li><li>setMilliseconds(ms) </li><li>setTime(milliseconds)</li></ul><p>设置超范围的数值，它会自动校准</p><h4 id="4-Date-获取-Unix-时间戳"><a href="#4-Date-获取-Unix-时间戳" class="headerlink" title="4.Date 获取 Unix 时间戳"></a>4.Date 获取 Unix 时间戳</h4><p>Unix 时间戳：它是一个整数值，表示自1970年1月1日00:00:00 UTC以来的毫秒数</p><p>前面可知，我们可以通过传入一个时间戳来获取其表示的时间</p><p>获取当前的时间戳：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">方法<span class="number">1</span>：<span class="keyword">var</span> timestamp1 = <span class="title class_">Date</span>.<span class="title function_">now</span>()</span><br><span class="line">方法<span class="number">2</span>：<span class="keyword">var</span> date = <span class="keyword">new</span> <span class="title class_">Date</span>()</span><br><span class="line">  <span class="keyword">var</span> timestamp2 = date.<span class="title function_">getTime</span>()</span><br><span class="line">方法<span class="number">3</span>：<span class="variable language_">console</span>.<span class="title function_">log</span>(+date)  <span class="comment">// +运算符</span></span><br><span class="line">可写为：<span class="keyword">var</span> timestamp5 = +<span class="keyword">new</span> <span class="title class_">Date</span>()</span><br></pre></td></tr></table></figure><p>将一个对象转成时间戳：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> date2 = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&quot;2033-03-03&quot;</span>)</span><br><span class="line">方法<span class="number">1</span>：<span class="keyword">var</span> timestamp3 = date2.<span class="title function_">getTime</span>()</span><br><span class="line">方法<span class="number">2</span>：<span class="keyword">var</span> timestamp4 = date2.<span class="title function_">valueOf</span>()</span><br><span class="line">方法<span class="number">3</span>：<span class="variable language_">console</span>.<span class="title function_">log</span>(+date2)</span><br><span class="line">可写为：<span class="keyword">var</span> timestamp6 = +<span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&quot;2033-03-03&quot;</span>)</span><br></pre></td></tr></table></figure><p>时间戳的作用：例如：计算一个操作花费的时间</p><h4 id="5-Date-parse-方法"><a href="#5-Date-parse-方法" class="headerlink" title="5.Date.parse 方法"></a>5.Date.parse 方法</h4><p> Date.parse(str) 方法可以从一个字符串中读取日期，并且输出对应的Unix时间戳</p><ul><li><p>作用等同于 new Date(dateString).getTime() 操作</p></li><li><p>需要符合 RFC2822 或 ISO 8601 日期格式的字符串</p></li><li><p>其他格式也许也支持，但结果不能保证一定正常</p></li><li><p>如果输入的格式不能被解析，那么会返回NaN</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> timeString = <span class="string">&quot;2033-2-3&quot;</span></span><br><span class="line"><span class="keyword">var</span> timestamp = <span class="title class_">Date</span>.<span class="title function_">parse</span>(timeString)</span><br></pre></td></tr></table></figure><h2 id="10-JavaScript-的-DOM-操作"><a href="#10-JavaScript-的-DOM-操作" class="headerlink" title="10.JavaScript 的 DOM 操作"></a>10.JavaScript 的 DOM 操作</h2><h3 id="1、什么是DOM"><a href="#1、什么是DOM" class="headerlink" title="1、什么是DOM"></a>1、什么是DOM</h3><p>学完以上ECMAScript 语法，我们还需要学习浏览器提供开发者的DOM、BOM相关的API才能对网页、浏览器进行操作</p><p>window 全局对象不仅提供了js语法部分的Object\Arry\Date等，也提供了DOM\BOM部分</p><p>DOM：浏览器考虑到开发者与用户可能需要对网页元素做某些操作，会将网页元素抽象成JS对象</p><ul><li>即将网页所有的元素表示为可以修改的对象</li><li>所以这些对象都可以通过 JS 来对其进行访问，所以可以通过 JS 来操作页面</li><li>这个抽象过程称之为文档对象模型，称之为 Document Object Model</li><li>作为了JS语法与网页元素的桥梁</li></ul><p>BOM：浏览器对象模型</p><ul><li>由浏览器提供的用于处理文档之外的所有的其他对象</li><li>比如 navigator、location、history 等对象</li></ul><h3 id="2、认识DOM-Tree"><a href="#2、认识DOM-Tree" class="headerlink" title="2、认识DOM Tree"></a>2、认识DOM Tree</h3><p>在 html 结构中，所有元素都会形成一个树结构（节点是元素）</p><p>抽象为 DOM 之后也会形成 DOM Tree （节点是抽象的对象）</p><h3 id="3、DOM-的整体结构"><a href="#3、DOM-的整体结构" class="headerlink" title="3、DOM 的整体结构"></a>3、DOM 的整体结构</h3><p>DOM相当于是JavaScript和HTML、CSS之间的桥梁</p><ul><li>通过浏览器提供给我们的DOM API，我们可以对元素以及其中的内容做任何事情；</li></ul><p>DOM的继承关系</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230309102756157.png" alt="image-20230309102756157"></p><p>document 对象</p><p>Document节点表示的整个载入的网页，它的实例是全局的document对象：</p><ul><li><p>对DOM的所有操作都是从 document 对象开始的</p></li><li><p>它是DOM的入口点，可以从document开始去访问任何节点元素</p></li></ul><p>对于最顶层的html、head、body元素，我们可以直接在document对象中获取到：</p><ul><li><p>html元素： &#x3D; document.documentElement</p></li><li><p>body元素： &#x3D; document.body</p></li><li><p>head元素： &#x3D; document.head</p></li><li><p>文档声明： &#x3D; document.doctype</p></li></ul><h3 id="4、节点、元素导航"><a href="#4、节点、元素导航" class="headerlink" title="4、节点、元素导航"></a>4、节点、元素导航</h3><h4 id="1-节点之间导航"><a href="#1-节点之间导航" class="headerlink" title="1.节点之间导航"></a>1.节点之间导航</h4><p>如果我们获取到一个节点（Node）后，可以根据这个节点去获取其他的节点，我们称之为节点之间的导航</p><p>节点之间存在如下的关系：</p><ul><li><p>父节点：parentNode</p></li><li><p>前兄弟节点：previousSibling</p></li><li><p>后兄弟节点：nextSibling</p></li><li><p>子节点：childNodes</p></li><li><p>第一个子节点：firstChild</p></li><li><p>第二个子节点：lastChild</p></li></ul><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230311132712739.png" alt="image-20230311132712739"></p><h4 id="2-元素之间导航"><a href="#2-元素之间导航" class="headerlink" title="2.元素之间导航"></a>2.元素之间导航</h4><p>如果我们获取到一个元素（Element）后，可以根据这个元素去获取其他的元素，我们称之为元素之间的导航。</p><p>节点之间存在如下的关系：</p><ul><li><p>父元素：parentElement</p></li><li><p>前兄弟节点：previousElementSibling</p></li><li><p>后兄弟节点：nextElementSibling</p></li><li><p>子节点：children</p></li><li><p>第一个子节点：firstElementChild</p></li><li><p>第二个子节点：lastElementChild</p></li></ul><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230311132841099.png" alt="image-20230311132841099"></p><h4 id="3-table元素之间的导航"><a href="#3-table元素之间的导航" class="headerlink" title="3.table元素之间的导航"></a>3.table元素之间的导航</h4><p>table 还元素支持以下这些属性：</p><ul><li><p>table.rows —  tr元素的集合</p></li><li><p>table.caption&#x2F;tHead&#x2F;tFoot — 引用元素caption、thead、tfoot </p></li><li><p>table.tBodies — tbody 元素的集合</p></li></ul><p>thead、tfoot、tbody 元素提供了 rows 属性</p><ul><li>tbody.rows — 表格内部 tr 元素的集合</li></ul><p>tr：</p><ul><li><p>tr.cells — 在给定 tr 中的 td 和 th 单元格的集合</p></li><li><p>tr.sectionRowIndex — 给定的 tr 在封闭的 thead&#x2F;tbody&#x2F;tfoot 中的位置（索引）</p></li><li><p>tr.rowIndex — 在整个表格中 tr 的编号（包括表格的所有行）</p></li></ul><p>td 和 th</p><ul><li>td.cellIndex — 在封闭的 tr 中单元格的编号</li></ul><h4 id="4-form元素之间的导航"><a href="#4-form元素之间的导航" class="headerlink" title="4.form元素之间的导航"></a>4.form元素之间的导航</h4><p>获取 form 元素可以通过节点和元素的方法获取，也可以通过forms获取；</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> formEl = <span class="variable language_">document</span>.<span class="property">forms</span>[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>form 元素中的内容可以通过 elements 来获取：form.elements</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> elements = formEl.<span class="property">elements</span></span><br></pre></td></tr></table></figure><p>获取 form 中的子元素还可以通过 name 其属性获取</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> inputEl = formEl.<span class="property">elements</span>.<span class="property">account</span></span><br></pre></td></tr></table></figure><p>作用是有时能够以此来获取 input 表单的 value</p><h3 id="5、获取元素的方法"><a href="#5、获取元素的方法" class="headerlink" title="5、获取元素的方法"></a>5、获取元素的方法</h3><p>DOM 提供的获取元素的方法：</p><table><thead><tr><th>方法名</th><th>搜索方式</th><th>可以在元素上调用？</th><th>实时？</th></tr></thead><tbody><tr><td>querySelector</td><td>css-selector</td><td>√</td><td>-</td></tr><tr><td>querySelectorAll</td><td>css-selector</td><td>√</td><td>-</td></tr><tr><td>getElementById</td><td>id</td><td>-</td><td>-</td></tr><tr><td>getElementByName</td><td>name</td><td>-</td><td>√</td></tr><tr><td>getElementByTagName</td><td>tar or ‘*’</td><td>√</td><td>√</td></tr><tr><td>getElementByClassName</td><td>class</td><td>√</td><td>√</td></tr></tbody></table><p>目前最常用的是querySelector和querySelectAll </p><p>getElementById偶尔也会使用或者在适配一些低版本浏览器时；</p><h3 id="6、Node-节点的属性"><a href="#6、Node-节点的属性" class="headerlink" title="6、Node 节点的属性"></a>6、Node 节点的属性</h3><h4 id="1-nodeType属性："><a href="#1-nodeType属性：" class="headerlink" title="1.nodeType属性："></a>1.nodeType属性：</h4><ul><li><p>nodeType 属性提供了一中获取节点类型的方法</p></li><li><p>它有一个数值型值</p></li></ul><p>常见的节点类型：</p><table><thead><tr><th>常量</th><th>值</th><th>描述</th></tr></thead><tbody><tr><td>Node.ELEMENT_NODE</td><td>1</td><td>一个元素节点，例如p元素和div元素</td></tr><tr><td>Node.TEXT_NODE</td><td>3</td><td>Element 或者 Attr 中实际的 文字</td></tr><tr><td>Node.COMMENT_NODE</td><td>8</td><td>一个 Comment 节点。</td></tr><tr><td>Node.DOCUMENT_NODE</td><td>9</td><td>一个 Document 节点。</td></tr><tr><td>Node.DOCUMENT_TYPE_NODE</td><td>10</td><td>描述文档类型的DocumentType 节点。例如<!DCOTYPE html></td></tr></tbody></table><p>nodeName：获取节点的名字</p><p>tagName：获取元素的名称</p><ul><li><p>tagName 属性仅适用于 Element 节点；</p></li><li><p>nodeName 是为任意 Node 定义的：</p><ul><li>对于元素，它的意义与 tagName 相同，所以使用哪一个都是可以的；</li><li>对于其他节点类型（text，comment 等），它拥有一个对应节点类型的字符串</li></ul></li></ul><p>nodeValue&#x2F;data： 用于获取非元素节点的文本内容</p><p>innerHTML 属性</p><ul><li>将元素中的 HTML 获取为字符串形式； </li><li>设置元素中的内容；</li></ul><p>outerHTML 属性</p><ul><li>包含了元素的完整 HTML</li><li>innerHTML 加上元素本身一样；</li></ul><p>textContent 属性</p><ul><li>仅仅获取元素中的文本内容；</li></ul><p>innerHTML和textContent的区别：</p><ul><li>仅仅设置文本的话作用相同</li></ul><p>内容带标签的话</p><ul><li><p>使用 innerHTML，我们将其“作为 HTML”插入，带有所有 HTML 标签</p></li><li><p>使用 textContent，我们将其“作为文本”插入，所有符号（symbol）均按字面意义处理</p></li></ul><p>全局属性 hidden：可以用于设置元素隐藏</p><p>一个元素除了有开始标签、结束标签、内容之外，还有很多的属性（attribute）</p><p>浏览器在解析HTML元素时，会将对应的attribute也创建出来放到对应的元素对象上。</p><ul><li><p>比如id、class就是全局的attribute，会有对应的id、class属性；</p></li><li><p>比如href属性是针对a元素的，type、value属性是针对input元素的；</p></li></ul><p>Attribute 的分类：</p><p>1.如果是HTML标准制定的Attribute，称之为标准的Attribute</p><p>2.而自定义的Attribute，称之为非标准的Attribute</p><h4 id="2-Attribute-属性的操作："><a href="#2-Attribute-属性的操作：" class="headerlink" title="2.Attribute 属性的操作："></a>2.Attribute 属性的操作：</h4><p>对于所有的（标准的和自定义的）attribute访问都支持如下的方法：</p><ul><li><p>elem.hasAttribute(name) — 检查特性是否存在。</p></li><li><p>elem.getAttribute(name) — 获取这个特性值。（字符串类型）（不存在则返回 null）</p></li><li><p>elem.setAttribute(name, value) — 设置这个特性值。</p></li><li><p>elem.removeAttribute(name) — 移除这个特性。</p></li><li><p>attributes：attr对象的集合，具有name、value属性</p></li></ul><p>attribute具备以下特征：</p><ul><li><p>它们的名字是大小写不敏感的（id 与 ID 相同）。</p></li><li><p>它们的值总是字符串类型的。</p></li></ul><h4 id="3-元素的属性-property"><a href="#3-元素的属性-property" class="headerlink" title="3.元素的属性 property"></a>3.元素的属性 property</h4><p>对于 HTML 元素，在元素中称其属性为 attribute，通过js获取元素对象之后（通过property获取attribute的值），称之为元素的对象模型。</p><p>对于标准的attribute，会在DOM对象上创建与其对应的property属性：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里的id称之为property</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(boxEl.<span class="property">id</span>, boxEl.<span class="property">age</span>, boxEl.<span class="property">height</span>,boxEl.<span class="property">title</span>)</span><br></pre></td></tr></table></figure><p>不是标准的属性的话（自定义）返回值为 undefined</p><p>在大多数情况下，它们是相互作用的</p><ul><li><p>改变property，通过attribute获取的值，会随着改变；</p></li><li><p>通过attribute操作修改，property的值会随着改变；</p><ul><li>但是input的value修改只能通过attribute的方法；</li></ul></li></ul><p>大多数情况下，设置、获取attribute，推荐使用property的方式：这是因为它默认情况下是有类型的；</p><p>*<em>HTML5的data-<em>自定义属性，那么它们也是可以在dataset属性中获取到的</em></em></p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230405193102932.png" alt="image-20230405193102932"></p><h4 id="4-JavaScript中动态修改样式"><a href="#4-JavaScript中动态修改样式" class="headerlink" title="4.JavaScript中动态修改样式"></a>4.JavaScript中动态修改样式</h4><p>有时候我们会通过JavaScript来动态修改样式，这个时候我们有两个选择：</p><ul><li><p>选择一：在CSS中编写好对应的样式，动态的添加class；</p></li><li><p>选择二：动态的修改style属性；</p></li></ul><p>开发中如何选择呢？</p><ul><li><p>在大多数情况下，如果可以动态修改class完成某个功能，更推荐使用动态class；</p></li><li><p>如果对于某些情况，无法通过动态修改class（比如精准修改某个css属性的值），那么就可以修改style属性</p></li></ul><p>元素的 className 和 classList</p><p>元素的class attribute，对应的property并非叫class，而是className：</p><p>这是因为JavaScript早期是不允许使用class这种关键字来作为对象的属性，所以DOM规范使用了className；</p><p>虽然现在JavaScript已经没有这样的限制，但是并不推荐，并且依然在使用className这个名称</p><p>对className进行赋值，<strong>它会替换整个类中的字符串</strong></p><p>如果我们需要添加或者移除单个的class，那么可以使用classList属性。</p><p>elem.classList 是一个特殊的对象：</p><ul><li><p>elem.classList.add (class) ：添加一个类</p></li><li><p>elem.classList.remove(class)：添加&#x2F;移除类。</p></li><li><p>elem.classList.toggle(class) ：如果类不存在就添加类，存在就移除它。</p></li><li><p>elem.classList.contains(class)：检查给定类，返回 true&#x2F;false。</p></li></ul><p>classList是可迭代对象，可以通过for of进行遍历。</p><p>元素的 style 属性</p><p>如果需要单独修改某一个CSS属性，那么可以通过style来操作：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">boxEl.<span class="property">style</span>.<span class="property">fontSize</span> = <span class="string">&quot;30px&quot;</span></span><br></pre></td></tr></table></figure><p>对于多词（multi-word）属性，使用驼峰式（小驼峰） camelCase</p><p>如果我们将值设置为空字符串，那么会使用CSS的默认样式：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">boxEl.<span class="property">style</span>.<span class="property">fontSize</span> = <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>多个样式的写法，我们需要使用cssText属性：</p><p>不推荐这种用法，<strong>因为它会替换整个字符串</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">boxEl.<span class="property">style</span>.<span class="property">cssText</span> = <span class="string">&#x27;font-size: 30px; color: red;&#x27;</span></span><br></pre></td></tr></table></figure><p>元素 style 的读取</p><p> 对于内联样式，是可以通过style.*的方式读取到的；</p><p>对于style、css文件中的样式，是读取不到的</p><p>这个时候，我们可以通过getComputedStyle的全局函数来实现</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getComputedStyle</span>(boxEl).<span class="property">fontSize</span>)</span><br></pre></td></tr></table></figure><h4 id="5-创建元素"><a href="#5-创建元素" class="headerlink" title="5.创建元素"></a>5.创建元素</h4><p>document.write：非常便捷，但是对于复杂的内容、元素关系拼接并不方便</p><h5 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h5><ul><li>步骤一：创建元素：document.createElement(tag)</li><li>步骤二：插入元素到 DOM 的某一个位置</li></ul><p>插入方式：</p><ul><li><p>node.append(…nodes or strings) —— 在 node 末尾插入节点或字符串</p></li><li><p>node.prepend(…nodes or strings) —— 在 node 开头插入节点或字符串</p></li><li><p>node.before(…nodes or strings) —— 在 node 前面插入节点或字符串</p></li><li><p>node.after(…nodes or strings) —— 在 node 后面插入节点或字符串</p></li><li><p>node.replaceWith(…nodes or strings) —— 将 node 替换为给定的节点或字符串</p></li></ul><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230312090927700.png" alt="image-20230312090927700"></p><h5 id="移除和克隆元素"><a href="#移除和克隆元素" class="headerlink" title="移除和克隆元素"></a>移除和克隆元素</h5><p>移除元素我们可以调用元素本身的remove方法：</p><p>想要复制一个现有的元素，可以通过cloneNode方法：</p><ul><li><p>可以传入一个Boolean类型的值，来决定是否是深度克隆；</p></li><li><p>深度克隆会克隆对应元素的子元素，否则不会；</p></li></ul><h5 id="旧方法操作元素（了解）"><a href="#旧方法操作元素（了解）" class="headerlink" title="旧方法操作元素（了解）"></a>旧方法操作元素（了解）</h5><p>parentElem.appendChild(node)： </p><ul><li>在parentElem的父元素最后位置添加一个子元素</li></ul><p>parentElem.insertBefore(node, nextSibling)：</p><ul><li>在parentElem的nextSibling前面插入一个子元素；</li></ul><p>parentElem.replaceChild(node, oldChild)：</p><ul><li>在parentElem中，新元素替换之前的oldChild元素；</li></ul><p>parentElem.removeChild(node)：</p><ul><li>在parentElem中，移除某一个元素；</li></ul><h4 id="6-元素的大小、滚动"><a href="#6-元素的大小、滚动" class="headerlink" title="6.元素的大小、滚动"></a>6.元素的大小、滚动</h4><p>clientWidth：contentWith+padding（不包含滚动条）</p><p>clientHeight：contentHeight+padding</p><p>clientTop：border-top的宽度</p><p>clientLeft：border-left的宽度</p><p>offsetWidth：元素完整的宽度</p><p>offsetHeight：元素完整的高度</p><p>offsetLeft：距离父元素的x</p><p>offsetHeight：距离父元素的y</p><p>scrollHeight：整个可滚动的区域高度</p><p>scrollTop：滚动部分的高度</p><h4 id="7-window的大小、滚动"><a href="#7-window的大小、滚动" class="headerlink" title="7.window的大小、滚动"></a>7.window的大小、滚动</h4><p>window的width和height</p><ul><li><p>innerWidth、innerHeight：获取window窗口的宽度和高度（包含滚动条）</p></li><li><p>outerWidth、outerHeight：获取window窗口的整个宽度和高度（包括调试工具、工具栏）</p></li><li><p>documentElement.clientHeight、documentElement.clientWidth：获取html的宽度和高度（不包含滚动条）</p></li></ul><p>indow的滚动位置：</p><ul><li><p>scrollX：X轴滚动的位置（别名pageXOffset）</p></li><li><p>scrollY：Y轴滚动的位置（别名pageYOffset）</p></li></ul><p>也有提供对应的滚动方法：</p><ul><li><p>方法 scrollBy(x,y) ：将页面滚动至相对于当前位置的 (x, y) 位置；</p></li><li><p>方法 scrollTo(pageX,pageY) 将页面滚动至绝对坐标；</p></li></ul><h2 id="11-JavaScript-中的事件"><a href="#11-JavaScript-中的事件" class="headerlink" title="11.JavaScript 中的事件"></a>11.JavaScript 中的事件</h2><h3 id="1、认识事件"><a href="#1、认识事件" class="headerlink" title="1、认识事件"></a>1、认识事件</h3><p>Web页面需要经常和用户之间进行交互，而交互的过程中我们可能想要捕捉这个交互的过程：</p><p>比如用户点击了某个按钮、用户在输入框里面输入了某个文本、用户鼠标经过了某个位置；</p><p>浏览器需要搭建一条JavaScript代码和事件之间的桥梁；</p><p>当某个事件发生时，让JavaScript可以响应（执行某个函数），所以我们需要针对事件编写处理程序（handler）</p><ul><li><p>事件监听方式一：在script中直接监听（很少使用）；</p></li><li><p>事件监听方式二：DOM属性，通过元素的on来监听事件；</p></li><li><p>事件监听方式三：通过EventTarget中的addEventListener来监听；</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;button onclick=<span class="string">&quot;console.log(&#x27;按钮1发生了点击~&#x27;)&quot;</span>&gt;按钮<span class="number">1</span>&lt;/button&gt;</span><br><span class="line">btn2El.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;按钮2发生了点击&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">btn3El.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;btn3的事件监听1&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="常见的事件列表"><a href="#常见的事件列表" class="headerlink" title="常见的事件列表"></a>常见的事件列表</h4><p>鼠标事件</p><ul><li>click —— 当鼠标点击一个元素时（触摸屏设备会在点击时生成）</li><li>mouseover &#x2F; mouseout —— 当鼠标指针移入&#x2F;离开一个元素时</li><li>mousedown &#x2F; mouseup —— 当在元素上按下&#x2F;释放鼠标按钮时</li><li>mousemove —— 当鼠标移动时</li></ul><p>键盘事件</p><ul><li>keydown 和 keyup —— 当按下和松开一个按键时</li></ul><p>表单（form）元素事件</p><ul><li>submit —— 当访问者提交了一个 form 时</li><li>focus —— 当访问者聚焦于一个元素时，例如聚焦于一个 input</li></ul><p>Document 事件</p><ul><li>DOMContentLoaded —— 当 HTML 的加载和处理均完成，DOM 被完全构建完成时</li></ul><p>CSS 事件</p><ul><li>transitionend —— 当一个 CSS 动画完成时。</li></ul><h3 id="2、认识事件流"><a href="#2、认识事件流" class="headerlink" title="2、认识事件流"></a>2、认识事件流</h3><h4 id="1-产生"><a href="#1-产生" class="headerlink" title="1.产生"></a>1.产生</h4><p>当我们在浏览器上对着一个元素点击时，你点击的不仅仅是这个元素本身；</p><p>这是因为我们的HTML元素是存在父子元素叠加层级的；</p><p>比如一个span元素是放在div元素上的，div元素是放在body元素上的，body元素是放在html元素上的</p><h4 id="2-事件冒泡和事件捕获"><a href="#2-事件冒泡和事件捕获" class="headerlink" title="2.事件冒泡和事件捕获"></a>2.事件冒泡和事件捕获</h4><p>默认情况下事件是从最内层的span向外依次传递的顺序，这个顺序我们称之为事件冒泡（Event Bubble）;</p><p>事实上，还有另外一种监听事件流的方式就是从外层到内层，这种称之为事件捕获（Event Capture）；</p><p>为什么会产生两种不同的处理流呢？</p><ul><li><p>这是因为早期浏览器开发时，不管是IE还是Netscape公司都发现了这个问题;</p></li><li><p>但是他们采用了完全相反的事件流来对事件进行了传递；</p></li><li><p>IE采用了事件冒泡的方式，Netscape采用了事件捕获的方式；</p></li></ul><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230403204855424.png"></p><p>过程：</p><p>如果我们都对其进行监听，则执行顺序：</p><ul><li><p>捕获阶段：事件（从 Window）向下走近元素</p></li><li><p>目标阶段：目标阶段（Target phase）</p></li><li><p>冒泡阶段：冒泡阶段（Bubbling phase）</p></li></ul><p>事实上，我们可以通过event对象来获取当前的阶段：eventPhase</p><p>开发中通常会使用事件冒泡，所以事件捕获了解即可</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230403205036219.png" alt="image-20230403205036219"></p><h3 id="3、事件对象"><a href="#3、事件对象" class="headerlink" title="3、事件对象"></a>3、事件对象</h3><p>当一个事件发生时，就会有和这个事件相关的很多信息：</p><ul><li><p>比如事件的类型是什么，你点击的是哪一个元素，点击的位置是哪里等等相关的信息；</p></li><li><p>这些信息会被封装到一个Event对象中，这个对象由浏览器创建，称之为event对象；</p></li><li><p>该对象给我们提供了想要的一些属性，以及可以通过该对象进行某些操作；</p></li></ul><p>如何获取这个event对象呢？</p><ul><li><p>event对象会在传入的事件处理（event handler）函数回调时，被系统传入；</p></li><li><p>我们可以在回调函数中拿到这个event对象；</p></li></ul><h4 id="event-常见的属性"><a href="#event-常见的属性" class="headerlink" title="event 常见的属性"></a>event 常见的属性</h4><p>type：事件的类型；</p><p><strong>target：当前事件发生的元素；</strong></p><p><strong>currentTarget：当前处理事件的元素；</strong></p><p>eventPhase：事件所处的阶段；</p><p>offsetX、offsetY：事件发生在元素内的位置；</p><p>clientX、clientY：事件发生在客户端内的位置；</p><p>pageX、pageY：事件发生在客户端相对于document的位置；</p><p>screenX、screenY：事件发生相对于屏幕的位置；</p><p>常见的方法：</p><ul><li><p>preventDefault：取消事件的默认行为；</p></li><li><p>stopPropagation：阻止事件的进一步传递（冒泡或者捕获都可以阻止）；</p></li></ul><p>事件处理中的 this</p><p>在函数中，我们也可以通过 this 来获取当前的发生元素</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btnEl = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;button&quot;</span>)</span><br><span class="line"><span class="keyword">var</span> divEl = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;div&quot;</span>)</span><br><span class="line"></span><br><span class="line">divEl.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">currentTarget</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(divEl)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span> === divEl)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是因为在浏览器内部，调用 event handler是绑定到当前的 currentTarget 上的</p><h3 id="4、EventTarget-类"><a href="#4、EventTarget-类" class="headerlink" title="4、EventTarget 类"></a>4、EventTarget 类</h3><p>所有的节点、元素都继承自EventTarget，事实上Window也继承自EventTarget</p><p><strong>EventTarget是一个DOM接口，主要用于添加、删除、派发Event事件；</strong></p><p>EventTarget常见的方法：</p><ul><li><p>addEventListener：注册某个事件类型以及事件处理函数；</p></li><li><p>removeEventListener：移除某个事件类型以及事件处理函数；</p></li><li><p>dispatchEvent：派发某个事件类型到 EventTarget 上；</p></li></ul><h3 id="5、事件委托"><a href="#5、事件委托" class="headerlink" title="5、事件委托"></a>5、事件委托</h3><p>事件冒泡在某种情况下可以帮助我们实现强大的事件处理模式 – 事件委托模式（也是一种设计模式）</p><ul><li><p>当子元素被点击时，父元素可以通过冒泡可以监听到子元素的点击；</p></li><li><p>并且可以通过event.target获取到当前监听的元素；</p></li></ul><p>案例：一个ul中存放多个li，点击某一个li会变成红色</p><ul><li><p>方案一：监听每一个li的点击，并且做出相应</p></li><li><p>方案二：在ul中监听点击，并且通过event.target拿到对应的li进行处理</p><ul><li>因为这种方案并不需要遍历后给每一个li上添加事件监听，所以它更加高效</li></ul></li></ul><h4 id="事件委托的标记"><a href="#事件委托的标记" class="headerlink" title="事件委托的标记"></a>事件委托的标记</h4><p>某些事件委托可能需要对具体的子组件进行区分，这个时候我们可以使用data-*对其进行标记：</p><p>比如多个按钮的点击，区分点击了哪一个按钮</p><h3 id="6、常见的事件"><a href="#6、常见的事件" class="headerlink" title="6、常见的事件"></a>6、常见的事件</h3><h4 id="1-常见的鼠标事件"><a href="#1-常见的鼠标事件" class="headerlink" title="1.常见的鼠标事件"></a>1.常见的鼠标事件</h4><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230404201639786.png" alt="image-20230404201639786"></p><h4 id="2-mouseover和mouseenter的区别"><a href="#2-mouseover和mouseenter的区别" class="headerlink" title="2.mouseover和mouseenter的区别"></a>2.mouseover和mouseenter的区别</h4><p>mouseenter和mouseleave</p><ul><li>不支持冒泡</li><li>进入子元素依然属于在该元素内，没有任何反应</li></ul><p>mouseover和mouseout</p><ul><li>支持冒泡</li><li>进入元素的子元素时<ul><li>先调用父元素的mouseout</li><li>再调用子元素的mouseover</li><li>因为支持冒泡，所以会将mouseover传递到父元素中</li></ul></li></ul><h4 id="3-常见的键盘事件"><a href="#3-常见的键盘事件" class="headerlink" title="3.常见的键盘事件"></a>3.常见的键盘事件</h4><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230404201729813.png" alt="image-20230404201729813"></p><p>事件的执行顺序是 onkeydown、onkeypress、onkeyup</p><ul><li><p>down事件先发生</p></li><li><p>press发生在文本被输入</p></li><li><p>up发生在文本输入完成</p></li></ul><p>通过key和code来区分按下的键：</p><ul><li>code：“按键代码”（”KeyA”，”ArrowLeft” 等），特定于键盘上按键的物理位置</li><li>key：字符（”A”，”a” 等），对于非字符（non-character）的按键，通常具有与 code 相同的值</li></ul><h4 id="4-常见的表单事件"><a href="#4-常见的表单事件" class="headerlink" title="4.常见的表单事件"></a>4.常见的表单事件</h4><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230403205650505.png" alt="image-20230403205650505"></p><h4 id="5-文档加载事件"><a href="#5-文档加载事件" class="headerlink" title="5.文档加载事件"></a>5.文档加载事件</h4><ul><li><p>DOMContentLoaded：浏览器已完全加载 HTML，并构建了 DOM 树，但像和样式表之类的外部资源可能尚未加载 完成</p></li><li><p>load：浏览器不仅加载完成了 HTML，还加载完成了所有外部资源：图片，样式等</p></li></ul><p>事件类型：<a href="https://developer.mozilla.org/zh-CN/docs/Web/Events">https://developer.mozilla.org/zh-CN/docs/Web/Events</a></p><h2 id="12-DOM阶段案例"><a href="#12-DOM阶段案例" class="headerlink" title="12.DOM阶段案例"></a>12.DOM阶段案例</h2><p>定时器</p><p>消息滚动</p><p>关闭弹窗</p><p>侧边栏触控展示</p><p>登录展示</p><p>tab栏切换</p><p>轮播图的实现</p><p>购物车操作</p><h2 id="13-JavaScript中的BOM操作"><a href="#13-JavaScript中的BOM操作" class="headerlink" title="13.JavaScript中的BOM操作"></a>13.JavaScript中的BOM操作</h2><h3 id="1、认识BOM操作"><a href="#1、认识BOM操作" class="headerlink" title="1、认识BOM操作"></a>1、认识BOM操作</h3><p>BOM：浏览器对象模型（Brower Object Model）</p><ul><li><p>简称 BOM，由浏览器提供的用于处理文档（document）之外的所有内容的其他对象</p></li><li><p>比如navigator、location、history等对象</p></li></ul><p>JavaScript有一个非常重要的运行环境就是浏览器</p><ul><li>而且浏览器本身又作为一个应用程序需要对其本身进行操作</li><li>所以通常浏览器会有对应的对象模型（BOM，Browser Object Model）</li><li>我们可以将BOM看成是连接 JavaScript 脚本与浏览器窗口的桥梁</li></ul><p>BOM主要包括一下的对象模型：</p><ul><li>window：包括全局属性、方法，控制浏览器窗口相关的属性、方法</li><li>location：浏览器连接到的对象的位置（URL）</li><li>history：操作浏览器的历史</li><li>navigator：用户代理（浏览器）的状态和标识（很少用到）</li><li>screen：屏幕窗口信息（很少用到）</li></ul><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230403201933683.png" alt="image-20230403201933683"></p><h3 id="2、全局对象window"><a href="#2、全局对象window" class="headerlink" title="2、全局对象window"></a>2、全局对象window</h3><p>window对象在浏览器中可以从两个视角来看待：</p><ul><li><p>视角一：全局对象</p><ul><li>我们知道ECMAScript其实是有一个全局对象的，这个全局对象在Node中是global</li><li>在浏览器中就是window对象</li></ul></li><li><p>视角二：浏览器窗口对象</p><ul><li>作为浏览器窗口时，提供了对浏览器操作的相关的API</li></ul></li></ul><p>这两个视角存在大量重叠的地方，不需要刻意去区分它们：</p><ul><li><p>事实上对于浏览器和Node中全局对象名称不一样的情况，目前已经指定了对应的标准，称之为globalThis，并且大多数现代 浏览器都支持它</p></li><li><p>放在window对象上的所有属性都可以被访问</p></li><li><p>使用var定义的变量会被添加到window对象中</p></li><li><p>window默认给我们提供了全局的函数和类：setTimeout、Math、Date、Object等</p></li></ul><p>事实上window对象上肩负的重担是非常大的：</p><ul><li><p>第一：包含大量的属性，localStorage、console、location、history、screenX、scrollX等</p></li><li><p>第二：包含大量的方法，alert、close、scrollTo、open等等（大概40+个方法）</p></li><li><p>第三：包含大量的事件，focus、blur、load、hashchange等等（大概30+个事件）</p></li><li><p>第四：包含从EventTarget继承过来的方法，addEventListener、removeEventListener、dispatchEvent方法；</p></li></ul><p>属性、方法、事件在MDN文档查看：<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window">https://developer.mozilla.org/zh-CN/docs/Web/API/Window</a></p><p>查看MDN文档时不同的符号的意思：</p><ul><li><p>删除符号：表示这个API已经废弃，不推荐继续使用了</p></li><li><p>点踩符号：表示这个API不属于W3C规范，某些浏览器有实现（所以兼容性的问题）</p></li><li><p>实验符号：该API是实验性特性，以后可能会修改，并且存在兼容性问题</p></li></ul><p>window 常见的属性</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">outerHeight</span>)</span><br></pre></td></tr></table></figure><p>window 常见的方法</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> openBtn = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;.open&quot;</span>)</span><br><span class="line"></span><br><span class="line">    openBtn.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">window</span>.<span class="title function_">open</span>(<span class="string">&quot;./page/new.html&quot;</span>, <span class="string">&quot;_blank&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> closeBtn = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;.close&quot;</span>)</span><br><span class="line"></span><br><span class="line">    closeBtn.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">window</span>.<span class="title function_">close</span>()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>window 常见的事件</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// window.onfocus = function() &#123;</span></span><br><span class="line">    <span class="comment">//   console.log(&quot;窗口获得了焦点&quot;)</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// window.onblur = function() &#123;</span></span><br><span class="line">    <span class="comment">//   console.log(&quot;窗口失去了焦点&quot;)</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="variable language_">window</span>.<span class="property">onhashchange</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hash值发生了改变&quot;</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="3、location对象"><a href="#3、location对象" class="headerlink" title="3、location对象"></a>3、location对象</h3><p>location对象用于表示window上当前链接到的URL信息</p><p>常见的属性：</p><ul><li>href: 当前window对应的超链接URL, 整个URL</li><li>protocol: 当前的协议；  host: 主机地址</li><li>hostname: 主机地址(不带端口)</li><li>port: 端口；  pathname: 路径</li><li>search: 查询字符串</li><li>hash: 哈希值</li><li>username：URL中的username（很多浏览器已经禁用）</li><li>password：URL中的password（很多浏览器已经禁用）</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.完整的url</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(location.<span class="property">href</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2。获取url的信息</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(location.<span class="property">hostname</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(location.<span class="property">host</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(location.<span class="property">protocol</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(location.<span class="property">port</span>)</span><br></pre></td></tr></table></figure><p>location其实是URL的一个抽象实现：</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230403202307394.png" alt="image-20230403202307394"></p><p>location有如下常用的方法：</p><ul><li>assign：赋值一个新的URL，并且跳转到该URL中</li><li>replace：打开一个新的URL，并且跳转到该URL中（不同的是不会在浏览记录中留下之前的记录）</li><li>reload：重新加载页面，可以传入一个Boolean类型</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">btns[<span class="number">0</span>].<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      location.<span class="title function_">assign</span>(<span class="string">&quot;https://www.baidu.com&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    btns[<span class="number">1</span>].<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      location.<span class="title function_">replace</span>(<span class="string">&quot;https://www.baidu.com&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    btns[<span class="number">2</span>].<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      location.<span class="title function_">reload</span>()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="4、URLSearchParams"><a href="#4、URLSearchParams" class="headerlink" title="4、URLSearchParams"></a>4、URLSearchParams</h3><p>URLSearchParams 定义了一些实用的方法来处理 URL 的查询字符串</p><ul><li><p>可以将一个字符串转化成URLSearchParams类型</p></li><li><p>也可以将一个URLSearchParams类型转成字符串</p></li></ul><p>URLSearchParams常见的方法有如下：</p><ul><li><p>get：获取搜索参数的值</p></li><li><p>set：设置一个搜索参数和值</p></li><li><p>append：追加一个搜索参数和值</p></li><li><p>has：判断是否有某个搜索参数</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/URLSearchParams">https://developer.mozilla.org/zh-CN/docs/Web/API/URLSearchParams</a></p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> urlSearchString = <span class="string">&quot;?name=wbh&amp;age=21&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(urlSearchString.<span class="title function_">split</span>(<span class="string">&quot;&amp;&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> searchParams = <span class="keyword">new</span> <span class="title class_">URLSearchParams</span>(urlSearchString)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(searchParams.<span class="title function_">get</span>(<span class="string">&quot;name&quot;</span>))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(searchParams.<span class="title function_">get</span>(<span class="string">&quot;age&quot;</span>))</span><br><span class="line"></span><br><span class="line">searchParams.<span class="title function_">append</span>(<span class="string">&quot;address&quot;</span>, <span class="string">&quot;广州市&quot;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(searchParams.<span class="title function_">get</span>(<span class="string">&quot;address&quot;</span>))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(searchParams.<span class="title function_">toString</span>())</span><br></pre></td></tr></table></figure><p>中文会使用encodeURIComponent和decodeURIComponent进行编码和解码</p><h3 id="5、history对象"><a href="#5、history对象" class="headerlink" title="5、history对象"></a>5、history对象</h3><p>history对象允许我们访问浏览器曾经的会话历史记录</p><p>有两个属性</p><ul><li><p>length：会话中的记录条数</p></li><li><p>state：当前保留的状态值</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(history.<span class="property">length</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(history.<span class="property">state</span>)</span><br></pre></td></tr></table></figure><p>有五个方法</p><ul><li>back()：返回上一页，等价于history.go(-1)</li><li>forward()：前进下一页，等价于history.go(1)</li><li>go()：加载历史中的某一页</li><li>pushState()：打开一个指定的地址</li><li>replaceState()：打开一个新的地址，并且使用replace；</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">btnEl.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// history.pushState(&#123;name:&quot;wd&quot;, age:&quot;23&quot;&#125;, &quot;&quot;, &quot;/why&quot;)</span></span><br><span class="line">      history.<span class="title function_">replaceState</span>(&#123;<span class="attr">name</span>:<span class="string">&quot;wd&quot;</span>, <span class="attr">age</span>:<span class="string">&quot;23&quot;</span>&#125;, <span class="string">&quot;&quot;</span>, <span class="string">&quot;/why&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> backEl = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;.back&quot;</span>)</span><br><span class="line">    backEl.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      history.<span class="title function_">back</span>()</span><br><span class="line">      history.<span class="title function_">forward</span>()</span><br><span class="line">      <span class="comment">// 类似于上面的两个方法，只是可以传入层级</span></span><br><span class="line">      history.<span class="title function_">go</span>(-<span class="number">2</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>history和hash目前是vue、react等框架实现路由的底层原理</p><h3 id="6、navigator、screen（很少用）"><a href="#6、navigator、screen（很少用）" class="headerlink" title="6、navigator、screen（很少用）"></a>6、navigator、screen（很少用）</h3><p>navigator 对象表示用户代理的状态和标识等信息</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230403202821277.png" alt="image-20230403202821277"></p><p>screen主要记录的是浏览器窗口外面的客户端显示器的信息</p><ul><li>比如屏幕的逻辑像素 screen.width、screen.height</li></ul><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230403202842991.png" alt="image-20230403202842991"></p><h3 id="7、JSON、Storage"><a href="#7、JSON、Storage" class="headerlink" title="7、JSON、Storage"></a>7、JSON、Storage</h3><h4 id="1-JSON的简单理解"><a href="#1-JSON的简单理解" class="headerlink" title="1.JSON的简单理解"></a>1.JSON的简单理解</h4><p>在目前的开发中，JSON是一种非常重要的数据格式，它并不是编程语言，而是一种可以在服务器和客户端之间传输的数据格式</p><p>JSON的全称是JavaScript Object Notation（JavaScript对象符号）</p><ul><li>JSON是由Douglas Crockford构想和设计的一种轻量级资料交换格式，算是JavaScript的一个子集</li><li>但是虽然JSON被提出来的时候是主要应用JavaScript中，但是目前已经独立于编程语言，可以在各个编程语言中使用</li><li>很多编程语言都实现了将JSON转成对应模型的方式</li></ul><p>其他的传输格式：</p><ul><li>XML：在早期的网络传输中主要是使用XML来进行数据交换的，但是这种格式在解析、传输等各方面都弱于JSON，所以目前已经很 少在被使用了</li><li>Protobuf：另外一个在网络传输中目前已经越来越多使用的传输格式是protobuf，但是直到2021年的3.x版本才支持JavaScript，所 以目前在前端使用的较少</li></ul><p>目前JSON被使用的场景也越来越多：</p><ul><li>网络数据的传输JSON数据</li><li>项目的某些配置文件</li><li>非关系型数据库（NoSQL）将json作为存储格式</li></ul><h4 id="2-JSON的基本语法"><a href="#2-JSON的基本语法" class="headerlink" title="2.JSON的基本语法"></a>2.JSON的基本语法</h4><p>JSON的顶层支持三种类型的值：</p><ul><li><p>简单值：数字（Number）、字符串（String，不支持单引号）、布尔类型（Boolean）、null类型</p></li><li><p>对象值：由key、value组成，key是字符串类型，并且必须添加双引号，值可以是简单值、对象值、数组值</p></li><li><p>数组值：数组的值可以是简单值、对象值、数组值</p></li></ul><h4 id="3-JSON序列化"><a href="#3-JSON序列化" class="headerlink" title="3.JSON序列化"></a>3.JSON序列化</h4><p>某些情况下我们希望将JavaScript中的复杂类型转化成JSON格式的字符串，这样方便对其进行处理</p><ul><li><p>比如我们希望将一个对象保存到localStorage中</p></li><li><p>但是如果我们直接存放一个对象，这个对象会被转化成 [object Object] 格式的字符串，并不是我们想要的结果；</p></li></ul><p>在ES5中引用了JSON全局对象，该对象有两个常用的方法：</p><ul><li>stringify方法：将JavaScript类型转成对应的JSON字符串</li><li>parse方法：解析JSON字符串，转回对应的JavaScript类型</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;sdw&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">23</span>,</span><br><span class="line">    <span class="attr">friend</span>: &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;dsds&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1.将obj对象进行序列化</span></span><br><span class="line"><span class="keyword">var</span> objJSONString = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(objJSONString)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.存储到浏览器本地 localstorage</span></span><br><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&quot;info&quot;</span>, objJSONString)</span><br><span class="line"><span class="keyword">var</span> item = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&quot;info&quot;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(item, <span class="keyword">typeof</span> item)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.将自付出转回到对象（反序列化）</span></span><br><span class="line"><span class="keyword">var</span> newObj = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(item)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newObj)</span><br></pre></td></tr></table></figure><h4 id="4-Stringfy的补充"><a href="#4-Stringfy的补充" class="headerlink" title="4.Stringfy的补充"></a>4.Stringfy的补充</h4><h5 id="Stringfy-的参数-replacer"><a href="#Stringfy-的参数-replacer" class="headerlink" title="Stringfy 的参数 replacer"></a>Stringfy 的参数 replacer</h5><p>JSON.stringify() 方法将一个 JavaScript 对象或值转换为 JSON 字符串：</p><ul><li><p>如果指定了一个 replacer 函数，则可以选择性地替换值</p></li><li><p>如果指定的 replacer 是数组，则可选择性地仅包含数组指定的属性</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// replacer参数</span></span><br><span class="line"><span class="keyword">var</span> objJSONString = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj, <span class="keyword">function</span>(<span class="params">key, value</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (key === <span class="string">&quot;name&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;coderwhy&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> value</span><br><span class="line">&#125;, <span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure><h5 id="Stringify的参数space"><a href="#Stringify的参数space" class="headerlink" title="Stringify的参数space"></a>Stringify的参数space</h5><p>如果对象本身包含toJSON方法，那么会直接使用toJSON方法的结果：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2.space参数</span></span><br><span class="line"><span class="comment">// var objJSONString = JSON.stringify(obj, null, 4)</span></span><br><span class="line"><span class="comment">// console.log(objJSONString)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.如果对象本身有显示toJSON方法，那么直接调用toJSON方法</span></span><br><span class="line"><span class="keyword">var</span> objJSONString = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(objJSONString)</span><br></pre></td></tr></table></figure><h4 id="5-parse方法"><a href="#5-parse方法" class="headerlink" title="5.parse方法"></a>5.parse方法</h4><p>JSON.parse() 方法用来解析JSON字符串，构造由字符串描述的JavaScript值或对象</p><ul><li>提供可选的 reviver 函数用以在返回之前对所得到的对象执行变换(操作)</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> newObj = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(objJSONString, <span class="keyword">function</span>(<span class="params">key, value</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (key === <span class="string">&quot;age&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> value + <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>JSON的方法可以帮我们实现对象的深拷贝</p><h3 id="8、认识Storage"><a href="#8、认识Storage" class="headerlink" title="8、认识Storage"></a>8、认识Storage</h3><h4 id="1-浏览器本地存储"><a href="#1-浏览器本地存储" class="headerlink" title="1.浏览器本地存储"></a>1.浏览器本地存储</h4><p>WebStorage主要提供了一种机制，可以让浏览器提供一种比cookie更直观的key、value存储方式：</p><ul><li>localStorage：本地存储，提供的是一种永久性的存储方法，在关闭掉网页重新打开时，存储的内容依然保留</li><li>sessionStorage：会话存储，提供的是本次会话的存储，在关闭掉会话时，存储的内容会被清除</li></ul><h4 id="2-localStorage和sessionStorage的区别"><a href="#2-localStorage和sessionStorage的区别" class="headerlink" title="2.localStorage和sessionStorage的区别"></a>2.localStorage和sessionStorage的区别</h4><ul><li>验证一：关闭网页后重新打开，localStorage会保留，而sessionStorage会被删除</li><li>验证二：在页面内实现跳转，localStorage会保留，sessionStorage也会保留</li><li>验证三：在页面外实现跳转（打开新的网页），localStorage会保留，sessionStorage不会被保留</li></ul><h4 id="3-Storage有如下的属性和方法："><a href="#3-Storage有如下的属性和方法：" class="headerlink" title="3.Storage有如下的属性和方法："></a>3.Storage有如下的属性和方法：</h4><p>属性：</p><ul><li>Storage.length：只读属性<ul><li>返回一个整数，表示存储在Storage对象中的数据项数量</li></ul></li></ul><p>方法：</p><ul><li>Storage.key()：该方法接受一个数值n作为参数，返回存储中的第n个key名称</li><li>Storage.getItem()：该方法接受一个key作为参数，并且返回key对应的value</li><li>Storage.setItem()：该方法接受一个key和value，并且将会把key和value添加到存储中<ul><li>如果key存储，则更新其对应的值</li></ul></li><li>Storage.removeItem()：该方法接受一个key作为参数，并把该key从存储中删除</li><li>Storage.clear()：该方法的作用是清空存储中的所有key</li></ul><h2 id="14-阶段案例"><a href="#14-阶段案例" class="headerlink" title="14.阶段案例"></a>14.阶段案例</h2><blockquote><p> 华为商城的搭建</p></blockquote><ol><li>页面搭建</li><li>数据插入，现阶段两种方法：创建每一个元素并插入；&#96;&#96;字符模板插入</li><li>实现列表的动态展示<ul><li>获取需要进行筛选的条件</li><li>动态获取 filters 内容（点击按钮获取textContent，取消按钮移除textContent）</li></ul></li><li>过滤数据</li><li>展示数据</li></ol><blockquote><p> 华为轮播图实现与无限轮播</p></blockquote><p>原理：为图片添加 active，并设置 opacity</p><ol><li>获取数据插入页面</li><li>使用定位，将图片定位在 banner 中</li><li>监听事件（上下页）点击，将图片进行展示（opacity &#x3D; 1，添加动画）</li><li>定时器进行自动轮播</li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IT前端 </tag>
            
            <tag> JavaScript </tag>
            
            <tag> DOM </tag>
            
            <tag> BOM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络知识整理</title>
      <link href="/archives/58e66b84.html"/>
      <url>/archives/58e66b84.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IT </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML/CSS 知识体系（部分）</title>
      <link href="/archives/f99e1de4.html"/>
      <url>/archives/f99e1de4.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前端开发"><a href="#前端开发" class="headerlink" title="前端开发"></a>前端开发</h1><h2 id="1-什么是软件"><a href="#1-什么是软件" class="headerlink" title="1.什么是软件"></a>1.什么是软件</h2><p>一系列按照特定顺序组织的计算机数据和指令，是电脑的非有型部分</p><p>软件开发就是告诉计算机一系列的指令，这些指令也称之为程序</p><h2 id="2-软件开发和应用程序开发有什么区别"><a href="#2-软件开发和应用程序开发有什么区别" class="headerlink" title="2.软件开发和应用程序开发有什么区别"></a>2.软件开发和应用程序开发有什么区别</h2><p> <img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230216143732155.png" alt="image-20230216143732155"></p><h2 id="3-完善的应用系统"><a href="#3-完善的应用系统" class="headerlink" title="3.完善的应用系统"></a>3.完善的应用系统</h2><p>服务器、客户端</p><h2 id="4-前端开发工程师-Front-end"><a href="#4-前端开发工程师-Front-end" class="headerlink" title="4.前端开发工程师-Front-end"></a>4.前端开发工程师-Front-end</h2><p>主要负责：Web（网站、后台管理系统、手机H5）、小程序端</p><p>也可以：移动端（Uniapp、React Native）、桌面端（Electron）、服务器开发（Node.js）</p><p><strong>书籍：</strong>《JavaScript高级程序设计》-nicholas C.Zakas  </p><p>《你不知道的JavaScript》</p><h1 id="Web开发"><a href="#Web开发" class="headerlink" title="Web开发"></a>Web开发</h1><h2 id="1-什么是网页"><a href="#1-什么是网页" class="headerlink" title="1.什么是网页"></a>1.什么是网页</h2><p>web page，打开浏览器查看到的一页，是网络中的一页，包括文字、链接、音乐、视频等</p><h2 id="2-什么是网站"><a href="#2-什么是网站" class="headerlink" title="2.什么是网站"></a>2.什么是网站</h2><p>网站是由多个网页组成；通常是n个网页（n&gt;&#x3D;1）</p><h2 id="3-网页的显示过程"><a href="#3-网页的显示过程" class="headerlink" title="3.网页的显示过程"></a>3.网页的显示过程</h2><p>用户：</p><p>网址-&gt;DNS服务器解析-&gt;ip地址-&gt;服务器-&gt;下载资源到浏览器-&gt;浏览器渲染引擎</p><p>​1.用户在浏览器输入一个网址</p><p>​2.浏览器会找到一个对应的服务器地址，请求静态资源</p><p>​3.服务器返回静态资源给浏览器</p><p>​4.浏览器对静态资源进行解析和展示</p><p>前端工程师：</p><p>​1.开发项目</p><p>​2.打包、部署项目到服务器里面</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230216162009343.png" alt="image-20230216162009343"></p><h2 id="4-服务器是什么"><a href="#4-服务器是什么" class="headerlink" title="4.服务器是什么"></a>4.服务器是什么</h2><p>本质是一台类似电脑的主机；稳定运行不关机；没有显示器；一般装的是Linux操作系统</p><h2 id="5-网页的组成"><a href="#5-网页的组成" class="headerlink" title="5.网页的组成"></a>5.网页的组成</h2><ul><li><p>HTML元素：网页的内容结构</p></li><li><p>CSS样式：网页的视觉体验</p></li><li><p>JavaScript语言：网页的交互处理</p></li></ul><h2 id="6-浏览器的作用"><a href="#6-浏览器的作用" class="headerlink" title="6.浏览器的作用"></a>6.浏览器的作用</h2><p>浏览器最核心的部分是渲染引擎，一般也称之为“浏览器内核”，负责解析网页语法，并渲染（显示）网页</p><h2 id="7-不同浏览器的内核"><a href="#7-不同浏览器的内核" class="headerlink" title="7.不同浏览器的内核"></a>7.不同浏览器的内核</h2><ul><li>Trident（三叉戟）：IE、360安全、搜狗高速、百度、UC</li><li>Gecko（壁虎）：火狐</li><li>Presto（急板乐趣）-&gt;Blink（眨眼）：Opera</li><li>Webkit：Safari、360极速、搜狗高速、移动端浏览器（安卓、ios）</li><li>Webkit-&gt;Blink：谷歌、Edge</li></ul><p>不同的浏览器内核有不同的解析、渲染规则，所以同一个网页在不同内核的浏览器中的渲染效果也可能不同</p><h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><p>Hyper-Text-Markup-Language：超文本标记语言，是一种用于创建网页的标记语言</p><p>HTML是构建网页的基石</p><h2 id="1-什么是标记语言"><a href="#1-什么是标记语言" class="headerlink" title="1.什么是标记语言"></a>1.什么是标记语言</h2><ul><li>由无数个标记组成</li><li>是对某些内容进行特殊的标记，以供其他解释器识别处理</li><li>比如<code>&lt;h2&gt;&lt;/h2&gt;</code>标记的文本会被识别为“标题”进行加粗、文字放大显示</li><li>由标签和内容组成的部分称为元素</li></ul><h2 id="2-什么是超文本"><a href="#2-什么是超文本" class="headerlink" title="2.什么是超文本"></a>2.什么是超文本</h2><ul><li>不仅仅可以插入普通的文本，还可以插入图片、音视频等</li><li>还可以表示超链接，从一个网页跳转到另一个网页</li></ul><h2 id="3-HTML文件的特点-结构"><a href="#3-HTML文件的特点-结构" class="headerlink" title="3.HTML文件的特点-结构"></a>3.HTML文件的特点-结构</h2><h3 id="1、HTML文件的扩展名"><a href="#1、HTML文件的扩展名" class="headerlink" title="1、HTML文件的扩展名"></a>1、HTML文件的扩展名</h3><p>因历史遗留问题，win95&#x2F;98系统的文件扩展名不能超过3位，所以用.htm</p><p>现在统一使用.html</p><h3 id="2、结构"><a href="#2、结构" class="headerlink" title="2、结构"></a>2、结构</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span>元数据（metedata）<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span>内容<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h2 id="4-工具"><a href="#4-工具" class="headerlink" title="4.工具"></a>4.工具</h2><p>vscode安装</p><ul><li><p>安装插件：中文-chinese</p></li><li><p>颜色主题：atom one dark</p></li><li><p>文件夹图标：VScode great Icons</p></li><li><p>在浏览器打开网页：open in browser、Live sever（实时刷新）</p></li><li><p>自动重命名标签：auto rename tag</p></li></ul><p>配置</p><ul><li><p>自动保存</p></li><li><p>自动换行：word wrap</p></li><li><p>空格的渲染方式：render whitespace</p></li><li><p>缩进：tab size</p></li></ul><h2 id="5-认识元素"><a href="#5-认识元素" class="headerlink" title="5.认识元素"></a>5.认识元素</h2><h3 id="1、什么是元素"><a href="#1、什么是元素" class="headerlink" title="1、什么是元素"></a>1、什么是元素</h3><p>元素是网页的一部分</p><p>一个元素可以包含一个数据项，或是一块文本，或是一张照片，亦或是什么都不包含</p><p>那么HTML中都有哪些元素呢？</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element">https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element</a></p><h3 id="2、元素的组成"><a href="#2、元素的组成" class="headerlink" title="2、元素的组成"></a>2、元素的组成</h3><ul><li>开始标签：被左右尖括号所包围</li><li>结束标签：与开始标签相似，只是在其元素名之前包含了一个斜杠，表示元素的结尾</li><li>内容：元素的内容</li><li>元素：前三者相结合便是一个完整的元素</li></ul><h3 id="3、单标签-双标签"><a href="#3、单标签-双标签" class="headerlink" title="3、单标签-双标签"></a>3、单标签-双标签</h3><p>双标签元素</p><p>html、body、head、h2、p、a元素</p><p>单标签元素</p><p>br、img、hr、meta、input</p><p>注意：</p><p>html标签不区分大小写，推荐小写</p><h3 id="4、元素的属性"><a href="#4、元素的属性" class="headerlink" title="4、元素的属性"></a>4、元素的属性</h3><p>元素也是可以拥有属性（Attribute）:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;p <span class="keyword">class</span>=<span class="string">&quot;attr&quot;</span>&gt;wowowo&lt;/p&gt;</span><br></pre></td></tr></table></figure><p>属性包含元素的额外信息，这些信息不会出现在实际的内容中</p><p>一个属性必须包含：</p><ul><li>1.一个空格，在属性和元素名称之间。多个属性用空格隔开</li><li>2.属性名称，后面跟着一个等于符</li><li>3.一个属性值，由一对引号“ ”引起来</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;h1 属性名=<span class="string">&quot;属性值&quot;</span>&gt;我是标题&lt;/h1&gt;</span><br></pre></td></tr></table></figure><p>元素属性的分类</p><p>有些属性是公共的，每一个元素都可以设置</p><ul><li>class、id、title属性</li></ul><p>有些属性是元素特有的，不是每一个元素都可以设置</p><ul><li>meta元素的charset属性、img元素的alt属性等</li></ul><h3 id="5、元素的嵌套关系"><a href="#5、元素的嵌套关系" class="headerlink" title="5、元素的嵌套关系"></a>5、元素的嵌套关系</h3><p>某些元素的内容除了可以是文本外，还可以是其他元素，这样就形成了元素的嵌套</p><p>元素之间的关系：                                                                                                                                                                                            </p><p>父子关系，比如ul和li，li和span之间</p><p>兄弟关系，比如两个div，两个span之间</p><p>注释：ctrl+&#x2F;</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!--  --&gt;</span><br></pre></td></tr></table></figure><h2 id="6-HTML常见的元素"><a href="#6-HTML常见的元素" class="headerlink" title="6.HTML常见的元素"></a>6.HTML常见的元素</h2><h3 id="1、HTML结构分析"><a href="#1、HTML结构分析" class="headerlink" title="1、HTML结构分析"></a>1、HTML结构分析</h3><p>文档声明：HTML最上方的一段文本我们称之为文档类型声明，用于声明类型。不仅声明文件类型，而且声明版本，让浏览器按照相应标准去解析识别内容，必须放在HTML文档的最前面，不可省略，否则会出现兼容性问题</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!<span class="variable constant_">DOCTYPE</span> html&gt;  <span class="comment">// 告诉浏览器是HTML5版本</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;元素表示一个<span class="variable constant_">HTML</span>文档的根（顶级元素），所以它被称之为根元素&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>所有其他元素必须是此元素的后代</p><p>W3C标准建议为html元素增加一个lang属性，作用是</p><ul><li>帮助语言合成工具确定要使用的语言</li><li>帮助翻译工具确定要使用的翻译规则</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt; 表示这个<span class="variable constant_">HTML</span>文档使用的语言是英文</span><br><span class="line">&lt;html lang=<span class="string">&quot;zh-CN&quot;</span>&gt; 表示这个<span class="variable constant_">HTML</span>文档的语言是中文</span><br></pre></td></tr></table></figure><p>HTML中head元素规定文档相关的配置信息（也称为元数据），包括文档的标题，引用的文档样式和脚本等</p><ul><li><p>元数据：描述数据的数据</p></li><li><p>这里我们可以理解成对整个页面的配置</p></li></ul><p>网页的标题：title元素</p><p>网页的编码：meta元素</p><ul><li>可以用于设置网页的字符编码，让浏览器更精准的显示每一个文字，不设置或者设置错误会导致乱码</li><li>一般都使用utf-8编码，涵盖了世界上几乎所有的文字</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br></pre></td></tr></table></figure><p>body元素里面的内容将是你在浏览器窗口中看到的东西，也就是网页的具体内容和结构</p><h3 id="2、常见的元素"><a href="#2、常见的元素" class="headerlink" title="2、常见的元素"></a>2、常见的元素</h3><p><strong>h元素</strong>：作为标题—h1-h6：呈现6个不同的级别的标题</p><p><strong>p元素</strong>：表示段落，段落之间有一定的间距</p><p><strong>img元素</strong>：将一份图像嵌入文档。是一个可替换元素</p><ul><li>src属性：图片文件的路径（必须）</li><li>alt属性：文件加载不成功时候显示这段文本；屏幕阅读器会将这些描述给需要使用阅读器的使用者听，让他们知道图片的含义（不是强制性的）</li></ul><p>图片的路径：</p><ul><li>绝对路径：根盘符开始查找，一直找到这个资源</li><li>相对路径：相对于当前文件的路径；.当前文件夹；..上级文件夹</li></ul><p>对于网页来说，不管是什么操作系统，路径分隔符都是&#x2F;，而不是\</p><p><strong>a元素</strong>：（锚：anchor）超链接，打开新的URL</p><ul><li><p>href（ Hypertext Reference）：指定要打开的URL地址，也可以是一个本地地址</p></li><li><p>target：指定在何处显示链接的资源</p><p>​_self：默认值，在当前窗口打开URL</p><p>​_blank：在新的窗口打开URL</p></li></ul><p>锚点链接：锚点可以实现跳转到网页中的具体位置</p><ul><li>在要跳到的元素上定义一个id属性</li><li>定义a元素，并且a元素的href指向对应的id</li></ul><p>a元素中能使用img元素作为跳转</p><p>a元素指向其他的URL：</p><ul><li>压缩包：</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;a href=<span class="string">&quot;https://github.com/coderwhy/HYMiniMall/archive/master.zip&quot;</span>&gt;下载zip包&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>​会直接下载</p><ul><li>指向其他的协议地址：</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;a href=<span class="string">&quot;mailto:123@qq.com&quot;</span>&gt;发邮箱给123qq.<span class="property">com</span>&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>​能打开电脑邮箱软件对发件邮箱进行填充</p><p><strong>iframe元素</strong>：在一个HTML文档中嵌入其他HTML文档</p><ul><li>frameborder属性：用于规定是否显示边框：1：显示  0：不显示</li></ul><p>a元素target属性的其他值：</p><ul><li>_parent：在父窗口打开URL</li><li>_top：在顶层窗口打开URL</li></ul><p>div元素和span元素都是纯粹的容器，也可以把他们理解为盒子，他们都是用来包裹内容的</p><p>无所用、无所不用：</p><p><strong>div元素</strong>：division，分开、分配的意思</p><p>多个div元素包裹的内容会在不同的行显示</p><ul><li>一般作为其他元素的父容器，把其他元素包住，代表一个整体</li><li>用于将网页分割为多个独立的部分</li></ul><p><strong>span元素</strong>：跨域、涵盖的意思；</p><p>多个span元素包裹的内容会同一行显示</p><ul><li>默认情况下，跟普通文本几乎没有差别</li><li>用于区分特殊文本和普通文本，比如显示一些关键字</li></ul><h3 id="3、不常用元素"><a href="#3、不常用元素" class="headerlink" title="3、不常用元素"></a>3、不常用元素</h3><p><strong>strong元素</strong>：内容加粗，强调</p><ul><li>通常加粗会使用css样式来完成</li><li>开发中偶尔会使用</li></ul><p><strong>i元素</strong>：内容倾斜</p><ul><li>开发中通常使用css设置倾斜</li><li>偶尔使用它来做字体图标（看起来像是icon的缩写）</li></ul><p><strong>code元素</strong>：用来显示代码</p><ul><li>偶尔会使用来显示等宽字体</li></ul><p><strong>br元素</strong>：换行元素</p><ul><li>开发中不再使用</li></ul><h3 id="4、HTML全局属性"><a href="#4、HTML全局属性" class="headerlink" title="4、HTML全局属性"></a>4、HTML全局属性</h3><p>某些属性只能设置在特定的元素中</p><p>但是也有一些属性是所有HTML都可以设置和拥有的，这样的属性称之为全局属性</p><p>常见的全局属性：</p><ul><li>id：定义唯一标识符，该标识符在整个文档中必须是唯一的</li><li>class：一个以空格分隔的元素的类名列表</li><li>style：给元素添加内联样式</li><li>title：包含表示与其属性元素相关信息的文本</li></ul><h2 id="7-额外补充"><a href="#7-额外补充" class="headerlink" title="7.额外补充"></a>7.额外补充</h2><h3 id="1、字符实体"><a href="#1、字符实体" class="headerlink" title="1、字符实体"></a>1、字符实体</h3><p>我们编写的HTML会被浏览器解析，那是怎么解析的呢？</p><ul><li><p>如果使用小于号&lt;，浏览器会将其后面的文本解析为一个标签</p></li><li><p>但是在某些情况下我们确实需要编写一个小于号&lt;</p></li><li><p>这时候就可以使用字符实体</p></li></ul><p>HTML实体是一段以连字号(&amp;)开头、以分号(;)结尾的文本（字符串）</p><ul><li>字符实体常用于显示保留字符（这些字符会被解析为HTML代码）和不可见字符（如“不换行空格”）</li><li>你也可以使用实体来代替其他难以用标准键盘键入的字符</li></ul><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230219140224361.png" alt="image-20230219140224361"></p><h3 id="2、URL地址"><a href="#2、URL地址" class="headerlink" title="2、URL地址"></a>2、URL地址</h3><p><strong>URL</strong> 代表着统一资源定位符（Uniform Resource Locator）</p><p>URL 无非就是一个给定的独特资源在Web上的网址</p><ul><li>理论上说：每一个有效的URL都指向一个唯一的资源</li><li>这个资源可以是一个HTML页面，一个CSS文档，一幅图像，等等</li></ul><p>URL标准格式：</p><ul><li>【协议类型】:&#x2F;&#x2F;[服务器地址]:[端口号]&#x2F;【文件路径】【文件名】？[查询]#[片段ID]</li></ul><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230219142839021.png" alt="image-20230219142839021"></p><p>和URI的区别：</p><p>URI（identifier）：统一资源标志符，用于标识Web技术使用的逻辑或物理资源</p><p>URI在某一个规则下能把一个资源独一无二的识别出来</p><ul><li>URL作为一个网络web资源的地址，可以唯一将一个资源识别出来，所以URL是一个URI</li><li>URL是URI的一个子集</li><li>但是URI并不一定是URL</li></ul><h3 id="3、元素语义化"><a href="#3、元素语义化" class="headerlink" title="3、元素语义化"></a>3、元素语义化</h3><p>用正确的元素做正确的事情</p><p>理论上来说，所有的HTML元素，我们都能实现相同的事情</p><p>标签语义化</p><ul><li>方面代码的维护</li><li>减少开发者之间的沟通成本</li><li>能让语音识别工具正确识别网页的用图，以便做出正确的反应</li><li>有利于SEO</li></ul><h3 id="4、SEO优化"><a href="#4、SEO优化" class="headerlink" title="4、SEO优化"></a>4、SEO优化</h3><p>搜索引擎优化（search engine optimization）是通过了解搜索引擎的运作规则来调整网站，以及提高网站在有关搜索引擎内排名的方式</p><h3 id="5、字符编码"><a href="#5、字符编码" class="headerlink" title="5、字符编码"></a>5、字符编码</h3><p>计算机只认识01二进制数字(底层硬件控制电路的开和闭)，计算机只能直接存储和处理二进制数字</p><p>为了在计算机上也能表示、存储和处理像文字、符号之类的字符，就必须将这些字符转化为二进制数字。而转化的标准就称之为字符编码</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230220161644042.png" alt="image-20230220161644042"></p><h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><h2 id="1-邂逅CSS"><a href="#1-邂逅CSS" class="headerlink" title="1.邂逅CSS"></a>1.邂逅CSS</h2><h3 id="1、认识CSS"><a href="#1、认识CSS" class="headerlink" title="1、认识CSS"></a>1、认识CSS</h3><p>CSS表示层叠样式表（Cascading Style Sheet），是为网页添加样式的代码</p><p>属于计算机语言，他不是真正的编程语言，甚至不是标记语言，是一门样式表语言</p><p>94年开发，96发布css1，97W3C成立CSS工作组，98年5月发布css2，06-09流行div+css</p><p>没有真正的CSS3，之后的发布是模块化发布</p><p>CSS的出现是为了美化HTML的，并且让结构与样式分离</p><ul><li>美化1：添加样式</li><li>美化2：对HTML进行布局</li></ul><h3 id="2、编写CSS样式"><a href="#2、编写CSS样式" class="headerlink" title="2、编写CSS样式"></a>2、编写CSS样式</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">color</span>: red;   <span class="comment">// 属性名： 属性值；</span></span><br></pre></td></tr></table></figure><p>三种方法添加样式：</p><ul><li>内联样式（行内样式）：存于HTML元素的style属性之中，分号隔开多个样式</li><li>内部样式表：将css放在HTML文件<code>&lt;head&gt;</code>元素里的<code>&lt;style&gt;</code>元素之中</li><li>外部样式表：link外部的CSS文件</li></ul><p>CSS注释：ctrl+&#x2F;</p><h3 id="3、常见的CSS属性"><a href="#3、常见的CSS属性" class="headerlink" title="3、常见的CSS属性"></a>3、常见的CSS属性</h3><p>css属性的官方文档：<a href="https://www.w3.org/TR/?tag=css">https://www.w3.org/TR/?tag=css</a></p><p>浏览器支持查询CSS属性的可用性：<a href="https://caniuse.com/">https://caniuse.com</a></p><ul><li>font-size：文字大小</li><li>color：前景色</li><li>background-color：背景色</li><li>width：宽度</li><li>height：高度</li></ul><h3 id="4、额外知识补充2"><a href="#4、额外知识补充2" class="headerlink" title="4、额外知识补充2"></a>4、额外知识补充2</h3><h4 id="1-link元素"><a href="#1-link元素" class="headerlink" title="1.link元素"></a>1.link元素</h4><p>link元素是外部资源链接元素，规范了文档与外部资源的关系</p><ul><li>link元素通常是在head元素中</li><li>最常用的链接是样式表</li><li>也可以使用网站图标（favicon）</li></ul><p>常见属性：</p><ul><li>href：指定被链接资源的URL</li><li>rel：指定链接类型<ul><li>icon：站点图标</li><li>stylesheet：CSS样式</li></ul></li></ul><h4 id="2-计算机进制"><a href="#2-计算机进制" class="headerlink" title="2.计算机进制"></a>2.计算机进制</h4><p>进位制是一种计数方式，亦称进位计数法或位值计数法；当数字达到某个值时，进一位</p><p>十六进制：a(10)，b(11)，c(12)，d(13)，e(14)，f(15)，10(16)</p><p>二进制：0b开头</p><p>八进制：0o开头</p><p>十六进制：0x开头</p><p>编程中还是以十进制为主</p><p>十进制转化其他进制：整除取余数</p><p>其他进制转十进制：二进制1001：9</p><h4 id="3-CSS表示颜色"><a href="#3-CSS表示颜色" class="headerlink" title="3.CSS表示颜色"></a>3.CSS表示颜色</h4><p>表示颜色的方法：</p><ul><li>颜色关键字</li></ul><p>RGB【A】颜色（取值0-255），A是可选的，表示透明度</p><ul><li>使用函数符：rgb[a]:(255,255,255)<ul><li>可以是数字，也可以是百分比</li><li>A处于0-1之间的数字，或者百分比，数字1表示完全不透明(100%)</li></ul></li><li>也可以使用十六进制：#FFFFFF <ul><li>可以使用三位数：#f09&#x3D;#ff0099</li><li>可以使用四位数：#0f38&#x3D;#00ff3388</li></ul></li></ul><h4 id="4-浏览器渲染流程"><a href="#4-浏览器渲染流程" class="headerlink" title="4.浏览器渲染流程"></a>4.浏览器渲染流程</h4><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230226155625725.png" alt="image-20230226155625725"></p><h2 id="2-CSS属性"><a href="#2-CSS属性" class="headerlink" title="2.CSS属性"></a>2.CSS属性</h2><h3 id="1、文本"><a href="#1、文本" class="headerlink" title="1、文本"></a>1、文本</h3><h4 id="1-text-decoration（常用）"><a href="#1-text-decoration（常用）" class="headerlink" title="1.text-decoration（常用）"></a>1.text-decoration（常用）</h4><p>用于设置文本的装饰线</p><p>取值：</p><ul><li>none：无任何装饰<ul><li>可以去除 a 元素的下划线</li></ul></li><li>underline：添加下划线</li><li>overline：上划线</li><li>line-through：中划线（删除线）</li></ul><h4 id="2-text-transform"><a href="#2-text-transform" class="headerlink" title="2.text-transform"></a>2.text-transform</h4><p>用于设置文字的大小写转换</p><p>常见的值：</p><ul><li>capitalize：将每个单词的首字母变成大写</li><li>uppercase：将每个单词的全部字母变成大写</li><li>lowercase：将每个单词的全部字母变成小写</li><li>none：没有任何影响</li></ul><h4 id="3-text-indent"><a href="#3-text-indent" class="headerlink" title="3.text-indent"></a>3.text-indent</h4><p>用于设置第一行内容的缩进</p><p>text-indent：2em；  ：刚好是缩进2个文字</p><h4 id="4-text-align（重要）"><a href="#4-text-align（重要）" class="headerlink" title="4.text-align（重要）"></a>4.text-align（重要）</h4><p>设置<strong>文本</strong>的对齐方式（不准确）</p><p>MDN：定义行内内容（例如文字）如何相对于它的<strong>块父元素</strong>对齐（不准确）</p><p>常用的值</p><ul><li>left：左对齐</li><li>right：右对齐</li><li>center：居中对齐，也可以让图片居中</li><li>justify：两端对齐<ul><li>最有一行与只有一行的情况下不生效，要想生效需要设置：text-align-last：justify</li></ul></li></ul><p>W3C：设置的是行内级元素居中</p><h4 id="5-word-x2F-letter-spacing"><a href="#5-word-x2F-letter-spacing" class="headerlink" title="5.word&#x2F;letter-spacing"></a>5.word&#x2F;letter-spacing</h4><p>分别是改变单词&#x2F;字母之间的间距</p><h3 id="2、字体"><a href="#2、字体" class="headerlink" title="2、字体"></a>2、字体</h3><h4 id="1-font-size"><a href="#1-font-size" class="headerlink" title="1.font-size"></a>1.font-size</h4><p>决定字体的大小</p><p>常用的设置</p><ul><li>具体数值+单位：比如100px，也可以使用em，1em代表100%</li><li>百分比：基于父元素的font-size计算</li></ul><h4 id="2-font-family"><a href="#2-font-family" class="headerlink" title="2.font-family"></a>2.font-family</h4><p>用于设置文字的字体名称</p><p>可以设置一个或多个字体名称</p><p>浏览器会选择列表中第一个该计算机上有安装的字体</p><p>或者是通过 @font-face 指定的可以直接下载的字体</p><h4 id="3-font-weight"><a href="#3-font-weight" class="headerlink" title="3.font-weight"></a>3.font-weight</h4><p>用于设置文字的粗细（重量）</p><p>常见的取值：</p><ul><li>100|200|300|400|500|600|700|800|900：每一个数字表示一个重量</li><li>nomal：等于400</li><li>bold：等于700</li></ul><p> strong、b、h1-h6等标签的font-weight默认值就是bold</p><h4 id="4-font-style"><a href="#4-font-style" class="headerlink" title="4.font-style"></a>4.font-style</h4><p>用来设置文本的常规、斜体显示</p><ul><li>normal：常规显示</li><li>italic（斜体）：用字体的斜体显示（通常会有专门的字体）</li><li>oblique（倾斜）：文本倾斜显示（仅仅是让文字倾斜）</li></ul><p>em、i、cite、address、var、dfn等元素的font-style默认值就是italic</p><h4 id="5-font-variant（了解）"><a href="#5-font-variant（了解）" class="headerlink" title="5.font-variant（了解）"></a>5.font-variant（了解）</h4><p>可以影响小写字母的显示形式</p><p>normal：正常显示</p><p>small-caps：将小写字母替换为缩小过的大写字母（高度不变，小写变为大写）</p><h4 id="6-line-height"><a href="#6-line-height" class="headerlink" title="6.line-height"></a>6.line-height</h4><p>用来设置文本的行高</p><p>简单理解就是一行文字所占据的高度</p><p>为什么需要行高？</p><p>严格定义：两行文字基线之间的间距</p><p>基线：与小写字母 x 最底部对齐的线</p><p>区分：</p><ul><li>height：整个元素的高度</li><li>line-height：元素中每一行文字所占据的高度</li></ul><p>只有一行文字时，设置line-height等于height可以设置文本居中（仅限于文本）</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230303083221666.png" alt="image-20230303083221666"></p><h4 id="7-font缩写属性"><a href="#7-font缩写属性" class="headerlink" title="7.font缩写属性"></a>7.font缩写属性</h4><p>font 是一个缩写属性，可以作为以上属性的缩写</p><p>一般：font-style font-variant font-weight font-size&#x2F;line-height font-family;</p><ul><li>前三个可以省略，顺序可以调换</li><li>&#x2F;line-height 可以省略，如果不省略，必须跟在 font-size后面</li><li>font-size、font-family不可以调换顺序，也不能省略</li></ul><p>line-height 写数字的话表示为font-size 的倍数</p><h3 id="3、选择器"><a href="#3、选择器" class="headerlink" title="3、选择器"></a>3、选择器</h3><p>需要找到特定的网页元素进行设置样式</p><p>选择器就是按照一定的规则选出符合条件的元素，为其添加css样式</p><h4 id="1-通用选择器"><a href="#1-通用选择器" class="headerlink" title="1.通用选择器"></a>1.通用选择器</h4><p>所有的元素都会被选中，一般用来设置所有元素的一些通用属性，比如网页重置</p><p>性能比较低，尽量不使用</p><h4 id="2-简单选择器"><a href="#2-简单选择器" class="headerlink" title="2.简单选择器"></a>2.简单选择器</h4><ul><li>元素选择器：使用元素名称</li><li>类选择器：使用 .类名</li><li>id 选择器：使用 #id</li></ul><p>id 注意事项</p><ul><li>一个HTML文档中的id值是唯一的，不能重复<ul><li>id值如果由多个单词组成，单词之间可以用中划线-、下划线_连接，也可使用驼峰标识</li><li>最好不要使用标签名作为id值（阅读性比较差）</li></ul></li></ul><p>中划线又叫连字符</p><h4 id="3-属性选择器"><a href="#3-属性选择器" class="headerlink" title="3.属性选择器"></a>3.属性选择器</h4><p>拥有某一个属性</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[title] &#123;</span><br><span class="line">      <span class="attr">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置包含title属性的div元素的背景色 */</span></span><br><span class="line">[title=div] &#123;</span><br><span class="line">    background-<span class="attr">color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他：</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230303095554442.png" alt="image-20230303095554442"></p><h4 id="4-后代选择器"><a href="#4-后代选择器" class="headerlink" title="4.后代选择器"></a>4.后代选择器</h4><p>后代选择器1：所有的后代（直接&#x2F;间接后代）</p><p>选择器之间以空格分开</p><p>后代选择器2：直接子代选择器（必须是直接子代）</p><p>选择器之间以 &gt; 分割</p><h4 id="5-兄弟选择器"><a href="#5-兄弟选择器" class="headerlink" title="5.兄弟选择器"></a>5.兄弟选择器</h4><p>兄弟选择器1：相邻兄弟选择器（后面）</p><p>使用符号 + 连接</p><p>兄弟选择器2：普遍兄弟选择器（后面）</p><p>使用符号 ~ 连接</p><h4 id="6-选择器组"><a href="#6-选择器组" class="headerlink" title="6.选择器组"></a>6.选择器组</h4><h5 id="1、交集选择器"><a href="#1、交集选择器" class="headerlink" title="1、交集选择器"></a>1、交集选择器</h5><p>需要同时符合两个选择器条件（两个选择器紧密相连）</p><ul><li>在开发中通常为了精准的选择某一个元素</li></ul><h5 id="2、并集选择器"><a href="#2、并集选择器" class="headerlink" title="2、并集选择器"></a>2、并集选择器</h5><p>符合一个选择器条件即可（两个选择器使用, 分割）</p><ul><li>在开发中通常为了给多个元素设置相同的样式</li></ul><h4 id="7-伪类"><a href="#7-伪类" class="headerlink" title="7.伪类"></a>7.伪类</h4><p>伪类是选择器的一种，它用于选择处于特定状态的元素</p><p> 比如：在鼠标悬浮在元素上时变色</p><h5 id="常见的伪类"><a href="#常见的伪类" class="headerlink" title="常见的伪类"></a>常见的伪类</h5><ul><li>动态伪类<ul><li>:link   :visited  :hover  :active  :focus</li></ul></li><li>目标伪类<ul><li>:target</li></ul></li><li>语言伪类<ul><li>:lang()</li></ul></li><li>元素状态伪类<ul><li>:enabled  :disabled  :checked</li></ul></li><li>结构伪类<ul><li>:nth-child()  nth-last-child()  :nth-of-type()  nth-last-of-type()</li><li>:first- child  :last-child  :first-of-type  :last-of-type</li><li>:root  :only-child  :only-of-type  :empty</li></ul></li><li>否定伪类<ul><li>:not()</li></ul></li></ul><h5 id="使用举例"><a href="#使用举例" class="headerlink" title="使用举例"></a>使用举例</h5><ul><li>a:link 未访问的链接</li><li>a:visited 已访问的链接</li><li>a:hover 鼠标挪动到链接上</li><li>a:active 激活的链接（鼠标在链接上长按未松开）</li></ul><h5 id="使用注意"><a href="#使用注意" class="headerlink" title="使用注意"></a>使用注意</h5><ul><li><p>:hover 必须放在 :link 和 :visited 后面才能完全生效</p></li><li><p>:active 必须放在 : hover后面才能完全生效</p></li><li><p>编程建议：:link、:visited、:hover、:active</p></li></ul><p>除了a元素，:hover、:active 也能用在其他元素上</p><p>:focus指当前拥有输入焦点的元素（能接收键盘输入）（能进行交互交互的元素）</p><ul><li>文本输入框一聚焦后，背景就会变红色</li></ul><p>编写顺序：:link、:visited、:focus、:hover、:active</p><p>直接给a元素设置样式，相当于给a元素的所有动态伪类都设置了</p><h4 id="8-伪元素"><a href="#8-伪元素" class="headerlink" title="8.伪元素"></a>8.伪元素</h4><p>伪元素默认为：行内非替换元素</p><p>常用的伪元素有</p><ul><li>:first-line、::first-line：针对首行文本设置属性</li><li>:first-letter、::first-letter：可以针对首字母设置属性</li><li>:before、::before：在一个元素之前插入其他内容</li><li>:after、::after：在一个元素之后插入其他内容</li></ul><p>使用伪元素的过程中，content不能省略，可以为“”</p><p>为了区分伪元素和伪类，建议伪元素使用2个冒号</p><h2 id="3-CSS属性的特性"><a href="#3-CSS属性的特性" class="headerlink" title="3.CSS属性的特性"></a>3.CSS属性的特性</h2><h3 id="1、css属性的继承"><a href="#1、css属性的继承" class="headerlink" title="1、css属性的继承"></a>1、css属性的继承</h3><p>css的某些属性具有继承性</p><ul><li>如果一个属性具备继承性，那么在该元素上设置后，他的后代元素都可以继承这个属性</li><li>如果后代元素自己有设置属性，那么优先使用后代元素自己的属性（不管继承过来的属性权重多高）</li></ul><p>常见的 fone-size&#x2F;font-family&#x2F;font-weight&#x2F;line-height&#x2F;color&#x2F;text-align都具有继承性</p><p><strong>继承过来的是计算值，而不是设置值</strong></p><p>强制继承：在子元素的style中将需要继承的属性的值设置为 inherit</p><h3 id="2、css属性的层叠"><a href="#2、css属性的层叠" class="headerlink" title="2、css属性的层叠"></a>2、css属性的层叠</h3><p>css：层叠样式表</p><ul><li><p>对于一个元素来说，相同一个属性我们可以通过不同的选择器给它进行多次设置</p></li><li><p>那么属性会被一层层覆盖上去，但是最终只有一个会生效</p></li><li><p>判断哪个样式生效</p></li></ul><p>判断1：选择器的权重, 权重大的生效, 根据权重可以判断出优先级</p><p>判断2：先后顺序, 权重相同时, 后面设置的生效</p><p>选择器的权重</p><p>!important：10000</p><p>内联样式：1000</p><p>id选择器：100</p><p>类选择器、属性选择器、伪类：10</p><p>元素选择器、伪元素：1</p><p>通配符：0</p><h3 id="3、HTML元素的类型"><a href="#3、HTML元素的类型" class="headerlink" title="3、HTML元素的类型"></a>3、HTML元素的类型</h3><p>html考虑一个问题：每个元素在页面中到底需要占据多大的空间</p><ul><li><p>某些元素非常重要；独占一行 -&gt;类型：块级元素（block level）h&#x2F;div&#x2F;p</p></li><li><p>某些元素属于内容的一部分，没不要独占一行，与其他内容在同一行显示，类型 -&gt; (inline level)  span a img</p></li></ul><p>HTML元素的类型</p><p>块级元素：独占父元素的一行</p><p>行内级元素：多个行内级元素可以在父元素的同一行中显示</p><p>img元素：inline - replaced -&gt; 行内替换元素</p><p>行内替换元素</p><ul><li><p>和其他的行内元素在同一行显示</p></li><li><p>可以设置宽高</p></li></ul><h3 id="4、display属性"><a href="#4、display属性" class="headerlink" title="4、display属性"></a>4、display属性</h3><p>css中有一个display属性，能够修改元素的显示类型</p><p>block：让元素显示为块级元素（独占父元素的一行，可以设置宽高，高度默认由内容决定）</p><p>inline：让元素显示为行内级元素（和其他元素在一行显示，不能设置宽高，大小由内容决定）</p><p>inline-block：让元素同时具备行内级、块级元素的特征</p><p>none：隐藏元素</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230319072815754.png" alt="image-20230319072815754"></p><p>编写 HTML 注意事项</p><p>块级元素、inline-block元素</p><ul><li><p>一般情况下，可以包含其他任何元素（比如块级元素、行内级元素、inline-block元素）</p></li><li><p>特殊情况，p元素不能包含其他块级元素</p></li></ul><p>行内级元素（比如a、span、strong等）</p><ul><li>一般情况下，只能包含行内级元素</li></ul><h3 id="5、元素的隐藏"><a href="#5、元素的隐藏" class="headerlink" title="5、元素的隐藏"></a>5、元素的隐藏</h3><p>方法一: display设置为none</p><ul><li>元素不显示出来, 并且也不占据位置, 不占据任何空间(和不存在一样)</li></ul><p>方法二: visibility设置为hidden</p><ul><li><p>设置为hidden, 虽然元素不可见, 但是会占据元素应该占据的空间</p></li><li><p>默认为visible, 元素是可见的</p></li></ul><p>方法三: rgba设置颜色, 将a的值设置为0</p><ul><li>rgba的a设置的是alpha值, 可以设置透明度, 不影响子元素（占据空间）</li></ul><p>方法四: opacity设置透明度, 设置为0</p><ul><li>设置整个元素的透明度, 会影响所有的子元素（占据空间）</li></ul><h4 id="编写的-CSS-样式不生效技巧"><a href="#编写的-CSS-样式不生效技巧" class="headerlink" title="编写的 CSS 样式不生效技巧"></a>编写的 CSS 样式不生效技巧</h4><ul><li>选择器优先级太低</li><li>选择器没选中对应的元素</li><li>CSS属性的使用形式不对<ul><li>元素不支持此CSS属性，比如span不支持设置宽高</li><li>浏览器不支持此CSS属性，比如旧版本的浏览器不支持一些css module3的某些属性</li><li>被同类型的CSS属性覆盖，比如font覆盖font-size</li></ul></li></ul><h3 id="6、overflow-属性"><a href="#6、overflow-属性" class="headerlink" title="6、overflow 属性"></a>6、overflow 属性</h3><p>overflow用于控制内容溢出时的行为</p><ul><li><p>visible：溢出的内容照样可见（默认值）</p></li><li><p>hidden：溢出的内容直接裁剪</p></li><li><p>scroll：溢出的内容被裁剪，但可以通过滚动机制查看</p><ul><li>会一直显示滚动条区域，滚动条区域占用的空间属于width、height</li></ul></li><li><p>auto：自动根据内容是否溢出来决定是否提供滚动机制（常用）</p></li></ul><h2 id="4-CSS的盒子模型"><a href="#4-CSS的盒子模型" class="headerlink" title="4.CSS的盒子模型"></a>4.CSS的盒子模型</h2><h3 id="1、认识盒子模型"><a href="#1、认识盒子模型" class="headerlink" title="1、认识盒子模型"></a>1、认识盒子模型</h3><p>我们可以把HTML每一个元素看出一个个的盒子，以具备这4个属性：</p><p>内容（content） ：元素的内容width&#x2F;height</p><p>内边距（padding）：元素和内容之间的间距</p><p>边框（border）：元素自己的边框</p><p>外边距（margin）：元素和其他元素之间的间距</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230314164800601.png" alt="image-20230314164800601"></p><p>盒子模型的四边</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230314171639045.png" alt="image-20230314171639045"></p><h3 id="2、内容—宽度和高度"><a href="#2、内容—宽度和高度" class="headerlink" title="2、内容—宽度和高度"></a>2、内容—宽度和高度</h3><p>设置内容是通过高度和宽度设置的：</p><p>宽度设置：width，默认值 auto，交给浏览器决定</p><p>高度设置：height</p><p>注意：对于行内级非替换元素来说, 设置宽高是无效的</p><p>其他设置：</p><p>min-width：最小宽度，无论内容多少，宽度都大于或等于min-width</p><p>max-width：最大宽度，无论内容多少，宽度都小于或等于max-width</p><p>移动端适配时, 可以设置最大宽度和最小宽度</p><p>min-height：最小高度，无论内容多少，高度都大于或等于min-height</p><p>max-height：最大高度，无论内容多少，高度都小于或等于max-height</p><h3 id="3、内边距：padding"><a href="#3、内边距：padding" class="headerlink" title="3、内边距：padding"></a>3、内边距：padding</h3><p>padding属性用于设置盒子的内边距, 通常用于设置边框和内容之间的间距</p><p>padding单独编写是一个缩写属性</p><ul><li><p>padding-top、padding-right、padding-bottom、padding-left的简写属性</p></li><li><p>padding缩写属性是从零点钟方向开始, 沿着顺时针转动的, 也就是上右下左</p></li></ul><p>padding并非必须是四个值, 也可以有其他值</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230319081108760.png" alt="image-20230319081108760"></p><h3 id="4、边框"><a href="#4、边框" class="headerlink" title="4、边框"></a>4、边框</h3><p>border用于设置盒子的边框，边框具备宽度width、样式style、颜色color</p><p>边框宽度</p><ul><li><p>border-top-width、border-right-width、border-bottom-width、border-left-width</p></li><li><p>border-width是上面4个属性的简写属性</p></li></ul><p>边框颜色</p><ul><li><p>border-top-color、border-right-color、border-bottom-color、border-left-color</p></li><li><p>border-color是上面4个属性的简写属性</p></li></ul><p>边框样式</p><ul><li><p>border-top-style、border-right-style、border-bottom-style、border-left-style</p></li><li><p>border-style是上面4个属性的简写属性</p></li></ul><p>边框样式的设置值：</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230319230129421.png" alt="image-20230319230129421"></p><p>同时设置的方式</p><p>border-top、border-right、border-bottom、border-left</p><p>border：统一设置4个方向的边框</p><p>边框颜色、宽度、样式的编写顺序任意</p><p>圆角</p><p>border-radius用于设置盒子的圆角</p><p>border-radius常见的值</p><ul><li><p>数值: 通常用来设置小的圆角, 比如6px</p></li><li><p>百分比: 通常用来设置一定的弧度或者圆形</p></li></ul><p>border-radius事实上是一个缩写属性</p><ul><li><p>将这四个属性 border-top-left-radius、border-top-right-radius、border-bottom-right-radius，和 border-bottomleft-radius 简写为一个属性</p></li><li><p>开发中比较少见一个个圆角设置</p></li></ul><p>如果一个元素是正方形，设置border-radius大于或等于50%时，就会变成一个圆</p><h3 id="5、外边距"><a href="#5、外边距" class="headerlink" title="5、外边距"></a>5、外边距</h3><p>margin属性用于设置盒子的外边距, 通常用于元素和元素之间的间距</p><p>margin包括四个方向, 所以有如下的取值</p><ul><li><p>margin-top：上内边距</p></li><li><p>margin-right：右内边距</p></li><li><p>margin-bottom：下内边距</p></li><li><p>margin-left：左内边距</p></li></ul><p>margin单独编写是一个缩写属性：</p><ul><li><p>margin-top、margin-right、margin-bottom、margin-left的简写属性</p></li><li><p>margin缩写属性是从零点钟方向开始, 沿着顺时针转动的, 也就是上右下左</p></li></ul><p>margin也并非必须是四个值, 也可以有其他值</p><p>margin和padding的区别</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">  &lt;style&gt;</span><br><span class="line">    .<span class="property">box</span> &#123;</span><br><span class="line">      <span class="attr">width</span>: 300px;</span><br><span class="line">      <span class="attr">height</span>: 300px;</span><br><span class="line">      background-<span class="attr">color</span>: red;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* padding弊端 会撑大盒子 */</span></span><br><span class="line">      <span class="comment">/* padding-left: 100px;</span></span><br><span class="line"><span class="comment">      box-sizing: border-box; */</span></span><br><span class="line">      <span class="attr">overflow</span>: auto;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .<span class="property">container</span> &#123;</span><br><span class="line">      <span class="attr">width</span>: 100px;</span><br><span class="line">      <span class="attr">height</span>: 100px;</span><br><span class="line">      background-<span class="attr">color</span>: green;</span><br><span class="line">      <span class="comment">/* 不用设置 border-box */</span></span><br><span class="line">      margin-<span class="attr">left</span>: 100px;</span><br><span class="line">      <span class="comment">/* 设置上下会有问题 发生传递  需在父元素设置overflow auto 触发bfc */</span></span><br><span class="line">      margin-<span class="attr">top</span>: 100px;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h4 id="1-上下margin传递"><a href="#1-上下margin传递" class="headerlink" title="1.上下margin传递"></a>1.上下margin传递</h4><p>margin-top传递</p><ul><li>如果块级元素的顶部线和父元素的顶部线重叠，那么这个块级元素的margin-top值会传递给父元素</li></ul><p>margin-bottom传递</p><ul><li>如果块级元素的底部线和父元素的底部线重写，并且父元素的高度是auto，那么这个块级元素的margin-bottom值会传递给父元素</li></ul><p>如何防止出现传递问题</p><ul><li><p>给父元素设置padding-top\padding-bottom</p></li><li><p>给父元素设置border</p></li><li><p>触发BFC: 设置overflow为auto</p></li></ul><p>建议</p><ul><li><p>margin一般是用来设置兄弟元素之间的间距</p></li><li><p>padding一般是用来设置父子元素之间的间距</p></li></ul><h4 id="2-上下margin的折叠"><a href="#2-上下margin的折叠" class="headerlink" title="2.上下margin的折叠"></a>2.上下margin的折叠</h4><p>垂直方向上相邻的2个margin（margin-top、margin-bottom）有可能会合并为1个margin，这种现象叫做collapse（折叠）</p><p>水平方向上的margin（margin-left、margin-right）永远不会collapse</p><p>折叠后最终值的计算规则</p><ul><li>两个值进行比较，取较大的值</li></ul><p>如何防止margin collapse？ </p><ul><li>只设置其中一个元素的margin</li></ul><p>margin 和 padding 的选择</p><p>元素与元素的距离：margin</p><p>子元素与父元素的距离：padding</p><h3 id="6、外轮廓"><a href="#6、外轮廓" class="headerlink" title="6、外轮廓"></a>6、外轮廓</h3><p>outline表示元素的外轮廓</p><ul><li><p>不占用空间</p></li><li><p>默认显示在border的外面</p></li></ul><p>outline相关属性有</p><ul><li><p>outline-width: 外轮廓的宽度</p></li><li><p>outline-style：取值跟border的样式一样，比如solid、dotted等</p></li><li><p>outline-color: 外轮廓的颜色</p></li><li><p>outline：outline-width、outline-style、outline-color的简写属性，跟border用法类似</p></li></ul><p>应用实例</p><ul><li>去除a元素、input元素的focus轮廓效果</li></ul><h3 id="7、盒子阴影"><a href="#7、盒子阴影" class="headerlink" title="7、盒子阴影"></a>7、盒子阴影</h3><p>box-shadow属性可以设置一个或者多个阴影</p><p>每个阴影用表示</p><p>多个阴影之间用逗号,隔开，从前到后叠加</p><p>格式：</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230319222535516.png" alt="image-20230319222535516"></p><p>第1个：offset-x, 水平方向的偏移，正数往右偏移</p><p>第2个：offset-y, 垂直方向的偏移，正数往下偏移</p><p>第3个：blur-radius, 模糊半径</p><p>第4个：spread-radius, 延伸半径</p><p><code>&lt;color&gt;</code>：阴影的颜色，如果没有设置，就跟随color属性的颜色</p><p>inset：外框阴影变成内框阴影</p><p>在线网址：<a href="https://html-css-js.com/css/generator/box-shadow/">https://html-css-js.com/css/generator/box-shadow/</a></p><h3 id="8、文字阴影"><a href="#8、文字阴影" class="headerlink" title="8、文字阴影"></a>8、文字阴影</h3><p>text-shadow用法类似于box-shadow，用于给文字添加阴影效果</p><p>常见格式如下</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230319222559369.png" alt="image-20230319222559369"></p><p>相当于box-shadow, 它没有spread-radius的值</p><h3 id="9、行内非替换元素的注意事项"><a href="#9、行内非替换元素的注意事项" class="headerlink" title="9、行内非替换元素的注意事项"></a>9、行内非替换元素的注意事项</h3><p>设置高宽不生效</p><p>设置padding：左右可以生效，上下能够撑开，但是不占据空间</p><p>设置border：上下会被撑起来，不占据空间</p><p>设置margin：上下不生效</p><p>以下属性对行内级非替换元素不起作用</p><ul><li>width、height、margin-top、margin-bottom</li></ul><p>以下属性对行内级非替换元素的效果比较特殊</p><ul><li>padding-top、padding-bottom、上下方向的border</li></ul><p>1.前景色有没有设置到border下面（有设置）</p><p>2.前景色会在border没有设置颜色的情况下，显示出color的颜色</p><h3 id="10、box-sizing"><a href="#10、box-sizing" class="headerlink" title="10、box-sizing"></a>10、box-sizing</h3><p>box-sizing用来设置盒子模型中宽高的行为</p><ul><li>content-box<ul><li>padding、border都布置在width、height<strong>外边</strong></li><li>元素的实际占用宽度 &#x3D; border + padding + width</li><li>元素的实际占用高度 &#x3D; border + padding + height</li></ul></li><li>border-box<ul><li>padding、border都布置在width、height<strong>里边</strong></li><li>元素的实际占用宽度 &#x3D; width</li><li>元素的实际占用高度 &#x3D; height</li></ul></li></ul><h3 id="11、元素的水平居中方案"><a href="#11、元素的水平居中方案" class="headerlink" title="11、元素的水平居中方案"></a>11、元素的水平居中方案</h3><p>在一些需求中，需要元素在父元素中水平居中显示（父元素一般都是块级元素、inline-block）</p><p>行内级元素(包括inline-block元素) </p><ul><li>水平居中：在父元素中设置text-align: center</li></ul><p>块级元素</p><ul><li>水平居中：margin: 0 auto（在块级元素中对自己设置）</li></ul><h3 id="12、案例练习总结"><a href="#12、案例练习总结" class="headerlink" title="12、案例练习总结"></a>12、案例练习总结</h3><p>文字介绍一行展示溢出显示…</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">white-<span class="attr">space</span>: nowrap;</span><br><span class="line"><span class="attr">overflow</span>: hidden;</span><br><span class="line">text-<span class="attr">overflow</span>: ellipsis;</span><br></pre></td></tr></table></figure><p>文字介绍两行展示溢出显示…</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">overflow</span>: hidden;</span><br><span class="line">text-<span class="attr">overflow</span>: ellipsis;</span><br><span class="line"><span class="attr">display</span>: -webkit-box;</span><br><span class="line">-webkit-line-<span class="attr">clamp</span>: <span class="number">2</span>;  <span class="comment">// 设置几行显示文字</span></span><br><span class="line">-webkit-box-<span class="attr">orient</span>: vertical;</span><br><span class="line"></span><br><span class="line">并且需要保证其父元素有具体的宽度，如果父元素设置了inline-block，可调为block</span><br></pre></td></tr></table></figure><h2 id="5-CSS-的背景设置"><a href="#5-CSS-的背景设置" class="headerlink" title="5.CSS 的背景设置"></a>5.CSS 的背景设置</h2><h3 id="1、background-image"><a href="#1、background-image" class="headerlink" title="1、background-image"></a>1、background-image</h3><p>background-image用于设置元素的背景图片</p><ul><li>会盖在（不是覆盖）background-color 的上面</li></ul><p>如果设置了多张图片</p><ul><li>设置的第一张图片将显示在最上面，其他图片按顺序层叠在下面</li></ul><p>注意：如果设置了背景图片后，元素没有具体的宽高，背景图片是不会显示出来的</p><h3 id="2、background-repeat"><a href="#2、background-repeat" class="headerlink" title="2、background-repeat"></a>2、background-repeat</h3><p>background-repeat用于设置背景图片是否要平铺</p><p>常见的属性值有</p><ul><li><p>repeat：平铺（默认值）</p></li><li><p>no-repeat：不平铺</p></li><li><p>repeat-x：只在水平方向平铺</p></li><li><p>repeat-y：只在垂直平方向平铺</p></li></ul><h3 id="3、background-size"><a href="#3、background-size" class="headerlink" title="3、background-size"></a>3、background-size</h3><p>background-size用于设置背景图片的大小</p><p>auto：默认值, 以背景图本身大小显示</p><p>cover：缩放背景图，以完全覆盖铺满元素,可能背景图片部分看不见</p><p>contain：缩放背景图，宽度或者高度铺满元素，但是图片保持宽高比</p><p><code>&lt;percentage&gt;</code>：百分比，相对于背景区（background positioning area）</p><p>length：具体的大小，比如100px</p><h3 id="4、background-position"><a href="#4、background-position" class="headerlink" title="4、background-position"></a>4、background-position</h3><p>background-position用于设置背景图片在水平、垂直方向上的具体位置</p><ul><li><p>可以设置具体的数值，比如 20px 30px</p></li><li><p>水平方向还可以设值：left、center、right</p></li><li><p>垂直方向还可以设值：top、center、bottom</p></li></ul><p>如果只设置了1个方向，另一个方向默认是center</p><h3 id="5、background-attachment"><a href="#5、background-attachment" class="headerlink" title="5、background-attachment"></a>5、background-attachment</h3><p>background-attachment决定背景图像的位置是在视口内固定，或者随着包含它的区块滚动</p><p>可以设置以下3个值</p><ul><li><p>scroll：此关键属性值表示背景相对于元素本身固定， 而不是随着它的内容滚动</p></li><li><p>local：此关键属性值表示背景相对于元素的内容固定。如果一个元素拥有滚动机制，背景将会随着元素的内容滚动</p></li><li><p>fixed：此关键属性值表示背景相对于视口固定。即使一个元素拥有滚动机制，背景也不会随着元素的内容滚动。</p></li></ul><h3 id="6、background"><a href="#6、background" class="headerlink" title="6、background"></a>6、background</h3><p>background是一系列背景相关属性的简写属性</p><p>background-size可以省略，如果不省略，&#x2F;background-size必须紧跟在background-position的后面</p><p>其他属性也都可以省略，而且顺序任意</p><h4 id="background-image-和-img-对比"><a href="#background-image-和-img-对比" class="headerlink" title="background-image 和 img 对比"></a>background-image 和 img 对比</h4><p>利用background-image和img都能够实现显示图片的需求，在开发中该如何选择？</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230319215927911.png" alt="image-20230319215927911"></p><p>总结</p><ul><li><p>img，作为网页内容的重要组成部分，比如广告图片、LOGO图片、文章配图、产品图片</p></li><li><p>background-image，可有可无。有，能让网页更加美观。无，也不影响用户获取完整的网页内容信息</p></li></ul><h2 id="6-高级元素"><a href="#6-高级元素" class="headerlink" title="6.高级元素"></a>6.高级元素</h2><h3 id="1、列表元素"><a href="#1、列表元素" class="headerlink" title="1、列表元素"></a>1、列表元素</h3><p>列表功能不同的方案实现</p><ul><li><p>方案一: 使用div元素来实现（比如汽车之家, 知乎上的很多列表）</p></li><li><p>方案二: 使用列表元素，使用元素语义化的方式实现</p></li></ul><p>HTML提供了3组常用的用来展示列表的元素</p><ul><li><p>有序列表：ol、li：直接子元素只能是 li</p></li><li><p>无序列表：ul、li：直接子元素只能是 li</p></li><li><p>定义列表：dl、dt、dd：直接子元素只能是 dt、dd</p><ul><li>dt（definition term）term是项的意思, 列表中每一项的项目名</li><li>列表中每一项的具体描述，是对 dt 的描述、解释、补充</li><li>一个dt后面一般紧跟着1个或者多个dd</li></ul></li></ul><h3 id="2、表格元素"><a href="#2、表格元素" class="headerlink" title="2、表格元素"></a>2、表格元素</h3><h4 id="1-常见的元素"><a href="#1-常见的元素" class="headerlink" title="1.常见的元素"></a>1.常见的元素</h4><p>table：表格</p><p>tr：表格中的行</p><p>td：行中的单元格</p><p>border-collapse CSS 属性是用来决定表格的<strong>边框</strong>是分开的还是合并的。 </p><ul><li><p>table { border-collapse: collapse; }</p></li><li><p>合并单元格的边框</p></li></ul><h4 id="2-表格的其他元素"><a href="#2-表格的其他元素" class="headerlink" title="2.表格的其他元素"></a>2.表格的其他元素</h4><p>thead：表格的表头</p><p>tbody：表格的主体</p><p>tfoot：表格的页脚</p><p>caption：表格的标题</p><p>th：表格的表头单元格</p><h4 id="3-单元格合并"><a href="#3-单元格合并" class="headerlink" title="3.单元格合并"></a>3.单元格合并</h4><p>在某些特殊的情况下, 每个单元格占据的大小可能并不是固定的</p><p>一个单元格可能会跨多行或者多列来使用</p><p>单元格合并分成两种情况</p><p>跨列合并: 使用colspan</p><ul><li>在最左边的单元格写上colspan属性，并且省略掉合并的td</li></ul><p>跨行合并: 使用rowspan</p><ul><li>在最上面的单元格协商rowspan属性，并且省略掉后面tr中的td</li></ul><h3 id="3、表单"><a href="#3、表单" class="headerlink" title="3、表单"></a>3、表单</h3><p>表单元素</p><p>form：表单，一般情况下，其他表单相关元素都是它的后代元素</p><p>input：单行文本输入框、单选框、复选框、按钮等元素</p><p>textarea：多行文本框</p><p>select、option：下拉选择框 </p><p>button：按钮</p><p>label：表单元素的标题</p><h4 id="1-input-元素的使用"><a href="#1-input-元素的使用" class="headerlink" title="1.input 元素的使用"></a>1.input 元素的使用</h4><p>常见的属性：</p><p>type：input的类型</p><ul><li><p>text：文本输入框（明文输入）</p></li><li><p>password：文本输入框（密文输入）</p></li><li><p>radio：单选框</p></li><li><p>checkbox：复选框</p></li><li><p>button：按钮</p></li><li><p>reset：重置</p></li><li><p>submit：提交表单数据给服务器</p></li><li><p>file：文件上传</p></li></ul><p>readonly：只读</p><p>disabled：禁用</p><p>checked：默认被选中</p><ul><li>只有当type为radio或checkbox时可用</li></ul><p>autofocus：当页面加载时，自动聚焦</p><p>name：名字</p><ul><li>在提交数据给服务器时，可用于区分数据类型</li></ul><p>value：取值</p><p>布尔属性</p><p>常见的布尔属性有disabled、checked、readonly、multiple、autofocus、selected</p><p>布尔属性可以没有属性值，写上属性名就代表使用这个属性</p><ul><li>如果要给布尔属性设值，值就是属性名本身</li></ul><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230320205600506.png" alt="image-20230320205600506"></p><h4 id="2-表单按钮"><a href="#2-表单按钮" class="headerlink" title="2.表单按钮"></a>2.表单按钮</h4><p>普通按钮（type&#x3D;button）：使用value属性设置按钮文字</p><p>重置按钮（type&#x3D;reset）：重置它所属form的所有表单元素（包括input、textarea、select）</p><p>提交按钮（type&#x3D;submit）：提交它所属form的表单数据给服务器（包括input、textarea、select）</p><h4 id="3-input-和-label-的关系"><a href="#3-input-和-label-的关系" class="headerlink" title="3.input 和 label 的关系"></a>3.input 和 label 的关系</h4><p>label元素一般跟input配合使用，用来表示input的标题</p><p>labe可以跟某个input绑定，点击label就可以激活对应的input变成选中</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;username&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    用户:</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;username&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h4 id="4-单选框—radio"><a href="#4-单选框—radio" class="headerlink" title="4.单选框—radio"></a>4.单选框—radio</h4><p>name值相同的radio才具备单选功能</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- 在类型为radio的input中 如果name一样 那么两个radio会互斥 --&gt;</span><br><span class="line">    &lt;label for=&quot;male&quot;&gt;</span><br><span class="line">      &lt;input type=&quot;radio&quot; name=&quot;sex&quot; id=&quot;male&quot; value=&quot;male&quot;&gt;男</span><br><span class="line">    &lt;/label&gt;</span><br><span class="line">    &lt;label for=&quot;female&quot;&gt;</span><br><span class="line">      &lt;input type=&quot;radio&quot; name=&quot;sex&quot; id=&quot;female&quot; value=&quot;female&quot;&gt;女</span><br><span class="line">    &lt;/label&gt;</span><br></pre></td></tr></table></figure><h4 id="5-多选框—checkbox"><a href="#5-多选框—checkbox" class="headerlink" title="5.多选框—checkbox"></a>5.多选框—checkbox</h4><p>属于同一种类型的checkbox，name值要保持一致</p><p>可以设置 checked 来默认选中其中一项</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;label <span class="keyword">for</span>=<span class="string">&quot;basketball&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;basketball&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span> <span class="attr">value</span>=<span class="string">&quot;basketball&quot;</span> <span class="attr">checked</span>&gt;</span>篮球</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h4 id="6-多行输入—textarea"><a href="#6-多行输入—textarea" class="headerlink" title="6.多行输入—textarea"></a>6.多行输入—textarea</h4><p>textarea的常用属性</p><p>cols：列数</p><p>rows：行数</p><p>缩放的CSS设置</p><ul><li><p>禁止缩放：resize: none</p></li><li><p>水平缩放：resize: horizontal</p></li><li><p>垂直缩放：resize: vertical</p></li><li><p>水平垂直缩放：resize: both</p></li></ul><h4 id="7-选项列表"><a href="#7-选项列表" class="headerlink" title="7.选项列表"></a>7.选项列表</h4><p>option是select的子元素，一个option代表一个选项</p><p>select常用属性</p><ul><li><p>multiple：可以多选</p></li><li><p>size：显示多少项</p></li></ul><p>option常用属性</p><ul><li>selected：默认被选中</li></ul><h4 id="8-form元素"><a href="#8-form元素" class="headerlink" title="8.form元素"></a>8.form元素</h4><p>form通常作为表单元素的父元素</p><ul><li><p>form可以将整个表单作为一个整体来进行操作</p></li><li><p>比如对整个表单进行重置</p></li><li><p>比如对整个表单的数据进行提交</p></li></ul><p>form常见的属性如下</p><ul><li><p>action：用于提交表单数据的请求URL</p></li><li><p>method：请求方法（get和post），默认是get</p></li><li><p>target：在什么地方打开URL（参考a元素的target）</p></li></ul><h2 id="7-emmet语法和结构伪类"><a href="#7-emmet语法和结构伪类" class="headerlink" title="7.emmet语法和结构伪类"></a>7.emmet语法和结构伪类</h2><h3 id="1、emmet语法"><a href="#1、emmet语法" class="headerlink" title="1、emmet语法"></a>1、emmet语法</h3><p>Emmet (前身为 Zen Coding) 是一个能大幅度提高前端开发效率的一个工具</p><p>在前端开发的过程中，一大部分的工作是写 HTML、CSS 代码，如果手动来编写效果会非常低</p><p>VsCode内置了Emmet语法，在后缀为.html&#x2F;.css中输入缩写后按Tab&#x2F;Enter键即会自动生成相应代码</p><p>!和html:5可以快速生成完整结构的html5代码</p><p><code>&gt;</code>：子代    <code>+</code>；兄弟   <code>*</code>：多个   <code>^</code>：上一级（最多到body）  <code>()</code>：分组</p><p> 属性：<code>[]</code>：普通属性  <code>#</code>：id属性  <code>.</code> ：class属性   <code>&#123;&#125;</code>：内容   <code>$</code>：数字  </p><p>隐式标签：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- ul&gt;.<span class="property">item</span>&#123;列表元素$$&#125;*<span class="number">3</span> --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span>列表元素01<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span>列表元素02<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span>列表元素03<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>css emmet：属性的缩写</p><h3 id="2、结构伪类"><a href="#2、结构伪类" class="headerlink" title="2、结构伪类"></a>2、结构伪类</h3><h4 id="1-nth-child-n"><a href="#1-nth-child-n" class="headerlink" title="1.:nth-child(n)"></a>1.:nth-child(n)</h4><p>:nth-child(1)：是父元素中的第1个子元素</p><p>:nth-child(2n)：n代表任意正整数和0</p><ul><li><p>是父元素中的第偶数个子元素（第2、4、6、8……个）</p></li><li><p>跟:nth-child(even)同义</p></li></ul><p>:nth-child(2n + 1)：n代表任意正整数和0</p><ul><li>是父元素中的第奇数个子元素（第1、3、5、7……个）</li><li>跟:nth-child(odd)同义</li></ul><p>nth-child(-n + 2)：代表前2个子元素</p><h4 id="2-nth-last-child-n"><a href="#2-nth-last-child-n" class="headerlink" title="2.:nth-last-child(n)"></a>2.:nth-last-child(n)</h4><p>:nth-last-child()的语法跟:nth-child()类似，不同点是:nth-last-child()从最后一个子元素开始往前计数</p><ul><li><p>:nth-last-child(1)，代表倒数第一个子元素</p></li><li><p>:nth-last-child(-n + 2)，代表最后2个子元素</p></li></ul><p>:nth-of-type()用法跟:nth-child()类似</p><ul><li>不同点是:nth-of-type()计数时只计算同种类型的元素</li></ul><p>:nth-last-of-type()用法跟:nth-of-type()类似</p><ul><li>不同点是:nth-last-of-type()从最后一个这种类型的子元素开始往前计数</li></ul><p>其他常见的伪类(了解)</p><ul><li><p>:first-child，等同于:nth-child(1)</p></li><li><p>:last-child，等同于:nth-last-child(1)</p></li><li><p>:first-of-type，等同于:nth-of-type(1)</p></li><li><p>:last-of-type，等同于:nth-last-of-type(1)</p></li><li><p>:only-child，是父元素中唯一的子元素</p></li><li><p>:only-of-type，是父元素中唯一的这种类型的子元素</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">.<span class="property">box</span> &gt; :first-child &#123;</span><br><span class="line">     <span class="attr">color</span>: red;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>偶尔使用</p><ul><li><p>:root，根元素，就是HTML元素</p></li><li><p>:empty代表里面完全空白的元素</p></li></ul><h4 id="3-否定伪类"><a href="#3-否定伪类" class="headerlink" title="3.否定伪类"></a>3.否定伪类</h4><p>:not()的格式是:not(x)</p><ul><li><p>x是一个简单选择器</p></li><li><p>元素选择器、通用选择器、属性选择器、类选择器、id选择器、伪类（除否定伪类）</p></li></ul><p>:not(x)表示除x以外的元素</p><h2 id="8-额外知识"><a href="#8-额外知识" class="headerlink" title="8.额外知识"></a>8.额外知识</h2><h3 id="1、边框的形状"><a href="#1、边框的形状" class="headerlink" title="1、边框的形状"></a>1、边框的形状</h3><p>border 主要是用来给盒子增加边框的, 但是在开发中我们也可以利用边框的特性来实现一些形状</p><p><a href="https://css-tricks.com/the-shape-of-css/#top-of-site">https://css-tricks.com/the-shape-of-css/#top-of-site</a></p><h3 id="2、认识-web-字体"><a href="#2、认识-web-字体" class="headerlink" title="2、认识 web 字体"></a>2、认识 web 字体</h3><p>在之前设置页面使用的字体: font-family</p><ul><li><p>我们需要提供一个或多个字体种类名称，浏览器会在列表中搜寻，直到找到它所运行的系统上可用的字体</p></li><li><p>这样的方式完全没有问题，但是对于传统的web开发人员来说，字体选择是有限的</p></li><li><p>这就是所谓的 Web-safe 字体</p></li><li><p>并且这种默认可选的字体并不能进行一些定制化的需求</p></li></ul><p>如果我们依然想在网页中使用别的字体，使用Web Fonts即可</p><h4 id="1-web-fonts-的工作原理"><a href="#1-web-fonts-的工作原理" class="headerlink" title="1.web fonts 的工作原理"></a>1.web fonts 的工作原理</h4><p>首先，需要通过一些渠道获取到希望使用的字体(不是开发来做的事情): </p><ul><li><p>对于某些收费的字体，需要获取到对应的授权</p></li><li><p>对于某些公司定制的字体，需要设计人员来设计</p></li><li><p>对于某些免费的字体，需要获取到对应的字体文件</p></li></ul><p>其次, 在我们的CSS代码当中使用该字体(重要)</p><p>最后, 在部署静态资源时，将HTML&#x2F;CSS&#x2F;JavaScript&#x2F;Font一起部署在静态服务器中</p><p>用户的角度</p><ul><li>浏览器一个网页时，因为代码中有引入字体文件, 字体文件会被一起下载下来</li><li>浏览器会根据使用的字体在下载的字体文件中查找、解析、使用对应的字体</li><li>在浏览器中使用对应的字体显示内容</li></ul><p>使用：</p><p>第一步</p><ul><li><p>在字体天下网站下载一个字体   <a href="https://www.fonts.net.cn/">https://www.fonts.net.cn/</a></p></li><li><p>默认下载下来的是ttf文件</p></li></ul><p> 第二步：使用字体</p><p>使用过程如下：</p><ul><li><p>1.将字体放到对应的目录中</p></li><li><p>2.通过@font-face来引入字体, 并且设置格式</p></li><li><p>3.使用字体</p></li></ul><p>注意: @font-face 用于加载一个自定义的字体;</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 字体引入 */</span></span><br><span class="line">    @font-face &#123;</span><br><span class="line">      font-<span class="attr">family</span>: <span class="string">&quot;wbh&quot;</span>;</span><br><span class="line">      <span class="attr">src</span>: <span class="title function_">url</span>(<span class="string">&quot;./fonts/SanJiLiFengTi-2.ttf&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 使用 */</span></span><br><span class="line">    .<span class="property">box</span> &#123;</span><br><span class="line">      font-<span class="attr">family</span>: <span class="string">&quot;wbh&quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="2-网络字体的兼容性"><a href="#2-网络字体的兼容性" class="headerlink" title="2.网络字体的兼容性"></a>2.网络字体的兼容性</h4><p>在开发中某些浏览器可能不支持该字体，为了浏览器的兼容性问题，需要有对应其他格式的字体</p><p>TrueType字体：拓展名是 .ttf </p><ul><li><p>OpenType&#x2F;TrueType字体：拓展名是 .ttf、.otf， 建立在TrueType字体之上</p></li><li><p>Embedded OpenType字体：拓展名是 .eot， OpenType字体的压缩版</p></li><li><p>SVG字体：拓展名是 .svg、 .svgz</p></li><li><p>WOFF表示Web Open Font Format web开放字体： 拓展名是 .woff，建立在TrueType字体之上</p></li></ul><p>生成兼容性字体：<a href="https://font.qqe2.com/">https://font.qqe2.com/</a></p><p>兼容性写法：</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230321122936480.png" alt="image-20230321122936480"></p><p>src用于指定字体资源</p><ul><li><p>url指定资源的路径</p></li><li><p>format用于帮助浏览器快速识别字体的格式</p></li></ul><h3 id="3、字体图标"><a href="#3、字体图标" class="headerlink" title="3、字体图标"></a>3、字体图标</h3><p>字体图标的使用步骤</p><p>第一步: 通过link引入iconfont.css文件</p><p>第二步: 使用字体图标</p><p>使用字体图标常见的有两种方式</p><p>方式一: 通过对应字体图标的 Unicode 来显示代码</p><p>方式二: 利用已经编写好的class，直接使用即可</p><p>即：方式1：同webfonts方式，引入ttf文件，再使用对应的字符实体，打开demo_index.html查看字符实体</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">  &lt;style&gt;</span><br><span class="line">    @font-face &#123;</span><br><span class="line">      font-<span class="attr">family</span>: <span class="string">&quot;iconfont&quot;</span>;</span><br><span class="line">      <span class="attr">src</span>: <span class="title function_">url</span>(<span class="string">&quot;./fonts03/iconfont.ttf&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .<span class="property">iconfont</span> &#123;</span><br><span class="line">      font-<span class="attr">family</span>: <span class="string">&quot;iconfont&quot;</span>;</span><br><span class="line">      font-<span class="attr">size</span>: normal;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;iconfont&quot;</span>&gt;</span><span class="symbol">&amp;#xe738;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>方式2：使用伪元素，::before，在 iconfont.css  查看 content</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">    @font-face &#123;</span><br><span class="line">      font-<span class="attr">family</span>: <span class="string">&quot;iconfont&quot;</span>;</span><br><span class="line">      <span class="attr">src</span>: <span class="title function_">url</span>(<span class="string">&quot;./fonts03/iconfont.ttf&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .<span class="property">iconfont</span> &#123;</span><br><span class="line">      font-<span class="attr">family</span>: <span class="string">&quot;iconfont&quot;</span>;</span><br><span class="line">      font-<span class="attr">size</span>: normal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .<span class="property">music</span>::before &#123;</span><br><span class="line">      <span class="attr">content</span>: <span class="string">&quot;\e61a&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;iconfont music&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>方法3：使用 class 类名，引入iconfont.css文件，需先设置类名 iconfont 再设置对应的图标类名</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">  &lt;link rel=<span class="string">&quot;stylesheet&quot;</span> href=<span class="string">&quot;./fonts03/iconfont.css&quot;</span>&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;iconfont icon-music&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>阿里：<a href="https://www.iconfont.cn/">https://www.iconfont.cn/</a></p><h3 id="4、精灵图"><a href="#4、精灵图" class="headerlink" title="4、精灵图"></a>4、精灵图</h3><p>CSS Sprite：是一种CSS图像合成技术，将各种小图片合并到一张图片上，然后利用CSS的背景定位来显示对应的图片部分</p><p>有人翻译为：CSS雪碧、CSS精灵</p><p>使用CSS Sprite的好处</p><ul><li>减少网页的http请求数量，加快网页响应速度，减轻服务器压力</li><li>减小图片总大小</li><li>解决了图片命名的困扰，只需要针对一张集合的图片命名</li></ul><p>精灵图的制作</p><p>方法1：专业设计人员</p><p>方法2：<a href="https://www.toptal.com/developers/css/sprite-generator">https://www.toptal.com/developers/css/sprite-generator</a></p><p>精灵图的使用</p><p>精灵图的原理是通过只显示图片的很小一部分来展示的</p><p>通常使用背景</p><ul><li>1.设置对应元素的宽度和高度</li><li>2.设置精灵图作为背景图片</li><li>3.调整背景图片的位置来展示</li></ul><p>获取精灵图的位置：<a href="http://www.spritecow.com/">http://www.spritecow.com/</a></p><h3 id="5、cursor"><a href="#5、cursor" class="headerlink" title="5、cursor"></a>5、cursor</h3><p>cursor可以设置鼠标指针（光标）在元素上面时的显示样式</p><p>cursor常见的设值有</p><ul><li><p>auto：浏览器根据上下文决定指针的显示样式，比如根据文本和非文本切换指针样式</p></li><li><p>default：由操作系统决定，一般就是一个小箭头</p></li><li><p>pointer：一只小手，鼠标指针挪动到链接上面默认就是这个样式</p></li><li><p>text：一条竖线，鼠标指针挪动到文本输入框上面默认就是这个样式</p></li><li><p>none：没有任何指针显示在元素上面</p></li></ul><h2 id="9-元素定位"><a href="#9-元素定位" class="headerlink" title="9.元素定位"></a>9.元素定位</h2><h3 id="1、标准流布局"><a href="#1、标准流布局" class="headerlink" title="1、标准流布局"></a>1、标准流布局</h3><p>默认情况下，元素都是按照normal flow（标准流、常规流、正常流、文档流【document flow】）进行排布</p><ul><li><p>从左到右、从上到下按顺序摆放好</p></li><li><p>默认情况下，互相之间不存在层叠现象</p></li></ul><p>在标准流中，可以使用margin、padding对元素进行定位</p><p>其中margin还可以设置负数</p><p>比较明显的缺点是</p><ul><li><p>设置一个元素的margin或者padding，通常会影响到标准流中其他元素的定位效果</p></li><li><p>不便于实现元素层叠的效果</p></li></ul><p>如果我们希望一个元素可以跳出标准流，单独的对某个元素进行定位呢? </p><p>可以通过position属性来进行设置</p><p>定位允许您从正常的文档流布局中取出元素，并使它们具有不同的行为: </p><ul><li><p>例如放在另一个元素的上面;</p></li><li><p>或者始终保持在浏览器视窗内的同一位置</p></li></ul><p>利用position可以对元素进行定位，常用取值有5个</p><ul><li>默认值:  static：默认值, 静态定位</li></ul><p>使用下面的值, 可以让元素变成 定位元素(positioned element)</p><ul><li><p>relative：相对定位</p></li><li><p>absolute：绝对定位</p></li><li><p>fixed：固定定位</p></li><li><p>sticky：粘性定位</p></li></ul><p>position属性的默认值：static</p><ul><li><p>元素按照 normal flow 布局</p></li><li><p>left 、right、top、bottom没有任何作用</p></li></ul><h3 id="2、相对定位"><a href="#2、相对定位" class="headerlink" title="2、相对定位"></a>2、相对定位</h3><p>元素按照normal flow布局</p><p>可以通过left、right、top、bottom进行定位</p><ul><li><strong>定位参照对象是元素自己原来的位置</strong></li></ul><p>left、right、top、bottom用来设置元素的具体位置</p><p>相对定位的应用场景</p><ul><li>在不影响其他元素位置的前提下，对当前元素位置进行微调（相对自己原来的位置）</li></ul><h3 id="3、固定定位"><a href="#3、固定定位" class="headerlink" title="3、固定定位"></a>3、固定定位</h3><p>元素脱离normal flow（脱离标准流、脱标）</p><p>可以通过left、right、top、bottom进行定位</p><p><strong>定位参照对象是视口（viewport）</strong></p><p>当画布滚动时，固定不动</p><p>视口（Viewport）</p><ul><li>文档的可视区域</li></ul><p>画布（Canvas）</p><ul><li><p>用于渲染文档的区域</p></li><li><p>文档内容超出视口范围，可以通过滚动查看</p></li></ul><p>宽高对比</p><ul><li>画布 &gt;&#x3D; 视口 画布 和 视口</li></ul><h3 id="4、绝对定位"><a href="#4、绝对定位" class="headerlink" title="4、绝对定位"></a>4、绝对定位</h3><p>元素脱离normal flow（脱离标准流、脱标）</p><p>可以通过left、right、top、bottom进行定位</p><ul><li><p><strong>定位参照对象是最邻近的定位祖先元素</strong></p></li><li><p><strong>如果找不到这样的祖先元素，参照对象是视口，内容是可以滚动的</strong></p></li></ul><p>定位元素（positioned element）</p><ul><li><p>position值不为static的元素</p></li><li><p>也就是position值为relative、absolute、fixed的元素</p></li></ul><h4 id="子绝父相"><a href="#子绝父相" class="headerlink" title="子绝父相"></a>子绝父相</h4><p>在绝大数情况下，子元素的绝对定位都是相对于父元素进行定位</p><p>如果希望子元素相对于父元素进行定位，又不希望父元素脱标，常用解决方案是：</p><ul><li><p>父元素设置position: relative（让父元素成为定位元素，而且父元素不脱离标准流）</p></li><li><p>子元素设置position: absolute</p></li><li><p>简称为“子绝父相”</p></li></ul><h4 id="绝对-x2F-固定-定位元素的特点"><a href="#绝对-x2F-固定-定位元素的特点" class="headerlink" title="绝对&#x2F;固定-定位元素的特点"></a>绝对&#x2F;固定-定位元素的特点</h4><ol><li>position:fixed    </li><li>position:absolute</li></ol><p>可以随意设置宽高</p><p>宽高默认由内容决定</p><p>不再受标准流的约束</p><ul><li>不再严格按照从上往下、从左到右排布</li><li>不再严格区分块级、行内级、行内块级的很多特征都会消失</li></ul><p>不再给父元素汇报宽高数据</p><p>脱标元素内部还是按照标准流布局</p><p>对于绝对定位元素来说</p><p>定位参照对象的宽度 &#x3D; left + right + margin-left + margin-right + 绝对定位元素的实际占用宽度</p><p>定位参照对象的高度 &#x3D; top + bottom + margin-top + margin-bottom + 绝对定位元素的实际占用高度</p><p>如果希望绝对定位元素的宽高和定位参照对象一样，可以给绝对定位元素设置以下属性</p><ul><li>left: 0、right: 0、top: 0、bottom: 0、margin:0</li></ul><p>如果希望绝对定位元素在定位参照对象中居中显示，可以给绝对定位元素设置以下属性</p><ul><li><p>left: 0、right: 0、top: 0、bottom: 0、margin: auto</p></li><li><p>另外，还得设置具体的宽高值（宽高小于定位参照对象的宽高）</p></li></ul><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230321222022472.png"></p><h3 id="5、粘性定位"><a href="#5、粘性定位" class="headerlink" title="5、粘性定位"></a>5、粘性定位</h3><p>还有一个定位的值是position: sticky，比起其他定位值要新一些</p><ul><li><p>sticky是一个大家期待已久的属性</p></li><li><p>可以看做是相对定位和固定定位的结合体</p></li></ul><p>它允许被定位的元素表现得像相对定位一样，直到它滚动到某个阈值点</p><p>当达到这个阈值点时, 就会变成固定定位</p><p>即需要设置这个阈值才能生效，如 top:0 </p><p>sticky是相对于最近的滚动祖先包含视口的(the nearest ancestor scroll container’s scrollport )</p><h3 id="6、z-index"><a href="#6、z-index" class="headerlink" title="6、z-index"></a>6、z-index</h3><p>z-index属性用来设置<strong>定位元素</strong>的层叠顺序（<strong>仅对定位元素有效</strong>）</p><ul><li>取值可以是正整数、负整数、0</li></ul><p>比较原则</p><ul><li><p>如果是兄弟关系</p><ul><li>z-index越大，层叠在越上面</li><li>z-index相等，写在后面的那个元素层叠在上面</li></ul></li><li><p>如果不是兄弟关系 </p><ul><li>各自从元素自己以及祖先元素中，找出最邻近的2个定位元素进行比较</li><li>而且这2个定位元素必须有设置z-index的具体数值</li></ul></li></ul><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230321224530651.png" alt="image-20230321224530651"></p><h2 id="10-CSS元素浮动"><a href="#10-CSS元素浮动" class="headerlink" title="10.CSS元素浮动"></a>10.CSS元素浮动</h2><h3 id="1、认识浮动"><a href="#1、认识浮动" class="headerlink" title="1、认识浮动"></a>1、认识浮动</h3><p>float 属性可以指定一个元素应沿其容器的左侧或右侧放置，允许文本和内联元素环绕它</p><ul><li><p>float 属性最初只用于在一段文本内浮动图像, 实现文字环绕的效果</p></li><li><p>但是早期的CSS标准中并没有提供好的左右布局方案, 因此在一段时间里面它成为网页多列布局的最常用工具</p></li></ul><p>绝对定位、浮动都会让元素脱离标准流，以达到灵活布局的效果</p><p>可以通过float属性让元素产生浮动效果，float的常用取值</p><ul><li><p>none：不浮动，默认值</p></li><li><p>left：向左浮动</p></li><li><p>right：向右浮动</p></li></ul><h3 id="2、浮动规则"><a href="#2、浮动规则" class="headerlink" title="2、浮动规则"></a>2、浮动规则</h3><h4 id="浮动规则1"><a href="#浮动规则1" class="headerlink" title="浮动规则1"></a>浮动规则1</h4><p>元素一旦浮动后, 脱离标准流</p><p>朝着向左或向右方向移动，直到自己的边界紧贴着包含块（一般是父元素）或者其他浮动元素的边界为止</p><p>定位元素会层叠在浮动元素上面</p><h4 id="浮动规则2"><a href="#浮动规则2" class="headerlink" title="浮动规则2"></a>浮动规则2</h4><p>如果元素是向左（右）浮动，浮动元素的左（右）边界不能超出包含块的左（右）边界</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230322211609799.png" alt="image-20230322211609799"></p><h4 id="浮动规则3"><a href="#浮动规则3" class="headerlink" title="浮动规则3"></a>浮动规则3</h4><p>浮动元素之间不能层叠</p><ul><li><p>如果一个元素浮动，另一个浮动元素已经在那个位置了，后浮动的元素将紧贴着前一个浮动元素（左浮找左浮，右浮找右浮）</p></li><li><p>如果水平方向剩余的空间不够显示浮动元素，浮动元素将向下移动，直到有充足的空间为止</p></li></ul><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230322211713800.png" alt="image-20230322211713800"></p><h4 id="浮动规则4"><a href="#浮动规则4" class="headerlink" title="浮动规则4"></a>浮动规则4</h4><p>浮动元素不能与行内级内容层叠，行内级内容将会被浮动元素推出</p><p>​比如行内级元素、inline-block元素、块级元素的文字内容</p><h4 id="浮动规则5"><a href="#浮动规则5" class="headerlink" title="浮动规则5"></a>浮动规则5</h4><p>行内级元素、inline-block元素浮动后，其顶部将与所在行的顶部对齐</p><h4 id="空隙的解决方案"><a href="#空隙的解决方案" class="headerlink" title="空隙的解决方案"></a>空隙的解决方案</h4><p>将多个行内级元素中间的空格去除</p><p>   1.删除换行符（不推荐）</p><p>   2.将父元素的font-size设置为0  但是需要在子元素设置回来</p><p>   3.浮动（设置子元素统一向一个方向浮动）</p><p>   4.flex 布局 (未学习)</p><h4 id="案例练习总结"><a href="#案例练习总结" class="headerlink" title="案例练习总结"></a>案例练习总结</h4><p>京东布局：</p><p>考虑本行最后一个模块跑第二行的解决办法</p><p>方法1：通过类名设置 margin-right 为0，稍微麻烦，但是无需考虑兼容</p><p>方法2：结构伪类，nth-child(n)，有可能存在兼容问题（好用）</p><p>方法3：margin 负值，无需考虑兼容（掌握）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">需在模块再包裹一个div元素，为其设置 margin 的负值</span><br><span class="line">    .<span class="property">box</span> &#123;</span><br><span class="line">      <span class="comment">/* margin-right: -10px; */</span></span><br><span class="line">      <span class="attr">margin</span>: <span class="number">0</span> -5px;</span><br><span class="line">    &#125;</span><br><span class="line">在item设置对应的外边距</span><br><span class="line">      <span class="attr">margin</span>: <span class="number">0</span> 5px;</span><br><span class="line">      <span class="comment">/* margin-right: 10px; */</span></span><br></pre></td></tr></table></figure><p>考拉边框线布局：需设置每一项为border-box</p><p>方法1：为item的父元素设置边框，再为item设置border-right，清除最后一个item的border-right</p><p>方法2：为每一个item设置边框，再设置item 的margin-right为-1px，再设置其中一个item的宽少一个px</p><h3 id="3、浮动存在的问题"><a href="#3、浮动存在的问题" class="headerlink" title="3、浮动存在的问题"></a>3、浮动存在的问题</h3><p>由于浮动元素脱离了标准流，变成了脱标元素，所以不再向父元素汇报高度</p><p>父元素计算总高度时，就不会计算浮动子元素的高度，导致了高度坍塌的问题</p><p>解决父元素高度坍塌问题的过程，一般叫做清浮动（清理浮动、清除浮动）</p><p>清浮动的目的是</p><ul><li>让父元素计算总高度的时候，把浮动子元素的高度算进去</li></ul><h3 id="4、清除浮动"><a href="#4、清除浮动" class="headerlink" title="4、清除浮动"></a>4、清除浮动</h3><p>clear属性是做什么的呢? </p><p>clear 属性可以指定一个元素是否必须移动（清除浮动后）到在它之前的浮动元素下面</p><p>clear的常用取值</p><ul><li><p>left：要求元素的顶部低于之前生成的所有左浮动元素的底部 </p></li><li><p>right：要求元素的顶部低于之前生成的所有右浮动元素的底部</p></li><li><p>both：要求元素的顶部低于之前生成的所有浮动元素的底部</p></li><li><p>none：默认值，无特殊要求</p></li></ul><p>因为所有的后代item元素都是浮动的，脱了标准流</p><p>不会向父元素汇报高度，所以content压根没有高度</p><p>方法一：给父元素设置固定高度</p><ul><li>扩展性不好（不推荐）</li></ul><p>方法二：在父元素最后增加一个空的块级子元素，并且让它设置clear: both</p><ul><li><p>会增加很多无意义的空标签，维护麻烦</p></li><li><p>违反了结构与样式分离的原则（不推荐）</p></li></ul><p>方法三：给父元素添加一个伪元素 </p><ul><li><p>推荐使用</p></li><li><p>编写好后可以轻松实现清除浮动</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">.<span class="property">clear</span>-<span class="attr">fix</span>::after &#123;</span><br><span class="line">  <span class="attr">content</span>: <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="attr">clear</span>: both;</span><br><span class="line">  <span class="attr">display</span>: block;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 增加兼容性 */</span></span><br><span class="line">  <span class="attr">visibility</span>: hidden;</span><br><span class="line">  <span class="attr">height</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.<span class="property">clear</span>-fix &#123;</span><br><span class="line">  <span class="comment">/* 兼容ie 6 7 */</span></span><br><span class="line">  *<span class="attr">zoom</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法四：双伪元素清除</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">.<span class="property">clearfix</span>::before,</span><br><span class="line">        .<span class="property">clearfix</span>::after &#123;</span><br><span class="line">            <span class="attr">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">            <span class="attr">display</span>: table;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 真正清除浮动的标签 */</span></span><br><span class="line">        </span><br><span class="line">        .<span class="property">clearfix</span>::after &#123;</span><br><span class="line">            <span class="attr">clear</span>: both;</span><br><span class="line">        &#125;</span><br><span class="line">父元素：&lt;div <span class="keyword">class</span>=<span class="string">&quot;top clearfix&quot;</span>&gt;</span><br></pre></td></tr></table></figure><p>方法五：</p><p>操作：直接给父元素设置 overflow : hidden</p><h3 id="5、对比布局方案"><a href="#5、对比布局方案" class="headerlink" title="5、对比布局方案"></a>5、对比布局方案</h3><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230322212037560.png" alt="image-20230322212037560"></p><h2 id="11-flex布局"><a href="#11-flex布局" class="headerlink" title="11.flex布局"></a>11.flex布局</h2><h3 id="1、认识flex布局"><a href="#1、认识flex布局" class="headerlink" title="1、认识flex布局"></a>1、认识flex布局</h3><p>Flexbox翻译为弹性盒子</p><ul><li><p>弹性盒子是一种用于按行或按列布局元素的一维布局方法</p></li><li><p>元素可以膨胀以填充额外的空间, 收缩以适应更小的空间</p></li><li><p>通常我们使用Flexbox来进行布局的方案称之为flex布局(flex layout)</p></li></ul><p>flex布局是目前web开发中使用最多的布局方案</p><ul><li><p>flex 布局（Flexible 布局，弹性布局）</p></li><li><p>目前特别在移动端可以说已经完全普及</p></li><li><p>在PC端也几乎已经完全普及和使用, 只有非常少数的网站依然在用浮动来布局</p></li></ul><p>为什么需要flex布局</p><ul><li><p>长久以来，CSS 布局中唯一可靠且跨浏览器兼容的布局工具只有 floats 和 positioning</p></li><li><p>但是这两种方法本身存在很大的局限性, 并且他们用于布局实在是无奈之举</p></li></ul><p>原先布局存在的痛点</p><ul><li>比如在父内容里面垂直居中一个块内容</li><li>比如使容器的所有子项等分可用宽度&#x2F;高度，而不管有多少宽度&#x2F;高度可用</li><li>比如使多列布局中的所有列采用相同的高度，即使它们包含的内容量不同</li></ul><h3 id="2、flex布局的理解"><a href="#2、flex布局的理解" class="headerlink" title="2、flex布局的理解"></a>2、flex布局的理解</h3><p>两个重要的概念：</p><ul><li><p>开启了 flex 布局的元素叫 flex container</p></li><li><p>flex container 里面的直接子元素叫做 flex item</p></li></ul><p>当flex container中的子元素变成了flex item时, 具备一下特点:</p><ul><li><p>flex item的布局将受flex container属性的设置来进行控制和布局</p></li><li><p>flex item不再严格区分块级元素和行内级元素</p></li><li><p>flex item默认情况下是包裹内容的, 但是可以设置宽度和高度</p></li></ul><p>设置 display 属性为 flex 或者 inline-flex 可以成为 flex container</p><p>flex：flex container 以 block-level 形式存在</p><p>inline-flex：flex container 以 inline-level 形式存在</p><h4 id="flex布局的模型"><a href="#flex布局的模型" class="headerlink" title="flex布局的模型"></a>flex布局的模型</h4><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230322220731649.png" alt="image-20230322220731649"></p><h3 id="3、flex-container属性"><a href="#3、flex-container属性" class="headerlink" title="3、flex-container属性"></a>3、flex-container属性</h3><p>应用在 flex container 上的 CSS 属性</p><p>flex-flow、flex-direction、flex-wrap、flex-flow、justify-content、align-items、align-content</p><h4 id="flex-direction"><a href="#flex-direction" class="headerlink" title="flex-direction"></a>flex-direction</h4><p>flex items 默认都是沿着 main axis（主轴）从 main start 开始往 main end 方向排布</p><p>flex-direction 决定了 main axis 的方向，有 4 个取值</p><p>row（默认值）、row-reverse、column、column-reverse</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 修改主轴的方向 */</span></span><br><span class="line"><span class="comment">/* row-reverse  主轴反转 */</span></span><br><span class="line"><span class="comment">/* flex-direction: row-reverse; */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* column 修改主轴的方向 列变成主轴的方向 */</span></span><br><span class="line"><span class="comment">/* column 反转列作为主轴的方向 */</span></span><br><span class="line"><span class="comment">/* flex-direction: column-reverse; */</span></span><br></pre></td></tr></table></figure><h4 id="flex-wrap"><a href="#flex-wrap" class="headerlink" title="flex-wrap"></a>flex-wrap</h4><p>flex-wrap 决定了 flex container 是单行还是多行</p><ul><li><p>nowrap（默认）：单行</p></li><li><p>wrap：多行</p></li><li><p>wrap-reverse：多行（对比 wrap，cross start 与 cross end 相反）</p></li></ul><h4 id="flex-flow"><a href="#flex-flow" class="headerlink" title="flex-flow"></a>flex-flow</h4><p>flex-flow 属性是 flex-direction 和 flex-wrap 的简写，顺序任何, 并且都可以省略</p><h4 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a>justify-content</h4><p>justify-content 决定了 flex items 在 main axis 上的对齐方式</p><p>flex-start（默认值）：与 main start 对齐</p><p>flex-end：与 main end 对齐</p><p>center：居中对齐</p><p>space-between：</p><ul><li><p>flex items 之间的距离相等</p></li><li><p>与 main start、main end两端对齐</p></li></ul><p>space-around： </p><ul><li><p>flex items 之间的距离相等 </p></li><li><p>flex items 与 main start、main end 之间的距离是 flex items 之间距离的一半</p></li></ul><p>space-evenly： </p><ul><li><p>flex items 之间的距离相等 </p></li><li><p>flex items 与 main start、main end 之间的距离等于 flex items 之间的距离</p></li></ul><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230322221215021.png" alt="image-20230322221215021"></p><h4 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h4><p>align-items 决定了 flex items 在 cross axis 上的对齐方式</p><ul><li><p>normal：在弹性布局中，效果和stretch一样</p></li><li><p>stretch：当 flex items 在 cross axis 方向的 size（height） 为 auto 时，会自动拉伸至填充 flex container</p></li><li><p>flex-start：与 cross start 对齐</p></li><li><p>flex-end：与 cross end 对齐</p></li><li><p>center：居中对齐</p></li><li><p>baseline：与基准线对齐 align-item</p></li></ul><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230322221453595.png" alt="image-20230322221453595"></p><h4 id="align-content"><a href="#align-content" class="headerlink" title="align-content"></a>align-content</h4><p>align-content 决定了多行 flex items 在 cross axis 上的对齐方式，用法与 justify-content 类似</p><p>stretch（默认值）：与 align-items 的 stretch 类似</p><p>flex-start：与 cross start 对齐</p><p>flex-end：与 cross end 对齐</p><p>center：居中对齐</p><p>space-between：flex items 之间的距离相等</p><ul><li>与 cross start、cross end两端对齐</li></ul><p>space-around：flex items 之间的距离相等</p><ul><li>flex items 与 cross start、cross end 之间的距离是 flex items 之间距离的一半</li></ul><p>space-evenly：flex items 之间的距离相等</p><ul><li>flex items 与 cross start、cross end 之间的距离等于 flex items 之间的距离</li></ul><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230322221508510.png" alt="image-20230322221508510"></p><h3 id="4、flex-item属性"><a href="#4、flex-item属性" class="headerlink" title="4、flex-item属性"></a>4、flex-item属性</h3><h4 id="order"><a href="#order" class="headerlink" title="order"></a>order</h4><p>order 决定了 flex items 的排布顺序</p><ul><li><p>可以设置任意整数（正整数、负整数、0），值越小就越排在前面</p></li><li><p>默认值是 0</p></li></ul><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230322222250489.png" alt="image-20230322222250489"></p><h4 id="align-self"><a href="#align-self" class="headerlink" title="align-self"></a>align-self</h4><p>flex items 可以通过 align-self 覆盖 flex container 设置的 align-items</p><ul><li><p>auto（默认值）：遵从 flex container 的 align-items 设置</p></li><li><p>stretch、flex-start、flex-end、center、baseline，效果跟 align-items 一致</p></li></ul><h4 id="flex-grow"><a href="#flex-grow" class="headerlink" title="flex-grow"></a>flex-grow</h4><p>flex-grow 决定了 flex items 如何扩展(拉伸&#x2F;成长) </p><ul><li><p>可以设置任意非负数字（正小数、正整数、0），默认值是 0</p></li><li><p>当 flex container 在 main axis 方向上有剩余 size 时，flex-grow 属性才会有效</p></li></ul><p>如果所有 flex items 的 flex-grow 总和 sum 超过 1，每个 flex item 扩展的 size 为</p><ul><li>flex container 的剩余 size * flex-grow &#x2F; sum</li></ul><p>flex items 扩展后的最终 size 不能超过 max-width\max-height</p><h4 id="flex-shrink"><a href="#flex-shrink" class="headerlink" title="flex-shrink"></a>flex-shrink</h4><p>flex-shrink 决定了 flex items 如何收缩（缩小）</p><ul><li><p>可以设置任意非负数字（正小数、正整数、0），默认值是 1</p></li><li><p>当 flex items 在 main axis 方向上超过了 flex container 的 size，flex-shrink 属性才会有效</p></li></ul><p>如果所有 flex items 的 flex-shrink 总和超过 1，每个 flex item 收缩的 size为</p><ul><li>flex items 超出 flex container 的 size * 收缩比例 &#x2F; 所有 flex items 的收缩比例之和</li></ul><p>flex items 收缩后的最终 size 不能小于 min-width\min-height</p><h4 id="flex-basis"><a href="#flex-basis" class="headerlink" title="flex-basis"></a>flex-basis</h4><p>flex-basis 用来设置 flex items 在 main axis 方向上的 base size</p><ul><li>auto（默认值）、具体的宽度数值（100px）</li></ul><p>唯一用处：和width差不多，但是在显示某些内容（比如一串英文）时会当做一个整体，显示不完是会扩展尺寸来显示完整</p><p>决定 flex items 最终 base size 的因素，从优先级高到低</p><ul><li><p>max-width\max-height\min-width\min-height</p></li><li><p>flex-basis</p></li><li><p>width\height</p></li><li><p>内容本身的 size</p></li></ul><h4 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h4><p>flex 是 flex-grow || flex-shrink || flex-basis 的简写,flex 属性可以指定1个，2个或3个值</p><p>设置为none：0 0 auto</p><p>设置为 auto：1 1 auto</p><p>单值语法: 值必须为以下其中之一</p><ul><li><p>一个无单位数：它会被当作 flex-grow 的值</p></li><li><p>一个有效的宽度值：它会被当作 flex-basis 的值</p></li><li><p>关键字none，auto或initial</p></li></ul><p>双值语法: </p><ul><li><p>第一个值必须为一个无单位数，并且它会被当作 flex-grow 的值。</p></li><li><p>第二个值必须为以下之一：</p><ul><li>一个无单位数：它会被当作 flex-shrink 的值</li><li>一个有效的宽度值: 它会被当作 flex-basis 的值</li></ul></li></ul><p>三值语法:</p><p>第一个值必须为一个无单位数，并且它会被当作 flex-grow 的值</p><p>第二个值必须为一个无单位数，并且它会被当作 flex-shrink 的值</p><p>第三个值必须为一个有效的宽度值， 并且它会被当作 flex-basis 的值。</p><h3 id="5、以下布局解决方案"><a href="#5、以下布局解决方案" class="headerlink" title="5、以下布局解决方案"></a>5、以下布局解决方案</h3><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230322222340960.png" alt="image-20230322222340960"></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">常用：在item元素结尾加上span元素 再为span设置相同的宽度（列数-<span class="number">2</span>）</span><br><span class="line">    &lt;div <span class="keyword">class</span>=<span class="string">&quot;item3 item&quot;</span>&gt;3x&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">    .<span class="property">container</span> &gt; span &#123;</span><br><span class="line">      <span class="attr">width</span>: 120px;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="12-项目练习"><a href="#12-项目练习" class="headerlink" title="12.项目练习"></a>12.项目练习</h2><h3 id="1、布局练习"><a href="#1、布局练习" class="headerlink" title="1、布局练习"></a>1、布局练习</h3><h3 id="2、网易云布局"><a href="#2、网易云布局" class="headerlink" title="2、网易云布局"></a>2、网易云布局</h3><p>1.text-indent对行内非替换元素无效</p><p>2.line-height对行内非替换元素的作用</p><p>3.块级元素中嵌套img，需要设置img的vertical-align才能完整盖住块级元素</p><p>4.box-sizing的应用场景：盒子明确设置了宽度和高度</p><p>5.box-sizing无效：块级盒子嵌套、定位、浮动</p><p>6.在a元素中嵌套div元素</p><h3 id="3、王者荣耀"><a href="#3、王者荣耀" class="headerlink" title="3、王者荣耀"></a>3、王者荣耀</h3><h2 id="13-形变与动画"><a href="#13-形变与动画" class="headerlink" title="13.形变与动画"></a>13.形变与动画</h2><h3 id="1、transform"><a href="#1、transform" class="headerlink" title="1、transform"></a>1、transform</h3><p>CSS transform属性允许对某一个元素进行某些形变, 包括旋转，缩放，倾斜或平移等</p><p>注意事项，并非所有的盒子都可以进行transform的转换（通常行内级元素不能进行形变）</p><p>所以，transform对于行内级非替换元素是无效的</p><ul><li><p>比如对span、a元素等</p></li><li><p>table 相关的也不能形变</p></li></ul><p>常见的函数transform function有</p><ul><li><p>平移：translate(x, y) </p></li><li><p>缩放：scale(x, y) </p></li><li><p>旋转：rotate(deg) </p></li><li><p>倾斜：skew(deg, deg)</p></li></ul><p>通过上面的几个函数，我们可以改变某个元素的形变</p><h4 id="1-位移—translate"><a href="#1-位移—translate" class="headerlink" title="1.位移—translate"></a>1.位移—translate</h4><p>平移：translate(x, y) </p><p>这个CSS 函数用于移动元素在平面上的位置</p><p>translate本身可以表示翻译的意思，在物理上也可以表示平移；</p><p>值个数 </p><ul><li>一个值时，设置x轴上的位移</li><li>二个值时，设置x轴和y轴上的位移</li></ul><p>值类型</p><ul><li><p>数字：100px</p></li><li><p>百分比：参照元素本身（ refer to the size of bounding box ）</p></li></ul><p>translate 是 translateX 和 translateY 函数的简写</p><p>translate 的百分比可以完成一个元素的水平和垂直居中</p><p>translate函数相对于 flex 布局的兼容性会好一点点（可忽略不计）</p><h4 id="2-补充：水平居中和垂直居中的方案"><a href="#2-补充：水平居中和垂直居中的方案" class="headerlink" title="2.补充：水平居中和垂直居中的方案"></a>2.补充：水平居中和垂直居中的方案</h4><p>水平居中<br>1.行内级元素</p><ul><li>设置父元素的 text-align:cente</li></ul><p>2.块级元素</p><ul><li>需要有宽度，设置当前块级元素的 margin:0 auto</li></ul><p>3.绝对定位</p><ul><li>元素有宽度的情况下，left0&#x2F;right0&#x2F;margin:0 auto;</li></ul><p>4.flex</p><pre><code>    * justify-content:center</code></pre><p>垂直居中方法</p><p>1.绝对定位</p><p>元素在有高度的情况下，top0&#x2F;bottom0&#x2F;margin:auto 0</p><p>弊端：</p><ul><li><p>必须使用定位（脱离标准流）</p></li><li><p>必须给元素设置宽度</p></li></ul><p>2.flex布局</p><p>弊端</p><ul><li>当前flex局部中的所有元素都会被垂直居中</li><li>相对来说兼容性差一点点（基本可以忽略）</li></ul><p>3.top&#x2F;translate</p><ul><li><p>1、让元素向下位移父元素的50%</p><ul><li>使用相对定位，不能使用margin-top 它相对于的是父元素的宽度</li></ul></li><li><p>2、让元素向上位移自身的50%</p></li></ul><h4 id="3-缩放"><a href="#3-缩放" class="headerlink" title="3.缩放"></a>3.缩放</h4><p>缩放：scale(x, y) </p><ul><li>scale() CSS 函数可改变元素的大小</li></ul><p>值个数</p><ul><li><p>一个值时，设置 x 轴上的缩放</p></li><li><p>二个值时，设置 x 轴和 y 轴上的缩放</p></li></ul><p>值类型：</p><ul><li><p>数字</p><ul><li>1：保持不变</li><li>2：放大一倍 </li><li>0.5：缩小一半</li></ul></li><li><p>百分比：百分比不常用</p></li></ul><p>scale 函数时 scaleX 和 scaleY 的缩写</p><h4 id="4-旋转"><a href="#4-旋转" class="headerlink" title="4.旋转"></a>4.旋转</h4><p>旋转：rotate(<code>&lt;angle&gt;</code>) </p><p>值个数</p><ul><li>一个值时，表示旋转的角度</li></ul><p>值类型：</p><ul><li><p>常用单位deg：旋转的角度（ degrees ）</p></li><li><p>正数为顺时针</p></li><li><p>负数为逆时针</p></li></ul><p>补充一：rotate函数是rotateZ函数的简写写法</p><p>补充二：rotate的其他单位</p><ul><li>度（degrees）、 百分度（gradians）、弧度（radians）或圈数（turns）；</li></ul><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230325082302662.png" alt="image-20230325082302662"></p><h4 id="5-transform-origin"><a href="#5-transform-origin" class="headerlink" title="5.transform origin"></a>5.transform origin</h4><p>transform-origin：形变的原点</p><p>比如在进行scale缩放或者rotate旋转时，都会有一个原点。</p><p>一个值：设置x轴的原点 </p><p>两个值：设置x轴和y轴的原点</p><p>必须是<code>&lt;length&gt;</code>，<code>&lt;percentage&gt;</code>，或 left, center, right, top, bottom关键字中的一个</p><ul><li><p>left, center, right, top, bottom关键字</p></li><li><p>length：从左上角开始计算</p></li><li><p>百分比：参考元素本身大小</p></li></ul><h4 id="6-倾斜"><a href="#6-倾斜" class="headerlink" title="6.倾斜"></a>6.倾斜</h4><p>倾斜：skew(x, y)</p><ul><li>函数定义了一个元素在二维平面上的倾斜转换</li></ul><p>值个数 </p><ul><li>一个值时，表示x轴上的倾斜 </li><li>二个值时，表示x轴和y轴上的倾斜</li></ul><p>值类型</p><ul><li><p>deg：倾斜的角度 </p></li><li><p>正数为顺时针 </p></li><li><p>负数为逆时针</p></li></ul><p>注意：倾斜的原点受transform-origin的影响</p><h4 id="7-transform-设置多个值"><a href="#7-transform-设置多个值" class="headerlink" title="7.transform 设置多个值"></a>7.transform 设置多个值</h4><p>transform的语法是可以设置多个transform-function的</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230325081501119.png" alt="image-20230325081501119"></p><p>+:一个或者多个，并且之间使用空格分割</p><p>#：一个或者多个 之间使用,进行分割（如box-shadow）</p><h3 id="2、transition动画"><a href="#2、transition动画" class="headerlink" title="2、transition动画"></a>2、transition动画</h3><p>CSS transitions 提供了一种在更改CSS属性时控制动画速度的方法</p><p>可以让CSS属性变化成为一个持续一段时间的过程，而不是立即生效的</p><p>比如将一个元素从一个位置移动到另外一个位置，默认在修改完CSS属性后会立即生效</p><p>但是我们可以通过CSS transition，让这个过程加上一定的动画效果，包括一定的曲线速率变化</p><p>通常将两个状态之间的过渡称为隐式过渡（implicit transitions），因为开始与结束之间的状态由浏览器决定</p><p>CSS transitions 可以决定</p><ul><li><p>哪些属性发生动画效果 (明确地列出这些属性) </p></li><li><p>何时开始 (设置 delay）</p></li><li><p>持续多久 (设置 duration) </p></li><li><p>如何动画 (定义timing function，比如匀速地或先快后慢)</p></li></ul><p>哪些属性可以做动画</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_animated_properties">https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_animated_properties</a></p><p>transition CSS 属性是 transition-property，transition-duration，transition-timing-function 和 transition-delay 的一个简写属性</p><p>transition-property：指定应用过渡属性的名称</p><ul><li><p>all：所有属性都执行动画</p></li><li><p>none：所有属性都不执行动画</p></li><li><p>CSS属性名称：要执行动画的CSS属性名称，比如width、left、transform等</p></li></ul><p>transition-duration：指定过渡动画所需的时间</p><ul><li>单位可以是秒（s）或毫秒（ms）</li></ul><p>transition-timing-function：指定动画的变化曲线</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transition-timing-function">https://developer.mozilla.org/zh-CN/docs/Web/CSS/transition-timing-function</a></li></ul><p>transition-delay：指定过渡动画执行之前的等待时间</p><p>transform是形变</p><ul><li><p>一个CSS属性，该CSS属性用于设置形变</p></li><li><p>后面的值是形变的函数，比如scale、rotate、translate</p></li></ul><p>translate是其中一个transform-function ：用于对元素进行平移</p><p>transition是过渡的意思：它本身也有转变的含义，但是更多表示的是过渡的过程</p><h3 id="3、Animation"><a href="#3、Animation" class="headerlink" title="3、Animation"></a>3、Animation</h3><p>transition来进行过渡动画，但是有如下的缺点：</p><ul><li><p>transition只能定义开始状态和结束状态，不能定义中间状态，也就是说只有两个状态</p></li><li><p>transition不能重复执行，除非一再触发动画</p></li><li><p>transition需要在特定状态下会触发才能执行，比如某个属性被修改了</p></li></ul><p>如果我们希望可以有更多状态的变化，我们可以使用CSS Animation</p><p>CSS Animation的使用分成两个步骤：</p><ul><li><p>步骤一：使用keyframes定义动画序列（每一帧动画如何执行）</p></li><li><p>步骤二：配置动画执行的名称、持续时间、动画曲线、延迟、执行次数、方向等等</p></li></ul><h3 id="4、vertical-align"><a href="#4、vertical-align" class="headerlink" title="4、vertical-align"></a>4、vertical-align</h3><p>给行内级元素设置</p><p>vertical-align会影响行内块级元素在一个行盒中垂直方向的位置</p><p>行盒的作用：包裹所有的内容</p><p>一个div没有设置高度的时候，会不会有高度？</p><ul><li><p>没有内容，没有高度</p></li><li><p>有内容，内容撑起来高度</p></li></ul><p>但是内容撑起来高度的本质是什么呢？</p><ul><li>内容有行高（line-height），撑起来了div的高度</li></ul><p>行高为什么可以撑起div的高度？</p><ul><li><p>这是因为line boxes的存在，并且line-boxes有一个特性，包裹每行的 inline level</p></li><li><p>而其中的文字是有行高的，必须将整个行高包裹进去，才算包裹这个 line-leve</p></li></ul><p>line-boxes一定会想办法包裹住当前行中所有的内容</p><p>为什么对齐方式千奇百怪呢？</p><p>答案就是baseline对齐</p><ul><li>官方vertical-align的默认值：没错，就是baseline</li></ul><p>但是baseline都是谁呢?</p><ul><li><p>文本的baseline是字母x的下方</p></li><li><p>Inline-block默认的baseline是margin-bottom的底部（没有，就是盒子的底部）</p></li><li><p>Inline-block有文本时，baseline是最后一行文本的x的下方</p></li></ul><p>不同的取值</p><ul><li>baseline(默认值)：基线对齐（你得先明白什么是基线</li><li>top：把行内级盒子的顶部跟line boxes顶部对齐</li><li>middle：行内级盒子的中心点与父盒基线加上x-height一半的线对齐 </li><li>bottom：把行内级盒子的底部跟line box底部对齐</li><li><code>&lt;percentage&gt;</code>：把行内级盒子提升或者下降一段距离（距离相对于line-height计算\元素高度）， 0%意味着同baseline一 样</li><li><code>&lt;length&gt;</code>：把行内级盒子提升或者下降一段距离，0cm意味着同baseline一样</li></ul><p>解决图片下边缘的间隙方法</p><ul><li>方法一: 设置成top&#x2F;middle&#x2F;bottom</li><li>方法二: 将图片设置为block元素</li></ul><p>盒子与文本分离：line-height 的继承与 vertical-align 的基线对齐导致，需要重新设置 line-height</p><h2 id="14-额外知识补充"><a href="#14-额外知识补充" class="headerlink" title="14.额外知识补充"></a>14.额外知识补充</h2><h3 id="1-HTML5新增元素"><a href="#1-HTML5新增元素" class="headerlink" title="1.HTML5新增元素"></a>1.HTML5新增元素</h3><h4 id="1、语义化元素"><a href="#1、语义化元素" class="headerlink" title="1、语义化元素"></a>1、语义化元素</h4><p> 在HMTL5之前，我们的网站分布层级通常包括 header、nav、main、footer</p><p>弊端：</p><ul><li><p>我们往往过多的使用div, 通过id或class来区分元素</p></li><li><p>对于浏览器来说这些元素不够语义化</p></li><li><p>对于搜索引擎来说, 不利于SEO的优化</p></li></ul><p> HTML5新增了语义化的元素：</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230327081851504.png" alt="image-20230327081851504"></p><h4 id="2、Video、Audio元素"><a href="#2、Video、Audio元素" class="headerlink" title="2、Video、Audio元素"></a>2、Video、Audio元素</h4><p>在HTML5之前是通过flash或者其他插件实现的, 但是会有很多问题</p><ul><li>比如无法很好的支持HTML&#x2F;CSS特性, 兼容性问题等</li></ul><p>HTML5增加了对媒体类型的支持：</p><ul><li><p>音频：audio</p></li><li><p>视频：video</p></li></ul><p>使用方法有两个：</p><ul><li>直接通过元素使用</li><li>通过 javascript 的 API 对其进行控制</li></ul><p><code> &lt;video&gt;</code> 元素用于在HTML或者XHTML文档中嵌入媒体播放器，用于支持文档内的视频播放</p><p>常见属性：</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230327150507161.png" alt="image-20230327150507161"></p><p>每个视频都会有自己的格式，浏览器的video并非支持所有的视频格式，mp4常用</p><p>video的兼容性写法</p><ul><li><p>内容一：通过元素指定更多视频格式的源</p></li><li><p>内容二：通过p&#x2F;div等元素指定在浏览器不支持video元素的情况，显示的内容</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;video src=<span class="string">&quot;./assets/fcrs.mp4&quot;</span> width=<span class="string">&quot;500&quot;</span> controls&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;./assets/fcrs.ogg&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;./assets/fcrs.webm&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>当前您的浏览器不支持视频的播放，请更换浏览器<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p><code>&lt;audio&gt;</code>元素用于在文档中嵌入音频内容, 和video的用法非常类似</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230327150706535.png" alt="image-20230327150706535"></p><p>每个音频都会有自己的格式, 浏览器的audio并非支持所有的视频格式</p><p>具体的支持的格式可以通过下面的链接查看</p><p><a href="https://developer.mozilla.org/en-US/docs/Web/Media/Formats/Audio_codecs">https://developer.mozilla.org/en-US/docs/Web/Media/Formats/Audio_codecs</a></p><p>兼容性写法（降级处理）：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;audio src=<span class="string">&quot;./assets/yhbk.mp3&quot;</span> controls &gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;./assets/fcrs.mp3&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>你的浏览器不支持<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="2-input、全局属性-data"><a href="#2-input、全局属性-data" class="headerlink" title="2.input、全局属性 data-*"></a>2.input、全局属性 data-*</h3><p>HTML5对input元素也进行了扩展，在之前我们已经学习过的其中几个属性也是HTML5的特性：</p><ul><li><p>placeholder：输入框的占位文字</p></li><li><p>multiple：多个值</p></li><li><p>autofocus：最多输入的内容</p></li></ul><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/Input">https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/Input</a></p><p>在HTML5中, 新增一种全局属性的格式 data-*，用于自定义数据属性</p><ul><li><p>data设置的属性可以在JavaScript的DOM操作中通过dataset轻松获取到</p></li><li><p>通常用于HTML和JavaScript数据之间的传递；</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div <span class="keyword">class</span>=<span class="string">&quot;box&quot;</span> data-name=<span class="string">&quot;dww&quot;</span> data-age=<span class="string">&quot;18&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">const</span> boxEl = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;.box&quot;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="variable language_">console</span>.<span class="title function_">log</span>(boxEl.<span class="property">dataset</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>在小程序中, 就是通过data-来传递数据的, 所以该全局属性必须要掌握</p><h3 id="3-white-space-x2F-text-overflow"><a href="#3-white-space-x2F-text-overflow" class="headerlink" title="3.white-space&#x2F;text-overflow"></a>3.white-space&#x2F;text-overflow</h3><p>white-space用于设置空白处理和换行规则</p><ul><li>normal：合并所有连续的空白，允许单词超屏时自动换行</li><li>nowrap：合并所有连续的空白，不允许单词超屏时自动换行</li><li>pre：阻止合并所有连续的空白，不允许单词超屏时自动换行</li><li>pre-wrap：阻止合并所有连续的空白，允许单词超屏时自动换行</li><li>pre-line：合并所有连续的空白（但保留换行），允许单词超屏时自动换行</li></ul><p>text-overflow</p><p>text-overflow通常用来设置文字溢出时的行为</p><ul><li><p>clip：溢出的内容直接裁剪掉（字符可能会显示不完整）</p></li><li><p>ellipsis：溢出那行的结尾处用省略号表示</p></li></ul><p>text-overflow生效的前提是overflow不为visible </p><p>常见的是将white-space、text-overflow、overflow一起使用：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">overflow</span>: hidden;</span><br><span class="line">white-<span class="attr">space</span>: nowrap;</span><br><span class="line">text-<span class="attr">overflow</span>: ellipsis;</span><br></pre></td></tr></table></figure><h3 id="4-CSS常见的函数扩展"><a href="#4-CSS常见的函数扩展" class="headerlink" title="4.CSS常见的函数扩展"></a>4.CSS常见的函数扩展</h3><p>在前面我们有使用过很多个CSS函数</p><ul><li><p>比如rgb&#x2F;rgba&#x2F;translate&#x2F;rotate&#x2F;scale等</p></li><li><p>CSS函数通常可以帮助我们更加灵活的来编写样式的值</p></li></ul><p>下面再学习几个好用的CSS函数</p><ul><li><p>var: 使用CSS定义的变量</p></li><li><p>calc: 计算CSS值，通常用于计算元素的大小或位置</p></li><li><p>blur: 毛玻璃（高斯模糊）效果</p></li><li><p>gradient：颜色渐变函数</p></li></ul><h4 id="1、var"><a href="#1、var" class="headerlink" title="1、var()"></a>1、var()</h4><p>CSS中可以自定义属性</p><ul><li><p>属性名需要以两个减号（–）开始</p></li><li><p>属性值则可以是任何有效的CSS值</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">:root &#123;</span><br><span class="line">  <span class="comment">/* 定义了一个变量 */</span></span><br><span class="line">  <span class="comment">/* 只有后代元素可以使用 */</span></span><br><span class="line">  --main-<span class="attr">color</span>: #f3c221;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以通过var函数来使用</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">.<span class="property">box</span> &#123;</span><br><span class="line">  <span class="attr">color</span>: <span class="title function_">var</span>(--main-color);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>规则集定义的选择器, 是自定义属性的可见作用域(只在选择器内部有效) </p><ul><li>所以推荐将自定义属性定义在html中，也可以使用 :root 选择器</li></ul><h4 id="2、calc"><a href="#2、calc" class="headerlink" title="2、calc()"></a>2、calc()</h4><p>calc() 函数允许在声明 CSS 属性值时执行一些计算</p><p>计算支持加减乘除的运算</p><ul><li>加和减运算符的两边必须要有空白字符</li></ul><p>通常用来设置一些元素的尺寸或者位置</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">.<span class="property">item1</span> &#123;</span><br><span class="line">    <span class="comment">/* width的百分比相当于包含块 */</span></span><br><span class="line">    <span class="attr">width</span>: <span class="title function_">calc</span>(<span class="number">100</span>% - 100px);</span><br><span class="line">    background-<span class="attr">color</span>: #f00;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、blur"><a href="#3、blur" class="headerlink" title="3、blur()"></a>3、blur()</h4><p>blur() 函数将高斯模糊应用于输出图片或者元素</p><p>blur(radius)</p><p>radius, 模糊的半径, 用于定义高斯函数的偏差值, 偏差值越大, 图片越模糊</p><p>通常会和两个属性一起使用：</p><p>filter: 将模糊或颜色偏移等图形效果应用于元素</p><p>backdrop-filter: 为元素后面的区域添加模糊或者其他效果</p><h4 id="4、gradient"><a href="#4、gradient" class="headerlink" title="4、gradient()"></a>4、gradient()</h4><p>是一种<code>&lt;image&gt;</code>CSS数据类型的子类型，用于表现两种或多种颜色的过渡转变</p><ul><li><p>CSS的<code>&lt;image&gt;</code>数据类型描述的是2D图形</p></li><li><p>比如 background-image、list-style-image、border-image、content 等</p></li><li><p>常见的方式是通过url来引入一个图片资源</p></li><li><p>它也可以通过 CSS 的 gradient() 函数来设置颜色的渐变</p></li></ul><p>常见的函数实现有下面几种：</p><ul><li><p>linear-gradient()：创建一个表示两种或多种颜色线性渐变的图片</p></li><li><p>radial-gradient()：创建了一个图像，该图像是由从原点发出的两种或者多种颜色之间的逐步过渡组成</p></li><li><p>repeating-linear-gradient()：创建一个由重复线性渐变组成的<code>&lt;image&gt;</code></p></li><li><p>repeating-radial-gradient()：创建一个重复的原点触发渐变组成的<code>&lt;image&gt;</code></p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">background-<span class="attr">image</span>: linear-<span class="title function_">gradient</span>( 90deg, red, blue 40px, orange <span class="number">60</span>%, purple <span class="number">100</span>%);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">background-<span class="attr">image</span>: radial-<span class="title function_">gradient</span>(at <span class="number">0</span> <span class="number">50</span>%, red,blue);</span><br></pre></td></tr></table></figure><h3 id="5-浏览器前缀"><a href="#5-浏览器前缀" class="headerlink" title="5.浏览器前缀"></a>5.浏览器前缀</h3><p>有时候可能会看到有些CSS属性名前面带有：-o-、-xv-、-ms-、mso-、-moz-、-webkit-</p><p>官方文档专业术语叫做：vendor-specific extensions（供应商特定扩展）</p><p>为什么需要浏览器前缀了？</p><p>CSS属性刚开始并没有成为标准，浏览器为了防止后续会修改名字给新的属性添加了浏览器前缀</p><p>上述前缀叫做浏览器私有前缀，只有对应的浏览器才能解析使用</p><ul><li>-o-、-xv-：Opera等</li><li>-ms-、mso-：IE等</li><li>-moz-：Firefox等</li><li>-webkit-：Safari、Chrome等</li></ul><p>注意：不需要手动添加，后面学习了模块化打包工具会自动添加浏览器前缀</p><h3 id="6-深入理解BFC"><a href="#6-深入理解BFC" class="headerlink" title="6.深入理解BFC"></a>6.深入理解BFC</h3><h4 id="1、FC的概念"><a href="#1、FC的概念" class="headerlink" title="1、FC的概念"></a>1、FC的概念</h4><p>FC的全称是Formatting Context，元素在标准流里面都是属于一个FC的</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230327151516721.png" alt="image-20230327151516721"></p><p>块级元素的布局属于Block Formatting Context（BFC）</p><p>也就是block level box都是在BFC中布局的</p><ul><li><p>行内级元素的布局属于Inline Formatting Context（IFC） </p></li><li><p>而inline level box都是在IFC中布局的</p></li></ul><h4 id="2、BFC的创建"><a href="#2、BFC的创建" class="headerlink" title="2、BFC的创建"></a>2、BFC的创建</h4><p>MDN上有整理出在哪些具体的情况下会创建BFC：</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230327151542003.png" alt="image-20230327151542003"></p><ul><li><p>根元素（<code>&lt;html&gt;</code>）</p></li><li><p>浮动元素（元素的 float 不是 none）</p></li><li><p>绝对定位元素（元素的 position 为 absolute 或 fixed）</p></li><li><p>行内块元素（元素的 display 为 inline-block）</p></li></ul><ul><li><p>表格单元格（元素的 display 为 table-cell，HTML表格单元格默认为该值），表格标题（元素的 display 为 table-caption，HTML表格标题默认为该值）</p></li><li><p>匿名表格单元格元素（元素的 display 为 table、table-row、 table-row-group、table-header-group、table-footer-group（分别是HTML table、 row、tbody、thead、tfoot 的默认属性）或 inline-table）</p></li><li><p>overflow 计算值(Computed)不为 visible 的块元素</p></li><li><p>弹性元素（display 为 flex 或 inline-flex 元素的直接子元素）</p></li><li><p>网格元素（display 为 grid 或 inline-grid 元素的直接子元素）</p></li><li><p>display 值为 flow-root 的元素</p></li></ul><h4 id="3、BFC的作用"><a href="#3、BFC的作用" class="headerlink" title="3、BFC的作用"></a>3、BFC的作用</h4><p>作用：</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230327151603473.png" alt="image-20230327151603473"></p><p>其作用简单概况如下：</p><ul><li><p>在BFC中，box会在垂直方向上一个挨着一个的排布</p></li><li><p>垂直方向的间距由margin属性决定</p></li><li><p>在同一个BFC中，相邻两个box之间的margin会折叠（collapse）</p></li><li><p>在BFC中，每个元素的左边缘是紧挨着包含块的左边缘的</p></li></ul><p>那么这个东西有什么用呢？</p><ul><li><p>解决margin的折叠问题</p></li><li><p>解决浮动高度塌陷问题</p></li></ul><h5 id="1-解决margin折叠"><a href="#1-解决margin折叠" class="headerlink" title="1.解决margin折叠"></a>1.解决margin折叠</h5><p>在同一个BFC中，相邻两个box之间的margin会折叠（collapse）</p><p>官方文档明确的有说</p><p>The vertical distance between two sibling boxes is determined by the ‘margin’ properties. Vertical margins  between adjacent block-level boxes in a block formatting context collapse.</p><p>那么如果我们让两个box是不同的BFC呢？那么就可以解决折叠问题</p><h5 id="2-解决高度塌陷"><a href="#2-解决高度塌陷" class="headerlink" title="2.解决高度塌陷"></a>2.解决高度塌陷</h5><p>网上有很多说法，BFC可以解决浮动高度塌陷，可以实现清除浮动的效果</p><p>但是从来没有给出过BFC可以解决高度塌陷的原理或者权威的文档说明</p><p>他们也压根没有办法解释，为什么可以解决浮动高度的塌陷问题，但是不能解决绝对定位元素的高度塌陷问题呢？</p><p>事实上，BFC解决高度塌陷需要满足两个条件：</p><ul><li><p>浮动元素的父元素触发BFC，形成独立的块级格式化上下文（Block Formatting Context）</p></li><li><p>浮动元素的父元素的高度是auto的</p></li></ul><p>BFC的高度是auto的情况下，是如下方法计算高度的</p><ul><li><p>1.如果只有inline-level，是行高的顶部和底部的距离</p></li><li><p>2.如果有block-level，是由最底层的块上边缘和最底层 块盒子的下边缘之间的距离</p></li><li><p>3.如果有绝对定位元素，将被忽略</p></li><li><p>4.如果有浮动元素，那么会增加高度以包括这些浮动元素的下边缘</p></li></ul><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230327141545017.png" alt="image-20230327141545017"></p><h3 id="7、媒体查询"><a href="#7、媒体查询" class="headerlink" title="7、媒体查询"></a>7、媒体查询</h3><p>媒体查询是一种提供给开发者针对不同设备需求进行定制化开发的一个接口</p><p>你可以根据设备的类型（比如屏幕设备、打印机设备）或者特定的特性（比如屏幕的宽度）来修改你的页面</p><p>媒体查询的使用方式主要有三种：</p><p>方式一：通过@media和@import使用不同的CSS规则（常用）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式1</span></span><br><span class="line">@<span class="keyword">import</span> <span class="title function_">url</span>(./css/body_bgc.<span class="property">css</span>) (max-<span class="attr">width</span>: 800px);</span><br><span class="line"><span class="comment">// 方式2</span></span><br><span class="line">@media (max-<span class="attr">width</span>: 800px) &#123;</span><br><span class="line">    body &#123;</span><br><span class="line">        background-<span class="attr">color</span>: #0f0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方式二：使用media属性为<code>&lt;style&gt;</code>、<code>&lt;link&gt;</code>、<code>&lt;source</code>和其他HTML元素指定的媒体类型</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方式3</span></span><br><span class="line">&lt;link rel=<span class="string">&quot;stylesheet&quot;</span> media=<span class="string">&quot;(max-width: 800px)&quot;</span> href=<span class="string">&quot;./css/body_bgc.css&quot;</span>&gt;</span><br></pre></td></tr></table></figure><p>方式三：使用Window.matchMedia() 和MediaQueryList.addListener() 方法来测试和监控媒体状态</p><h4 id="1-媒体类型"><a href="#1-媒体类型" class="headerlink" title="1.媒体类型"></a>1.媒体类型</h4><p>在使用媒体查询时，你必须指定要使用的媒体类型</p><ul><li>媒体类型是可选的，并且会（隐式地）应用 all 类型</li></ul><p>常见的媒体类型值如下：</p><ul><li>all：适用于所有设备</li></ul><ul><li><p>print：适用于在打印预览模式下在屏幕上查看的分页材料和文档</p></li><li><p>screen（掌握）：主要用于屏幕</p></li><li><p>speech：主要用于语音合成器</p></li></ul><p>被废弃的媒体类型：</p><ul><li><p>CSS2.1 和 Media Queries 3 定义了一些额外的媒体类型(tty, tv, projection, handheld, braille, embossed, 以及 aural)</p></li><li><p>但是他们在Media Queries 4 中已经被废弃，并且不应该被使用</p></li><li><p>aural类型被替换为具有相似效果的speech</p></li></ul><h4 id="2-媒体特性"><a href="#2-媒体特性" class="headerlink" title="2.媒体特性"></a>2.媒体特性</h4><p>媒体特性（Media features）描述了 浏览器、输出设备，或是预览环境的具体特征</p><ul><li><p>通常会将媒体特性描述为一个表达式</p></li><li><p>每条媒体特性表达式都必须用括号括起来</p></li></ul><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230327144350254.png" alt="image-20230327144350254"></p><h4 id="3-逻辑操作符"><a href="#3-逻辑操作符" class="headerlink" title="3.逻辑操作符"></a>3.逻辑操作符</h4><p>媒体查询的表达式最终会获得一个Boolean值，也就是真（true）或者假（false）</p><p>如果结果为真（true），那么就会生效</p><p>如果结果为假（false），那么就不会生效</p><p>如果有多个条件，我们可以通过逻辑操作符联合复杂的媒体查询： </p><ul><li>and：and 操作符用于将多个媒体查询规则组合成单条媒体查询</li><li>not：not运算符用于否定媒体查询，如果不满足这个条件则返回true，否则返回false</li><li>only：only运算符仅在整个查询匹配时才用于应用样式</li><li>, (逗号)：逗号用于将多个媒体查询合并为一个规则</li></ul><p>常见的移动端设备：</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230327152232222.png" alt="image-20230327152232222"></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">@media (min-<span class="attr">width</span>: 320px) and (max-<span class="attr">width</span>:375px) &#123;</span><br><span class="line">    .<span class="property">box</span> &#123; font-<span class="attr">size</span>: 15px; &#125;</span><br><span class="line">&#125;</span><br><span class="line">@media (min-<span class="attr">width</span>: 375px) and (max-<span class="attr">width</span>:414px) &#123;</span><br><span class="line">    .<span class="property">box</span> &#123; font-<span class="attr">size</span>: 18px; &#125;</span><br><span class="line">&#125;</span><br><span class="line">@media (min-<span class="attr">width</span>: 414px) and (max-<span class="attr">width</span>:480px) &#123;</span><br><span class="line">    .<span class="property">box</span> &#123; font-<span class="attr">size</span>: 21px; &#125;</span><br><span class="line">&#125;</span><br><span class="line">@media (min-<span class="attr">width</span>: 480px) &#123;</span><br><span class="line">    .<span class="property">box</span> &#123; font-<span class="attr">size</span>: 24px; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="15-额外知识补充二"><a href="#15-额外知识补充二" class="headerlink" title="15.额外知识补充二"></a>15.额外知识补充二</h2><h3 id="1、CSS中的单位"><a href="#1、CSS中的单位" class="headerlink" title="1、CSS中的单位"></a>1、CSS中的单位</h3><p>px是一个长度（length）单位，事实上CSS中还有非常多的长度单位</p><p>整体可以分成两类：</p><ul><li><p>绝对长度单位（Absolute length units）</p></li><li><p>相对长度单位（Relative length units）</p></li></ul><h4 id="1-绝对单位"><a href="#1-绝对单位" class="headerlink" title="1.绝对单位"></a>1.绝对单位</h4><p>它们与其他任何东西都没有关系，通常被认为总是相同的大小</p><p>这些值中的大多数在用于打印时比用于屏幕输出时更有用，例如，我们通常不会在屏幕上使用cm</p><p>唯一一个经常使用的值，就是px(像素)</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230327154240579.png" alt="image-20230327154240579"></p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230327154805615.png" alt="image-20230327154805615"></p><h4 id="2-相对单位"><a href="#2-相对单位" class="headerlink" title="2.相对单位"></a>2.相对单位</h4><p>相对长度单位相对于其他一些东西</p><p>比如父元素的字体大小，或者视图端口的大小</p><p>使用相对单位的好处是经过一些仔细的规划，可以使文本或其他元素的大小与页面上的其他内容相对应</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230327154928680.png" alt="image-20230327154928680"></p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230327154942985.png" alt="image-20230327154942985"></p><h3 id="2、深入理解pixel、DPR、PPI"><a href="#2、深入理解pixel、DPR、PPI" class="headerlink" title="2、深入理解pixel、DPR、PPI"></a>2、深入理解pixel、DPR、PPI</h3><h4 id="1-pixel"><a href="#1-pixel" class="headerlink" title="1.pixel"></a>1.pixel</h4><p>前面我们已经一直在使用px单位了，px是pixel单词的缩写，翻译为像素</p><p>像素是影响显示的基本单位。（比如屏幕上看到的画面、一幅图片）</p><p>pix是英语单词picture的常用简写，加上英语单词“元素”element，就得到pixel</p><p>“像素”表示“画像元素”之意，有时亦被称为pel（picture element）</p><p>像素的分类</p><p>但是这个100个pixel到底是多少呢？</p><ul><li><p>我们确实可以在屏幕上看到一个大小，但是这个大小代表的真实含义是什么呢？</p></li><li><p>我们经常说一个电脑的分辨率、手机的分辨率，这个CSS当中的像素又是什么关系呢？</p></li></ul><p>这里我们要深入到不同的像素概念中，来理解CSS中的pixel到底代表什么含义</p><p>像素单位常见的有三种像素名称：</p><ul><li><p>设备像素（也称之为物理像素）</p></li><li><p>设备独立像素（也称之为逻辑像素）</p></li></ul><ul><li>CSS像素</li></ul><p>设备像素，也叫物理像素</p><ul><li><p>设备像素指的是显示器上的真实像素，每个像素的大小是屏幕固有的属性，屏幕出厂以后就不会改变了</p></li><li><p>我们在购买显示器或者手机的时候，提到的设备分辨率就是设备像素的大小</p></li><li><p>比如iPhone X的分辨率 1125x2436，指的就是设备像素</p></li></ul><p>设备独立像素，也叫逻辑像素</p><ul><li>如果面向开发者我们使用设备像素显示一个100px的宽度，那么在不同屏幕上显示效果会是不同的</li></ul><ul><li><p>开发者针对不同的屏幕很难进行较好的适配，编写程序必须了解用户的分辨率来进行开发</p></li><li><p>所以在设备像素之上，操作系统为开发者进行抽象，提供了逻辑像素的概念</p></li><li><p>比如你购买了一台显示器，在操作系统上是以1920x1080设置的显示分辨率，那么无论你购买的是2k、4k的显示器，对于开发者来说，都是 1920x1080的大小</p></li></ul><p>CSS像素</p><ul><li><p>CSS中我们经常使用的单位也是pixel，它在默认情况下等同于设备独立像素（也就是逻辑像素）</p></li><li><p>毕竟逻辑像素才是面向我们开发者的</p></li></ul><p>我们可以通过JavaScript中的 screen.width 和 screen.height 获取到电脑的逻辑分辨率</p><h4 id="2-DPR、PPI"><a href="#2-DPR、PPI" class="headerlink" title="2.DPR、PPI"></a>2.DPR、PPI</h4><p>DPR：device pixel ratio</p><p>2010年，iPhone4问世，不仅仅带来了移动互联网，还带来了Retina屏幕</p><p>Retina屏幕翻译为视网膜显示屏，可以为用户带来更好的显示</p><p>在Retina屏幕中，一个逻辑像素在长度上对应两个物理像素，这个比例称之为设备像素比（device pixel ratio）</p><p>我们可以通过window.devicePixelRatio获取到当前屏幕上的DPR值</p><p>PPI（了解）：每英寸像素（英语：Pixels Per Inch，缩写：PPI）</p><p>通常用来表示一个打印图像或者显示器上像素的密度</p><p>前面我们提过1英寸&#x3D;2.54厘米（大概为96px&#x2F;逻辑像素），在工业领域被广泛应用</p><h3 id="3、预处理器"><a href="#3、预处理器" class="headerlink" title="3、预处理器"></a>3、预处理器</h3><h4 id="1-css编写的痛点"><a href="#1-css编写的痛点" class="headerlink" title="1.css编写的痛点"></a>1.css编写的痛点</h4><p>CSS作为一种样式语言, 本身用来给HTML元素添加样式是没有问题的</p><p>但是目前前端项目已经越来越复杂，不再是简简单单的几行CSS就可以搞定的，我们需要几千行甚至上万行的CSS来完成页面的美化工作</p><p>随着代码量的增加, 必然会造成很多的编写不便：</p><ul><li><p>比如大量的重复代码, 虽然可以用类来勉强管理和抽取, 但是使用起来依然不方便</p></li><li><p>比如无法定义变量（当然目前已经支持）, 如果一个值被修改, 那么需要修改大量代码, 可维护性很差(比如主题颜色)</p></li><li><p>比如没有专门的作用域和嵌套, 需要定义大量的id&#x2F;class来保证选择器的准确性, 避免样式混淆</p></li></ul><p>所以有一种对CSS称呼是 “面向命名编程”</p><p>社区为了解决CSS面临的大量问题, 出现了一系列的CSS预处理器(CSS_preprocessor)</p><ul><li>CSS 预处理器是一个能让你通过预处理器自己独有的语法来生成CSS的程序</li><li>市面上有很多CSS预处理器可供选择，且绝大多数CSS预处理器会增加一些原生CSS不具备的特性</li><li>代码最终会转化为CSS来运行, 因为对于浏览器来说只识别CSS</li></ul><h4 id="2-常见的三种预处理器"><a href="#2-常见的三种预处理器" class="headerlink" title="2.常见的三种预处理器"></a>2.常见的三种预处理器</h4><p>Sass&#x2F;Scss：</p><ul><li>2007年诞生，最早也是最成熟的CSS预处理器，拥有ruby社区的支持，是属于Haml（一种模板系统）的一部分</li><li>目前受LESS影响，已经进化到了全面兼容CSS的SCSS</li></ul><p>Less：</p><ul><li>2009年出现，受SASS的影响较大，但又使用CSS的语法，让大部分开发者更容易上手</li><li>比起SASS来，可编程功能不够，不过优点是使用方式简单、便捷，兼容CSS，并且已经足够使用</li><li>另外反过来也影响了SASS演变到了SCSS的时代</li><li>著名的Twitter Bootstrap就是采用LESS做底层语言的，也包括 React 的 UI 框架 AntDesign</li></ul><p>Stylus：</p><ul><li>2010年产生，来自Node.js社区，主要用来给Node项目进行CSS预处理支持</li><li>语法偏向于Python, 使用率相对于Sass&#x2F;Less少很多</li></ul><h4 id="3-less"><a href="#3-less" class="headerlink" title="3.less"></a>3.less</h4><p>It’s CSS, with just a little more</p><p>Less （Leaner Style Sheets 的缩写） 是一门CSS 扩展语言, 并且兼容CSS</p><ul><li><p>Less增加了很多相比于CSS更好用的特性</p></li><li><p>比如定义变量、混入、嵌套、计算等等</p></li><li><p>Less最终需要被编译成CSS运行于浏览器中（包括部署到服务器中）</p></li></ul><h5 id="1-less-代码的编译"><a href="#1-less-代码的编译" class="headerlink" title="1.less 代码的编译"></a>1.less 代码的编译</h5><p>方式一：下载Node环境，通过npm包管理下载less工具，使用less工具对代码进行编译</p><p>方法二：通过VSCode插件（easy less）来编译成CSS或者在线编译：<a href="https://lesscss.org/less-preview/">https://lesscss.org/less-preview/</a></p><p>方式三：引入CDN的less编译代码，对less进行实时的处理</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;link rel=<span class="string">&quot;stylesheet/less&quot;</span> href=<span class="string">&quot;./less/01-less的基本使用.less&quot;</span>&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/less@4&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>方式四：将less编译的js代码下载到本地，执行js代码对less进行编译</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;link rel=<span class="string">&quot;stylesheet/less&quot;</span> href=<span class="string">&quot;./less/01-less的基本使用.less&quot;</span>&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./js/lessc.js&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h5 id="2-less语法"><a href="#2-less语法" class="headerlink" title="2.less语法"></a>2.less语法</h5><p><strong>Less语法一：兼容</strong></p><p>Less是兼容CSS的</p><ul><li>所以我们可以在Less文件中编写所有的CSS代码</li></ul><ul><li>只是将css的扩展名改成了.less结尾而已</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 兼容 css 代码</span></span><br><span class="line">.<span class="property">box</span> &#123;</span><br><span class="line">   <span class="attr">width</span>: 100px;</span><br><span class="line">   <span class="attr">height</span>: 100px;</span><br><span class="line">   background-<span class="attr">color</span>: orange;</span><br><span class="line">   font-<span class="attr">size</span>: 20px;</span><br><span class="line">   <span class="attr">color</span>: white;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>less语法二：变量</strong></p><p>在一个大型的网页项目中，我们CSS使用到的某几种属性值往往是特定的</p><ul><li>比如我们使用到的主题颜色值，那么每次编写类似于#f3c258格式的语法</li><li>一方面是记忆不太方便，需要重新编写或者拷贝样式</li><li>另一方面如果有一天主题颜色改变，我们需要修改大量的代码</li><li>所以，我们可以将常见的颜色或者字体等定义为变量来使用</li></ul><p>在Less中使用如下的格式来定义变量：</p><p>@变量名: 变量值;</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义变量</span></span><br><span class="line">@<span class="attr">mainColor</span>: #0f0;</span><br><span class="line">@<span class="attr">mainFontSize</span>: 15px;</span><br><span class="line">@<span class="attr">smallFontSize</span>: 12px;</span><br><span class="line">@<span class="attr">bigFontSize</span>: 20px;</span><br><span class="line"></span><br><span class="line">.<span class="property">box</span> .<span class="property">pel</span> &#123;</span><br><span class="line">  background-<span class="attr">color</span>: @mainColor;</span><br><span class="line">  font-<span class="attr">size</span>: @smallFontSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>less语法三：嵌套</strong></p><p>在之前的项目中，当我们需要找到一个内层的元素时，往往需要嵌套很多层的选择器</p><p>Less提供了选择器的嵌套</p><p>特殊符号：&amp; 表示当前选择器的父级</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 选择器的嵌套</span></span><br><span class="line">.<span class="property">box</span> &#123;</span><br><span class="line">  .<span class="property">pel</span> &#123;</span><br><span class="line">    <span class="attr">color</span>: @mainColor;</span><br><span class="line">    font-<span class="attr">size</span>: @mainFontSize;</span><br><span class="line">  &#125;</span><br><span class="line">  h1 &#123;</span><br><span class="line">    .<span class="property">keyword</span> &#123;</span><br><span class="line">      <span class="attr">color</span>: @mainColor;</span><br><span class="line">      font-<span class="attr">size</span>: @bigFontSize;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  p &#123;</span><br><span class="line">    a.<span class="property">link</span> &#123;</span><br><span class="line">      <span class="attr">color</span>: @mainColor;</span><br><span class="line">      font-<span class="attr">size</span>: @smallFontSize;</span><br><span class="line">        </span><br><span class="line">      &amp;:hover &#123;</span><br><span class="line">        <span class="attr">color</span>: blue;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>less语法四：运算</strong></p><p>在Less中，算术运算符 +、-、 * 、&#x2F; 可以对任何数字、颜色或变量进行运算</p><ul><li>算术运算符在加、减或比较之前会进行单位换算，计算的结果以最左侧操作数的单位类型为准</li></ul><ul><li>如果单位换算无效或失去意义，则忽略单位</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">.<span class="property">box</span> &#123;</span><br><span class="line">  font-<span class="attr">size</span>: 20px;</span><br><span class="line">  <span class="attr">width</span>: <span class="number">10</span>% + 50px;  <span class="comment">// 60%</span></span><br><span class="line">  <span class="attr">height</span>: 100px;</span><br><span class="line">  background-<span class="attr">color</span>: #ff0000 + #00ff00;  <span class="comment">//#ffff00</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>less语法五：混入（Mixins）</strong></p><p>在原来的CSS编写过程中，多个选择器中可能会有大量相同的代码</p><ul><li><p>我们希望可以将这些代码进行抽取到一个独立的地方，任何选择器都可以进行复用</p></li><li><p>在less中提供了混入（Mixins）来帮助我们完成这样的操作</p></li></ul><p>混合（Mixin）是一种将一组属性从一个规则集（或混入）到另一个规则集的方法</p><p>注意：混入在没有参数的情况下，小括号可以省略，但是不建议这样使用</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2.1 混入的基本使用</span></span><br><span class="line">.<span class="property">nowrap_ellipsis</span> &#123;</span><br><span class="line">  white-<span class="attr">space</span>: nowrap;</span><br><span class="line">  text-<span class="attr">overflow</span>: ellipsis;</span><br><span class="line">  <span class="attr">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.<span class="property">box1</span> &#123;</span><br><span class="line">  <span class="attr">width</span>: 200px;</span><br><span class="line">  background-<span class="attr">color</span>: orange;</span><br><span class="line"></span><br><span class="line">  .<span class="title function_">nowrap_ellipsis</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>混入也可以传入变量</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2.2混入是可以传递参数（定义变量）的</span></span><br><span class="line">.<span class="title function_">box_border</span>(<span class="params">@borderWidth: 5px, @borderColor: green</span>) &#123;</span><br><span class="line">  <span class="attr">border</span>: @borderWidth solid @borderColor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.<span class="property">box2</span> &#123;</span><br><span class="line">  <span class="attr">width</span>: 150px;</span><br><span class="line">  background-<span class="attr">color</span>: #f00;</span><br><span class="line"></span><br><span class="line">  .<span class="title function_">nowrap_ellipsis</span>();</span><br><span class="line">  .<span class="title function_">box_border</span>(10px, yellow);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>less语法六：映射</strong></p><p>混入和映射结合：混入也可以当做一个自定义函数来使用</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2.3 混入和映射（Map）结合使用</span></span><br><span class="line"><span class="comment">// 作用：弥补less中不能自定义函数的缺陷</span></span><br><span class="line">.<span class="property">box_size</span> &#123;</span><br><span class="line">  <span class="attr">width</span>: 200px;</span><br><span class="line">  <span class="attr">height</span>: 150px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.<span class="property">box1</span> &#123;</span><br><span class="line">  <span class="attr">width</span>: .<span class="title function_">box_size</span>()[width];</span><br><span class="line">  background-<span class="attr">color</span>: orange;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单位转换：</p><p><img src="C:\Users\王邦辉\AppData\Roaming\Typora\typora-user-images\image-20230327211450716.png" alt="image-20230327211450716"></p><p><strong>less语法七：extend继承</strong></p><p>和mixins作用类似，用于复用代码</p><p>和mixins相比，继承代码最终会转化成并集选择器</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.box_border &#123;</span><br><span class="line">  border: 5px solid red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.box &#123;</span><br><span class="line">  width: 100px;</span><br><span class="line">  background-color: orange;</span><br><span class="line"></span><br><span class="line">  // .box_border();</span><br><span class="line">  &amp;:extend(.box_border);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Less语法八：Less内置函数</strong></p><p>Less 内置了多种函数用于转换颜色、处理字符串、算术运算等</p><p>内置函数手册：<a href="https://less.bootcss.com/functions/">https://less.bootcss.com/functions/</a></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">.<span class="property">box</span> &#123;</span><br><span class="line">  <span class="attr">color</span>: <span class="title function_">color</span>(skyblue);  <span class="comment">// 转化为16进制编码</span></span><br><span class="line">  <span class="attr">width</span>: <span class="title function_">convert</span>(100px, <span class="string">&quot;in&quot;</span>);  <span class="comment">// px转化为in</span></span><br><span class="line">  font-<span class="attr">size</span>: <span class="title function_">ceil</span>(<span class="number">18.</span>5px);  <span class="comment">// 向上取整</span></span><br><span class="line">  background-<span class="attr">color</span>: orange;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Less语法九：作用域（Scope）</strong></p><p>在查找一个变量时，首先在本地查找变量和混合（mixins）</p><p>如果找不到，则从“父”级作用域继承</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">@<span class="attr">mainColor</span>:#f00;</span><br><span class="line"></span><br><span class="line">.<span class="property">box_mixin</span> &#123;</span><br><span class="line">  @<span class="attr">mainColor</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line">.<span class="property">box</span> &#123;</span><br><span class="line">  <span class="comment">// @mainColor:#0f0;</span></span><br><span class="line">  .<span class="property">item</span> &#123;</span><br><span class="line">    span &#123;</span><br><span class="line">      <span class="attr">color</span>: @mainColor;  <span class="comment">// yellow</span></span><br><span class="line">      .<span class="title function_">box_mixin</span>()</span><br><span class="line">      <span class="comment">// @mainColor:#00f;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Less语法十：注释（Comments）</strong></p><p>在Less中，块注释和行注释都可以使用</p><p><strong>Less语法十一：导入（Importing）</strong></p><ul><li><p>导入的方式和CSS的用法是一致的</p></li><li><p>导入一个 .less 文件，此文件中的所有变量就可以全部使用了</p></li><li><p>如果导入的文件是 .less 扩展名，则可以将扩展名省略掉</p></li></ul><h3 id="4、认识Sass和Scss"><a href="#4、认识Sass和Scss" class="headerlink" title="4、认识Sass和Scss"></a>4、认识Sass和Scss</h3><p>事实上，最初Sass 是Haml的一部分，Haml 是一种模板系统，由 Ruby 开发者设计和开发</p><p>所以，Sass的语法使用的是类似于Ruby的语法，没有花括号，没有分号，具有严格的缩进</p><p>它的语法和CSS区别很大，后来官方推出了全新的语法SCSS，意思是Sassy CSS，完全兼容CSS的</p><p>SCSS的语法也包括变量、嵌套、混入、函数、操作符、作用域等</p><p>通常也包括更为强大的控制语句、更灵活的函数、插值语法等</p><p><a href="https://sass-lang.com/guide">https://sass-lang.com/guide</a></p><h3 id="5、移动端适配"><a href="#5、移动端适配" class="headerlink" title="5、移动端适配"></a>5、移动端适配</h3><p>移动端开发目前主要包括三类：</p><ul><li><p>原生App开发（iOS、Android、RN、uniapp、Flutter等）</p></li><li><p>小程序开发（原生小程序、uniapp、Taro等）</p></li><li><p>Web页面（移动端的Web页面，可以使用浏览器或者webview浏览）</p></li></ul><p>因为目前移动端设备较多，所以我们需要对其进行一些适配</p><p>这里有两个概念：</p><ul><li><p>自适应：根据不同的设备屏幕大小来自动调整尺寸、大小</p></li><li><p>响应式：会随着屏幕的实时变动而自动调整，是一种自适应</p></li></ul><h4 id="1-视口"><a href="#1-视口" class="headerlink" title="1.视口"></a>1.视口</h4><p>在前面我们已经简单了解过视口的概念了：</p><ul><li><p>在一个浏览器中，我们可以看到的区域就是视口（viewport）</p></li><li><p>fixed就是相对于视口来进行定位的</p></li><li><p>在PC端的页面中，是不需要对视口进行区分，因为我们的布局视口和视觉视口是同一个</p></li></ul><p>但是在移动端不太一样，布局的视口和可见的视口是不太一样的</p><p>这是因为移动端的网页窗口往往比较小，我们可能会希望一个大的网页在移动端可以完整的显示，所以在默认情况下，移动端的布局视口是大于视觉视口的</p><p>在移动端，我们可以将视口划分为三种情况：</p><ul><li><p>布局视口（layout viewport）</p></li><li><p>视觉视口（visual layout）</p></li><li><p>理想视口（ideal layout）</p></li></ul><p>这些概念的区分，来自于ppk：<a href="https://www.quirksmode.org/mobile/viewports2.html">https://www.quirksmode.org/mobile/viewports2.html</a></p><p>布局视口</p><p>默认情况下，一个在PC端的网页在移动端的显示：</p><ul><li><p>第一，它会按照宽度为980px来布局一个页面的盒子和内容</p></li><li><p>第二，为了在移动端可以完整的显示页面，会对整个页面进行缩小</p></li></ul><p>我们相对于980px布局的这个视口，称之为布局视口（layout  viewport）</p><ul><li>布局视口的默认宽度是980px</li></ul><p>视觉视口</p><ul><li><p>如果默认情况下，我们按照980px显示内容，那么右侧有一部分区域就会无法显示，所以手机端浏览器会默认对页面进行缩放以显示到用户的可见区域中</p></li><li><p>那么显示在可见区域的这个视口，就是视觉视口（visual viewport）</p></li></ul><p>如果所有的网页都按照980px在移动端布局，那么最终页面都会被缩放显示</p><p>事实上这种方式是不利于我们进行移动的开发的，我们希望的是设置100px，那么显示的就是100px；</p><p>如何做到这一点呢？通过设置理想视口（ideal viewport）</p><p>理想视口</p><ul><li><p>默认情况下的layout viewport并不适合我们进行布局</p></li><li><p>我们可以对layout viewport进行宽度和缩放的设置，以满足正常在一个移动端窗口的布局</p></li><li><p>这个时候可以设置meta中的viewport</p></li></ul><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230328092425280.png" alt="image-20230328092425280"></p><h4 id="2-移动适配方案"><a href="#2-移动适配方案" class="headerlink" title="2.移动适配方案"></a>2.移动适配方案</h4><p>移动端的屏幕尺寸通常是非常繁多的，很多时候我们希望在不同的屏幕尺寸上显示不同的大小</p><p>比如我们设置一个100x100的盒子</p><ul><li><p>在375px的屏幕上显示是100x100</p></li><li><p>在320px的屏幕上显示是90x90</p></li><li><p>在414px的屏幕上显示是100x100</p></li></ul><p>其他尺寸也是类似，比如padding、margin、border、left，甚至是font-size等</p><p>这个时候，我们可能可以想到一些方案来处理尺寸：</p><ul><li><p>方案一：百分比设置</p><ul><li>因为不同属性的百分比值，相对的可能是不同参照物，所以百分比往往很难统一</li><li>所以百分比在移动端适配中使用是非常少的</li></ul></li><li><p>方案二：rem单位+动态html的font-size</p></li><li><p>方案三：vw单位</p></li><li><p>方案四：flex的弹性布局</p></li></ul><h5 id="方案二："><a href="#方案二：" class="headerlink" title="方案二："></a>方案二：</h5><p>rem单位是相对于html元素的font-size来设置的，那么如果我们需要在不同的屏幕下有不同的尺寸，可以动态的修改html的 font-size尺寸</p><p>比如如下案例：</p><ul><li><p>1.设置一个盒子的宽度是2rem</p></li><li><p>2.设置不同的屏幕上html的font-size不同</p></li></ul><p>这样在开发中，我们只需要考虑两个问题：</p><ul><li>问题一：针对不同的屏幕，设置html不同的font-size</li><li>问题二：将原来要设置的尺寸，转化成rem单位</li></ul><h6 id="动态改变font-size"><a href="#动态改变font-size" class="headerlink" title="动态改变font-size"></a>动态改变font-size</h6><p>方案一：媒体查询</p><ul><li>可以通过媒体查询来设置不同尺寸范围内的屏幕html的font-size尺寸</li><li>缺点：<ul><li>1.我们需要针对不同的屏幕编写大量的媒体查询</li><li>2.如果动态改变尺寸，不会实时的进行更新</li></ul></li></ul><p>方案二：编写js代码</p><ul><li><p>如果希望实时改变屏幕尺寸时，font-size也可以实时更改，可以通过js代码</p></li><li><p>方法：</p><ul><li>1.根据html的宽度计算出font-size的大小，并且设置到html上</li><li>2.监听页面的实时改变，并且重新设置font-size的大小到html上</li></ul></li></ul><p>方案三：lib-flexible库</p><ul><li>事实上，lib-flexible库做的事情是相同的，你也可以直接引入它</li></ul><h6 id="rem计算"><a href="#rem计算" class="headerlink" title="rem计算"></a>rem计算</h6><p>方案一：手动换算</p><p>比如有一个在375px屏幕上，100px宽度和高度的盒子</p><p>我们需要将100px转成对应的rem值</p><p>100&#x2F;37.5&#x3D;2.6667，其他也是相同的方法计算即可</p><p>方案二：less&#x2F;scss函数</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">.<span class="title function_">pxToRem</span>(<span class="params">@px</span>) &#123;</span><br><span class="line">  <span class="attr">result</span>: 1rem * (@px / <span class="number">37.5</span>);</span><br><span class="line">&#125;</span><br><span class="line">.<span class="property">box</span> &#123;</span><br><span class="line">  <span class="attr">width</span>: .<span class="title function_">pxToRem</span>(<span class="number">100</span>)[result];</span><br><span class="line">  <span class="attr">height</span>: .<span class="title function_">pxToRem</span>(<span class="number">100</span>)[result];</span><br><span class="line">  background-<span class="attr">color</span>: orange;</span><br><span class="line">&#125;</span><br><span class="line">p &#123;</span><br><span class="line">  font-<span class="attr">size</span>: .<span class="title function_">pxToRem</span>(<span class="number">14</span>)[result];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方案三：postcss-pxtorem（后续学习）</p><ul><li>目前在前端的工程化开发中，我们可以借助于webpack的工具来完成自动的转化</li></ul><p>方案四：VSCode插件</p><ul><li>px to rem 的插件，在编写时自动转化</li></ul><h5 id="方案三：vw适配"><a href="#方案三：vw适配" class="headerlink" title="方案三：vw适配"></a>方案三：vw适配</h5><p>rem事实上是作为一种过渡的方案，它利用的也是vw的思想</p><p>前面不管是我们自己编写的js，还是flexible的源码</p><p>都是将1rem等同于设计稿的1&#x2F;10，在利用1rem计算相对于整个屏幕的尺寸大小</p><p>1vw刚好等于屏幕的1&#x2F;100</p><p>vw相比于rem的优势：</p><ul><li><p>优势一：不需要去计算html的font-size大小，也不需要给html设置这样一个font-size</p></li><li><p>优势二：不会因为设置html的font-size大小，而必须给body再设置一个font-size，防止继承</p></li><li><p>优势三：因为不依赖font-size的尺寸，所以不用担心某些原因html的font-size尺寸被篡改，页面尺寸混乱</p></li><li><p>优势四：vw相比于rem更加语义化，1vw刚才是1&#x2F;100的viewport的大小</p></li><li><p>优势五：可以具备rem之前所有的优点</p></li></ul><p>vw我们只面临一个问题，将尺寸换算成vw的单位即可</p><p>所以，目前相比于rem，更加推荐使用vw</p><p>vw的单位转换</p><p>方案一：手动换算</p><ul><li><p>比如有一个在375px屏幕上，100px宽度和高度的盒子</p></li><li><p>我们需要将100px转成对应的vw值</p></li><li><p>100&#x2F;3.75&#x3D;26.667，其他也是相同的方法计算即可</p></li></ul><p>方案二：less&#x2F;scss函数</p><p>方案三：postcss-px-to-viewport-8-plugin（后续学习）</p><ul><li>和rem一样，在前端的工程化开发中，可以借助于webpack的工具来完成自动的转化</li></ul><p>方案四：VSCode插件</p><ul><li>px to vw 的插件，在编写时自动转化</li></ul><h3 id="6、认识grid布局"><a href="#6、认识grid布局" class="headerlink" title="6、认识grid布局"></a>6、认识grid布局</h3><p>CSS为了进一步增强自己的布局能力，提供了grid布局</p><ul><li><p>CSS Grid Layout (又名“Grid”或 “CSS Grid”)是一种基于二维的布局系统</p></li><li><p>它更加强大，同时也更加复杂; .</p></li></ul><p>目前公司生产环境的项目基本都是使用flex布局为主，因为它兼容性比flex布局差一 些</p><p>Grid Container</p><ul><li>元素设置display 为grid的盒子</li></ul><p>Grid Item，单元格称之为grid cell</p><ul><li>grid container 的直接子项</li></ul><p>Grid Line</p><ul><li>构成网格结构的分割线</li><li>它们可以是垂直的(“列网格线”)或水平的(”行网格线”)</li></ul><p>Grid Track</p><ul><li>两条相邻网格线之间的空间</li><li>可以看成是网格的行或者列</li></ul><p>Grid Area</p><ul><li>由四条网格线包围的总空间</li><li>一个网格区域可以由任意数量的网格单元组成</li></ul><p><a href="https://css-tricks.com/snippets/css/complete-guide-grid/">https://Css-tricks.com/snippets/css/complete-guide-grid/</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IT前端 </tag>
            
            <tag> HTML </tag>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>站点简介</title>
      <link href="/archives/a8213f80.html"/>
      <url>/archives/a8213f80.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>大家好，欢迎来到我的个人blog，在这里我将会分享一些自己的学习笔记，主要分为前端体系、计算机网络、网络规划与设计、相关工具等，也会分享一些个人好用的网站，白嫖攻略，科学魔法等；如有需要，也欢迎私信进行分享交流~</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>

<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>数据结构与算法</title>
      <link href="/archives/0.html"/>
      <url>/archives/0.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="数据结构与算法结合-JavaScript"><a href="#数据结构与算法结合-JavaScript" class="headerlink" title="数据结构与算法结合 JavaScript"></a>数据结构与算法结合 JavaScript</h4><h4 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h4><p>数据结构与算法是什么？</p><p>数据结构：计算机存储、组织数据的方式，就像锅碗瓢盆。</p><p>算法：一系列解决问题的清晰指令，就像食谱。</p><p>程序 &#x3D; 数据结构 + 算法</p><p>数据结构为算法提供服务，算法围绕数据结构操作。</p><p>有序：栈、队列、链表</p><p>无需：集合、字典</p><p>树、堆、图</p><h4 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h4><h5 id="时间复杂度计算"><a href="#时间复杂度计算" class="headerlink" title="时间复杂度计算"></a>时间复杂度计算</h5><p>定性描述该算法的运行时间</p><h5 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h5><p>算法在运行过程中临时占用存储空间大小的量度</p><h4 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h4><h5 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h5><p>一个后进先出的数据结构</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> stack = [];</span><br><span class="line">stack.<span class="title function_">push</span>(<span class="number">1</span>);              <span class="comment">//[1]</span></span><br><span class="line">stack.<span class="title function_">push</span>(<span class="number">2</span>);              <span class="comment">//[1,2]</span></span><br><span class="line"><span class="keyword">const</span> item1 = stack.<span class="title function_">pop</span>();   <span class="comment">//[1]</span></span><br><span class="line"><span class="keyword">const</span> item2 = stack.<span class="title function_">pop</span>()    <span class="comment">//[]</span></span><br></pre></td></tr></table></figure><h5 id="栈的应用场景："><a href="#栈的应用场景：" class="headerlink" title="栈的应用场景："></a>栈的应用场景：</h5><p>需要后进先出的场景</p><p>比如：十进制转二进制、判断字符串的括号是否有效、函数调用堆栈…</p><p>例1: 判断括号是否有效：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isValid = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(s.<span class="property">length</span> % <span class="number">2</span> === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> stack = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i&lt;s.<span class="property">length</span>; i+=<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> c = s[i];</span><br><span class="line">        <span class="keyword">if</span>(c === <span class="string">&#x27;(&#x27;</span> || c===<span class="string">&#x27;&#123;&#x27;</span>|| c===<span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">            stack.<span class="title function_">push</span>(c);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> t = stack[stack.<span class="property">length</span> -<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(</span><br><span class="line">                (t === <span class="string">&#x27;(&#x27;</span> &amp;&amp; c ===<span class="string">&#x27;)&#x27;</span>) ||</span><br><span class="line">                (t === <span class="string">&#x27;&#123;&#x27;</span> &amp;&amp; c ===<span class="string">&#x27;&#125;&#x27;</span>) ||</span><br><span class="line">                (t === <span class="string">&#x27;[&#x27;</span> &amp;&amp; c ===<span class="string">&#x27;]&#x27;</span>)</span><br><span class="line">            )&#123;</span><br><span class="line">                stack.<span class="title function_">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.<span class="property">length</span> === <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>例2: 函数调用堆栈</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">func1</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line"><span class="title function_">func2</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">func2</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line"><span class="title function_">func3</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">func3</span> = (<span class="params"></span>) =&gt; &#123;&#125;</span><br><span class="line"><span class="title function_">func1</span>();</span><br></pre></td></tr></table></figure><h4 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h4><h5 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h5><p>一个先进先出的数据结构</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> queue = [];</span><br><span class="line">queue.<span class="title function_">push</span>(<span class="number">1</span>);   <span class="comment">//[1]</span></span><br><span class="line">queue.<span class="title function_">push</span>(<span class="number">2</span>);    <span class="comment">//[1,2]</span></span><br><span class="line"><span class="keyword">const</span> item1 = queue.<span class="title function_">shift</span>();  <span class="comment">//[2]</span></span><br><span class="line"><span class="keyword">const</span> item2 = queue.<span class="title function_">shift</span>();  <span class="comment">//[]</span></span><br></pre></td></tr></table></figure><h5 id="队列的应用场景"><a href="#队列的应用场景" class="headerlink" title="队列的应用场景"></a>队列的应用场景</h5><p>需要先进先出，保证有序性。</p><p>比如食堂买饭、js异步中的任务队列、计算最近请求次数。</p><p>例1：js异步中的任务队列</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>),<span class="number">0</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">先打印<span class="number">2</span> 再打印<span class="number">1</span></span><br></pre></td></tr></table></figure><p>例2:  计算最近请求次数</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">RecentCounter</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">q</span>=[];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">t</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">RecentCounter</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">ping</span> = <span class="keyword">function</span>(<span class="params">t</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">q</span>.<span class="title function_">push</span>(t);</span><br><span class="line">    <span class="keyword">while</span>(<span class="variable language_">this</span>.<span class="property">q</span>[<span class="number">0</span>] &lt; t-<span class="number">3000</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">q</span>.<span class="title function_">shift</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">q</span>.<span class="property">length</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your RecentCounter object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * var obj = new RecentCounter()</span></span><br><span class="line"><span class="comment"> * var param_1 = obj.ping(t)</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h4 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h4><h5 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h5><p>多个元素组成的列表</p><p>元素存储不连续，用 next 指针连在一起。</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20221011201543267.png" alt="image-20221011201543267"></p><h5 id="数组-vs-链表"><a href="#数组-vs-链表" class="headerlink" title="数组 vs 链表"></a>数组 vs 链表</h5><p>数组：增删非首尾元素时往往需要移动元素。</p><p>链表：增删非首尾元素，不需要移动元素，只需要更改 next 的指向即可。</p><p>javascript中没有链表，可以用object模仿。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;<span class="attr">val</span>:<span class="string">&#x27;a&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> b = &#123;<span class="attr">val</span>:<span class="string">&#x27;b&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> c = &#123;<span class="attr">val</span>:<span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> d = &#123;<span class="attr">val</span>:<span class="string">&#x27;d&#x27;</span>&#125;;</span><br><span class="line">a.<span class="property">next</span> = b;</span><br><span class="line">b.<span class="property">next</span> = c;</span><br><span class="line">c.<span class="property">next</span> = d;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历链表</span></span><br><span class="line"><span class="keyword">let</span> p = a;  <span class="comment">// 需声明一个指针指向表头</span></span><br><span class="line"><span class="keyword">while</span>(p)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">val</span>);</span><br><span class="line">p=p.<span class="property">next</span>;</span><br><span class="line">&#125;   <span class="comment">// a b c d</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入</span></span><br><span class="line"><span class="keyword">const</span> e = &#123;<span class="attr">val</span>:<span class="string">&#x27;e&#x27;</span>&#125;;</span><br><span class="line">c.<span class="property">next</span> = e;</span><br><span class="line">e.<span class="property">next</span> = d;    <span class="comment">// a b c e d</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除</span></span><br><span class="line">c.<span class="property">next</span> = d;</span><br></pre></td></tr></table></figure><p>反转链表（206）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">head</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">ListNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverseList = <span class="keyword">function</span>(<span class="params">head</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> p1 = head;</span><br><span class="line">    <span class="keyword">let</span> p2 = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(p1)&#123;</span><br><span class="line">        <span class="keyword">const</span> tmp = p1.<span class="property">next</span>;</span><br><span class="line">        p1.<span class="property">next</span> = p2;</span><br><span class="line">        p2=p1;</span><br><span class="line">        p1=p1.<span class="property">next</span>;</span><br><span class="line">        p1 = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>两数相加（2）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">l1</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">l2</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">ListNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> addTwoNumbers = <span class="keyword">function</span>(<span class="params">l1, l2</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> l3 = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> p1 = l1;</span><br><span class="line">    <span class="keyword">let</span> p2 = l2;</span><br><span class="line">    <span class="keyword">let</span> p3 = l3;</span><br><span class="line">    <span class="keyword">let</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p1 || p2)&#123;</span><br><span class="line">        <span class="keyword">const</span> v1 = p1 ? p1.<span class="property">val</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">const</span> v2 = p2 ? p2.<span class="property">val</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">const</span> val = v1 + v2 + carry;</span><br><span class="line">        carry = <span class="title class_">Math</span>.<span class="title function_">floor</span>(val/<span class="number">10</span>);</span><br><span class="line">        p3.<span class="property">next</span> = <span class="keyword">new</span> <span class="title class_">ListNode</span>(val % <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span>(p1) p1= p1.<span class="property">next</span>;</span><br><span class="line">        <span class="keyword">if</span>(p2) p2 = p2.<span class="property">next</span>;</span><br><span class="line">        p3 = p3.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(carry)&#123;</span><br><span class="line">        p3.<span class="property">next</span> = <span class="keyword">new</span> <span class="title class_">ListNode</span>(carry);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l3.<span class="property">next</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>删除排序链表中的重复元素（83）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">head</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">ListNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> deleteDuplicates = <span class="keyword">function</span>(<span class="params">head</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> p = head;</span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; p.<span class="property">next</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(p.<span class="property">val</span> === p.<span class="property">next</span>.<span class="property">val</span>) &#123;</span><br><span class="line">            p.<span class="property">next</span> = p.<span class="property">next</span>.<span class="property">next</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p = p.<span class="property">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>环形链表（141）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> * @param &#123;<span class="title class_">ListNode</span>&#125; head</span><br><span class="line"> * @<span class="keyword">return</span> &#123;boolean&#125;</span><br><span class="line"> */</span><br><span class="line"><span class="keyword">var</span> hasCycle = <span class="keyword">function</span>(<span class="params">head</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> p1 = head;  <span class="comment">// 快的指针</span></span><br><span class="line">    <span class="keyword">let</span> p2 = head;  <span class="comment">// 慢的指针</span></span><br><span class="line">    <span class="keyword">while</span>(p1 &amp;&amp; p2 &amp;&amp; p2.<span class="property">next</span>) &#123;</span><br><span class="line">        p1=p1.<span class="property">next</span>;</span><br><span class="line">        p2=p2.<span class="property">next</span>.<span class="property">next</span>;</span><br><span class="line">        <span class="keyword">if</span>(p1 === p2)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="前端与链表"><a href="#前端与链表" class="headerlink" title="前端与链表"></a>前端与链表</h5><h5 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h5><p>原型链的本质是链表。</p><p>原型链上的节点是各种原型对象，比如：Function。prototype、Object.prototype….</p><p>原型链通过_ proto_ 属性连接各种原型对象。（不是.next）</p><p>obj -&gt; Object.prototype -&gt; null</p><p>func -&gt; Function.prototype -&gt; Object.prototype -&gt; null</p><p>arr -&gt; Array.prototype -&gt; Object.prototype -&gt; null</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const obj = &#123;&#125;;</span><br><span class="line">const func = () =&gt; &#123;&#125;;</span><br><span class="line">const arr = [];</span><br></pre></td></tr></table></figure><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20221012152006352.png" alt="image-20221012152006352"></p><h5 id="原型链知识点"><a href="#原型链知识点" class="headerlink" title="原型链知识点"></a>原型链知识点</h5><p>如果 A 沿着原型链能找到 B.prototype，那么 A instanceof B 为true。</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20221012151915876.png" alt="image-20221012151915876"></p><p>如果在 A 对象上没有找到 x 属性，那么会沿着原型链找 x 属性。</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20221012152348319.png" alt="image-20221012152348319"></p><p>面试题1：instanceof 的原理，并用代码实现</p><p>知识点：如果A沿着原型链能找到 B.prototype，那么A instanceof B为 true。</p><p>解法：遍历A的原型链，如果找到 B.prototype，返回 true，否则返回 false。</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20221012153221227.png" alt="image-20221012153221227"></p><p>面试题2：</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20221012153435595.png" alt="image-20221012153435595"></p><p>知识点：如果在 A 对象上没有找到 x 属性，那么会沿着原型链找 x 属性。</p><p>解法：明确 foo 和 F 变量的原型链，沿着原型链找 a 属性和 b 属性。</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20221012153840827.png" alt="image-20221012153840827"></p><h5 id="使用链表指针获取-JSON-的节点值"><a href="#使用链表指针获取-JSON-的节点值" class="headerlink" title="使用链表指针获取 JSON 的节点值"></a>使用链表指针获取 JSON 的节点值</h5><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20221012154813607.png" alt="image-20221012154813607"></p><h5 id="技术要点"><a href="#技术要点" class="headerlink" title="技术要点"></a>技术要点</h5><p>链表里的元素存储不是连续的，之间通过 next 连接。</p><p>JavaScript 中没有链表，但可以用 Object 模拟链表。</p><p>链表常用操作：修改 next 、遍历链表。</p><h4 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h4><h5 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h5><p>一种无序且唯一的数据结构。</p><p>ES6中有集合，名为 set。</p><p>集合的常用操作：去重、判断某元素是否在集合中、求交集…</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20221012160819142.png" alt="image-20221012160819142"></p><p>两个数组的交集（349）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums1</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums2</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> intersection = <span class="keyword">function</span>(<span class="params">nums1, nums2</span>) &#123;</span><br><span class="line"><span class="comment">// return [...new Set(nums1)].filter(n =&gt; new Set(nums2).has(n))</span></span><br><span class="line">    <span class="keyword">return</span> [...<span class="keyword">new</span> <span class="title class_">Set</span>(nums1)].<span class="title function_">filter</span>(<span class="function"><span class="params">n</span> =&gt;</span> nums2.<span class="title function_">includes</span>(n))</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="set-操作"><a href="#set-操作" class="headerlink" title="set 操作"></a>set 操作</h5><p>使用 Set 对象：new、add、delete、has、size</p><p>迭代 Set：多种迭代方法、Set 与 Array 互转、求交集&#x2F;差集</p><p>add 方法</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20221012181036153.png" alt="image-20221012181036153"></p><p>has 方法</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20221012181331923.png" alt="image-20221012181331923"></p><p>delete 方法</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20221012181551547.png" alt="image-20221012181551547"></p><p>迭代对象：for_of 方法</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20221012181923579.png" alt="image-20221012181923579"></p><p>keys 方法</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20221012182037679.png" alt="image-20221012182037679"></p><p>value 方法</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20221012182110785.png" alt="image-20221012182110785"></p><p>entries 方法：key 和 value 的值是一样的。</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20221012182309636.png" alt="image-20221012182309636"></p><h5 id="set-和-arr-互转"><a href="#set-和-arr-互转" class="headerlink" title="set 和 arr 互转"></a>set 和 arr 互转</h5><p>set 转换为 arr：（1）</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20221012182518662.png" alt="image-20221012182518662"></p><p>（2）：Array 方法</p><p><img src="C:\Users\王邦辉\AppData\Roaming\Typora\typora-user-images\image-20221012182715677.png" alt="image-20221012182715677"></p><p>arr 转换为 set：</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20221012182949771.png" alt="image-20221012182949771"></p><h5 id="求交集和差集"><a href="#求交集和差集" class="headerlink" title="求交集和差集"></a>求交集和差集</h5><p>交集</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20221012183644381.png" alt="image-20221012183644381"></p><p>差集</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20221012183926481.png" alt="image-20221012183926481"></p><h5 id="技术要点-1"><a href="#技术要点-1" class="headerlink" title="技术要点"></a>技术要点</h5><p>集合是一种无序且唯一的数据结构。</p><p>ES6 中有集合，名为 Set。</p><h4 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h4><h5 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h5><p>与集合类似，字典也是一种存储唯一值的数据结构，但它是以键值对的形式来存储。</p><p>ES6 中有字典，名为 Map。</p><p>字典的常用操作：键值对的增删改查。</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20221012184824452.png" alt="image-20221012184824452"></p><p>删除</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20221012185106637.png" alt="image-20221012185106637"></p><p>改</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20221012185210902.png" alt="image-20221012185210902"></p><p>求数组交集（349）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> intersection = <span class="keyword">function</span>(<span class="params">nums1, nums2</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">    nums1.<span class="title function_">forEach</span>(<span class="function"><span class="params">n</span>=&gt;</span>&#123;</span><br><span class="line">    map.<span class="title function_">set</span>(n,<span class="literal">true</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">const</span> res = [];</span><br><span class="line">    nums2.<span class="title function_">forEach</span>(<span class="function"><span class="params">n</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(map.<span class="title function_">get</span>(n))&#123;</span><br><span class="line">    res.<span class="title function_">push</span>(n);</span><br><span class="line">    map.<span class="title function_">delete</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>有效地括号（优化）（20）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isValid = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(s.<span class="property">length</span> % <span class="number">2</span> === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> stack = [];</span><br><span class="line">    <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">    map.<span class="title function_">set</span>(<span class="string">&#x27;(&#x27;</span>,<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">    map.<span class="title function_">set</span>(<span class="string">&#x27;[&#x27;</span>,<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">    map.<span class="title function_">set</span>(<span class="string">&#x27;&#123;&#x27;</span>,<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i&lt;s.<span class="property">length</span>; i+=<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> c = s[i];</span><br><span class="line">        <span class="keyword">if</span>(map.<span class="title function_">has</span>(c)) &#123;</span><br><span class="line">            stack.<span class="title function_">push</span>(c);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> t = stack[stack.<span class="property">length</span> -<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(map.<span class="title function_">get</span>(t) === c)&#123;</span><br><span class="line">                stack.<span class="title function_">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.<span class="property">length</span> === <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>两数之和（1）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>无重复字符的最长子串（3）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> lengthOfLongestSubstring = <span class="keyword">function</span>(<span class="params">s</span>) &#123; <span class="comment">// 双指针滑动窗口</span></span><br><span class="line">    <span class="keyword">let</span> l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> r = <span class="number">0</span>; r&lt;s.<span class="property">length</span>;r++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(map.<span class="title function_">has</span>(s[r]) &amp;&amp; map.<span class="title function_">get</span>(s[r]) &gt;= l)&#123;</span><br><span class="line">            l = map.<span class="title function_">get</span>(s[r])+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="title class_">Math</span>.<span class="title function_">max</span>(res,r-l+<span class="number">1</span>);</span><br><span class="line">        map.<span class="title function_">set</span>(s[r],r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>最小覆盖子串（76）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">t</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">string</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> minWindow = <span class="keyword">function</span>(<span class="params">s, t</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span>(s.<span class="property">length</span> &lt; t.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> need = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> c <span class="keyword">of</span> t) &#123;</span><br><span class="line">        need.<span class="title function_">set</span>(c,need.<span class="title function_">has</span>(c) ? need.<span class="title function_">get</span>(c)+<span class="number">1</span> :<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> needType = need.<span class="property">size</span>;</span><br><span class="line">    <span class="keyword">while</span>(r &lt; s.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> c = s[r];</span><br><span class="line">        <span class="keyword">if</span>(need.<span class="title function_">has</span>(c))&#123;</span><br><span class="line">            need.<span class="title function_">set</span>(c,need.<span class="title function_">get</span>(c)-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(need.<span class="title function_">get</span>(c) === <span class="number">0</span>) needType--</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(needType === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> newRes = s.<span class="title function_">substring</span>(l,r+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(!res || newRes.<span class="property">length</span> &lt; res.<span class="property">length</span>) res=newRes</span><br><span class="line">            <span class="keyword">const</span>  c2 = s[l];</span><br><span class="line">            <span class="keyword">if</span>(need.<span class="title function_">has</span>(c2)) &#123;</span><br><span class="line">                need.<span class="title function_">set</span>(c2,need.<span class="title function_">get</span>(c2) + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(need.<span class="title function_">get</span>(c2) ===<span class="number">1</span>) needType++;</span><br><span class="line">            &#125;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        r++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="技术要点-2"><a href="#技术要点-2" class="headerlink" title="技术要点"></a>技术要点</h5><p>与集合类似，字典也是一种存储唯一值的数据结构， 但它是以键值对的形式来存储。</p><h4 id="第八章"><a href="#第八章" class="headerlink" title="第八章"></a>第八章</h4><h5 id="树"><a href="#树" class="headerlink" title="树"></a>树</h5><p>一种分层数据的抽象模型</p><p>前端工作中常见的树包括：DOM树、级联选择、树形控件……</p><p>JS中没有树，但是可以用Object和Array构建树</p><p>树的常用操作：深度&#x2F;广度优先遍历、先中后序遍历</p><h5 id="深度-x2F-广度优先遍历"><a href="#深度-x2F-广度优先遍历" class="headerlink" title="深度&#x2F;广度优先遍历"></a>深度&#x2F;广度优先遍历</h5><p>深度优先遍历：尽可能深的搜索树的分支（尽可能访问完每一个分支）</p><p>广度优先遍历：先访问离根节点最近的节点（每层每层的来）</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20221015183033642.png" alt="image-20221015183033642"></p><h5 id="深度优先遍历算法口诀（递归）"><a href="#深度优先遍历算法口诀（递归）" class="headerlink" title="深度优先遍历算法口诀（递归）"></a>深度优先遍历算法口诀（递归）</h5><p>（1）访问根节点</p><p>（2）对根节点的 children 挨个进行深度优先遍历</p><p>树节点：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> tree = &#123;</span><br><span class="line">  <span class="attr">val</span>:<span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">  <span class="attr">children</span>:[</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">val</span>:<span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">      <span class="attr">children</span>:[</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">val</span>:<span class="string">&#x27;d&#x27;</span>,</span><br><span class="line">          <span class="attr">children</span>:[]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">val</span>:<span class="string">&#x27;e&#x27;</span>,</span><br><span class="line">          <span class="attr">children</span>:[]</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">val</span>:<span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">      <span class="attr">children</span>:[</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">val</span>:<span class="string">&#x27;f&#x27;</span>,</span><br><span class="line">          <span class="attr">children</span>:[]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">val</span>:<span class="string">&#x27;g&#x27;</span>,</span><br><span class="line">          <span class="attr">children</span>:[]</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">dfs</span> = (<span class="params">root</span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(root.<span class="property">val</span>);</span><br><span class="line">  root.<span class="property">children</span>.<span class="title function_">forEach</span>(dfs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">dfs</span>(tree);</span><br></pre></td></tr></table></figure><h5 id="广度优先遍历算法口诀"><a href="#广度优先遍历算法口诀" class="headerlink" title="广度优先遍历算法口诀"></a>广度优先遍历算法口诀</h5><p>（1）新建一个队列，把根节点入队</p><p>（2）把队头出队并访问</p><p>（3）把队头的 children 挨个入队</p><p>（4）重复第二、三步，直到队列为空</p><p>代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">bfs</span> = (<span class="params">root</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> q = [root];</span><br><span class="line">  <span class="keyword">while</span>(q.<span class="property">length</span>&gt;<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> n = q.<span class="title function_">shift</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(n.<span class="property">val</span>);</span><br><span class="line">    n.<span class="property">children</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">child</span> =&gt;</span> &#123;</span><br><span class="line">      q.<span class="title function_">push</span>(child);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">bfs</span>(tree);</span><br></pre></td></tr></table></figure><h5 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h5><p>树中每个节点最多只能有两个子节点</p><p>在 JS 中通常用 Object 来模拟二叉树</p><h5 id="二叉树先序遍历算法口诀（递归）（根左右）"><a href="#二叉树先序遍历算法口诀（递归）（根左右）" class="headerlink" title="二叉树先序遍历算法口诀（递归）（根左右）"></a>二叉树先序遍历算法口诀（递归）（根左右）</h5><p>（1）访问根节点</p><p>（2）对根节点的左子树进行先序遍历</p><p>（3）对根节点的右子树进行先序遍历</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20221015185206420.png" alt="image-20221015185206420"></p><p>节点：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> bt = &#123;</span><br><span class="line">  <span class="attr">val</span>:<span class="number">1</span>,</span><br><span class="line">  <span class="attr">left</span>: &#123;</span><br><span class="line">    <span class="attr">val</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="attr">left</span>:&#123;</span><br><span class="line">      <span class="attr">val</span>:<span class="number">4</span>,</span><br><span class="line">      <span class="attr">left</span>:<span class="literal">null</span>,</span><br><span class="line">      <span class="attr">right</span>:<span class="literal">null</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">right</span>:&#123;</span><br><span class="line">      <span class="attr">val</span>:<span class="number">5</span>,</span><br><span class="line">      <span class="attr">left</span>:<span class="literal">null</span>,</span><br><span class="line">      <span class="attr">right</span>:<span class="literal">null</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">right</span>:&#123;</span><br><span class="line">    <span class="attr">val</span>:<span class="number">3</span>,</span><br><span class="line">    <span class="attr">left</span>:&#123;</span><br><span class="line">      <span class="attr">val</span>:<span class="number">6</span>,</span><br><span class="line">      <span class="attr">left</span>:<span class="literal">null</span>,</span><br><span class="line">      <span class="attr">right</span>:<span class="literal">null</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">right</span>:&#123;</span><br><span class="line">      <span class="attr">val</span>:<span class="number">7</span>,</span><br><span class="line">      <span class="attr">left</span>:<span class="literal">null</span>,</span><br><span class="line">      <span class="attr">right</span>:<span class="literal">null</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = bt;</span><br></pre></td></tr></table></figure><p>代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> bt = <span class="built_in">require</span>(<span class="string">&#x27;./bt&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">preorder</span> = (<span class="params">root</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span>(!root) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(root.<span class="property">val</span>);</span><br><span class="line">  <span class="title function_">preorder</span>(root.<span class="property">left</span>);</span><br><span class="line">  <span class="title function_">preorder</span>(root.<span class="property">right</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">preorder</span>(bt);</span><br></pre></td></tr></table></figure><h5 id="二叉树中序遍历算法口诀（递归）"><a href="#二叉树中序遍历算法口诀（递归）" class="headerlink" title="二叉树中序遍历算法口诀（递归）"></a>二叉树中序遍历算法口诀（递归）</h5><p>（1）对根节点的左子树进行中序遍历</p><p>（2）访问根节点</p><p>（3）对根节点的右子树进行中序遍历</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20221015193416827.png" alt="image-20221015193416827"></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> bt = <span class="built_in">require</span>(<span class="string">&#x27;./bt&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">inorder</span> = (<span class="params">root</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span>(!root) &#123;<span class="keyword">return</span>;&#125;</span><br><span class="line">  <span class="title function_">inorder</span>(root.<span class="property">left</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(root.<span class="property">val</span>);</span><br><span class="line">  <span class="title function_">inorder</span>(root.<span class="property">right</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">inorder</span>(bt);</span><br></pre></td></tr></table></figure><h5 id="二叉树后序遍历算法口诀（递归）（左右根）"><a href="#二叉树后序遍历算法口诀（递归）（左右根）" class="headerlink" title="二叉树后序遍历算法口诀（递归）（左右根）"></a>二叉树后序遍历算法口诀（递归）（左右根）</h5><p>（1）对根节点的左子树进行后序遍历</p><p>（2）对根节点的右子树进行后序遍历</p><p>（3）访问根节点</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20221016101116303.png" alt="image-20221016101116303"></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> bt = <span class="built_in">require</span>(<span class="string">&#x27;./bt&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">postorder</span> = (<span class="params">root</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span>(!root) &#123;<span class="keyword">return</span>;&#125;</span><br><span class="line">  <span class="title function_">postorder</span>(root.<span class="property">left</span>);</span><br><span class="line">  <span class="title function_">postorder</span>(root.<span class="property">right</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(root.<span class="property">val</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">postorder</span>(bt);</span><br></pre></td></tr></table></figure><h5 id="二叉树的先序遍历（非递归）"><a href="#二叉树的先序遍历（非递归）" class="headerlink" title="二叉树的先序遍历（非递归）"></a>二叉树的先序遍历（非递归）</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">preorder</span> = (<span class="params">root</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span>(!root) &#123;<span class="keyword">return</span>;&#125;</span><br><span class="line">  <span class="keyword">const</span> stack = [root];</span><br><span class="line">  <span class="keyword">while</span>(stack.<span class="property">length</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> n = stack.<span class="title function_">pop</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(n.<span class="property">val</span>);</span><br><span class="line">    <span class="keyword">if</span>(n.<span class="property">right</span>) stack.<span class="title function_">push</span>(n.<span class="property">right</span>);</span><br><span class="line">    <span class="keyword">if</span>(n.<span class="property">left</span>) stack.<span class="title function_">push</span>(n.<span class="property">left</span>);</span><br><span class="line">  &#125; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">preorder</span>(bt);</span><br></pre></td></tr></table></figure><h5 id="二叉树的中序遍历（非递归）"><a href="#二叉树的中序遍历（非递归）" class="headerlink" title="二叉树的中序遍历（非递归）"></a>二叉树的中序遍历（非递归）</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">inorder</span> = (<span class="params">root</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span>(!root) &#123;<span class="keyword">return</span>;&#125;</span><br><span class="line">  <span class="keyword">const</span> stack = [];</span><br><span class="line">  <span class="keyword">let</span> p = root;</span><br><span class="line">  <span class="keyword">while</span>(stack.<span class="property">length</span> || p) &#123;</span><br><span class="line">    <span class="keyword">while</span>(p) &#123;</span><br><span class="line">      stack.<span class="title function_">push</span>(p)</span><br><span class="line">      p = p.<span class="property">left</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> n = stack.<span class="title function_">pop</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(n.<span class="property">val</span>);</span><br><span class="line">    p = n.<span class="property">right</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">inorder</span>(bt);</span><br></pre></td></tr></table></figure><h5 id="二叉树的后序遍历（非递归）"><a href="#二叉树的后序遍历（非递归）" class="headerlink" title="二叉树的后序遍历（非递归）"></a>二叉树的后序遍历（非递归）</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">postorder</span> = (<span class="params">root</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span>(!root) &#123;<span class="keyword">return</span>;&#125;</span><br><span class="line">  <span class="keyword">const</span> stack = [root];</span><br><span class="line">  <span class="keyword">const</span> outputStack = [];</span><br><span class="line">  <span class="keyword">while</span>(stack.<span class="property">length</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> n = stack.<span class="title function_">pop</span>();</span><br><span class="line">    outputStack.<span class="title function_">push</span>(n)</span><br><span class="line">    <span class="keyword">if</span>(n.<span class="property">left</span>) stack.<span class="title function_">push</span>(n.<span class="property">left</span>);</span><br><span class="line">    <span class="keyword">if</span>(n.<span class="property">right</span>) stack.<span class="title function_">push</span>(n.<span class="property">right</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(outputStack.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> n = outputStack.<span class="title function_">pop</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(n.<span class="property">val</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">postorder</span>(bt);</span><br></pre></td></tr></table></figure><p>二叉树的最大深度（104）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxDepth = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">dfs</span> = (<span class="params">n,l</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span>(!n) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line">        <span class="keyword">if</span>(!n.<span class="property">left</span> &amp;&amp; !n.<span class="property">right</span>) &#123;</span><br><span class="line">            res = <span class="title class_">Math</span>.<span class="title function_">max</span>(res, l)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">dfs</span>(n.<span class="property">left</span>,l+<span class="number">1</span>);</span><br><span class="line">        <span class="title function_">dfs</span>(n.<span class="property">right</span>,l+<span class="number">1</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="title function_">dfs</span>(root,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>二叉树的最小深度（111）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IT前端 </tag>
            
            <tag> 算法 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git的基本使用</title>
      <link href="/archives/163a8691.html"/>
      <url>/archives/163a8691.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Github社区基本使用"><a href="#Github社区基本使用" class="headerlink" title="Github社区基本使用"></a>Github社区基本使用</h2><h3 id="Git基础概念"><a href="#Git基础概念" class="headerlink" title="Git基础概念"></a>Git基础概念</h3><h4 id="Git-的特性"><a href="#Git-的特性" class="headerlink" title="Git 的特性"></a>Git 的特性</h4><p>Git 是一个开源的分布式版本控制系统，是目前世界上最先进、最流行的版本控制系统。可以快速高效地处理从很小到非常大的项目版本管理。</p><p>特点：项目越大越复杂，协同开发者越多，越能体现出 Git 的高性能和高可用性！</p><h5 id="Git-之所以快速和高效，主要依赖于它的如下两个特性："><a href="#Git-之所以快速和高效，主要依赖于它的如下两个特性：" class="headerlink" title="Git 之所以快速和高效，主要依赖于它的如下两个特性："></a>Git 之所以快速和高效，主要依赖于它的如下两个特性：</h5><p>①直接记录快照，而非差异比较</p><p>②近乎所有操作都是本地执行</p><h5 id="SVN-的差异比较"><a href="#SVN-的差异比较" class="headerlink" title="SVN 的差异比较"></a>SVN 的差异比较</h5><p>传统的版本控制系统（例如 SVN）是基于差异的版本控制，它们存储的是一组基本文件和每个文件随时间逐步累积的差异。</p><p>好处：节省磁盘空间</p><p>缺点：耗时、效率低</p><p>​在每次切换版本的时候，都需要在基本文件的基础上，应用每个差异，从而生成目标版本对应的文件。</p><p><strong>Git</strong> <strong>的记录快照</strong></p><p>Git 快照是在原有文件版本的基础上重新生成一份新的文件，类似于备份。为了效率，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。</p><p>缺点：占用磁盘空间较大</p><p>优点：版本切换时非常快，因为每个版本都是完整的文件快照，切换版本时直接恢复目标版本的快照即可。</p><p>特点：空间换时间</p><h5 id="近乎所有操作都是本地执行"><a href="#近乎所有操作都是本地执行" class="headerlink" title="近乎所有操作都是本地执行"></a>近乎所有操作都是本地执行</h5><p>在 Git 中的绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其它计算机的信息。</p><p>特性：</p><p>①断网后依旧可以在本地对项目进行版本管理</p><p>②联网后，把本地修改的记录同步到云端服务器即可</p><h5 id="Git-中的三个区域"><a href="#Git-中的三个区域" class="headerlink" title="Git 中的三个区域"></a>Git 中的三个区域</h5><p>使用 Git 管理的项目，拥有三个区域，分别是工作区（处理工作的区域）、暂存区（已完成的工作的临时存放区域，等待被提交）、Git 仓库（最终的存放区域）。</p><h5 id="Git-中的三种状态"><a href="#Git-中的三种状态" class="headerlink" title="Git 中的三种状态"></a>Git 中的三种状态</h5><p>已修改：表示修改了文件，但还没将修改的结果放到暂存区</p><p>已暂存：表示对已修改文件的当前版本做了标记，使之包含在下次提交的列表中</p><p>已提交：表示文件已经安全地保存在本地的 Git 仓库中</p><p>注意：</p><p>工作区的文件被修改了，但还没有放到暂存区，就是已修改状态。</p><p>如果文件已修改并放入暂存区，就属于已暂存状态。</p><p>如果 Git 仓库中保存着特定版本的文件，就属于已提交状态。</p><h5 id="基本的-Git-工作流程如下"><a href="#基本的-Git-工作流程如下" class="headerlink" title="基本的 Git 工作流程如下"></a>基本的 Git 工作流程如下</h5><p>①在工作区中修改文件</p><p>②将你想要下次提交的更改进行暂存</p><p>③提交更新，找到暂存区的文件，将快照永久性存储到 Git 仓库</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>​在开始使用 Git 管理项目的版本之前，需要将它安装到计算机上。可以使用浏览器访问如下的网址，根据自己的操作系统，选择下载对应的 Git 安装包：</p><p><a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a></p><h4 id="配置用户信息"><a href="#配置用户信息" class="headerlink" title="配置用户信息"></a>配置用户信息</h4><p>​安装完 Git 之后，要做的第一件事就是设置自己的用户名和邮件地址。因为通过 Git 对项目进行版本管理的时候，Git 需要使用这些基本信息，来记录是谁对项目进行了操作：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;wangbanghui&quot;</span><br><span class="line">git config --global user.email &quot;546836216@qq.com&quot;</span><br></pre></td></tr></table></figure><p>注意：如果使用了 –global 选项，那么该命令只需要运行一次，即可永久生效。</p><p>​通过 git config –global user.name 和 git config –global user.email 配置的用户名和邮箱地址，会被写入到 C:&#x2F;Users&#x2F;用户名文件夹&#x2F;.gitconfig 文件中。这个文件是 Git 的全局配置文件，配置一次即可永久生效。</p><p>可以使用记事本打开此文件，从而查看自己曾经对 Git 做了哪些全局性的配置。</p><p>除了使用记事本查看全局的配置信息之外，还可以运行如下的终端命令，快速的查看 Git 的全局配置信息：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查看所有的全局配置项</span><br><span class="line">git config --list --global</span><br><span class="line"># 查看指定的全局配置项</span><br><span class="line">git config user.name</span><br><span class="line">git config user.email</span><br></pre></td></tr></table></figure><p>可以使用 git help <verb> 命令，无需联网即可在浏览器中打开帮助手册，例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 要想打开 git config 命令的帮助手册</span><br><span class="line">git help config</span><br></pre></td></tr></table></figure><p>如果不想查看完整的手册，那么可以用 -h 选项获得更简明的“help”输出：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config -h</span><br></pre></td></tr></table></figure><h4 id="Git-的基本操作"><a href="#Git-的基本操作" class="headerlink" title="Git 的基本操作"></a>Git 的基本操作</h4><h5 id="获取-Git-仓库的两种方式"><a href="#获取-Git-仓库的两种方式" class="headerlink" title="获取 Git 仓库的两种方式"></a>获取 Git 仓库的两种方式</h5><p>①将尚未进行版本控制的本地目录转换为 Git 仓库</p><p>②从其它服务器克隆一个已存在的 Git 仓库</p><p>以上两种方式都能够在自己的电脑上得到一个可用的 Git 仓库</p><h5 id="在现有目录中初始化仓库"><a href="#在现有目录中初始化仓库" class="headerlink" title="在现有目录中初始化仓库"></a>在现有目录中初始化仓库</h5><p>如果自己有一个尚未进行版本控制的项目目录，想要用 Git 来控制它，需要执行如下两个步骤：</p><p>①在项目目录中，通过鼠标右键打开“Git Bash”</p><p>②执行 git init 命令将当前的目录转化为 Git 仓库</p><p>git init 命令会创建一个名为 .git 的隐藏目录，这个 .git 目录就是当前项目的 Git 仓库，里面包含了初始的必要文件，这些文件是 Git 仓库的必要组成部分。</p><h5 id="工作区中文件的-4-种状态"><a href="#工作区中文件的-4-种状态" class="headerlink" title="工作区中文件的 4 种状态"></a>工作区中文件的 4 种状态</h5><p>工作区中的每一个文件可能有 4 种状态，这四种状态共分为两大类，</p><p>未跟踪（Untracked）：不被 Git 所管理的文件</p><p>未修改（Unmodified）：工作区中文件的内容和 Git 仓库中文件的内容保持一致</p><p>已修改（Modified）：工作区中文件的内容和 Git 仓库中文件的内容不一致</p><p>已暂存（Staged）：工作区中被修改的文件已被放到暂存区，准备将修改后的文件保存到 Git 仓库中</p><p>Git 操作的终极结果：让工作区中的文件都处于“未修改”的状态。</p><h5 id="检查文件的状态"><a href="#检查文件的状态" class="headerlink" title="检查文件的状态"></a>检查文件的状态</h5><p>可以使用 git status 命令查看文件处于什么状态</p><p>以精简的方式显示文件状态</p><p>使用 git status 输出的状态报告很详细，但有些繁琐。如果希望以精简的方式显示文件的状态，可以使用如下两条完全等价的命令，其中 <strong>-s</strong> 是 <strong>–short</strong> 的简写形式：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git status -s</span><br><span class="line">git status --short</span><br></pre></td></tr></table></figure><p>未跟踪文件前面有红色的 ?? 标记</p><h5 id="跟踪新文件"><a href="#跟踪新文件" class="headerlink" title="跟踪新文件"></a>跟踪新文件</h5><p>使用命令 git add 开始跟踪一个文件。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add index.html</span><br></pre></td></tr></table></figure><p>此时再运行 git status 命令，会看到 indegit sat.html 文件在 Changes to be committed 这行的下面，说明已被跟踪，并处于暂存状态。</p><p>以精简的方式显示文件的状态：新添加到暂存区中的文件前面有绿色的 A 标记</p><h5 id="提交更新"><a href="#提交更新" class="headerlink" title="提交更新"></a>提交更新</h5><p>现在暂存区中有一个 index.html 文件等待被提交到 Git 仓库中进行保存。可以执行 git commit 命令进行提交,其中 -m 选项后面是本次的提交消息，用来对提交的内容做进一步的描述。提交成功之后，会显示信息：新建了 index.html 文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit -m &quot;新建了index.html文件&quot;</span><br></pre></td></tr></table></figure><p>提交成之后，再次检查文件的状态：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">On branch master</span><br><span class="line">nothing to commit,working tree clean</span><br></pre></td></tr></table></figure><p>证明工作区中所有的文件都处于“未修改”的状态，没有任何文件需要被提交。</p><h5 id="对已提交的文件进行修改"><a href="#对已提交的文件进行修改" class="headerlink" title="对已提交的文件进行修改"></a>对已提交的文件进行修改</h5><p>目前，index.html 文件已经被 Git 跟踪，并且工作区和 Git 仓库中的 index.html 文件内容保持一致。当我们修改了工作区中 index.html 的内容之后，再次运行 git status 和 git status -s 命令，会看到如下的内容：</p><p>文件 index.html 出现在 Changes not staged for commit 这行下面，说明已跟踪文件的内容发生了变化，但还没有放到暂存区。</p><p>注意：修改过的、没有放入暂存区的文件前面有红色的 M 标记。</p><h5 id="暂存已修改的文件"><a href="#暂存已修改的文件" class="headerlink" title="暂存已修改的文件"></a>暂存已修改的文件</h5><p>目前，工作区中的 index.html 文件已被修改，如果要暂存这次修改，需要再次运行 git add 命令，这个命令是个多功能的命令，主要有如下 3 个功效：</p><p>① 可以用它开始跟踪新文件</p><p>② 把已跟踪的、且已修改的文件放到暂存区</p><p>③ 把有冲突的文件标记为已解决状态</p><h5 id="提交已暂存的文件"><a href="#提交已暂存的文件" class="headerlink" title="提交已暂存的文件"></a>提交已暂存的文件</h5><p>再次运行 git commit -m “提交消息” 命令，即可将暂存区中记录的 index.html 的快照，提交到 Git 仓库中进行保存：</p><h5 id="撤销对文件的修改"><a href="#撤销对文件的修改" class="headerlink" title="撤销对文件的修改"></a>撤销对文件的修改</h5><p>撤销对文件的修改指的是：把对工作区中对应文件的修改，还原成 Git 仓库中所保存的版本。</p><p>操作的结果：所有的修改会丢失，且无法恢复！危险性比较高，请慎重操作！</p><p>撤销操作的本质：用 Git 仓库中保存的文件，覆盖工作区中指定的文件。</p><h5 id="向暂存区中一次性添加多个文件"><a href="#向暂存区中一次性添加多个文件" class="headerlink" title="向暂存区中一次性添加多个文件"></a>向暂存区中一次性添加多个文件</h5><p>如果需要被暂存的文件个数比较多，可以使用如下的命令，一次性将所有的新增和修改过的文件加入暂存区：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure><p>今后在项目开发中，会经常使用这个命令，将新增和修改过后的文件加入暂存区。</p><h5 id="取消暂存的文件"><a href="#取消暂存的文件" class="headerlink" title="取消暂存的文件"></a>取消暂存的文件</h5><p>如果需要从暂存区中移除对应的文件，可以使用如下的命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git reset HEAD 要移除的文件名</span><br></pre></td></tr></table></figure><h5 id="跳过使用暂存区域"><a href="#跳过使用暂存区域" class="headerlink" title="跳过使用暂存区域"></a>跳过使用暂存区域</h5><p>Git 标准的工作流程是工作区 → 暂存区 → Git 仓库，但有时候这么做略显繁琐，此时可以跳过暂存区，直接将工作区中的修改提交到 Git 仓库，这时候 Git 工作的流程简化为了工作区 → Git 仓库。</p><p>Git 提供了一个跳过使用暂存区域的方式， 只要在提交的时候，给 git commit 加上 -a 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 git add 步骤：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git  commit -a -m &quot;描述信息&quot;</span><br></pre></td></tr></table></figure><h5 id="移除文件"><a href="#移除文件" class="headerlink" title="移除文件"></a>移除文件</h5><p>从 Git 仓库中移除文件的方式有两种：</p><p>①从 Git 仓库和工作区中同时移除对应的文件</p><p>②只从 Git 仓库中移除指定的文件，但保留工作区中对应的文件</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"># 从 Git 仓库和工作区中同时移除 index.js 文件</span><br><span class="line">git rm -f index.js</span><br><span class="line"># 只从 Git 仓库中移除 index.css 但保留工作区中的 index.css 文件</span><br><span class="line">git rm --cached index.css</span><br></pre></td></tr></table></figure><h5 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h5><p>一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。 在这种情况下，我们可以创建一个名为 .gitignore 的配置文件，列出要忽略的文件的匹配模式。</p><p>文件 .gitignore 的格式规范如下：</p><p>①以 # 开头的是注释</p><p>②以 &#x2F; 结尾的是目录</p><p>③以 &#x2F; 开头防止递归</p><p>④以 ! 开头表示取反</p><p>⑤可以使用 glob 模式进行文件和文件夹的匹配（glob 指简化了的正则表达式）</p><h5 id="glob-模式"><a href="#glob-模式" class="headerlink" title="glob 模式"></a>glob 模式</h5><p>所谓的 glob 模式是指简化了的正则表达式：</p><p>① <strong>星号 *</strong> 匹配零个或多个任意字符</p><p>② <strong>[abc]</strong> 匹配任何一个列在方括号中的字符 （此案例匹配一个 a 或匹配一个 b 或匹配一个 c）</p><p>③ <strong>问号</strong> <strong>?</strong> 只匹配一个任意字符</p><p>④ 在方括号中使用<strong>短划线</strong>分隔两个字符， 表示所有在这两个字符范围内的都可以匹配（比如 [0-9] 表示匹配所有 0 到 9 的数字）</p><p>⑤ <strong>两个星号 *</strong>* 表示匹配任意中间目录（比如 a&#x2F;**&#x2F;z 可以匹配 a&#x2F;z 、 a&#x2F;b&#x2F;z 或 a&#x2F;b&#x2F;c&#x2F;z 等）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 忽略所有的.a文件</span><br><span class="line">*.a</span><br><span class="line"># 但跟踪所有的lib.a, 即便你在前面忽略了.a文件</span><br><span class="line">!lib.a</span><br><span class="line"># 只忽略当前目录下的TODO文件，而不忽略subdir/TODO </span><br><span class="line">/TODO</span><br><span class="line"># 忽略任何目录下名为build的文件夹</span><br><span class="line">build/</span><br><span class="line"># 忽略doc/notes.txt,但不忽略doc/server/arch.txt</span><br><span class="line">doc/*.txt</span><br><span class="line"># 忽略doc/目录及其所有子目录下的.pdf文件</span><br><span class="line">doc/**/*.pdf</span><br></pre></td></tr></table></figure><h5 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h5><p>如果希望回顾项目的提交历史，可以使用 git log 这个简单且有效的命令</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 按时间先后顺序列出所有的提交历史，最近的提交排在最上面</span><br><span class="line">git log</span><br><span class="line"># 只展示最新的两条提交历史，数字可以按需进行填写</span><br><span class="line">git log -2</span><br><span class="line"># 在一行上展示最近两条提交历史的信息</span><br><span class="line">git log -2 --pretty=oneline</span><br><span class="line"># 在一行上展示最近两条提交历史的信息，并自定义输出的格式</span><br><span class="line"># %h提交的简写哈希值  %an作者名字  %ar作者修订日期，按多久以前的方式显示  %s提交说明</span><br><span class="line">git log -2 --pretty=format:&quot;%h | %an | %ar | %s&quot;</span><br></pre></td></tr></table></figure><h5 id="回退到指定的版本"><a href="#回退到指定的版本" class="headerlink" title="回退到指定的版本"></a>回退到指定的版本</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 在一行上展示所有的提交历史</span><br><span class="line">git log --pretty=oneline</span><br><span class="line"># 使用git reset --hard 命令，根据指定的提交ID回退到指定版本</span><br><span class="line">git reset --hard &lt;CommitID&gt; </span><br><span class="line"># 在旧版本中使用git reflog --pretty=oneline 命令，查看命令操作的历史</span><br><span class="line">git reflog --pretty=oneline</span><br><span class="line"># 再次根据最新的提交ID, 跳转到最新的版本</span><br><span class="line">git reset --hard &lt;CommitID&gt;</span><br></pre></td></tr></table></figure><h5 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h5><p>① 初始化 Git 仓库的命令</p><p>git init</p><p>② 查看文件状态的命令</p><p>git status 或 git status -s</p><p>③ 一次性将文件加入暂存区的命令</p><p>git add .</p><p>④ 将暂存区的文件提交到 Git 仓库的命令</p><p>git commit -m “提交消息”</p><h3 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h3><h5 id="开源许可协议"><a href="#开源许可协议" class="headerlink" title="开源许可协议"></a>开源许可协议</h5><p>开源并不意味着完全没有限制，为了限制使用者的使用范围和保护作者的权利，每个开源项目都应该遵守开源许可协议（ Open Source License ）。</p><p>常见的 5 种开源许可协议</p><p>① BSD（Berkeley Software Distribution）</p><p>② Apache Licence 2.0</p><p>③ <strong>GPL</strong>（GNU General Public License）</p><p>​具有传染性的一种开源协议，不允许修改后和衍生的代码做为闭源的商业软件发布和销售</p><p>​使用 GPL 的最著名的软件项目是：Linux</p><p>④ LGPL（GNU Lesser General Public License）</p><p>⑤ <strong>MIT</strong>（Massachusetts Institute of Technology, MIT）</p><p>​是目前限制最少的协议，唯一的条件：在修改后的代码或者发行包中，必须包含原作者的许可信息</p><p>​使用 MIT 的软件项目有：jquery、Node.js</p><p>关于更多开源许可协议的介绍，可以参考博客 <a href="https://www.runoob.com/w3cnote/open-source-license.html">https://www.runoob.com/w3cnote/open-source-license.html</a></p><p>专门用于免费存放开源项目源代码的网站，叫做<strong>开源项目托管平台</strong>。目前世界上比较出名的开源项目托管平台主要有以下 3 个：</p><p>​Github（全球最牛的开源项目托管平台，没有之一）</p><p>​Gitlab（对代码私有性支持较好，因此企业用户较多）</p><p>​Gitee（又叫做码云，是国产的开源项目托管平台。访问速度快、纯中文界面、使用友好）</p><p>注意：以上 3 个开源项目托管平台，只能托管以 Git 管理的项目源代码，因此，它们的名字都以 Git 开头。</p><p>Github 的官网首页 <a href="https://github.com/">https://github.com/</a></p><h5 id="远程仓库的两种访问方式"><a href="#远程仓库的两种访问方式" class="headerlink" title="远程仓库的两种访问方式"></a>远程仓库的两种访问方式</h5><p>Github 上的远程仓库，有两种访问方式，分别是 HTTPS 和 SSH。它们的区别是：</p><p>①HTTPS：零配置；但是每次访问仓库时，需要重复输入 Github 的账号和密码才能访问成功</p><p>②SSH：需要进行额外的配置；但是配置成功后，每次访问仓库时，不需重复输入 Github 的账号和密码</p><p>注意：在实际开发中，推荐使用 SSH 的方式访问远程仓库。</p><h5 id="SSH-key"><a href="#SSH-key" class="headerlink" title="SSH key"></a>SSH key</h5><p>SSH key 的<strong>作用</strong>：实现本地仓库和 Github 之间免登录的加密数据传输。</p><p>SSH key 的<strong>好处</strong>：免登录身份认证、数据加密传输。</p><p>SSH key 由<strong>两部分组成</strong>，分别是：</p><p>①id_rsa（私钥文件，存放于客户端的电脑中即可）</p><p>②id_rsa.pub（公钥文件，需要配置到 Github 中）</p><h6 id="生成-SSH-key"><a href="#生成-SSH-key" class="headerlink" title="生成 SSH key"></a>生成 SSH key</h6><p>①打开 Git Bash</p><p>②粘贴如下的命令，并将 <a href="mailto:&#121;&#111;&#117;&#114;&#x5f;&#101;&#x6d;&#x61;&#105;&#108;&#x40;&#x65;&#120;&#97;&#x6d;&#x70;&#x6c;&#x65;&#46;&#99;&#x6f;&#x6d;">&#121;&#111;&#117;&#114;&#x5f;&#101;&#x6d;&#x61;&#105;&#108;&#x40;&#x65;&#120;&#97;&#x6d;&#x70;&#x6c;&#x65;&#46;&#99;&#x6f;&#x6d;</a> 替换为注册 Github 账号时填写的邮箱：</p><p>l ssh-keygen -t rsa -b 4096 -C “<a href="mailto:&#121;&#x6f;&#117;&#114;&#95;&#101;&#109;&#x61;&#x69;&#x6c;&#x40;&#101;&#120;&#x61;&#109;&#x70;&#x6c;&#101;&#46;&#99;&#111;&#109;">&#121;&#x6f;&#117;&#114;&#95;&#101;&#109;&#x61;&#x69;&#x6c;&#x40;&#101;&#120;&#x61;&#109;&#x70;&#x6c;&#101;&#46;&#99;&#111;&#109;</a>“</p><p>③连续敲击 3 次回车，即可在 C:\Users\用户名文件夹.ssh 目录中生成 id_rsa 和 id_rsa.pub 两个文件</p><h6 id="配置-SSH-key"><a href="#配置-SSH-key" class="headerlink" title="配置 SSH key"></a><strong>配置</strong> SSH key</h6><p>①使用记事本打开 id_rsa.pub 文件，复制里面的文本内容</p><p>②在浏览器中登录 Github，点击头像 -&gt; Settings -&gt; SSH and GPG Keys -&gt; New SSH key</p><p>③将 id_rsa.pub 文件中的内容，粘贴到 Key 对应的文本框中</p><p>④在 Title 文本框中任意填写一个名称，来标识这个 Key 从何而来</p><h6 id="检测-Github-的-SSH-key-是否配置成功"><a href="#检测-Github-的-SSH-key-是否配置成功" class="headerlink" title="检测 Github 的 SSH key 是否配置成功"></a><strong>检测</strong> <strong>Github</strong> <strong>的</strong> <strong>SSH key</strong> 是否配置成功</h6><p>打开 Git Bash，输入如下的命令并回车执行：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br><span class="line">The authenticity of host &#x27; github.com (IP ADDRESS)&#x27;</span><br><span class="line">can&#x27;t be established. </span><br><span class="line">RSA key fingerprint is SHA256: nThbg6kXUpJWG17E1 IGOCspRomTxdCARLvi KW6E5SY8</span><br><span class="line">Are you sure you want to continue connecting (yes/no)?  输入 yes</span><br><span class="line">输入 yes 之后，如果能看到类似于下面的提示消息，证明 SSH key 已经配置成功了：</span><br><span class="line">Hi wangabnghui! You&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure><p>便可以基于 ssh 将本地仓库上传到Github</p><h6 id="将远程仓库克隆到本地"><a href="#将远程仓库克隆到本地" class="headerlink" title="将远程仓库克隆到本地"></a><strong>将远程仓库克隆到本地</strong></h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone 远程仓库的地址</span><br></pre></td></tr></table></figure><h3 id="Git-分支"><a href="#Git-分支" class="headerlink" title="Git 分支"></a>Git 分支</h3><h4 id="master-主分支"><a href="#master-主分支" class="headerlink" title="master 主分支"></a>master 主分支</h4><p>在初始化本地 Git 仓库的时候，Git 默认已经帮我们创建了一个名字叫做 master 的分支。通常我们把这个 master 分支叫做主分支。</p><p>在实际工作中，master 主分支的作用是：<strong>用来保存和记录整个项目已完成的功能代码</strong>。</p><p>因此，不允许程序员直接在 master 分支上修改代码，因为这样做的风险太高，容易导致整个项目崩溃。</p><p>由于程序员不能直接在 master 分支上进行功能的开发，所以就有了功能分支的概念。</p><p><strong>功能分支</strong>指的是专门用来开发新功能的分支，它是临时从 master 主分支上分叉出来的，当新功能开发且测试完毕后，最终需要合并到 master 主分支上。</p><h5 id="查看分支列表"><a href="#查看分支列表" class="headerlink" title="查看分支列表"></a>查看分支列表</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure><p>注意：分支名字前面的 ***** 号表示当前所处的分支。</p><h5 id="创建新分支"><a href="#创建新分支" class="headerlink" title="创建新分支"></a>创建新分支</h5><p>使用如下的命令，可以基于当前分支，创建一个新的分支，此时，新分支中的代码和当前分支完全一样：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch 分支名称</span><br></pre></td></tr></table></figure><h5 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout login # 切换到 login 上</span><br></pre></td></tr></table></figure><h5 id="分支的快速创建和切换"><a href="#分支的快速创建和切换" class="headerlink" title="分支的快速创建和切换"></a>分支的快速创建和切换</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout -b 分支名称</span><br></pre></td></tr></table></figure><p>注意：</p><p>“git checkout -b 分支名称” 是下面两条命令的简写形式：</p><p>①git branch 分支名称</p><p>②git checkout 分支名称</p><h5 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h5><p>功能分支的代码开发测试完毕之后，可以使用如下的命令，将完成后的代码合并到 master 主分支上：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout master  # 先切换值主分支</span><br><span class="line">git merge login   #合并</span><br></pre></td></tr></table></figure><p>合并分支时的注意点：</p><p>假设要把 C 分支的代码合并到 A 分支，则必须<strong>先切换到</strong> <strong>A</strong> <strong>分支</strong>上，<strong>再运行</strong> <strong>git merge</strong> <strong>命令</strong>，来合并 C 分支！</p><h5 id="遇到冲突时的分支合并"><a href="#遇到冲突时的分支合并" class="headerlink" title="遇到冲突时的分支合并"></a>遇到冲突时的分支合并</h5><p>如果在两个不同的分支中，对同一个文件进行了不同的修改，Git 就没法干净的合并它们。 此时，我们需要打开这些包含冲突的文件然后<strong>手动解决冲突</strong>。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 假设:在把reg分支合并到 master 分支期间，代码发生了冲突</span><br><span class="line">git checkout master</span><br><span class="line">git merge reg</span><br><span class="line"># 打开包含冲突的文件，手动解决冲突之后，再执行如下的命令</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;解决了分支合并冲突的问题”</span><br></pre></td></tr></table></figure><h5 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h5><p>当把功能分支的代码合并到 master 主分支上以后，就可以使用如下的命令，删除对应的功能分支：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch -d 分支名称</span><br></pre></td></tr></table></figure><h4 id="远程分支操作"><a href="#远程分支操作" class="headerlink" title="远程分支操作"></a>远程分支操作</h4><p>将本地分支推送到远程仓库</p><p>如果是<strong>第一次</strong>将本地分支推送到远程仓库，需要运行如下的命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># -u 表示把本地分支和远程分支进行关联，只在第一次推送的时候需要带 -u 参数</span><br><span class="line">git push -u 远程仓库的别名本地分支名称:远程分支名称</span><br><span class="line"># 实际案例:</span><br><span class="line">git push -u origin payment:pay</span><br><span class="line"># 如果希望远程分支的名称和本地分支名称保持一致，可以对命令进行简化:</span><br><span class="line">git push -u origin payment</span><br></pre></td></tr></table></figure><p>注意：第一次推送分支需要带 -u 参数，此后可以直接使用 git push 推送代码到远程分支。</p><h5 id="查看远程仓库中所有的分支列表"><a href="#查看远程仓库中所有的分支列表" class="headerlink" title="查看远程仓库中所有的分支列表"></a>查看远程仓库中所有的分支列表</h5><p>通过如下的命令，可以查看远程仓库中，所有的分支列表的信息：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote show 远程仓库名称</span><br></pre></td></tr></table></figure><h5 id="跟踪分支"><a href="#跟踪分支" class="headerlink" title="跟踪分支"></a>跟踪分支</h5><p>跟踪分支指的是：从远程仓库中，把远程分支下载到本地仓库中。需要运行的命令如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 从远程仓库中，把对应的远程分支下载到本地仓库，保持本地分支和远程分支名称相同</span><br><span class="line">git checkout 远程分支的名称</span><br><span class="line"># 示例:</span><br><span class="line">git checkout pay</span><br><span class="line"># 从远程仓库中，把对应的远程分支下载到本地仓库，并把下载的本地分支进行重命名</span><br><span class="line">git checkout -b 本地分支名称 远程仓库名称/远程分支名称</span><br><span class="line"># 示例:</span><br><span class="line">git checkout -b payment origin/pay</span><br></pre></td></tr></table></figure><h5 id="拉取远程分支的最新的代码"><a href="#拉取远程分支的最新的代码" class="headerlink" title="拉取远程分支的最新的代码"></a>拉取远程分支的最新的代码</h5><p>可以使用如下的命令，把远程分支最新的代码下载到本地对应的分支中：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure><h5 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h5><p>可以使用如下的命令，删除远程仓库中指定的分支：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#删除远程仓库中，指定名称的远程分支</span><br><span class="line">git push 远程仓库名称 --delete 远程分支名称</span><br><span class="line">#示例:</span><br><span class="line">git push origin --delete pay</span><br></pre></td></tr></table></figure><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>①能够掌握 Git 中基本命令的使用</p><p>git init</p><p>git add .</p><p>git commit –m “提交消息”</p><p>git status 和 git status -s</p><p>②能够使用 Github 创建和维护远程仓库</p><p>能够配置 Github 的 SSH 访问</p><p>能够将本地仓库上传到 Github</p><p>③能够掌握 Git 分支的基本使用</p><p>git checkout -b 新分支名称</p><p>git push -u origin 新分支名称</p><p>git checkout 分支名称</p><p>git branch</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IT </tag>
            
            <tag> 开发工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络规划与设计</title>
      <link href="/archives/974a452e.html"/>
      <url>/archives/974a452e.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
      
      <categories>
          
          <category> 网络设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IT </tag>
            
            <tag> 网络设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript基础</title>
      <link href="/archives/4b0178e0.html"/>
      <url>/archives/4b0178e0.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><h2 id="1-邂逅JavaScript"><a href="#1-邂逅JavaScript" class="headerlink" title="1.邂逅JavaScript"></a>1.邂逅JavaScript</h2><h3 id="1、认识编程语言"><a href="#1、认识编程语言" class="headerlink" title="1、认识编程语言"></a>1、认识编程语言</h3><p>计算机语言就是我们人和计算机进行交流要学习的语言</p><p>HTML：标记语言；CSS：样式语言；都属于计算机语言</p><p>JavaScript也是计算机语言，更精确来说是一门编程语言</p><p><strong>计算机语言：</strong>人与计算机之间通讯的语言，是人与计算机之间传递信息的介质，其概念比通用的编程语言要更广泛；</p><p><strong>编程语言</strong>：用来定义计算机程序的形式语言。它是一种被标准化的交流技巧，用来向计算机发出指令，一种能让程序员准确定义计算机所需使用数据的计算机语言，并准确的定义在不同情况下所应采取的行动。</p><p><strong>编程语言特点</strong>：</p><ul><li>数据和数据结构</li><li>指令及流程控制</li><li>引用机制和重用机制</li><li>设计哲学</li></ul><h3 id="2、编程语言发展史"><a href="#2、编程语言发展史" class="headerlink" title="2、编程语言发展史"></a>2、编程语言发展史</h3><p><strong>阶段一：</strong>机器语言，只由0和1组成 </p><p><strong>阶段二：</strong>汇编语言，用符号来代替冗长的、难以记忆的0和1代码，经过汇编器转化为0和1</p><p><strong>阶段三：</strong>高级语言，接近自然语言，更符合人类的思维方式</p><h3 id="3、JavaScript的历史"><a href="#3、JavaScript的历史" class="headerlink" title="3、JavaScript的历史"></a>3、JavaScript的历史</h3><p>javascript是一门高级的、解释型的编程语言</p><p>是一门基于原型的、头等函数的语言，是一门多范式的语言，支持面向对象程序设计、指令式编程、以及函数式编程</p><p>94年网景公司发布navigator浏览器0.9版，但是只能用于浏览，不具备与用户的交互能力。</p><p>95年招募Brendan Eich，希望将scheme语言作为网页脚本语言的可能性</p><p>同时，sun公司将oak语言更名为Java，管理层倾向于java，希望能简化java来适应脚本的需求</p><p>brendan eich不感兴趣并且用了十天设计了js，最初叫做mocha，在navigator2.0 beta更名为livescript，在navigator3.0beta 3 改名为javascript，为了搭上java热度</p><p>95年微软首推IE，并对navigator进行逆向发明了jscript</p><p>96.11月，网景正式向ECMA提交了语言规范</p><ul><li>97.6月，ECMA为javascript制定了ECMAScript标准规范</li></ul><p>所以，ecmascript是一种规范，而javascript是这种规范的一种实现</p><h3 id="4、JavaScript的组成"><a href="#4、JavaScript的组成" class="headerlink" title="4、JavaScript的组成"></a>4、JavaScript的组成</h3><p>定义语言规范：ECMAScript</p><p>DOM：用于操作文档的API</p><p>BOM：用于操作浏览器的API</p><h3 id="5、JavaScript运行引擎"><a href="#5、JavaScript运行引擎" class="headerlink" title="5、JavaScript运行引擎"></a>5、JavaScript运行引擎</h3><p>常见的js引擎：</p><ul><li>javascriptCore：webkit中的js引擎，apple公司开发</li><li>v8：Goole开发的强大的js引擎</li></ul><p>浏览器内核与js引擎的关系</p><p>webkit为例：</p><ul><li>webcore：负责html的解析、布局、渲染等相关工作（渲染层）</li><li>javascriptcore：解析、执行js代码（逻辑层）</li></ul><h3 id="6、JavaScript应用场景"><a href="#6、JavaScript应用场景" class="headerlink" title="6、JavaScript应用场景"></a>6、JavaScript应用场景</h3><p>web开发、移动端开发、小程序端开发、桌面应用开发、后端开发</p><h2 id="2-JavaScript的基本语法"><a href="#2-JavaScript的基本语法" class="headerlink" title="2.JavaScript的基本语法"></a>2.JavaScript的基本语法</h2><h3 id="1、javascript编写方式"><a href="#1、javascript编写方式" class="headerlink" title="1、javascript编写方式"></a>1、javascript编写方式</h3><ul><li>HTML代码内</li><li>script标签内</li><li>外部的js文件</li></ul><h3 id="2、noscript元素的使用"><a href="#2、noscript元素的使用" class="headerlink" title="2、noscript元素的使用"></a>2、noscript元素的使用</h3><p>如果运行的浏览器不支持js，需要一直优雅的处理方式</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;noscript&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>您的浏览器不支持js<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">&lt;/noscript&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">alert</span>(<span class="string">&#x27;您的浏览器正在运行js代码&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="3、javascript注意事项"><a href="#3、javascript注意事项" class="headerlink" title="3、javascript注意事项"></a>3、javascript注意事项</h3><ul><li>script元素不能写成单标签，在外联引用js文件时，script标签内不能编写js代码</li><li>省略type属性，以前的script标签中：type&#x3D;”text&#x2F;javascrpit”</li><li>加载顺序：自上而下，推荐放在body子元素的最后一行</li><li>js代码严格区分大小写</li></ul><h3 id="4、javascript交互方式"><a href="#4、javascript交互方式" class="headerlink" title="4、javascript交互方式"></a>4、javascript交互方式</h3><p>alert：接受一个参数，弹窗查看</p><p>console.log：接收多个参数，在浏览器控制台查看</p><p>document.write：接受多个字符串，在浏览器页面查看</p><p>prompt：接受一个参数，在浏览器接受用户输入</p><ul><li>代码出错可以再控制台console查看</li><li>控制台 &gt; 可以直接编写js代码，回车执行代码，shift+enter可以写多行代码</li><li>debug进行调试，查看代码的执行流程</li></ul><h3 id="5、javascript语句和分号"><a href="#5、javascript语句和分号" class="headerlink" title="5、javascript语句和分号"></a>5、javascript语句和分号</h3><p>语句是向浏览器发出的指令，通常表达为一个操作或行为</p><p>通常情况下每条语句的后面会添一个分号，表示语句的结束：</p><ul><li>当存在换行符时，在大多数情况下可以省略分号</li><li>js将换行理解为”隐式”分号</li><li>也称之为自动插入分号</li></ul><p>注释方式：&#x2F;*  … *&#x2F;：多行注释      &#x2F;&#x2F;：单行注释</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">文档注释  <span class="comment">// js文件中</span></span><br><span class="line"><span class="comment">/**.....*/</span></span><br></pre></td></tr></table></figure><p>Js中不支持注释的嵌套</p><p>插件：</p><p>log快速：react：clg</p><p>括号范围：bracket pair colorizer，里面配置设置.json</p><h2 id="3-JavaScript的变量和数据结构"><a href="#3-JavaScript的变量和数据结构" class="headerlink" title="3.JavaScript的变量和数据结构"></a>3.JavaScript的变量和数据结构</h2><h3 id="1、认识JavaScript变量"><a href="#1、认识JavaScript变量" class="headerlink" title="1、认识JavaScript变量"></a>1、认识JavaScript变量</h3><p>程序中变量的数据：</p><ul><li>购物车商品的数量、价格</li><li>游戏技能时间的冷却、血量</li></ul><h4 id="1-变化数据的记录—变量"><a href="#1-变化数据的记录—变量" class="headerlink" title="1.变化数据的记录—变量"></a>1.变化数据的记录—变量</h4><ul><li>一个变量就是用于存放数值的容器</li><li>这个数字可能是一个用于计算的数字，或字符串，或其他的任意数据</li><li>变量的独特之处在于它存放的数量是可以改变的</li></ul><p>可以把变量看做一个盒子，盒子里面装着我们的数据</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var message = &#x27;hello&#x27;</span><br><span class="line">message = &#x27;why&#x27;</span><br></pre></td></tr></table></figure><h4 id="2-变量的命名格式"><a href="#2-变量的命名格式" class="headerlink" title="2.变量的命名格式"></a>2.变量的命名格式</h4><p>定义一个变量包含两部分</p><ul><li>变量的声明：告诉js引擎接下来我要定一个变量</li><li>变量的赋值：使用  &#x3D;  给变量进行赋值</li></ul><p>可以同时声明多个变量</p><h3 id="2、变量的定义、规范"><a href="#2、变量的定义、规范" class="headerlink" title="2、变量的定义、规范"></a>2、变量的定义、规范</h3><p><strong>变量命名规则：</strong>必须遵守</p><ul><li>第一个字符必须是一个英文字母、下划线（_）、$符号</li><li>其他字符可以是字母、下划线、美元符号或数字</li><li>不能使用关键字和保留字命名</li><li>变量严格区分大小写</li></ul><p><strong>规范：</strong></p><ul><li>多个单词，驼峰命名法</li><li>推荐等号两边添加一个空格，结构清晰</li><li>语句结束加上分号</li><li>变量名字尽量见名知意</li></ul><p>如果变量未声明就使用，会直接报错  not defined</p><p>如果一个变量有声明但是没有赋值，会打印undefined</p><p>在js中也可以不使用var在全局声明一个变量（不推荐），如果不使用var来声明一个变量，也是可以声明成功的，而且这个变量会被加入到window对象中</p><h3 id="3、数据类型和typeof"><a href="#3、数据类型和typeof" class="headerlink" title="3、数据类型和typeof"></a>3、数据类型和typeof</h3><p>js中的值都有特定的类型，将值赋值给一个变量，那这么变量就具备了特定的类型</p><p>一个变量可以在前一刻是个字符串，下一刻就存储一个数字</p><p>允许这种操作的编程语言，比如js，称之为动态类型的编程语言</p><p>在js中有八种基本的数据类型（7中原始类型和一种复杂类型）</p><ul><li>Number（包括小数）</li><li>String</li><li>Boolean</li><li>Undefined</li><li>Null</li><li>Object</li><li>Bigint</li><li>Symbol</li></ul><p>因为ECMAScript的类型系统是松散的，所以需要一种手段来确定任意变量的数据类型</p><p>typeof应运而生，返回值：</p><p>“undefined”表示值未定义；</p><p>“boolean”表示值为布尔值；</p><p>“string”表示值为字符串；</p><p>“number”表示值为数值；</p><p>“object”表示值为对象（而不是函数）或null；</p><p>“function”表示值为函数；</p><p>“symbol”表示值为符号；</p><p>typeof(x)  它与typeof x 相同</p><p>typeof是一个操作符，它并非是一个函数，()只是将后续的内容当作一个整体而已</p><h3 id="4、常见的数据类型"><a href="#4、常见的数据类型" class="headerlink" title="4、常见的数据类型"></a>4、常见的数据类型</h3><h4 id="number类型"><a href="#number类型" class="headerlink" title="number类型"></a>number类型</h4><p>代表整数和浮点数，可以进行加减乘除，除了常规的数字，还包括特殊数值也属于number类型</p><ul><li>Infinity：代表无穷大，负无穷大：1&#x2F;0</li><li>NaN：代表一个计算错误，比如数字乘字符串</li></ul><p>最大的数字：Number.MAX_VALUE</p><p>最小的数字：Number.MIN_VALUE，小于这个数字会被转化为0</p><p>isNaN()来判断一个数字是不是数字，不是数字返回true</p><h4 id="string类型：字符串类型"><a href="#string类型：字符串类型" class="headerlink" title="string类型：字符串类型"></a>string类型：字符串类型</h4><p>在开发中我们经常会有一些文本需要表示，这个时候我们会使用字符串String：</p><ul><li>比如人的姓名：coderwhy。地址：广州市。简介：认真是一种可怕的力量</li></ul><p>JavaScript 中的字符串必须被括在引号里，有三种包含字符串的方式</p><ul><li><p>双引号：”Hello”</p></li><li><p>单引号：’Hello’</p></li><li><p>反引号：<code>Hello</code></p></li></ul><p>前后的引号类型必须一致：</p><ul><li><p>如果在字符串里面本身包括单引号，可以使用双引号</p></li><li><p>如果在字符串里面本身包括双引号，可以使用单引号</p></li></ul><p>引号：单引号、双引号、反引号（支持${表达式&#x2F;变量}）</p><p>前后的引号必须一致</p><p>转义字符：除了普通可打印的字符，一些特殊的字符可以通过转义字符的形式放在字符串中</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230227141333739.png" alt="image-20230227141333739"></p><p>字符串的操作：</p><ul><li>字符串拼接（+）</li><li>获取字符串长度（.length）</li></ul><h4 id="Boolean类型：用于表示真假"><a href="#Boolean类型：用于表示真假" class="headerlink" title="Boolean类型：用于表示真假"></a>Boolean类型：用于表示真假</h4><p>包含两个值：true；false</p><h4 id="Undefined类型"><a href="#Undefined类型" class="headerlink" title="Undefined类型"></a>Undefined类型</h4><p>只有一个值，undefined：声明了变量未赋值（未进行初始化）</p><ul><li>定义变量时候最好进行赋值，而不是只是声明</li><li>不要显示的将一个变量赋值为undefined<ul><li>可以初始化为0\null\空字符串等值</li></ul></li></ul><h4 id="Object类型"><a href="#Object类型" class="headerlink" title="Object类型"></a>Object类型</h4><p>是一个特殊的类型，通常称之为引用类型或者复杂类型</p><p>其他的数据类型我们称之为原始类型，因为它们的值只包含一个单独的内容</p><p>Object往往可以表示一组数据，是其他数据的一个集合，用{}表示一个对象</p><h4 id="Null类型"><a href="#Null类型" class="headerlink" title="Null类型"></a>Null类型</h4><p>只有一个值：null</p><p>通常用来表示一个对象为空，所以我们通常再给一个对象进行初始化时，会赋值为null</p><p>typeof识别为object</p><p>null与undefined的关系：</p><ul><li>undefined通常只有在一个变量声明但是未初始化时，默认为undefined才使用</li><li>并且我们不推荐给一个变量直接赋值为undefined，所以很少使用</li><li>null值非常常用，当一个变量准备保存一个对象，但是这个对象不确定时，可以先赋值为null</li></ul><h4 id="数据类型总结"><a href="#数据类型总结" class="headerlink" title="数据类型总结"></a>数据类型总结</h4><p>JavaScript 中有八种基本的数据类型（前七种为基本数据类型，也称为原始类型，而 object 为复杂数据类型，也称为引用类型）</p><ul><li>number 用于任何类型的数字：整数或浮点数</li><li>string 用于字符串：一个字符串可以包含 0 个或多个字符，所以没有单独的单字符类型</li><li>boolean 用于 true 和 false</li><li>undefined 用于未定义的值 —— 只有一个 undefined 值的独立类型</li><li>object 用于更复杂的数据结构</li><li>null 用于未知的值 —— 只有一个 null 值的独立类型</li><li>symbol 用于唯一的标识符</li><li>bigint 用于任意长度的整数。</li></ul><h3 id="5、数据类型的转换"><a href="#5、数据类型的转换" class="headerlink" title="5、数据类型的转换"></a>5、数据类型的转换</h3><p>在大多数情况下，运算符和函数会自动将赋予它们的值转换为正确的类型，这是一种隐式转换</p><p>我们也可通过显式的方式来对数据进行类型转换</p><h4 id="1-字符串String的转换"><a href="#1-字符串String的转换" class="headerlink" title="1.字符串String的转换"></a>1.字符串String的转换</h4><p>方式1：隐式转换</p><ul><li>一个字符串和其他类型进行+操作<ul><li>+运算符左右两边有一个是字符串，那么另一边会自动转换为字符串再进行拼接操作</li></ul></li><li>某些函数的执行也会自动将参数转为字符串类型<ul><li>比如log函数</li></ul></li></ul><p>方式2：显式转换</p><ul><li>调用String()函数</li><li>调用toString方法</li></ul><h4 id="2-数字类型Number的转换"><a href="#2-数字类型Number的转换" class="headerlink" title="2.数字类型Number的转换"></a>2.数字类型Number的转换</h4><p>方式1：隐式转换</p><ul><li>在算数运算中，通常会将其他类型转换为数字类型来进行计算<ul><li>比如：“6”&#x2F;“2”</li><li>但是如果是+运算，并且其中一边有字符串，那么还是按照字符串来连接的</li></ul></li></ul><p>方式2：显示转换</p><ul><li>Numbe() 函数</li></ul><h5 id="其他类型转换数字的规则"><a href="#其他类型转换数字的规则" class="headerlink" title="其他类型转换数字的规则"></a>其他类型转换数字的规则</h5><p>undefined—&gt;NaN</p><p>null—&gt;0</p><p>true和false—&gt;1and0</p><p>string—&gt;去掉首尾空格后的纯数字字符串中含有的数字；如果剩余字符串为空，则转换为0；否则，将会从剩余字符串中“读取”数字；当类型转换出现error时返回NaN</p><h4 id="3-布尔类型Boolean的转换"><a href="#3-布尔类型Boolean的转换" class="headerlink" title="3.布尔类型Boolean的转换"></a>3.布尔类型Boolean的转换</h4><p> 隐式转换的规则：</p><p>1.直观上为空的值转换成boolean类型都是false</p><ul><li><p>直观上空的值：0&#x2F;“”&#x2F;undefined&#x2F;null&#x2F;NaN -&gt; false</p></li><li><p>其他值：true</p></li></ul><p>2.显示转换</p><ul><li>Boolean()</li></ul><p>包含0的字符串转化是true</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Boolean</span>(<span class="string">&quot;&quot;</span>));  <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Boolean</span>(<span class="string">&quot;0&quot;</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="4-JavaScript基础运算符"><a href="#4-JavaScript基础运算符" class="headerlink" title="4.JavaScript基础运算符"></a>4.JavaScript基础运算符</h2><h3 id="1、运算符和运算元"><a href="#1、运算符和运算元" class="headerlink" title="1、运算符和运算元"></a>1、运算符和运算元</h3><p>认识运算符（operators）：加（+）、减（-）、乘（*）、除（&#x2F;）</p><p>运算元：运算符应用的对象</p><ul><li>5*2: 5 和 2 就是运算元</li></ul><p>如果一个运算符对应的只有一个运算元，那么它是一元运算符</p><ul><li>-10</li></ul><p>如果一个运算符拥有两个运算元，那么就是二元运算符</p><h3 id="2、算术运算符"><a href="#2、算术运算符" class="headerlink" title="2、算术运算符"></a>2、算术运算符</h3><p>用在数学表达式中，与数学方法一致</p><p>算术运算符是对数据进行计算的符号</p><p>Math.pow(2,3)  表示 2 的3次幂（es6）；   **  也是幂（es7）</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230405151813539.png" alt="image-20230405151813539"></p><h3 id="3、赋值运算符"><a href="#3、赋值运算符" class="headerlink" title="3、赋值运算符"></a>3、赋值运算符</h3><p>使用的 &#x3D; 就是赋值运算符</p><p>语句 x &#x3D; value 将value写入 x 然后返回 x</p><p>链式赋值（不推荐）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 = num2 = num3 = <span class="number">321</span></span><br></pre></td></tr></table></figure><ul><li>链式赋值从右往左计算</li><li>所有的变量共享一个值</li></ul><h5 id="原地修改"><a href="#原地修改" class="headerlink" title="原地修改"></a>原地修改</h5><p>我们经常需要对变量做运算，并将新的结果存放在同一变量中</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">100</span></span><br><span class="line">num = num + <span class="number">10</span></span><br></pre></td></tr></table></figure><ul><li>可以使用 +&#x3D;  *&#x3D; 来缩写</li></ul><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230227165921852.png" alt="image-20230227165921852"></p><p>所有的算术运算符都有简短的“修改并赋值”运算符：&#x2F;&#x3D; 和 -&#x3D; 等</p><h3 id="4、自增和自减"><a href="#4、自增和自减" class="headerlink" title="4、自增和自减"></a>4、自增和自减</h3><p>对一个数进行加一、减一是最常见的数学运算符之一</p><p>自增 ++ 将变量加一</p><p>自减 – 将变量减一</p><p>自增&#x2F;自减只能用于变量</p><ul><li>用在数值（5–）则会报错</li></ul><h5 id="和–的位置"><a href="#和–的位置" class="headerlink" title="++和–的位置"></a>++和–的位置</h5><p>独立使用的话++、–放在前后无所谓，放在后面称之为后置形式，放在前面称之为前置形式</p><p>都是+1，单独使用是看不到区别</p><p>如果我们要对变量进行自增操作时，并且需要立即使用自增后的值，那么需要使用前置形式</p><p>前置形式返回一个新的值，但后置返回原来的值</p><h3 id="5、运算符优先级"><a href="#5、运算符优先级" class="headerlink" title="5、运算符优先级"></a>5、运算符优先级</h3><p>运算符放在一起使用时会有一定的优先级</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence</a></p><h3 id="6、比较运算符"><a href="#6、比较运算符" class="headerlink" title="6、比较运算符"></a>6、比较运算符</h3><p>比大小的运算符</p><p>大于&#x2F;小于： &gt;   &lt;</p><p>大于等于：&gt;&#x3D;</p><p>相等：&#x3D;&#x3D;</p><p>不相等：！&#x3D;</p><p>比较运算符的结果都是boolean类型</p><h3 id="额外知识补充"><a href="#额外知识补充" class="headerlink" title="额外知识补充"></a>额外知识补充</h3><h4 id="x3D-x3D-和-x3D-x3D-x3D-的区别"><a href="#x3D-x3D-和-x3D-x3D-x3D-的区别" class="headerlink" title="&#x3D;&#x3D;和&#x3D;&#x3D;&#x3D;的区别"></a>&#x3D;&#x3D;和&#x3D;&#x3D;&#x3D;的区别</h4><p>&#x3D;&#x3D; 普通相等运算符，在类型不相同的情况下，会将运算元先转成Number类型的值，再进行比较</p><p>空字符串和false也是如此，会进行隐式转换</p><p>null比较特殊，内存地址：0X0，应该会被当成一个对象与原生类型进行比较</p><p>&#x3D;&#x3D;&#x3D; 严格相等运算符，在类型不相同的情况下，直接返回false</p><p>不相等：!&#x3D;；  严格不相等：!&#x3D;&#x3D;</p><p>严格代码稍长，但是能体现代码的意图</p><h2 id="5-JavaScript分支语句"><a href="#5-JavaScript分支语句" class="headerlink" title="5.JavaScript分支语句"></a>5.JavaScript分支语句</h2><h3 id="1、if分支语句"><a href="#1、if分支语句" class="headerlink" title="1、if分支语句"></a>1、if分支语句</h3><p>程序的三种执行方式</p><ul><li>顺序：从上到下，顺序执行</li><li>分支：根据条件判断，决定执行代码的分支</li><li>循环：让特定代码重复执行</li></ul><p>代码块：是多行执行代码的集合，通过一个{}放在一起</p><ul><li>在开发中，一行代码很难完成某一个特定的功能，我们将这些代码放在一个代码块中</li></ul><p>在js中，我们通过流程控制语句来决定如何执行一段代码块</p><ul><li>关键字</li><li>分支语句、循环语句</li></ul><p>分支结构</p><ul><li>根据条件来决定代码的执行</li><li>也称为判断结构或选择结构</li><li>几乎所有的编程语言都有分支结构</li></ul><p>js常见的分支结构</p><ul><li>if分支结构<ul><li>单分支结构<ul><li>if…</li></ul></li><li>多分支结构<ul><li>if…else…</li><li>if…esle if…else…</li></ul></li></ul></li><li>switch分支结构</li></ul><p>if 单分支结构</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件判断) &#123; 执行代码块 &#125; <span class="comment">// 条件判断为true就执行代码块</span></span><br></pre></td></tr></table></figure><p>如果代码块中只有一行代码，那么可以省略花括号，写在一排</p><p>if(…)语句会计算圆括号中的表达式，并将计算结果转换为布尔值，规则同Boolean函数</p><h3 id="2、if…else…语句"><a href="#2、if…else…语句" class="headerlink" title="2、if…else…语句"></a>2、if…else…语句</h3><p>多分支语句，if 语句有时会包含可选的else模块</p><p>如果判断条件不成立，就会执行它内部的代码</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件成立) &#123;成立的代码块&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;不成立的代码块&#125;</span><br></pre></td></tr></table></figure><h3 id="3、if…else-if…else语句"><a href="#3、if…else-if…else语句" class="headerlink" title="3、if…else if…else语句"></a>3、if…else if…else语句</h3><p>判断多个条件，可以使用 else if 实现</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件<span class="number">1</span>) &#123;代码块&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(条件<span class="number">2</span>) &#123;代码块&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;前面所有条件不成立&#125;</span><br></pre></td></tr></table></figure><h3 id="4、三元运算符"><a href="#4、三元运算符" class="headerlink" title="4、三元运算符"></a>4、三元运算符</h3><p>只是用if else语句可能会导致代码臃肿</p><p>三元运算符通过<code>？</code>表示</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> result = condition ? value1 : value2</span><br><span class="line"><span class="keyword">var</span> result = num1 &gt; num2 ? num1 : num2  <span class="comment">// 比较大小</span></span><br></pre></td></tr></table></figure><h3 id="5、逻辑运算符"><a href="#5、逻辑运算符" class="headerlink" title="5、逻辑运算符"></a>5、逻辑运算符</h3><p>主要有三个：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">||(或)：一个为真   &amp;&amp;(与)：同时为真    ！(非)：取反</span><br></pre></td></tr></table></figure><p>可以将多个表达式或值放在一起来获取到一个最终的结果</p><h5 id="逻辑-的本质"><a href="#逻辑-的本质" class="headerlink" title="逻辑||的本质"></a>逻辑||的本质</h5><ul><li>也称之为短路或</li><li>从左到右依次计算操作数</li><li>处理每一个操作数时，都会将其转化为布尔值</li><li>如果结果是true，就停止计算，返回这个<strong>操作数的初始值</strong></li><li>如果所有操作数都被计算过(也就是，转换结果都是false)，则返回最后一个<strong>操作数</strong></li></ul><p>返回的值是操作数的初始形式，不会转换为boolean类型</p><p>换句话说，一个或运算的链，将返回第一个真值，如果不存在真值，就返回该链的最后一个值</p><h5 id="逻辑-amp-amp-的本质"><a href="#逻辑-amp-amp-的本质" class="headerlink" title="逻辑&amp;&amp;的本质"></a>逻辑&amp;&amp;的本质</h5><ul><li>也称之为短路与</li><li>从左到右依次计算操作数</li><li>处理每一个操作数时，都会将其转化为布尔值</li><li>如果结果是false，就停止计算，返回这个<strong>操作数的原始值</strong></li><li>如果所有操作数都被计算过(都是真值)，则返回最后一个<strong>操作数</strong></li></ul><p>换句话说，与运算返回第一个假值，如果没有假值就返回最后一个值</p><h5 id="逻辑非的补充"><a href="#逻辑非的补充" class="headerlink" title="逻辑非的补充"></a>逻辑非的补充</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> message = <span class="string">&#x27;hello world&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Boolean</span>(message))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(!!message)</span><br></pre></td></tr></table></figure><p>逻辑非运算符接受一个参数，并按如下运算：</p><ul><li><p>步骤一：将操作数转化为布尔类型：true&#x2F;false</p></li><li><p>步骤二：返回相反的值；</p></li></ul><p>两个非运算 !! 有时候用来将某个值转化为布尔类型</p><ul><li><p>也就是，第一个非运算将该值转化为布尔类型并取反，第二个非运算再次取反</p></li><li><p>最后我们就得到了一个任意值到布尔值的转化。</p></li></ul><h3 id="6、switch语句"><a href="#6、switch语句" class="headerlink" title="6、switch语句"></a>6、switch语句</h3><p>switch 是分支结构的一种语句</p><ul><li>通过判断表达式的结果（或者变量）是否等于case语句的常量，来执行相应的分支体的</li></ul><p>与if不同的是，switch语句只能做值的严格相等判断（&#x3D;&#x3D;&#x3D;），而 if 语句可以做值的范围判断</p><ul><li><p>switch语句至少一个 case 代码块和一个可选的 default 代码块</p></li><li><p>默认情况下会有 case 穿透，case语句结束后会执行下一条case语句，添加break会跳出 switch，不执行后续代码</p></li></ul><h2 id="6-JavaScript循环语句"><a href="#6-JavaScript循环语句" class="headerlink" title="6.JavaScript循环语句"></a>6.JavaScript循环语句</h2><h3 id="1、认识循环语句"><a href="#1、认识循环语句" class="headerlink" title="1、认识循环语句"></a>1、认识循环语句</h3><p>生活中：对一个列表进行累加、将1到10数字逐个输出等等</p><p>循环是一种重复运行同一代码的方法</p><ul><li>如果是对某一列表进行循环操作，我们通常称之为遍历或者迭代</li></ul><p>三种循环方式：</p><ul><li>while循环</li><li>do…while循环</li><li>for循环</li></ul><h3 id="2、while-循环"><a href="#2、while-循环" class="headerlink" title="2、while 循环"></a>2、while 循环</h3><p>当条件成立时，执行代码块</p><p>当条件不成立时，跳出代码块</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(循环条件) &#123;</span><br><span class="line">    <span class="comment">// 循环代码块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果条件一直成立，那么会产生死循环</p><ul><li><p>这时候必须通过关闭网页来停止死循环</p></li><li><p>开发中一定要避免死循环的产生</p></li></ul><h3 id="3、do…while-循环"><a href="#3、do…while-循环" class="headerlink" title="3、do…while 循环"></a>3、do…while 循环</h3><p>do…while 循环与while循环非常像，二者经常可以相互替代</p><p>但是do…while的特点是不管条件成不成立，do循环都会先执行一次</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    <span class="comment">//循环代码块</span></span><br><span class="line">&#125; <span class="keyword">while</span>(循环条件)</span><br></pre></td></tr></table></figure><h3 id="4、for-循环"><a href="#4、for-循环" class="headerlink" title="4、for 循环"></a>4、for 循环</h3><p>for循环更加复杂，但它是最常用的循环形式</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(begin;condition;step)&#123;</span><br><span class="line">    <span class="comment">//循环代码块body</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>begin：进入循环时执行一次</li><li>condition：在每次循环迭代之前检查：如果为false，停止循环</li><li>循环体：条件为真时，重复运行</li><li>step：在每次循环迭代后执行</li></ul><p>begin执行一次，然后进行迭代：每次检查condition后，执行body和step</p><p><strong>for循环的嵌套</strong></p><ul><li>在开发中，某下情况下一次循环是无法达到目的的，需要使用循环的嵌套</li></ul><p>for循环的嵌套：循环中执行体又嵌套了循环</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">九九乘法表</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&#x27;&lt;table&gt;&#x27;</span>)</span><br><span class="line"><span class="comment">// 九九乘法表</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&quot;&lt;tr&gt;&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>;j &lt; i + <span class="number">1</span>; j++)&#123;</span><br><span class="line">        <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">`&lt;td&gt;<span class="subst">$&#123;j+<span class="number">1</span>&#125;</span>×<span class="subst">$&#123;i+<span class="number">1</span>&#125;</span>=<span class="subst">$&#123;(j+<span class="number">1</span>)*(i+<span class="number">1</span>)&#125;</span>&lt;/td&gt;`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&quot;&lt;/tr&gt;&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&#x27;&lt;/table&gt;&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="5、循环控制—break、continue"><a href="#5、循环控制—break、continue" class="headerlink" title="5、循环控制—break、continue"></a>5、循环控制—break、continue</h3><p>在执行循环过程中，遇到某一个条件时</p><ul><li>循环体不再执行(即使没有执行完)，跳出循环</li><li>本次循环体不再执行，执行下一次的循环体</li></ul><p>break：直接跳出循环，循环结束</p><ul><li>break在某一条件满足时，退出循环，不再执行后续重复的代码</li></ul><p>continue：跳过本次循环次，执行下一次循环体</p><ul><li>continue是break的”轻量版”</li><li>continue 在满足某一条件时，不执行后续重复的代码</li></ul><h3 id="6、案例练习"><a href="#6、案例练习" class="headerlink" title="6、案例练习"></a>6、案例练习</h3><p>随机数的生成</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">100</span>)    <span class="comment">// [0,1)</span></span><br></pre></td></tr></table></figure><h2 id="7-JavaScript函数"><a href="#7-JavaScript函数" class="headerlink" title="7.JavaScript函数"></a>7.JavaScript函数</h2><h3 id="1、认识-JavaScript-函数"><a href="#1、认识-JavaScript-函数" class="headerlink" title="1、认识 JavaScript 函数"></a>1、认识 JavaScript 函数</h3><p>foo、bar、baz：通常被用做函数、变量、文件的名词，计算机编程术语的一部分，本身没有别的用途和意义，被称为“伪变量”</p><p>什么是函数呢？</p><p>alert函数、prompt函数、log函数、String&#x2F;Number&#x2F;Boolean函数</p><p>函数是某种特定功能的代码的封装，帮助我们完成特定的功能</p><p>函数的使用</p><ul><li>声明函数—封装独立的功能</li><li>调用函数—享受封装的成果</li></ul><p>函数的作用：在开发程序时，使用函数可以提高编写的效率以及代码的重用</p><h3 id="2、函数的声明和调用"><a href="#2、函数的声明和调用" class="headerlink" title="2、函数的声明和调用"></a>2、函数的声明和调用</h3><p>声明函数使用function关键字：这种写法称之为函数的定义</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> 函数名() &#123; 函数封装的代码块 &#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>函数名的命名规则和前面变量名的命名规则是相同的</li><li>函数要尽量做到见名知意（一般是动词）</li><li>函数定义完后里面的代码是不会执行的，函数必须调用才会执行</li></ul><p>函数的参数：增加函数的通用性，针对相同的数据处理逻辑，能够适应更多的数据</p><ul><li>在函数内部，把参数当做变量使用，进行需要的数据处理</li><li>在函数调用时，按照函数定义的参数顺序，把希望在函数内部处理的数据，通过参数传递</li></ul><p>形参和实参</p><ul><li>形参（parameters）：定义函数时，小括号中的参数，是用来接收参数用的，在函数内部作为变量使用</li><li>实参（arguments）：调用函数时，小括号里的参数，是用来把数据传递到函数内部用的</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// name 称之为函数的参数（形参，形式参数）</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printInfo</span>(<span class="params">name</span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`my name is <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &#x27;wbh&#x27; 称之为函数的参数（实参，实际参数）</span></span><br><span class="line"><span class="title function_">printInfo</span>(<span class="string">&#x27;wbh&#x27;</span>)</span><br></pre></td></tr></table></figure><p>函数的返回值</p><p>函数不仅可以有参数，还可以有返回值</p><ul><li>使用return关键字来返回结果</li><li>一旦函数中执行returan操作，那么当前函数会终止</li><li>如果函数中没有使用return语句，那么函数会有默认的返回值：undefined</li><li>如果函数使用return语句，但是return后面没有任何值，那么函数的返回值也是undefined</li></ul><p>事实上在函数中有一个特别的对象：arguments对象</p><ul><li>默认情况下，arguments对象是所有(非箭头)函数中都可用的局部变量</li><li>该对象中存放着所有调用者传入的参数，从0位置开始，依次存放</li><li>arguments变量的类型是一个object类型(array-like)，不是一个数组，但是和数组的用法看起来很像</li><li>如果调用者传入的参数多于函数接收的参数，可以通过arguments去获取所有的参数</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(name)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>)</span><br><span class="line">    <span class="comment">// arguments是一个对象</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="variable language_">arguments</span>) </span><br><span class="line">    <span class="comment">// 对arguments进行遍历</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;<span class="variable language_">arguments</span>.<span class="property">length</span>;i++) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>[i])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>(<span class="string">&#x27;why&#x27;</span>,<span class="number">23</span>,<span class="number">445</span>,<span class="string">&quot;大连市&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="3、函数的递归调用"><a href="#3、函数的递归调用" class="headerlink" title="3、函数的递归调用"></a>3、函数的递归调用</h3><p>在开发中，函数内部是可以调用另外一个函数的</p><p>那么可以调用自己吗？</p><ul><li>可以的</li><li>但是必须有结束条件，否则会产生无限调用，造成报错</li></ul><p>函数调用自己—递归（recursion）</p><p>编程的递归调用</p><ul><li>将一个复杂的任务，转化成可以重复执行的相同任务</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">pow</span>(<span class="params">x,n</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(n=<span class="number">1</span>) <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">return</span> x*<span class="title function_">pow</span>(x,n-<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、局部和全局变量"><a href="#4、局部和全局变量" class="headerlink" title="4、局部和全局变量"></a>4、局部和全局变量</h3><p>在 javascript（es5之前）中没有块级作用域的概念，var 定义的变量是没有块级作用域</p><p>但是函数可以定义自己的作用域（scope）</p><p>作用域：表示一些标识符的作用有效范围</p><p>函数的作用域表示在函数内部定义的变量，只有在函数内部可以被访问到</p><ul><li><p>es5 之前函数代码块是会形成自己的作用域的</p></li><li><p>在函数内部定义的变量在外面是拿不到的</p></li></ul><p>全局变量：在全局（script元素中）定义一个变量，那么这个变量是可以在定义之后的任何范围内被访问到，那么称这个变量为全局变量，在任何函数中可见，通过var定义的变量会被添加到window中</p><p>内部变量：局部变量，在函数内部定义的变量，只有在函数的内部才能访问，称之为局部变量</p><p>外部变量：在函数内部去访问函数之外的变量，被访问的变量称之为外部变量，（定义在函数外部的变量）</p><p>在函数中，访问变量的顺序</p><ul><li>优先访问自己函数中的变量，没有找到时，在外部中访问</li></ul><h3 id="5、函数表达式的写法"><a href="#5、函数表达式的写法" class="headerlink" title="5、函数表达式的写法"></a>5、函数表达式的写法</h3><p>在js中，函数并不是一种神奇的语法结构，而是一种特殊的值</p><ul><li>前面定义函数的方式，我们称之为函数的声明</li></ul><p>函数表达式写法：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> bar = <span class="keyword">function</span>(<span class="params"></span>) &#123; &#125;</span><br></pre></td></tr></table></figure><p>function关键字后面没有函数名</p><ul><li>函数表达式允许省略函数名</li></ul><p>无论函数是如何创建的，函数都是一个值</p><p>在js开发中，我们可以将函数作为头等公民</p><h5 id="声明-vs-表达式"><a href="#声明-vs-表达式" class="headerlink" title="声明 vs 表达式"></a>声明 vs 表达式</h5><ul><li>语法不同<ul><li>函数声明：在主代码流中声明为单独的语句的函数</li><li>函数表达式：在一个表达式中或另一个语法结构中创建的函数</li></ul></li><li>创建函数的时机不同<ul><li>函数表达式是在代码执行到达时被创建，并且仅在那一刻起可用</li><li>在函数声明被定义之前，它就可以被调用<ul><li>这是内部算法的缘故</li><li>当javascript准备运行脚本时，首先会在脚本中寻找全局函数声明，并创建这些函数</li></ul></li></ul></li></ul><h5 id="开发中如何选择"><a href="#开发中如何选择" class="headerlink" title="开发中如何选择"></a>开发中如何选择</h5><p>首选考虑函数声明语法</p><p>它能够为组织代码提供更多的灵活性，因为我们可以在声明这些函数之前调用这些函数</p><h3 id="6、函数的头等公民"><a href="#6、函数的头等公民" class="headerlink" title="6、函数的头等公民"></a>6、函数的头等公民</h3><p>头等函数（第一等函数）：是指在程序设计语言中，函数被当做头等公民</p><ul><li>这意味着，函数可以作为别的函数的参数、函数的返回值，赋值给变量或存储在数据结构中</li><li>有人主张也应包括支持匿名函数</li></ul><p>通常对作为头等公民的编程方式，称之为函数式编程</p><ul><li>JavaScript 就是符合函数式编程的语言，这也是 js 的一大特点</li></ul><h5 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h5><p>既然一个函数可以在变量中来回传递，那么也可以传递给另外一个函数</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">fn</span>)&#123;</span><br><span class="line">    <span class="title function_">fn</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;执行了bar函数&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>(bar)</span><br></pre></td></tr></table></figure><p>foo这种函数我们也可以称之为高阶函数</p><h5 id="高阶函数必须满足两个条件之一"><a href="#高阶函数必须满足两个条件之一" class="headerlink" title="高阶函数必须满足两个条件之一"></a>高阶函数必须满足两个条件之一</h5><ul><li>接受一个或者多个函数作为输入</li><li>输出一个函数</li></ul><h5 id="匿名函数的理解"><a href="#匿名函数的理解" class="headerlink" title="匿名函数的理解"></a>匿名函数的理解</h5><p>如果在传入一个函数时，我们没有指定这个函数的名称或者通过函数表达式指定函数对应的变量，那么这个函数称之为匿名函数</p><h3 id="7、立即执行函数"><a href="#7、立即执行函数" class="headerlink" title="7、立即执行函数"></a>7、立即执行函数</h3><p>一个函数定义完后被立即执行</p><ul><li>第一部分是定义了一个匿名函数，这个函数有自己独立的作用域</li><li>第二部分是后面的()，表示这个函数被执行了</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>)&#123;  <span class="comment">// 函数名可以删除</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;bar函数被立刻执行&#x27;</span>)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p>会创建一个独立的执行上下文环境，可以避免外界访问或修改内部的变量，也避免了对内部变量的修改</p><h5 id="立即执行函数的其他写法"><a href="#立即执行函数的其他写法" class="headerlink" title="立即执行函数的其他写法"></a>立即执行函数的其他写法</h5><p>立即执行函数必须是一个表达式，不能是函数声明</p><p>当圆括号出现在匿名函数的末尾想要调用函数时，会默认将函数当成是函数声明</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="title function_">clg</span>(<span class="string">&quot;立即执行函数&quot;</span>) </span><br><span class="line">&#125;()  <span class="comment">// 错误写法</span></span><br></pre></td></tr></table></figure><p>当圆括号包裹函数时，会默认将函数作为表达式去解析，而不是函数声明</p><p>下面方法也可</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 3.其他写法</span></span><br><span class="line"><span class="comment">// 匿名函数</span></span><br><span class="line"><span class="comment">// (function(fn) &#123;</span></span><br><span class="line"><span class="comment">//   console.log(&#x27;立即执行函数被调用&#x27;)</span></span><br><span class="line"><span class="comment">// &#125;())</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// + - !</span></span><br><span class="line">+<span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;立即执行函数&#x27;</span>)</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><h3 id="8、代码规范"><a href="#8、代码规范" class="headerlink" title="8、代码规范"></a>8、代码规范</h3><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230302102120792.png" alt="image-20230302102120792"></p><h2 id="8-JavaScript的面向对象"><a href="#8-JavaScript的面向对象" class="headerlink" title="8.JavaScript的面向对象"></a>8.JavaScript的面向对象</h2><h3 id="1、对象类型的使用"><a href="#1、对象类型的使用" class="headerlink" title="1、对象类型的使用"></a>1、对象类型的使用</h3><p>对象类型是一种存储键值对（key-value）的更复杂的数据类型</p><ul><li>键值对可以是属性和方法</li><li>其中key是字符串<ul><li>key是字符串类型，但是在定义对象的属性名时，大部分情况下引号都是可以省略的</li></ul></li><li>value可以是任意类型，包括基本数据类型、函数类型、对象类型等</li></ul><p>两个术语：函数&#x2F;方法</p><p>​    函数（function）：如果在js中通过function默认定义一个结构，称之为函数</p><p>​    方法(method)：如果将一个函数放到对象中，并作为对象的一个属性，那么这个函数称之为方法</p><h5 id="创建对象和使用对象"><a href="#创建对象和使用对象" class="headerlink" title="创建对象和使用对象"></a>创建对象和使用对象</h5><p>创建对象的方式很多，包括三种：</p><ul><li>对象字面量：通过{}</li><li>new Object + 动态添加属性</li><li>new 其他类</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.字面量创建</span></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;why&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2.new object</span></span><br><span class="line"><span class="comment">// Object 构造函数</span></span><br><span class="line"><span class="keyword">var</span> obj2 = <span class="keyword">new</span> <span class="title class_">Object</span>()</span><br><span class="line">obj2.<span class="property">name</span> = <span class="string">&#x27;kobe&#x27;</span></span><br><span class="line"><span class="comment">// 3.new 其他类()</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> obj3 = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj3)</span><br></pre></td></tr></table></figure><p>属性之间是以逗号分割的</p><p>对象的使用：</p><ul><li>访问对象的属性</li><li>修改对象的属性</li><li>添加对象的属性</li><li>删除对象的属性：delete 关键字</li></ul><h5 id="方括号和引用的使用"><a href="#方括号和引用的使用" class="headerlink" title="方括号和引用的使用"></a>方括号和引用的使用</h5><p>对于多词属性来说，js是无法理解的</p><p>而点符号要求key是有效的变量标识符</p><ul><li>不包含空格、不以数字开头、也不包含特殊字符(允许使用$和_)</li></ul><p>这时候可以使用方括号来获取对象的属性 </p><h5 id="对象的遍历"><a href="#对象的遍历" class="headerlink" title="对象的遍历"></a>对象的遍历</h5><p>表示获取对象中所有的属性和方法</p><p>Object.keys() 方法会返回一个由一个给定对象的自身可枚举属性组成的数组</p><ul><li>普通的for循环</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> userKeys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(user)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; userKeys.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> key = userKeys[i]</span><br><span class="line">  <span class="keyword">var</span> value = user[key]</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`key: <span class="subst">$&#123;key&#125;</span>, value: <span class="subst">$&#123;value&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>for…in…遍历，key 即是属性，user[key] 这是对应的值</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> user) &#123;</span><br><span class="line">  <span class="keyword">var</span> value = user[key]</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`key: <span class="subst">$&#123;key&#125;</span>, value: <span class="subst">$&#123;value&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>for…of..不能遍历，因为对象默认是不可迭代的，for of 对数组有效</li></ul><h5 id="栈内存和堆内存"><a href="#栈内存和堆内存" class="headerlink" title="栈内存和堆内存"></a>栈内存和堆内存</h5><p>程序是需要加载到内存中执行的，我们可以将内存划分为两个区域，栈内存和堆内存</p><p>原始类型占据的空间是在栈内存中分配的</p><p>对象类型占据的空间是在堆内存中分配的</p><h3 id="2、值类型和引用类型"><a href="#2、值类型和引用类型" class="headerlink" title="2、值类型和引用类型"></a>2、值类型和引用类型</h3><p>原始类型的保存方式：在变量中保存的是值本身</p><ul><li>所以原始类型也被称之为值类型</li></ul><p>对象类型的保存方式：在变量中保存的是对象的“引用”</p><ul><li>所以对象类型也被称之为引用类型</li></ul><h3 id="3、函数的-this-指向"><a href="#3、函数的-this-指向" class="headerlink" title="3、函数的 this 指向"></a>3、函数的 this 指向</h3><p>函数中是有一个this的变量，this变量在大多数情况下会指向一个对象</p><p>使用 this 方便在一个方法中，拿到当前对象的一些属性</p><p>情况一：如果普通的函数被默认调用，即全局环境下默认调用一个函数，那么this指向的是window</p><p>情况二：如果函数它是被某一个对象来引用并且调用它，即通过对象调用，那么this对指向这个对象(调用的那个对象)</p><p>this代表的是当前调用对象</p><h3 id="4、工厂方法创建类"><a href="#4、工厂方法创建类" class="headerlink" title="4、工厂方法创建类"></a>4、工厂方法创建类</h3><h5 id="1-类和对象的思维方式"><a href="#1-类和对象的思维方式" class="headerlink" title="1.类和对象的思维方式"></a>1.类和对象的思维方式</h5><p>创建一些列类似的对象，比如学生、游戏英雄，都具有姓名学号，但是具体的值不同</p><p>方法1：手动创建，但是重复代码很多</p><p>方法2：for循环，但是不能修改具体的值</p><p>方法3：工厂函数，一种常见的设计模式，但在js中大可不必这样做</p><p>工厂方法创建对象有一个比较大的问题：我们在打印对象时，对象的类型都是Object类型</p><ul><li>但是从某些角度来说，这些对象应该有一个他们共同的类型</li></ul><h5 id="2-构造函数的方式：使用new关键词（操作符）"><a href="#2-构造函数的方式：使用new关键词（操作符）" class="headerlink" title="2.构造函数的方式：使用new关键词（操作符）"></a>2.构造函数的方式：使用new关键词（操作符）</h5><ul><li>构造函数也被称之为构造器，通常我们在创建对象时会调用的函数</li><li>在其他编程语言，构造函数存在于类中的一个方法，称为构造方法</li><li>但在js中，构造函数扮演了其他语言中类的角色</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">coder</span>(<span class="params">name, age, height</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">height</span> = height</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">running</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;running&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在函数调用的前面加上 new 关键字(操作符)</span></span><br><span class="line"><span class="keyword">var</span> stu1 = <span class="keyword">new</span> <span class="title function_">coder</span>(<span class="string">&quot;why&quot;</span>, <span class="number">21</span>, <span class="number">157</span>)</span><br></pre></td></tr></table></figure><p>也就是在 JavaScript 中，构造函数其实就是类的扮演者：</p><p>比如系统默认给我们提供的 Date 就是一个构造函数，也可以看成是一个类</p><p>在ES5之前，我们都是通过 function 来声明一个构造函数（类）的，之后通过 new 关键字来对其进行调用</p><p>在ES6之后，JavaScript 可以像别的语言一样，通过 class 来声明一个类</p><h3 id="5、构造函数和类"><a href="#5、构造函数和类" class="headerlink" title="5、构造函数和类"></a>5、构造函数和类</h3><h5 id="1-什么是类（构造函数）"><a href="#1-什么是类（构造函数）" class="headerlink" title="1.什么是类（构造函数）"></a>1.什么是类（构造函数）</h5><ul><li><p>现实生活中往往是根据一份描述&#x2F;一个模板来创建一个实体对象的</p></li><li><p>编程语言也是一样, 也必须先有一份描述, 在这份描述中说明将来创建出来的对象有哪些属性(成员变量)和行为(成员方法)</p></li></ul><p>比如现实生活中，我们会如此来描述一些事物：</p><ul><li><p>比如水果fruits是一类事物的统称，苹果、橘子、葡萄等是具体的对象；</p></li><li><p>比如人person是一类事物的统称，而Jim、Lucy、Lily、李雷、韩梅梅是具体的对象；</p></li></ul><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230303155836052.png" alt="image-20230303155836052"></p><p>对象是由类创建出来的，类相当于设计图纸，用于描述对象的内容(属性)</p><p>类在没有调用的情况下是没有在内存中创建的，使用需要new操作符</p><p>JavaScript中类的表示形式就是构造函数。</p><h5 id="2-JavaScript中的构造函数是怎么样的？"><a href="#2-JavaScript中的构造函数是怎么样的？" class="headerlink" title="2.JavaScript中的构造函数是怎么样的？"></a>2.JavaScript中的构造函数是怎么样的？</h5><p>构造函数也是一个普通的函数，从表现形式来说，和千千万万个普通的函数没有任何区别；</p><p>那么如果这么一个普通的函数被使用new操作符来调用了，那么这个函数就称之为是一个构造函数；</p><p>如果一个函数被使用new操作符调用了，那么它会执行如下操作：</p><ol><li><p>在内存中创建一个新的对象（空对象）；</p></li><li><p>这个对象内部的[[prototype]]属性会被赋值为该构造函数的prototype属性；</p></li><li><p>构造函数内部的this，会指向创建出来的新对象；</p></li><li><p>执行函数的内部代码（函数体代码）；</p></li><li><p>如果构造函数没有返回非空对象，则返回创建出来的新对象；</p></li></ol><p>构造函数可以确保我们的对象是有我们定义的类型的（例如：student）</p><h5 id="3-全局对象window了解"><a href="#3-全局对象window了解" class="headerlink" title="3.全局对象window了解"></a>3.全局对象window了解</h5><p>浏览器中存在一个全局对象 Object —&gt; window</p><p>作用1：查找变量时，最终会查到 window 头上</p><p>作用2：将我们一些浏览器全局提供给我们的变量&#x2F;函数&#x2F;对象，放在 window 对象上</p><p>作用3：使用 var 定义的变量会被默认添加到 window 上面(设计缺陷)</p><p>浏览器看到后面添加了<strong>var</strong> message 信息，会对前方 clg.window 进行刷新，所以前方打印的window对象中可以查看到 message定义的信息</p><p>函数也是对象</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义对象类型的变量</span></span><br><span class="line"><span class="comment">// 地址 -&gt; 指针 -&gt; 引用</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125; <span class="comment">// 堆内存</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125; <span class="comment">// 堆内存</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;&#125;  <span class="comment">// 堆内存</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// console.log(typeof obj)  //Object</span></span><br><span class="line"><span class="comment">// console.log(typeof foo)  // function -&gt; object</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Dog</span>(<span class="params"></span>) &#123; &#125;</span><br><span class="line"><span class="comment">// 构造函数上(类上面) 添加的函数，称之为类方法</span></span><br><span class="line"><span class="title class_">Dog</span>.<span class="property">running</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="title class_">Dog</span>.<span class="title function_">running</span>()</span><br></pre></td></tr></table></figure><h2 id="9-JavaScript常见的内置类"><a href="#9-JavaScript常见的内置类" class="headerlink" title="9.JavaScript常见的内置类"></a>9.JavaScript常见的内置类</h2><h3 id="1、认识包装类型"><a href="#1、认识包装类型" class="headerlink" title="1、认识包装类型"></a>1、认识包装类型</h3><p>原始类型的包装类</p><p>js的原始类型并非对象类型，所以理论上，他们是没法获取属性或调用方法的</p><p>那么出现这样的现象，是因为js为了使其可以获取属性和调用方法，对其封装了对应的包装类型</p><p>常见的包装类型：String、Number、Boolean、Symbol、Bigint类型</p><p>包装类型的使用过程，当我们使用原始类型的属性或者方法时</p><ul><li><p>根据原始值，创建一个原始类型对应的包装类型对象</p></li><li><p>调用对应的属性或者方法，返回一个新的值</p></li><li><p>创建的包装类对象被销毁</p></li><li><p>通常JavaScript引擎会进行很多的优化，它可以跳过创建包装类的过程在内部直接完成属性的获取或者方法的调用</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;why&quot;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> num1)  <span class="comment">// object</span></span><br></pre></td></tr></table></figure><p>注意事项：null、undefined 没有任何的方法，也没有对应的 “ 对象包装型 ”</p><h3 id="2、数字类型Number"><a href="#2、数字类型Number" class="headerlink" title="2、数字类型Number"></a>2、数字类型Number</h3><h4 id="1-属性补充："><a href="#1-属性补充：" class="headerlink" title="1.属性补充："></a>1.属性补充：</h4><ul><li>Number.MAX_SAFE_INTEGER：JavaScript 中最大的安全整数 (2^53 - 1) </li><li>Number.MIN_SAFE_INTEGER：JavaScript 中最小的安全整数 -(2^53 - 1)</li></ul><h4 id="2-实例方法补充"><a href="#2-实例方法补充" class="headerlink" title="2.实例方法补充"></a>2.实例方法补充</h4><p> 方法一：toString(base)，将数字转成字符串，并且按照base进制进行转化</p><ul><li><p>base 的范围可以从 2 到 36，默认情况下是 10； </p></li><li><p>注意：如果是直接对一个数字操作，需要使用..运算符；</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num1.<span class="title function_">toString</span>(<span class="number">2</span>))  <span class="comment">// 转成2进制</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1000.</span>.<span class="title function_">toString</span>(<span class="number">2</span>))</span><br></pre></td></tr></table></figure><p>方法二：toFixed(digits)，格式化一个数字，保留digits位的小数，返回值是string类型； </p><ul><li><p>digits的范围是0到20（包含）之间；</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类方法：</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">parseInt</span>()  通过类名调用</span><br><span class="line"><span class="comment">// 实例方法：</span></span><br><span class="line"><span class="number">123.</span>.<span class="title function_">toFixed</span>(<span class="number">2</span>) 通过具体的对象调用</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-类方法补充"><a href="#3-类方法补充" class="headerlink" title="3.类方法补充"></a>3.类方法补充</h4><p>方法一：Number.parseInt(string[, radix])，将字符串解析成整数，也有对应的全局方法parseInt，不会四舍五入</p><p>方法二：Number. parseFloat(string)，将字符串解析成浮点数，也有对应的全局方法parseFloat</p><h3 id="3、数字对象Math"><a href="#3、数字对象Math" class="headerlink" title="3、数字对象Math"></a>3、数字对象Math</h3><p>Math 是一个内置对象（不是一个构造函数），它拥有一些数学常数属性和数学函数方法</p><p>常见的属性</p><ul><li>Math.PI：圆周率</li><li>Math.ceil：向上舍入取整 </li><li>Math.round：四舍五入取整 </li><li>Math.random：生成0~1的随机数（包含0，不包含1）</li><li>Math.pow(x, y)：返回x的y次幂</li></ul><h3 id="4、字符串类型String"><a href="#4、字符串类型String" class="headerlink" title="4、字符串类型String"></a>4、字符串类型String</h3><p>String 类提供了我们对于字符串各种操作的属性和方法</p><h4 id="1-常见的属性"><a href="#1-常见的属性" class="headerlink" title="1.常见的属性"></a>1.常见的属性</h4><ul><li>length：获取字符串的长度</li></ul><p>操作一：访问字符串的字符 </p><p>使用方法一：通过字符串的索引 str[0] </p><p>使用方法二：通过str.charAt(pos)方法 </p><p>它们的区别是索引的方式没有找到会返回undefined，而charAt没有找到会返回空字符串； </p><p>练习：字符串的遍历 </p><p>方式一：普通for循环</p><p>方式二：for..of..遍历</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// for...of...的遍历 -&gt; 迭代器</span></span><br><span class="line"><span class="comment">// 目前的可迭代对象：字符串/数组</span></span><br><span class="line"><span class="comment">// 对象不支持 for  of</span></span><br><span class="line"><span class="comment">// string 对象内部是将字符串变成了一个可迭代对象</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> char <span class="keyword">of</span> message) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(char)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-修改字符串"><a href="#2-修改字符串" class="headerlink" title="2.修改字符串"></a>2.修改字符串</h4><p>字符串的不可变性</p><ul><li>字符串在定义后是不可修改的</li></ul><p>在我们改变很多字符串的操作中，都是生成了一个新的字符串</p><p>比如改变字符串大小的两个方法 </p><ul><li><p>toLowerCase()：将所有的字符转成小写； </p></li><li><p>toUpperCase()：将所有的字符转成大写；</p></li></ul><h4 id="3-查找字符串"><a href="#3-查找字符串" class="headerlink" title="3.查找字符串"></a>3.查找字符串</h4><p>方法1：str.indexOf(searchValue[, fromIndex])</p><ul><li>从fromIndex开始，查找searchValue的索引</li><li>没有找到则返回-1</li><li>类似的方法 lastIndexOf，从最后开始查找（用的较少）</li></ul><p>方法2：是否包含字符串 str.includes(searchString[, position])</p><ul><li>position位置开始查找searchString， 根据情况返回 true 或 false</li><li>这是ES6新增的方法</li></ul><p>方法3：以xxx开头 str.startWith(searchString[, position])</p><ul><li>从position位置开始，判断字符串是否以searchString开头</li><li>这是ES6新增的方法，下面的方法也一样</li></ul><p>方法4：以xxx结尾 str.endWith(searchString[, length])</p><ul><li>length长度内，判断字符串是否以searchString结尾</li></ul><p>方法5：替换字符串 str.replace(regexp|substr,newSubStr|function)</p><ul><li>查找到对应的字符串，并且使用新的字符串进行替代</li><li>也可以传入一个正则表达式来查找，也可以传入一个函数来替换</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> message = <span class="string">&quot;my name is why.&quot;</span></span><br><span class="line">   <span class="keyword">var</span> name = <span class="string">&#x27;why&#x27;</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 判断一个字符串中是否有另外一个字符串</span></span><br><span class="line">   <span class="comment">// 1.indexOf(searchString, fromIndex)</span></span><br><span class="line">   <span class="comment">// 返回的结果是一个索引值</span></span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">     index:</span></span><br><span class="line"><span class="comment">       情况1：搜索到：搜索字符串所在的索引位置</span></span><br><span class="line"><span class="comment">       情况2：没有搜索到，返回-1</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"> <span class="comment">//  var index = message.indexOf(name)</span></span><br><span class="line"> <span class="comment">//  if (message.indexOf(name) !== -1) &#123;</span></span><br><span class="line"> <span class="comment">//   console.log(&quot;message中包含name&quot;)</span></span><br><span class="line"> <span class="comment">//  &#125; else &#123;</span></span><br><span class="line"> <span class="comment">//   console.log(&quot;message中不包含name&quot;)</span></span><br><span class="line"> <span class="comment">//  &#125;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 方法2：es6中新增一个方法，来判断包含关系</span></span><br><span class="line"> <span class="comment">// if (message.includes(name)) &#123;</span></span><br><span class="line"> <span class="comment">//   console.log(&quot;message中包含name&quot;)</span></span><br><span class="line"> <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 3.startWith:是否以xxx开头</span></span><br><span class="line"> <span class="comment">// if (message.startsWith(&quot;my&quot;)) &#123;</span></span><br><span class="line"> <span class="comment">//   console.log(&quot;message以my开头&quot;)</span></span><br><span class="line"> <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 4.endWith:是否以xxx结尾</span></span><br><span class="line"> <span class="comment">// if (message.endsWith(&#x27;why&#x27;)) &#123;</span></span><br><span class="line"> <span class="comment">//   console.log(&quot;message以why结尾&quot;)</span></span><br><span class="line"> <span class="comment">// &#125; else &#123;</span></span><br><span class="line"> <span class="comment">//   console.log(&quot;no&quot;)</span></span><br><span class="line"> <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 5.替换字符串 replace</span></span><br><span class="line"> <span class="comment">// var newMessage = message.replace(&quot;why&quot;, &quot;kobe&quot;)</span></span><br><span class="line"> <span class="comment">// console.log(newMessage)</span></span><br><span class="line"> <span class="keyword">var</span> newName = <span class="string">&quot;kobe&quot;</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">var</span> newMessage = message.<span class="title function_">replace</span>(<span class="string">&quot;why&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> newName.<span class="title function_">toUpperCase</span>()</span><br><span class="line"> &#125;)</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(newMessage)</span><br></pre></td></tr></table></figure><p>获取子字符串</p><table><thead><tr><th>方法</th><th>选择方式</th><th>负值参数</th></tr></thead><tbody><tr><td>slice(start,end)</td><td>从start到end（不含end）</td><td>允许</td></tr><tr><td>substring(start,end)</td><td>从start到end（不含end）</td><td>负值代表0</td></tr><tr><td>substr(start,length)</td><td>从start开始获取长为 length 的字符串</td><td>允许start为负数</td></tr></tbody></table><p>substr 方法可能有的浏览器不支持，推荐slcie，负值：-1表示为最后一位</p><h4 id="4-字符串的拼接"><a href="#4-字符串的拼接" class="headerlink" title="4.字符串的拼接"></a>4.字符串的拼接</h4><p>方法：</p><ul><li><p>运用 + 运算符</p></li><li><p>str1.concat(str2)   括号中的是可变参数，支持链式编程</p></li></ul><p>删除首尾空格：str.trim()</p><h4 id="6-字符串切割与改变连接方式"><a href="#6-字符串切割与改变连接方式" class="headerlink" title="6.字符串切割与改变连接方式"></a>6.字符串切割与改变连接方式</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> message = <span class="string">&quot;223-423-422-122-352&quot;</span></span><br><span class="line">   <span class="keyword">var</span> items = message.<span class="title function_">split</span>(<span class="string">&quot;-&quot;</span>)  <span class="comment">// 返回值是一个string类型的数组</span></span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(items)</span><br><span class="line">   <span class="comment">// 将此数组改为以 * 连接的字符串</span></span><br><span class="line">   <span class="keyword">var</span> newMessage = items.<span class="title function_">join</span>(<span class="string">&quot;*&quot;</span>)</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(newMessage)</span><br></pre></td></tr></table></figure><p>补充 string 方法</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;124&quot;</span></span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">padStart</span>(<span class="number">4</span>, <span class="string">&quot;0&quot;</span>))   <span class="comment">// 0124</span></span><br></pre></td></tr></table></figure><h3 id="5、数组Array使用详解"><a href="#5、数组Array使用详解" class="headerlink" title="5、数组Array使用详解"></a>5、数组Array使用详解</h3><h4 id="1-什么是数组"><a href="#1-什么是数组" class="headerlink" title="1.什么是数组"></a>1.什么是数组</h4><p>是一种有序的组合，里面的元素是按照一定顺序来排列的，可以通过索引查找</p><p>数组和对象都是一种保存多个数据的数据结构</p><p>通过 [ ] 创建</p><ul><li>数组是一种特殊的对象类型</li></ul><p>通过构造函数 Array 创建</p><ul><li>new Array()  &#x2F;&#x2F; () 里面可以传入数据  “ ”  ，但是如果传入一个数字类型，会默认当成我们要创建一个对应长度的数组</li></ul><p>数组元素从0开始索引</p><ul><li>一些编程语言可以通过 arr[-1] 来访问最后一个元素</li><li>js并不支持这种写法，访问最后一个元素：arr[arr.length-1]</li></ul><h4 id="2-数组的基本操作"><a href="#2-数组的基本操作" class="headerlink" title="2.数组的基本操作"></a>2.数组的基本操作</h4><h5 id="1、访问数组中的元素"><a href="#1、访问数组中的元素" class="headerlink" title="1、访问数组中的元素"></a>1、访问数组中的元素</h5><ul><li>arr[index]</li><li>arr.at(index)<ul><li>如果index &gt;&#x3D; 0，则与arr[index] 的情况相同</li><li>对于index为负数的情况，它则从数组的尾部向前数</li></ul></li></ul><h5 id="2、修改数组中的元素"><a href="#2、修改数组中的元素" class="headerlink" title="2、修改数组中的元素"></a>2、修改数组中的元素</h5><p>arr[index] &#x3D; “coderwhy”</p><h5 id="3、删除"><a href="#3、删除" class="headerlink" title="3、删除"></a>3、删除</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">delete</span> names[<span class="number">2</span>] </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(names)  <span class="comment">// 索引为2的位置为empty</span></span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(names[<span class="number">2</span>])  <span class="comment">// 查询结果为undefined</span></span><br></pre></td></tr></table></figure><p>删除和添加元素虽然也可以通过索引来直接操作，但是开发中很少这样操作。</p><p>具体的操作方法</p><ul><li>添加&#x2F;删除尾部<ul><li>push()：在尾部添加元素，为可变参数</li><li>pop()：在尾部删除元素，一次只能删除一个元素</li></ul></li><li>添加&#x2F;删除首部<ul><li>unshift()：在首部添加元素，为可变参数， 在首端添加元素，整个其他数组元素向后移动</li><li>shift()：在首部删除元素，一次只能删除一个元素， 取出队列首端的一个元素，整个数组元素向前前移动</li></ul></li></ul><p>相对来说，push和pop的运行比较快</p><p>删除方法2：</p><ul><li>arr.splice</li></ul><p>语法结构：arr.splice(start, deleteCount, [, item1[, item2[,item3]…]])</p><p>从start位置开始，删除deleteCount（0代表不删除)个元素，后面的则为添加items</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除元素</span></span><br><span class="line">names.<span class="title function_">splice</span>(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(names)</span><br><span class="line"><span class="comment">// 新增元素</span></span><br><span class="line">names.<span class="title function_">splice</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="string">&quot;ssx&quot;</span>, <span class="string">&quot;ccg&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(names)</span><br><span class="line"><span class="comment">// 替换元素</span></span><br><span class="line">names.<span class="title function_">splice</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;vc&quot;</span>, <span class="string">&quot;ccc&quot;</span>, <span class="string">&quot;kobe&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(names)</span><br></pre></td></tr></table></figure><p>这个方法会修改原数组</p><p>length 属性：用于获取数组的长</p><ul><li>当我们修改出租的时候，length 属性会自动更新</li></ul><p>length属性是可写的</p><ul><li>如果我们手动增加一个默认大于length的数值，那么会增加数组的长度</li><li>但是如果我们减少它，数组会被截断</li></ul><p>清空数组的最简单的方法就是：arr.length &#x3D; 0</p><h5 id="4、数组的遍历"><a href="#4、数组的遍历" class="headerlink" title="4、数组的遍历"></a>4、数组的遍历</h5><ul><li>普通的 for 循环</li><li>for..in 遍历：获取到的 index 为索引值，arr[index] 为 value 值</li><li>for..of 遍历：获取不到索引值，能获取到每一个元素</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2.1 普通的for 循环</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; names.<span class="property">length</span>; i++) &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(names[i])</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 2.2 for...in</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">var</span> index <span class="keyword">in</span> names) &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(index, names[index])  <span class="comment">// 索引</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 2.3 for...of</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">var</span> items <span class="keyword">of</span> names) &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(items)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h5 id="5、数组方法"><a href="#5、数组方法" class="headerlink" title="5、数组方法"></a>5、数组方法</h5><ul><li>arr.slice 方法：用于对数组进行截取，不会修改原数组，类似于字符串的slice方法<ul><li>arr.slice(start, end) 截取到的元素包含strat，但不包含end 元素</li></ul></li><li>arr.concat 方法：创建一个新的数组，其中包含来自于其他数组和其他项的值<ul><li>var newArr &#x3D; arr.concat(“ssd”, “ssx”, “ccc”)</li></ul></li><li>arr.join 方法：将一个数组的所有元素连接成一个字符串并返回这个字符串<ul><li>console.log(arr.join(“-“))</li></ul></li></ul><h5 id="6、查找元素"><a href="#6、查找元素" class="headerlink" title="6、查找元素"></a>6、查找元素</h5><ul><li>arr.indexOf(searchElement[, fromIndex]) 方法，查找某个元素的索引<ul><li>从 fromIndex 开始查找，如果找到则返回索引，没找到返回-1</li><li>也有对应的从最后位置开始查找的 lastIndexOf 方法</li><li>对于复杂数据类型的不便于查找，使用 for 循环也可以实现</li></ul></li><li>arr.includes 方法：判断数组是否包含某个元素<ul><li>arr.includes(valueToFind[, fromIndex])</li><li>从索引from开始查找item，找到则返回true，找不到返回false</li></ul></li><li>find 和 findIndex 直接查找元素或者元素的索引（es6之后）</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> findStu = students.<span class="title function_">find</span>(<span class="keyword">function</span>(<span class="params">item</span>)&#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(item)</span><br><span class="line">     <span class="keyword">return</span> item.<span class="property">id</span> = <span class="number">101</span></span><br><span class="line">   &#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(findStu)</span><br></pre></td></tr></table></figure><h5 id="7、排序和反转"><a href="#7、排序和反转" class="headerlink" title="7、排序和反转"></a>7、排序和反转</h5><p>方法1：算法实现排序</p><p>方法2：使用 sort 高级函数，排序之后生成一个新的数组，可用于复杂类型的数组</p><ul><li><p>如果 compareFunction(a, b) 小于 0 ，那么 a 会被排列到 b 前面； </p></li><li><p>如果 compareFunction(a, b) 等于 0 ， a 和 b 的相对位置不变； </p></li><li><p>如果 compareFunction(a, b) 大于 0 ， b 会被排列到 a 前面； </p></li><li><p>也就是说，谁小谁排在前面；</p></li></ul><p> reverse() 方法将数组中元素的位置颠倒，并返回该数组</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">num.<span class="title function_">sort</span>(<span class="keyword">function</span>(<span class="params">item1, item2</span>) &#123;</span><br><span class="line">     <span class="comment">// item1 和 item2 进行比较</span></span><br><span class="line">     <span class="comment">// 返回的是 正数</span></span><br><span class="line">     <span class="comment">// 谁小谁在前</span></span><br><span class="line">     <span class="keyword">return</span> item1 - item2  <span class="comment">//升序</span></span><br><span class="line">     <span class="comment">// return item2 - item1  //降序</span></span><br><span class="line">   &#125;)</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(num)</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(num.<span class="title function_">reverse</span>())  <span class="comment">// 反转</span></span><br></pre></td></tr></table></figure><h5 id="8、数组的其他高阶函数"><a href="#8、数组的其他高阶函数" class="headerlink" title="8、数组的其他高阶函数"></a>8、数组的其他高阶函数</h5><p>arr.forEach  参数（item,index,arr）</p><ul><li>遍历数组，并且让数组中每一个元素都执行一次对应的方法</li></ul><p>arr.map   参数（item,index,arr）</p><ul><li>map() 方法创建一个新数组</li><li>这个新数组由原数组中的每个元素都调用一次提供的函数后的返回值组成</li></ul><p>arr.filter   参数（item,index,arr）</p><ul><li>filter() 方法创建一个新数组</li><li>新数组中只包含每个元素调用函数返回为true的元素</li></ul><p>arr.reduce  参数（preValue, item） preValue 可以传入一个0  作为第一次执行的preValue</p><ul><li>用于计算数组中所有元素的总和</li><li>对数组中的每个元素按序执行一个由您提供的 reducer 函数</li><li>每一次运行 reducer 会将先前元素的计算结果作为参数传入，最后将其结果汇总为单个返回值</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">综合练习：过滤所有的偶数 计算偶数的平方 再求和</span><br><span class="line">    <span class="keyword">var</span> total = num.<span class="title function_">filter</span>(<span class="keyword">function</span>(<span class="params">item</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> item % <span class="number">2</span> === <span class="number">0</span></span><br><span class="line">    &#125;).<span class="title function_">map</span>(<span class="keyword">function</span>(<span class="params">item</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> item * item</span><br><span class="line">    &#125;).<span class="title function_">reduce</span>(<span class="keyword">function</span>(<span class="params">preValue, item</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> preValue + item</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(total)</span><br></pre></td></tr></table></figure><h3 id="6、Date类型的使用"><a href="#6、Date类型的使用" class="headerlink" title="6、Date类型的使用"></a>6、Date类型的使用</h3><h4 id="1-创建Date对象"><a href="#1-创建Date对象" class="headerlink" title="1.创建Date对象"></a>1.创建Date对象</h4><p>在 js 中使用 Date 来表示和处理时间</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Date 构造函数的以下用法</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>()  <span class="comment">// 当前时间</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&quot;2022-08-08&quot;</span>)   <span class="comment">// 传入参数，时间字符串</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">2022</span>, <span class="number">02</span>, <span class="number">03</span>, <span class="number">06</span>, <span class="number">15</span>, <span class="number">06</span>, <span class="number">33</span>) <span class="comment">// 传入具体的年月日时分秒毫秒</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">1000267496623</span>) <span class="comment">// 传入一个Unix时间戳  1s -&gt; 1000ms</span></span><br></pre></td></tr></table></figure><h4 id="2-dateString-时间的表示方式"><a href="#2-dateString-时间的表示方式" class="headerlink" title="2. dateString 时间的表示方式"></a>2. dateString 时间的表示方式</h4><p>日期的表示方式有两种：RFC 2822 标准 或者 ISO 8601 标准</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date)  <span class="comment">//  Wed Mar 08 2023 09:52:44 GMT+0800 (中国标准时间) </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date.<span class="title function_">toDateString</span>())  <span class="comment">// Wed Mar 08 2023</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date.<span class="title function_">toISOString</span>())  <span class="comment">// 2023-03-08T01:52:44.254Z 标准时间 不是北京时间</span></span><br></pre></td></tr></table></figure><p>可以将其转化成ISO 8601标准的：  </p><p>YYYY：年份，0000 ~ 9999</p><p>MM：月份，01 ~ 12</p><p>DD：日，01 ~ 31</p><p>T：分隔日期和时间，没有特殊含义，可以省略</p><p>HH：小时，00 ~ 24 </p><p>mm：分钟，00 ~ 59 </p><p>ss：秒，00 ~ 59</p><p>.sss：毫秒  Z：时区</p><h4 id="3-Date-对象的方法"><a href="#3-Date-对象的方法" class="headerlink" title="3.Date 对象的方法"></a>3.Date 对象的方法</h4><p>我们可以从Date对象中获取各种详细的信息： </p><ul><li><p>getFullYear()：获取年份（4 位数）</p></li><li><p>getMonth()：获取月份，从 0 到 11</p></li><li><p>getDate()：获取当月的具体日期，从 1 到 31（方法名字有点迷）</p></li><li><p>getHours()：获取小时</p></li><li><p>getMinutes()：获取分钟</p></li><li><p>getSeconds()：获取秒钟</p></li><li><p>getMilliseconds()：获取毫秒</p></li><li><p>getDay()：获取一周中的第几天，从 0（星期日）到 6（星期六）</p></li></ul><p>设置信息的方法</p><ul><li>setFullYear(year, [month], [date]) </li><li>setMonth(month, [date]) </li><li>setDate(date) </li><li>setHours(hour, [min], [sec], [ms]) </li><li>setMinutes(min, [sec], [ms]) </li><li>setSeconds(sec, [ms]) </li><li>setMilliseconds(ms) </li><li>setTime(milliseconds)</li></ul><p>设置超范围的数值，它会自动校准</p><h4 id="4-Date-获取-Unix-时间戳"><a href="#4-Date-获取-Unix-时间戳" class="headerlink" title="4.Date 获取 Unix 时间戳"></a>4.Date 获取 Unix 时间戳</h4><p>Unix 时间戳：它是一个整数值，表示自1970年1月1日00:00:00 UTC以来的毫秒数</p><p>前面可知，我们可以通过传入一个时间戳来获取其表示的时间</p><p>获取当前的时间戳：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">方法<span class="number">1</span>：<span class="keyword">var</span> timestamp1 = <span class="title class_">Date</span>.<span class="title function_">now</span>()</span><br><span class="line">方法<span class="number">2</span>：<span class="keyword">var</span> date = <span class="keyword">new</span> <span class="title class_">Date</span>()</span><br><span class="line">  <span class="keyword">var</span> timestamp2 = date.<span class="title function_">getTime</span>()</span><br><span class="line">方法<span class="number">3</span>：<span class="variable language_">console</span>.<span class="title function_">log</span>(+date)  <span class="comment">// +运算符</span></span><br><span class="line">可写为：<span class="keyword">var</span> timestamp5 = +<span class="keyword">new</span> <span class="title class_">Date</span>()</span><br></pre></td></tr></table></figure><p>将一个对象转成时间戳：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> date2 = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&quot;2033-03-03&quot;</span>)</span><br><span class="line">方法<span class="number">1</span>：<span class="keyword">var</span> timestamp3 = date2.<span class="title function_">getTime</span>()</span><br><span class="line">方法<span class="number">2</span>：<span class="keyword">var</span> timestamp4 = date2.<span class="title function_">valueOf</span>()</span><br><span class="line">方法<span class="number">3</span>：<span class="variable language_">console</span>.<span class="title function_">log</span>(+date2)</span><br><span class="line">可写为：<span class="keyword">var</span> timestamp6 = +<span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&quot;2033-03-03&quot;</span>)</span><br></pre></td></tr></table></figure><p>时间戳的作用：例如：计算一个操作花费的时间</p><h4 id="5-Date-parse-方法"><a href="#5-Date-parse-方法" class="headerlink" title="5.Date.parse 方法"></a>5.Date.parse 方法</h4><p> Date.parse(str) 方法可以从一个字符串中读取日期，并且输出对应的Unix时间戳</p><ul><li><p>作用等同于 new Date(dateString).getTime() 操作</p></li><li><p>需要符合 RFC2822 或 ISO 8601 日期格式的字符串</p></li><li><p>其他格式也许也支持，但结果不能保证一定正常</p></li><li><p>如果输入的格式不能被解析，那么会返回NaN</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> timeString = <span class="string">&quot;2033-2-3&quot;</span></span><br><span class="line"><span class="keyword">var</span> timestamp = <span class="title class_">Date</span>.<span class="title function_">parse</span>(timeString)</span><br></pre></td></tr></table></figure><h2 id="10-JavaScript-的-DOM-操作"><a href="#10-JavaScript-的-DOM-操作" class="headerlink" title="10.JavaScript 的 DOM 操作"></a>10.JavaScript 的 DOM 操作</h2><h3 id="1、什么是DOM"><a href="#1、什么是DOM" class="headerlink" title="1、什么是DOM"></a>1、什么是DOM</h3><p>学完以上ECMAScript 语法，我们还需要学习浏览器提供开发者的DOM、BOM相关的API才能对网页、浏览器进行操作</p><p>window 全局对象不仅提供了js语法部分的Object\Arry\Date等，也提供了DOM\BOM部分</p><p>DOM：浏览器考虑到开发者与用户可能需要对网页元素做某些操作，会将网页元素抽象成JS对象</p><ul><li>即将网页所有的元素表示为可以修改的对象</li><li>所以这些对象都可以通过 JS 来对其进行访问，所以可以通过 JS 来操作页面</li><li>这个抽象过程称之为文档对象模型，称之为 Document Object Model</li><li>作为了JS语法与网页元素的桥梁</li></ul><p>BOM：浏览器对象模型</p><ul><li>由浏览器提供的用于处理文档之外的所有的其他对象</li><li>比如 navigator、location、history 等对象</li></ul><h3 id="2、认识DOM-Tree"><a href="#2、认识DOM-Tree" class="headerlink" title="2、认识DOM Tree"></a>2、认识DOM Tree</h3><p>在 html 结构中，所有元素都会形成一个树结构（节点是元素）</p><p>抽象为 DOM 之后也会形成 DOM Tree （节点是抽象的对象）</p><h3 id="3、DOM-的整体结构"><a href="#3、DOM-的整体结构" class="headerlink" title="3、DOM 的整体结构"></a>3、DOM 的整体结构</h3><p>DOM相当于是JavaScript和HTML、CSS之间的桥梁</p><ul><li>通过浏览器提供给我们的DOM API，我们可以对元素以及其中的内容做任何事情；</li></ul><p>DOM的继承关系</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230309102756157.png" alt="image-20230309102756157"></p><p>document 对象</p><p>Document节点表示的整个载入的网页，它的实例是全局的document对象：</p><ul><li><p>对DOM的所有操作都是从 document 对象开始的</p></li><li><p>它是DOM的入口点，可以从document开始去访问任何节点元素</p></li></ul><p>对于最顶层的html、head、body元素，我们可以直接在document对象中获取到：</p><ul><li><p>html元素： &#x3D; document.documentElement</p></li><li><p>body元素： &#x3D; document.body</p></li><li><p>head元素： &#x3D; document.head</p></li><li><p>文档声明： &#x3D; document.doctype</p></li></ul><h3 id="4、节点、元素导航"><a href="#4、节点、元素导航" class="headerlink" title="4、节点、元素导航"></a>4、节点、元素导航</h3><h4 id="1-节点之间导航"><a href="#1-节点之间导航" class="headerlink" title="1.节点之间导航"></a>1.节点之间导航</h4><p>如果我们获取到一个节点（Node）后，可以根据这个节点去获取其他的节点，我们称之为节点之间的导航</p><p>节点之间存在如下的关系：</p><ul><li><p>父节点：parentNode</p></li><li><p>前兄弟节点：previousSibling</p></li><li><p>后兄弟节点：nextSibling</p></li><li><p>子节点：childNodes</p></li><li><p>第一个子节点：firstChild</p></li><li><p>第二个子节点：lastChild</p></li></ul><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230311132712739.png" alt="image-20230311132712739"></p><h4 id="2-元素之间导航"><a href="#2-元素之间导航" class="headerlink" title="2.元素之间导航"></a>2.元素之间导航</h4><p>如果我们获取到一个元素（Element）后，可以根据这个元素去获取其他的元素，我们称之为元素之间的导航。</p><p>节点之间存在如下的关系：</p><ul><li><p>父元素：parentElement</p></li><li><p>前兄弟节点：previousElementSibling</p></li><li><p>后兄弟节点：nextElementSibling</p></li><li><p>子节点：children</p></li><li><p>第一个子节点：firstElementChild</p></li><li><p>第二个子节点：lastElementChild</p></li></ul><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230311132841099.png" alt="image-20230311132841099"></p><h4 id="3-table元素之间的导航"><a href="#3-table元素之间的导航" class="headerlink" title="3.table元素之间的导航"></a>3.table元素之间的导航</h4><p>table 还元素支持以下这些属性：</p><ul><li><p>table.rows —  tr元素的集合</p></li><li><p>table.caption&#x2F;tHead&#x2F;tFoot — 引用元素caption、thead、tfoot </p></li><li><p>table.tBodies — tbody 元素的集合</p></li></ul><p>thead、tfoot、tbody 元素提供了 rows 属性</p><ul><li>tbody.rows — 表格内部 tr 元素的集合</li></ul><p>tr：</p><ul><li><p>tr.cells — 在给定 tr 中的 td 和 th 单元格的集合</p></li><li><p>tr.sectionRowIndex — 给定的 tr 在封闭的 thead&#x2F;tbody&#x2F;tfoot 中的位置（索引）</p></li><li><p>tr.rowIndex — 在整个表格中 tr 的编号（包括表格的所有行）</p></li></ul><p>td 和 th</p><ul><li>td.cellIndex — 在封闭的 tr 中单元格的编号</li></ul><h4 id="4-form元素之间的导航"><a href="#4-form元素之间的导航" class="headerlink" title="4.form元素之间的导航"></a>4.form元素之间的导航</h4><p>获取 form 元素可以通过节点和元素的方法获取，也可以通过forms获取；</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> formEl = <span class="variable language_">document</span>.<span class="property">forms</span>[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>form 元素中的内容可以通过 elements 来获取：form.elements</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> elements = formEl.<span class="property">elements</span></span><br></pre></td></tr></table></figure><p>获取 form 中的子元素还可以通过 name 其属性获取</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> inputEl = formEl.<span class="property">elements</span>.<span class="property">account</span></span><br></pre></td></tr></table></figure><p>作用是有时能够以此来获取 input 表单的 value</p><h3 id="5、获取元素的方法"><a href="#5、获取元素的方法" class="headerlink" title="5、获取元素的方法"></a>5、获取元素的方法</h3><p>DOM 提供的获取元素的方法：</p><table><thead><tr><th>方法名</th><th>搜索方式</th><th>可以在元素上调用？</th><th>实时？</th></tr></thead><tbody><tr><td>querySelector</td><td>css-selector</td><td>√</td><td>-</td></tr><tr><td>querySelectorAll</td><td>css-selector</td><td>√</td><td>-</td></tr><tr><td>getElementById</td><td>id</td><td>-</td><td>-</td></tr><tr><td>getElementByName</td><td>name</td><td>-</td><td>√</td></tr><tr><td>getElementByTagName</td><td>tar or ‘*’</td><td>√</td><td>√</td></tr><tr><td>getElementByClassName</td><td>class</td><td>√</td><td>√</td></tr></tbody></table><p>目前最常用的是querySelector和querySelectAll </p><p>getElementById偶尔也会使用或者在适配一些低版本浏览器时；</p><h3 id="6、Node-节点的属性"><a href="#6、Node-节点的属性" class="headerlink" title="6、Node 节点的属性"></a>6、Node 节点的属性</h3><h4 id="1-nodeType属性："><a href="#1-nodeType属性：" class="headerlink" title="1.nodeType属性："></a>1.nodeType属性：</h4><ul><li><p>nodeType 属性提供了一中获取节点类型的方法</p></li><li><p>它有一个数值型值</p></li></ul><p>常见的节点类型：</p><table><thead><tr><th>常量</th><th>值</th><th>描述</th></tr></thead><tbody><tr><td>Node.ELEMENT_NODE</td><td>1</td><td>一个元素节点，例如p元素和div元素</td></tr><tr><td>Node.TEXT_NODE</td><td>3</td><td>Element 或者 Attr 中实际的 文字</td></tr><tr><td>Node.COMMENT_NODE</td><td>8</td><td>一个 Comment 节点。</td></tr><tr><td>Node.DOCUMENT_NODE</td><td>9</td><td>一个 Document 节点。</td></tr><tr><td>Node.DOCUMENT_TYPE_NODE</td><td>10</td><td>描述文档类型的DocumentType 节点。例如<!DCOTYPE html></td></tr></tbody></table><p>nodeName：获取节点的名字</p><p>tagName：获取元素的名称</p><ul><li><p>tagName 属性仅适用于 Element 节点；</p></li><li><p>nodeName 是为任意 Node 定义的：</p><ul><li>对于元素，它的意义与 tagName 相同，所以使用哪一个都是可以的；</li><li>对于其他节点类型（text，comment 等），它拥有一个对应节点类型的字符串</li></ul></li></ul><p>nodeValue&#x2F;data： 用于获取非元素节点的文本内容</p><p>innerHTML 属性</p><ul><li>将元素中的 HTML 获取为字符串形式； </li><li>设置元素中的内容；</li></ul><p>outerHTML 属性</p><ul><li>包含了元素的完整 HTML</li><li>innerHTML 加上元素本身一样；</li></ul><p>textContent 属性</p><ul><li>仅仅获取元素中的文本内容；</li></ul><p>innerHTML和textContent的区别：</p><ul><li>仅仅设置文本的话作用相同</li></ul><p>内容带标签的话</p><ul><li><p>使用 innerHTML，我们将其“作为 HTML”插入，带有所有 HTML 标签</p></li><li><p>使用 textContent，我们将其“作为文本”插入，所有符号（symbol）均按字面意义处理</p></li></ul><p>全局属性 hidden：可以用于设置元素隐藏</p><p>一个元素除了有开始标签、结束标签、内容之外，还有很多的属性（attribute）</p><p>浏览器在解析HTML元素时，会将对应的attribute也创建出来放到对应的元素对象上。</p><ul><li><p>比如id、class就是全局的attribute，会有对应的id、class属性；</p></li><li><p>比如href属性是针对a元素的，type、value属性是针对input元素的；</p></li></ul><p>Attribute 的分类：</p><p>1.如果是HTML标准制定的Attribute，称之为标准的Attribute</p><p>2.而自定义的Attribute，称之为非标准的Attribute</p><h4 id="2-Attribute-属性的操作："><a href="#2-Attribute-属性的操作：" class="headerlink" title="2.Attribute 属性的操作："></a>2.Attribute 属性的操作：</h4><p>对于所有的（标准的和自定义的）attribute访问都支持如下的方法：</p><ul><li><p>elem.hasAttribute(name) — 检查特性是否存在。</p></li><li><p>elem.getAttribute(name) — 获取这个特性值。（字符串类型）（不存在则返回 null）</p></li><li><p>elem.setAttribute(name, value) — 设置这个特性值。</p></li><li><p>elem.removeAttribute(name) — 移除这个特性。</p></li><li><p>attributes：attr对象的集合，具有name、value属性</p></li></ul><p>attribute具备以下特征：</p><ul><li><p>它们的名字是大小写不敏感的（id 与 ID 相同）。</p></li><li><p>它们的值总是字符串类型的。</p></li></ul><h4 id="3-元素的属性-property"><a href="#3-元素的属性-property" class="headerlink" title="3.元素的属性 property"></a>3.元素的属性 property</h4><p>对于 HTML 元素，在元素中称其属性为 attribute，通过js获取元素对象之后（通过property获取attribute的值），称之为元素的对象模型。</p><p>对于标准的attribute，会在DOM对象上创建与其对应的property属性：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里的id称之为property</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(boxEl.<span class="property">id</span>, boxEl.<span class="property">age</span>, boxEl.<span class="property">height</span>,boxEl.<span class="property">title</span>)</span><br></pre></td></tr></table></figure><p>不是标准的属性的话（自定义）返回值为 undefined</p><p>在大多数情况下，它们是相互作用的</p><ul><li><p>改变property，通过attribute获取的值，会随着改变；</p></li><li><p>通过attribute操作修改，property的值会随着改变；</p><ul><li>但是input的value修改只能通过attribute的方法；</li></ul></li></ul><p>大多数情况下，设置、获取attribute，推荐使用property的方式：这是因为它默认情况下是有类型的；</p><p>*<em>HTML5的data-<em>自定义属性，那么它们也是可以在dataset属性中获取到的</em></em></p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230405193102932.png" alt="image-20230405193102932"></p><h4 id="4-JavaScript中动态修改样式"><a href="#4-JavaScript中动态修改样式" class="headerlink" title="4.JavaScript中动态修改样式"></a>4.JavaScript中动态修改样式</h4><p>有时候我们会通过JavaScript来动态修改样式，这个时候我们有两个选择：</p><ul><li><p>选择一：在CSS中编写好对应的样式，动态的添加class；</p></li><li><p>选择二：动态的修改style属性；</p></li></ul><p>开发中如何选择呢？</p><ul><li><p>在大多数情况下，如果可以动态修改class完成某个功能，更推荐使用动态class；</p></li><li><p>如果对于某些情况，无法通过动态修改class（比如精准修改某个css属性的值），那么就可以修改style属性</p></li></ul><p>元素的 className 和 classList</p><p>元素的class attribute，对应的property并非叫class，而是className：</p><p>这是因为JavaScript早期是不允许使用class这种关键字来作为对象的属性，所以DOM规范使用了className；</p><p>虽然现在JavaScript已经没有这样的限制，但是并不推荐，并且依然在使用className这个名称</p><p>对className进行赋值，<strong>它会替换整个类中的字符串</strong></p><p>如果我们需要添加或者移除单个的class，那么可以使用classList属性。</p><p>elem.classList 是一个特殊的对象：</p><ul><li><p>elem.classList.add (class) ：添加一个类</p></li><li><p>elem.classList.remove(class)：添加&#x2F;移除类。</p></li><li><p>elem.classList.toggle(class) ：如果类不存在就添加类，存在就移除它。</p></li><li><p>elem.classList.contains(class)：检查给定类，返回 true&#x2F;false。</p></li></ul><p>classList是可迭代对象，可以通过for of进行遍历。</p><p>元素的 style 属性</p><p>如果需要单独修改某一个CSS属性，那么可以通过style来操作：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">boxEl.<span class="property">style</span>.<span class="property">fontSize</span> = <span class="string">&quot;30px&quot;</span></span><br></pre></td></tr></table></figure><p>对于多词（multi-word）属性，使用驼峰式（小驼峰） camelCase</p><p>如果我们将值设置为空字符串，那么会使用CSS的默认样式：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">boxEl.<span class="property">style</span>.<span class="property">fontSize</span> = <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>多个样式的写法，我们需要使用cssText属性：</p><p>不推荐这种用法，<strong>因为它会替换整个字符串</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">boxEl.<span class="property">style</span>.<span class="property">cssText</span> = <span class="string">&#x27;font-size: 30px; color: red;&#x27;</span></span><br></pre></td></tr></table></figure><p>元素 style 的读取</p><p> 对于内联样式，是可以通过style.*的方式读取到的；</p><p>对于style、css文件中的样式，是读取不到的</p><p>这个时候，我们可以通过getComputedStyle的全局函数来实现</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getComputedStyle</span>(boxEl).<span class="property">fontSize</span>)</span><br></pre></td></tr></table></figure><h4 id="5-创建元素"><a href="#5-创建元素" class="headerlink" title="5.创建元素"></a>5.创建元素</h4><p>document.write：非常便捷，但是对于复杂的内容、元素关系拼接并不方便</p><h5 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h5><ul><li>步骤一：创建元素：document.createElement(tag)</li><li>步骤二：插入元素到 DOM 的某一个位置</li></ul><p>插入方式：</p><ul><li><p>node.append(…nodes or strings) —— 在 node 末尾插入节点或字符串</p></li><li><p>node.prepend(…nodes or strings) —— 在 node 开头插入节点或字符串</p></li><li><p>node.before(…nodes or strings) —— 在 node 前面插入节点或字符串</p></li><li><p>node.after(…nodes or strings) —— 在 node 后面插入节点或字符串</p></li><li><p>node.replaceWith(…nodes or strings) —— 将 node 替换为给定的节点或字符串</p></li></ul><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230312090927700.png" alt="image-20230312090927700"></p><h5 id="移除和克隆元素"><a href="#移除和克隆元素" class="headerlink" title="移除和克隆元素"></a>移除和克隆元素</h5><p>移除元素我们可以调用元素本身的remove方法：</p><p>想要复制一个现有的元素，可以通过cloneNode方法：</p><ul><li><p>可以传入一个Boolean类型的值，来决定是否是深度克隆；</p></li><li><p>深度克隆会克隆对应元素的子元素，否则不会；</p></li></ul><h5 id="旧方法操作元素（了解）"><a href="#旧方法操作元素（了解）" class="headerlink" title="旧方法操作元素（了解）"></a>旧方法操作元素（了解）</h5><p>parentElem.appendChild(node)： </p><ul><li>在parentElem的父元素最后位置添加一个子元素</li></ul><p>parentElem.insertBefore(node, nextSibling)：</p><ul><li>在parentElem的nextSibling前面插入一个子元素；</li></ul><p>parentElem.replaceChild(node, oldChild)：</p><ul><li>在parentElem中，新元素替换之前的oldChild元素；</li></ul><p>parentElem.removeChild(node)：</p><ul><li>在parentElem中，移除某一个元素；</li></ul><h4 id="6-元素的大小、滚动"><a href="#6-元素的大小、滚动" class="headerlink" title="6.元素的大小、滚动"></a>6.元素的大小、滚动</h4><p>clientWidth：contentWith+padding（不包含滚动条）</p><p>clientHeight：contentHeight+padding</p><p>clientTop：border-top的宽度</p><p>clientLeft：border-left的宽度</p><p>offsetWidth：元素完整的宽度</p><p>offsetHeight：元素完整的高度</p><p>offsetLeft：距离父元素的x</p><p>offsetHeight：距离父元素的y</p><p>scrollHeight：整个可滚动的区域高度</p><p>scrollTop：滚动部分的高度</p><h4 id="7-window的大小、滚动"><a href="#7-window的大小、滚动" class="headerlink" title="7.window的大小、滚动"></a>7.window的大小、滚动</h4><p>window的width和height</p><ul><li><p>innerWidth、innerHeight：获取window窗口的宽度和高度（包含滚动条）</p></li><li><p>outerWidth、outerHeight：获取window窗口的整个宽度和高度（包括调试工具、工具栏）</p></li><li><p>documentElement.clientHeight、documentElement.clientWidth：获取html的宽度和高度（不包含滚动条）</p></li></ul><p>indow的滚动位置：</p><ul><li><p>scrollX：X轴滚动的位置（别名pageXOffset）</p></li><li><p>scrollY：Y轴滚动的位置（别名pageYOffset）</p></li></ul><p>也有提供对应的滚动方法：</p><ul><li><p>方法 scrollBy(x,y) ：将页面滚动至相对于当前位置的 (x, y) 位置；</p></li><li><p>方法 scrollTo(pageX,pageY) 将页面滚动至绝对坐标；</p></li></ul><h2 id="11-JavaScript-中的事件"><a href="#11-JavaScript-中的事件" class="headerlink" title="11.JavaScript 中的事件"></a>11.JavaScript 中的事件</h2><h3 id="1、认识事件"><a href="#1、认识事件" class="headerlink" title="1、认识事件"></a>1、认识事件</h3><p>Web页面需要经常和用户之间进行交互，而交互的过程中我们可能想要捕捉这个交互的过程：</p><p>比如用户点击了某个按钮、用户在输入框里面输入了某个文本、用户鼠标经过了某个位置；</p><p>浏览器需要搭建一条JavaScript代码和事件之间的桥梁；</p><p>当某个事件发生时，让JavaScript可以响应（执行某个函数），所以我们需要针对事件编写处理程序（handler）</p><ul><li><p>事件监听方式一：在script中直接监听（很少使用）；</p></li><li><p>事件监听方式二：DOM属性，通过元素的on来监听事件；</p></li><li><p>事件监听方式三：通过EventTarget中的addEventListener来监听；</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;button onclick=<span class="string">&quot;console.log(&#x27;按钮1发生了点击~&#x27;)&quot;</span>&gt;按钮<span class="number">1</span>&lt;/button&gt;</span><br><span class="line">btn2El.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;按钮2发生了点击&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">btn3El.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;btn3的事件监听1&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="常见的事件列表"><a href="#常见的事件列表" class="headerlink" title="常见的事件列表"></a>常见的事件列表</h4><p>鼠标事件</p><ul><li>click —— 当鼠标点击一个元素时（触摸屏设备会在点击时生成）</li><li>mouseover &#x2F; mouseout —— 当鼠标指针移入&#x2F;离开一个元素时</li><li>mousedown &#x2F; mouseup —— 当在元素上按下&#x2F;释放鼠标按钮时</li><li>mousemove —— 当鼠标移动时</li></ul><p>键盘事件</p><ul><li>keydown 和 keyup —— 当按下和松开一个按键时</li></ul><p>表单（form）元素事件</p><ul><li>submit —— 当访问者提交了一个 form 时</li><li>focus —— 当访问者聚焦于一个元素时，例如聚焦于一个 input</li></ul><p>Document 事件</p><ul><li>DOMContentLoaded —— 当 HTML 的加载和处理均完成，DOM 被完全构建完成时</li></ul><p>CSS 事件</p><ul><li>transitionend —— 当一个 CSS 动画完成时。</li></ul><h3 id="2、认识事件流"><a href="#2、认识事件流" class="headerlink" title="2、认识事件流"></a>2、认识事件流</h3><h4 id="1-产生"><a href="#1-产生" class="headerlink" title="1.产生"></a>1.产生</h4><p>当我们在浏览器上对着一个元素点击时，你点击的不仅仅是这个元素本身；</p><p>这是因为我们的HTML元素是存在父子元素叠加层级的；</p><p>比如一个span元素是放在div元素上的，div元素是放在body元素上的，body元素是放在html元素上的</p><h4 id="2-事件冒泡和事件捕获"><a href="#2-事件冒泡和事件捕获" class="headerlink" title="2.事件冒泡和事件捕获"></a>2.事件冒泡和事件捕获</h4><p>默认情况下事件是从最内层的span向外依次传递的顺序，这个顺序我们称之为事件冒泡（Event Bubble）;</p><p>事实上，还有另外一种监听事件流的方式就是从外层到内层，这种称之为事件捕获（Event Capture）；</p><p>为什么会产生两种不同的处理流呢？</p><ul><li><p>这是因为早期浏览器开发时，不管是IE还是Netscape公司都发现了这个问题;</p></li><li><p>但是他们采用了完全相反的事件流来对事件进行了传递；</p></li><li><p>IE采用了事件冒泡的方式，Netscape采用了事件捕获的方式；</p></li></ul><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230403204855424.png"></p><p>过程：</p><p>如果我们都对其进行监听，则执行顺序：</p><ul><li><p>捕获阶段：事件（从 Window）向下走近元素</p></li><li><p>目标阶段：目标阶段（Target phase）</p></li><li><p>冒泡阶段：冒泡阶段（Bubbling phase）</p></li></ul><p>事实上，我们可以通过event对象来获取当前的阶段：eventPhase</p><p>开发中通常会使用事件冒泡，所以事件捕获了解即可</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230403205036219.png" alt="image-20230403205036219"></p><h3 id="3、事件对象"><a href="#3、事件对象" class="headerlink" title="3、事件对象"></a>3、事件对象</h3><p>当一个事件发生时，就会有和这个事件相关的很多信息：</p><ul><li><p>比如事件的类型是什么，你点击的是哪一个元素，点击的位置是哪里等等相关的信息；</p></li><li><p>这些信息会被封装到一个Event对象中，这个对象由浏览器创建，称之为event对象；</p></li><li><p>该对象给我们提供了想要的一些属性，以及可以通过该对象进行某些操作；</p></li></ul><p>如何获取这个event对象呢？</p><ul><li><p>event对象会在传入的事件处理（event handler）函数回调时，被系统传入；</p></li><li><p>我们可以在回调函数中拿到这个event对象；</p></li></ul><h4 id="event-常见的属性"><a href="#event-常见的属性" class="headerlink" title="event 常见的属性"></a>event 常见的属性</h4><p>type：事件的类型；</p><p><strong>target：当前事件发生的元素；</strong></p><p><strong>currentTarget：当前处理事件的元素；</strong></p><p>eventPhase：事件所处的阶段；</p><p>offsetX、offsetY：事件发生在元素内的位置；</p><p>clientX、clientY：事件发生在客户端内的位置；</p><p>pageX、pageY：事件发生在客户端相对于document的位置；</p><p>screenX、screenY：事件发生相对于屏幕的位置；</p><p>常见的方法：</p><ul><li><p>preventDefault：取消事件的默认行为；</p></li><li><p>stopPropagation：阻止事件的进一步传递（冒泡或者捕获都可以阻止）；</p></li></ul><p>事件处理中的 this</p><p>在函数中，我们也可以通过 this 来获取当前的发生元素</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btnEl = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;button&quot;</span>)</span><br><span class="line"><span class="keyword">var</span> divEl = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;div&quot;</span>)</span><br><span class="line"></span><br><span class="line">divEl.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">currentTarget</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(divEl)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span> === divEl)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是因为在浏览器内部，调用 event handler是绑定到当前的 currentTarget 上的</p><h3 id="4、EventTarget-类"><a href="#4、EventTarget-类" class="headerlink" title="4、EventTarget 类"></a>4、EventTarget 类</h3><p>所有的节点、元素都继承自EventTarget，事实上Window也继承自EventTarget</p><p><strong>EventTarget是一个DOM接口，主要用于添加、删除、派发Event事件；</strong></p><p>EventTarget常见的方法：</p><ul><li><p>addEventListener：注册某个事件类型以及事件处理函数；</p></li><li><p>removeEventListener：移除某个事件类型以及事件处理函数；</p></li><li><p>dispatchEvent：派发某个事件类型到 EventTarget 上；</p></li></ul><h3 id="5、事件委托"><a href="#5、事件委托" class="headerlink" title="5、事件委托"></a>5、事件委托</h3><p>事件冒泡在某种情况下可以帮助我们实现强大的事件处理模式 – 事件委托模式（也是一种设计模式）</p><ul><li><p>当子元素被点击时，父元素可以通过冒泡可以监听到子元素的点击；</p></li><li><p>并且可以通过event.target获取到当前监听的元素；</p></li></ul><p>案例：一个ul中存放多个li，点击某一个li会变成红色</p><ul><li><p>方案一：监听每一个li的点击，并且做出相应</p></li><li><p>方案二：在ul中监听点击，并且通过event.target拿到对应的li进行处理</p><ul><li>因为这种方案并不需要遍历后给每一个li上添加事件监听，所以它更加高效</li></ul></li></ul><h4 id="事件委托的标记"><a href="#事件委托的标记" class="headerlink" title="事件委托的标记"></a>事件委托的标记</h4><p>某些事件委托可能需要对具体的子组件进行区分，这个时候我们可以使用data-*对其进行标记：</p><p>比如多个按钮的点击，区分点击了哪一个按钮</p><h3 id="6、常见的事件"><a href="#6、常见的事件" class="headerlink" title="6、常见的事件"></a>6、常见的事件</h3><h4 id="1-常见的鼠标事件"><a href="#1-常见的鼠标事件" class="headerlink" title="1.常见的鼠标事件"></a>1.常见的鼠标事件</h4><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230404201639786.png" alt="image-20230404201639786"></p><h4 id="2-mouseover和mouseenter的区别"><a href="#2-mouseover和mouseenter的区别" class="headerlink" title="2.mouseover和mouseenter的区别"></a>2.mouseover和mouseenter的区别</h4><p>mouseenter和mouseleave</p><ul><li>不支持冒泡</li><li>进入子元素依然属于在该元素内，没有任何反应</li></ul><p>mouseover和mouseout</p><ul><li>支持冒泡</li><li>进入元素的子元素时<ul><li>先调用父元素的mouseout</li><li>再调用子元素的mouseover</li><li>因为支持冒泡，所以会将mouseover传递到父元素中</li></ul></li></ul><h4 id="3-常见的键盘事件"><a href="#3-常见的键盘事件" class="headerlink" title="3.常见的键盘事件"></a>3.常见的键盘事件</h4><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230404201729813.png" alt="image-20230404201729813"></p><p>事件的执行顺序是 onkeydown、onkeypress、onkeyup</p><ul><li><p>down事件先发生</p></li><li><p>press发生在文本被输入</p></li><li><p>up发生在文本输入完成</p></li></ul><p>通过key和code来区分按下的键：</p><ul><li>code：“按键代码”（”KeyA”，”ArrowLeft” 等），特定于键盘上按键的物理位置</li><li>key：字符（”A”，”a” 等），对于非字符（non-character）的按键，通常具有与 code 相同的值</li></ul><h4 id="4-常见的表单事件"><a href="#4-常见的表单事件" class="headerlink" title="4.常见的表单事件"></a>4.常见的表单事件</h4><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230403205650505.png" alt="image-20230403205650505"></p><h4 id="5-文档加载事件"><a href="#5-文档加载事件" class="headerlink" title="5.文档加载事件"></a>5.文档加载事件</h4><ul><li><p>DOMContentLoaded：浏览器已完全加载 HTML，并构建了 DOM 树，但像和样式表之类的外部资源可能尚未加载 完成</p></li><li><p>load：浏览器不仅加载完成了 HTML，还加载完成了所有外部资源：图片，样式等</p></li></ul><p>事件类型：<a href="https://developer.mozilla.org/zh-CN/docs/Web/Events">https://developer.mozilla.org/zh-CN/docs/Web/Events</a></p><h2 id="12-DOM阶段案例"><a href="#12-DOM阶段案例" class="headerlink" title="12.DOM阶段案例"></a>12.DOM阶段案例</h2><p>定时器</p><p>消息滚动</p><p>关闭弹窗</p><p>侧边栏触控展示</p><p>登录展示</p><p>tab栏切换</p><p>轮播图的实现</p><p>购物车操作</p><h2 id="13-JavaScript中的BOM操作"><a href="#13-JavaScript中的BOM操作" class="headerlink" title="13.JavaScript中的BOM操作"></a>13.JavaScript中的BOM操作</h2><h3 id="1、认识BOM操作"><a href="#1、认识BOM操作" class="headerlink" title="1、认识BOM操作"></a>1、认识BOM操作</h3><p>BOM：浏览器对象模型（Brower Object Model）</p><ul><li><p>简称 BOM，由浏览器提供的用于处理文档（document）之外的所有内容的其他对象</p></li><li><p>比如navigator、location、history等对象</p></li></ul><p>JavaScript有一个非常重要的运行环境就是浏览器</p><ul><li>而且浏览器本身又作为一个应用程序需要对其本身进行操作</li><li>所以通常浏览器会有对应的对象模型（BOM，Browser Object Model）</li><li>我们可以将BOM看成是连接 JavaScript 脚本与浏览器窗口的桥梁</li></ul><p>BOM主要包括一下的对象模型：</p><ul><li>window：包括全局属性、方法，控制浏览器窗口相关的属性、方法</li><li>location：浏览器连接到的对象的位置（URL）</li><li>history：操作浏览器的历史</li><li>navigator：用户代理（浏览器）的状态和标识（很少用到）</li><li>screen：屏幕窗口信息（很少用到）</li></ul><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230403201933683.png" alt="image-20230403201933683"></p><h3 id="2、全局对象window"><a href="#2、全局对象window" class="headerlink" title="2、全局对象window"></a>2、全局对象window</h3><p>window对象在浏览器中可以从两个视角来看待：</p><ul><li><p>视角一：全局对象</p><ul><li>我们知道ECMAScript其实是有一个全局对象的，这个全局对象在Node中是global</li><li>在浏览器中就是window对象</li></ul></li><li><p>视角二：浏览器窗口对象</p><ul><li>作为浏览器窗口时，提供了对浏览器操作的相关的API</li></ul></li></ul><p>这两个视角存在大量重叠的地方，不需要刻意去区分它们：</p><ul><li><p>事实上对于浏览器和Node中全局对象名称不一样的情况，目前已经指定了对应的标准，称之为globalThis，并且大多数现代 浏览器都支持它</p></li><li><p>放在window对象上的所有属性都可以被访问</p></li><li><p>使用var定义的变量会被添加到window对象中</p></li><li><p>window默认给我们提供了全局的函数和类：setTimeout、Math、Date、Object等</p></li></ul><p>事实上window对象上肩负的重担是非常大的：</p><ul><li><p>第一：包含大量的属性，localStorage、console、location、history、screenX、scrollX等</p></li><li><p>第二：包含大量的方法，alert、close、scrollTo、open等等（大概40+个方法）</p></li><li><p>第三：包含大量的事件，focus、blur、load、hashchange等等（大概30+个事件）</p></li><li><p>第四：包含从EventTarget继承过来的方法，addEventListener、removeEventListener、dispatchEvent方法；</p></li></ul><p>属性、方法、事件在MDN文档查看：<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window">https://developer.mozilla.org/zh-CN/docs/Web/API/Window</a></p><p>查看MDN文档时不同的符号的意思：</p><ul><li><p>删除符号：表示这个API已经废弃，不推荐继续使用了</p></li><li><p>点踩符号：表示这个API不属于W3C规范，某些浏览器有实现（所以兼容性的问题）</p></li><li><p>实验符号：该API是实验性特性，以后可能会修改，并且存在兼容性问题</p></li></ul><p>window 常见的属性</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">outerHeight</span>)</span><br></pre></td></tr></table></figure><p>window 常见的方法</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> openBtn = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;.open&quot;</span>)</span><br><span class="line"></span><br><span class="line">    openBtn.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">window</span>.<span class="title function_">open</span>(<span class="string">&quot;./page/new.html&quot;</span>, <span class="string">&quot;_blank&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> closeBtn = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;.close&quot;</span>)</span><br><span class="line"></span><br><span class="line">    closeBtn.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">window</span>.<span class="title function_">close</span>()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>window 常见的事件</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// window.onfocus = function() &#123;</span></span><br><span class="line">    <span class="comment">//   console.log(&quot;窗口获得了焦点&quot;)</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// window.onblur = function() &#123;</span></span><br><span class="line">    <span class="comment">//   console.log(&quot;窗口失去了焦点&quot;)</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="variable language_">window</span>.<span class="property">onhashchange</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hash值发生了改变&quot;</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="3、location对象"><a href="#3、location对象" class="headerlink" title="3、location对象"></a>3、location对象</h3><p>location对象用于表示window上当前链接到的URL信息</p><p>常见的属性：</p><ul><li>href: 当前window对应的超链接URL, 整个URL</li><li>protocol: 当前的协议；  host: 主机地址</li><li>hostname: 主机地址(不带端口)</li><li>port: 端口；  pathname: 路径</li><li>search: 查询字符串</li><li>hash: 哈希值</li><li>username：URL中的username（很多浏览器已经禁用）</li><li>password：URL中的password（很多浏览器已经禁用）</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.完整的url</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(location.<span class="property">href</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2。获取url的信息</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(location.<span class="property">hostname</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(location.<span class="property">host</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(location.<span class="property">protocol</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(location.<span class="property">port</span>)</span><br></pre></td></tr></table></figure><p>location其实是URL的一个抽象实现：</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230403202307394.png" alt="image-20230403202307394"></p><p>location有如下常用的方法：</p><ul><li>assign：赋值一个新的URL，并且跳转到该URL中</li><li>replace：打开一个新的URL，并且跳转到该URL中（不同的是不会在浏览记录中留下之前的记录）</li><li>reload：重新加载页面，可以传入一个Boolean类型</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">btns[<span class="number">0</span>].<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      location.<span class="title function_">assign</span>(<span class="string">&quot;https://www.baidu.com&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    btns[<span class="number">1</span>].<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      location.<span class="title function_">replace</span>(<span class="string">&quot;https://www.baidu.com&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    btns[<span class="number">2</span>].<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      location.<span class="title function_">reload</span>()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="4、URLSearchParams"><a href="#4、URLSearchParams" class="headerlink" title="4、URLSearchParams"></a>4、URLSearchParams</h3><p>URLSearchParams 定义了一些实用的方法来处理 URL 的查询字符串</p><ul><li><p>可以将一个字符串转化成URLSearchParams类型</p></li><li><p>也可以将一个URLSearchParams类型转成字符串</p></li></ul><p>URLSearchParams常见的方法有如下：</p><ul><li><p>get：获取搜索参数的值</p></li><li><p>set：设置一个搜索参数和值</p></li><li><p>append：追加一个搜索参数和值</p></li><li><p>has：判断是否有某个搜索参数</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/URLSearchParams">https://developer.mozilla.org/zh-CN/docs/Web/API/URLSearchParams</a></p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> urlSearchString = <span class="string">&quot;?name=wbh&amp;age=21&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(urlSearchString.<span class="title function_">split</span>(<span class="string">&quot;&amp;&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> searchParams = <span class="keyword">new</span> <span class="title class_">URLSearchParams</span>(urlSearchString)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(searchParams.<span class="title function_">get</span>(<span class="string">&quot;name&quot;</span>))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(searchParams.<span class="title function_">get</span>(<span class="string">&quot;age&quot;</span>))</span><br><span class="line"></span><br><span class="line">searchParams.<span class="title function_">append</span>(<span class="string">&quot;address&quot;</span>, <span class="string">&quot;广州市&quot;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(searchParams.<span class="title function_">get</span>(<span class="string">&quot;address&quot;</span>))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(searchParams.<span class="title function_">toString</span>())</span><br></pre></td></tr></table></figure><p>中文会使用encodeURIComponent和decodeURIComponent进行编码和解码</p><h3 id="5、history对象"><a href="#5、history对象" class="headerlink" title="5、history对象"></a>5、history对象</h3><p>history对象允许我们访问浏览器曾经的会话历史记录</p><p>有两个属性</p><ul><li><p>length：会话中的记录条数</p></li><li><p>state：当前保留的状态值</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(history.<span class="property">length</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(history.<span class="property">state</span>)</span><br></pre></td></tr></table></figure><p>有五个方法</p><ul><li>back()：返回上一页，等价于history.go(-1)</li><li>forward()：前进下一页，等价于history.go(1)</li><li>go()：加载历史中的某一页</li><li>pushState()：打开一个指定的地址</li><li>replaceState()：打开一个新的地址，并且使用replace；</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">btnEl.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// history.pushState(&#123;name:&quot;wd&quot;, age:&quot;23&quot;&#125;, &quot;&quot;, &quot;/why&quot;)</span></span><br><span class="line">      history.<span class="title function_">replaceState</span>(&#123;<span class="attr">name</span>:<span class="string">&quot;wd&quot;</span>, <span class="attr">age</span>:<span class="string">&quot;23&quot;</span>&#125;, <span class="string">&quot;&quot;</span>, <span class="string">&quot;/why&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> backEl = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;.back&quot;</span>)</span><br><span class="line">    backEl.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      history.<span class="title function_">back</span>()</span><br><span class="line">      history.<span class="title function_">forward</span>()</span><br><span class="line">      <span class="comment">// 类似于上面的两个方法，只是可以传入层级</span></span><br><span class="line">      history.<span class="title function_">go</span>(-<span class="number">2</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>history和hash目前是vue、react等框架实现路由的底层原理</p><h3 id="6、navigator、screen（很少用）"><a href="#6、navigator、screen（很少用）" class="headerlink" title="6、navigator、screen（很少用）"></a>6、navigator、screen（很少用）</h3><p>navigator 对象表示用户代理的状态和标识等信息</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230403202821277.png" alt="image-20230403202821277"></p><p>screen主要记录的是浏览器窗口外面的客户端显示器的信息</p><ul><li>比如屏幕的逻辑像素 screen.width、screen.height</li></ul><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230403202842991.png" alt="image-20230403202842991"></p><h3 id="7、JSON、Storage"><a href="#7、JSON、Storage" class="headerlink" title="7、JSON、Storage"></a>7、JSON、Storage</h3><h4 id="1-JSON的简单理解"><a href="#1-JSON的简单理解" class="headerlink" title="1.JSON的简单理解"></a>1.JSON的简单理解</h4><p>在目前的开发中，JSON是一种非常重要的数据格式，它并不是编程语言，而是一种可以在服务器和客户端之间传输的数据格式</p><p>JSON的全称是JavaScript Object Notation（JavaScript对象符号）</p><ul><li>JSON是由Douglas Crockford构想和设计的一种轻量级资料交换格式，算是JavaScript的一个子集</li><li>但是虽然JSON被提出来的时候是主要应用JavaScript中，但是目前已经独立于编程语言，可以在各个编程语言中使用</li><li>很多编程语言都实现了将JSON转成对应模型的方式</li></ul><p>其他的传输格式：</p><ul><li>XML：在早期的网络传输中主要是使用XML来进行数据交换的，但是这种格式在解析、传输等各方面都弱于JSON，所以目前已经很 少在被使用了</li><li>Protobuf：另外一个在网络传输中目前已经越来越多使用的传输格式是protobuf，但是直到2021年的3.x版本才支持JavaScript，所 以目前在前端使用的较少</li></ul><p>目前JSON被使用的场景也越来越多：</p><ul><li>网络数据的传输JSON数据</li><li>项目的某些配置文件</li><li>非关系型数据库（NoSQL）将json作为存储格式</li></ul><h4 id="2-JSON的基本语法"><a href="#2-JSON的基本语法" class="headerlink" title="2.JSON的基本语法"></a>2.JSON的基本语法</h4><p>JSON的顶层支持三种类型的值：</p><ul><li><p>简单值：数字（Number）、字符串（String，不支持单引号）、布尔类型（Boolean）、null类型</p></li><li><p>对象值：由key、value组成，key是字符串类型，并且必须添加双引号，值可以是简单值、对象值、数组值</p></li><li><p>数组值：数组的值可以是简单值、对象值、数组值</p></li></ul><h4 id="3-JSON序列化"><a href="#3-JSON序列化" class="headerlink" title="3.JSON序列化"></a>3.JSON序列化</h4><p>某些情况下我们希望将JavaScript中的复杂类型转化成JSON格式的字符串，这样方便对其进行处理</p><ul><li><p>比如我们希望将一个对象保存到localStorage中</p></li><li><p>但是如果我们直接存放一个对象，这个对象会被转化成 [object Object] 格式的字符串，并不是我们想要的结果；</p></li></ul><p>在ES5中引用了JSON全局对象，该对象有两个常用的方法：</p><ul><li>stringify方法：将JavaScript类型转成对应的JSON字符串</li><li>parse方法：解析JSON字符串，转回对应的JavaScript类型</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;sdw&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">23</span>,</span><br><span class="line">    <span class="attr">friend</span>: &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;dsds&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1.将obj对象进行序列化</span></span><br><span class="line"><span class="keyword">var</span> objJSONString = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(objJSONString)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.存储到浏览器本地 localstorage</span></span><br><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&quot;info&quot;</span>, objJSONString)</span><br><span class="line"><span class="keyword">var</span> item = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&quot;info&quot;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(item, <span class="keyword">typeof</span> item)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.将自付出转回到对象（反序列化）</span></span><br><span class="line"><span class="keyword">var</span> newObj = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(item)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newObj)</span><br></pre></td></tr></table></figure><h4 id="4-Stringfy的补充"><a href="#4-Stringfy的补充" class="headerlink" title="4.Stringfy的补充"></a>4.Stringfy的补充</h4><h5 id="Stringfy-的参数-replacer"><a href="#Stringfy-的参数-replacer" class="headerlink" title="Stringfy 的参数 replacer"></a>Stringfy 的参数 replacer</h5><p>JSON.stringify() 方法将一个 JavaScript 对象或值转换为 JSON 字符串：</p><ul><li><p>如果指定了一个 replacer 函数，则可以选择性地替换值</p></li><li><p>如果指定的 replacer 是数组，则可选择性地仅包含数组指定的属性</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// replacer参数</span></span><br><span class="line"><span class="keyword">var</span> objJSONString = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj, <span class="keyword">function</span>(<span class="params">key, value</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (key === <span class="string">&quot;name&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;coderwhy&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> value</span><br><span class="line">&#125;, <span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure><h5 id="Stringify的参数space"><a href="#Stringify的参数space" class="headerlink" title="Stringify的参数space"></a>Stringify的参数space</h5><p>如果对象本身包含toJSON方法，那么会直接使用toJSON方法的结果：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2.space参数</span></span><br><span class="line"><span class="comment">// var objJSONString = JSON.stringify(obj, null, 4)</span></span><br><span class="line"><span class="comment">// console.log(objJSONString)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.如果对象本身有显示toJSON方法，那么直接调用toJSON方法</span></span><br><span class="line"><span class="keyword">var</span> objJSONString = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(objJSONString)</span><br></pre></td></tr></table></figure><h4 id="5-parse方法"><a href="#5-parse方法" class="headerlink" title="5.parse方法"></a>5.parse方法</h4><p>JSON.parse() 方法用来解析JSON字符串，构造由字符串描述的JavaScript值或对象</p><ul><li>提供可选的 reviver 函数用以在返回之前对所得到的对象执行变换(操作)</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> newObj = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(objJSONString, <span class="keyword">function</span>(<span class="params">key, value</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (key === <span class="string">&quot;age&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> value + <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>JSON的方法可以帮我们实现对象的深拷贝</p><h3 id="8、认识Storage"><a href="#8、认识Storage" class="headerlink" title="8、认识Storage"></a>8、认识Storage</h3><h4 id="1-浏览器本地存储"><a href="#1-浏览器本地存储" class="headerlink" title="1.浏览器本地存储"></a>1.浏览器本地存储</h4><p>WebStorage主要提供了一种机制，可以让浏览器提供一种比cookie更直观的key、value存储方式：</p><ul><li>localStorage：本地存储，提供的是一种永久性的存储方法，在关闭掉网页重新打开时，存储的内容依然保留</li><li>sessionStorage：会话存储，提供的是本次会话的存储，在关闭掉会话时，存储的内容会被清除</li></ul><h4 id="2-localStorage和sessionStorage的区别"><a href="#2-localStorage和sessionStorage的区别" class="headerlink" title="2.localStorage和sessionStorage的区别"></a>2.localStorage和sessionStorage的区别</h4><ul><li>验证一：关闭网页后重新打开，localStorage会保留，而sessionStorage会被删除</li><li>验证二：在页面内实现跳转，localStorage会保留，sessionStorage也会保留</li><li>验证三：在页面外实现跳转（打开新的网页），localStorage会保留，sessionStorage不会被保留</li></ul><h4 id="3-Storage有如下的属性和方法："><a href="#3-Storage有如下的属性和方法：" class="headerlink" title="3.Storage有如下的属性和方法："></a>3.Storage有如下的属性和方法：</h4><p>属性：</p><ul><li>Storage.length：只读属性<ul><li>返回一个整数，表示存储在Storage对象中的数据项数量</li></ul></li></ul><p>方法：</p><ul><li>Storage.key()：该方法接受一个数值n作为参数，返回存储中的第n个key名称</li><li>Storage.getItem()：该方法接受一个key作为参数，并且返回key对应的value</li><li>Storage.setItem()：该方法接受一个key和value，并且将会把key和value添加到存储中<ul><li>如果key存储，则更新其对应的值</li></ul></li><li>Storage.removeItem()：该方法接受一个key作为参数，并把该key从存储中删除</li><li>Storage.clear()：该方法的作用是清空存储中的所有key</li></ul><h2 id="14-阶段案例"><a href="#14-阶段案例" class="headerlink" title="14.阶段案例"></a>14.阶段案例</h2><blockquote><p> 华为商城的搭建</p></blockquote><ol><li>页面搭建</li><li>数据插入，现阶段两种方法：创建每一个元素并插入；&#96;&#96;字符模板插入</li><li>实现列表的动态展示<ul><li>获取需要进行筛选的条件</li><li>动态获取 filters 内容（点击按钮获取textContent，取消按钮移除textContent）</li></ul></li><li>过滤数据</li><li>展示数据</li></ol><blockquote><p> 华为轮播图实现与无限轮播</p></blockquote><p>原理：为图片添加 active，并设置 opacity</p><ol><li>获取数据插入页面</li><li>使用定位，将图片定位在 banner 中</li><li>监听事件（上下页）点击，将图片进行展示（opacity &#x3D; 1，添加动画）</li><li>定时器进行自动轮播</li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IT前端 </tag>
            
            <tag> JavaScript </tag>
            
            <tag> DOM </tag>
            
            <tag> BOM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络知识整理</title>
      <link href="/archives/58e66b84.html"/>
      <url>/archives/58e66b84.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IT </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML/CSS 知识体系（部分）</title>
      <link href="/archives/f99e1de4.html"/>
      <url>/archives/f99e1de4.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前端开发"><a href="#前端开发" class="headerlink" title="前端开发"></a>前端开发</h1><h2 id="1-什么是软件"><a href="#1-什么是软件" class="headerlink" title="1.什么是软件"></a>1.什么是软件</h2><p>一系列按照特定顺序组织的计算机数据和指令，是电脑的非有型部分。</p><p>软件开发就是告诉计算机一系列的指令，这些指令也称之为程序。</p><h2 id="2-软件开发和应用程序开发有什么区别"><a href="#2-软件开发和应用程序开发有什么区别" class="headerlink" title="2.软件开发和应用程序开发有什么区别"></a>2.软件开发和应用程序开发有什么区别</h2><p> <img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230216143732155.png" alt="image-20230216143732155"></p><h2 id="3-完善的应用系统"><a href="#3-完善的应用系统" class="headerlink" title="3.完善的应用系统"></a>3.完善的应用系统</h2><p>服务器、客户端</p><h2 id="4-前端开发工程师-Front-end"><a href="#4-前端开发工程师-Front-end" class="headerlink" title="4.前端开发工程师-Front-end"></a>4.前端开发工程师-Front-end</h2><p>主要负责：Web（网站、后台管理系统、手机H5）、小程序端；                   </p><p>也可以：移动端（Uniapp、React Native）、桌面端（Electron）、服务器开发（Node.js）；</p><p><strong>书籍：</strong>《JavaScript高级程序设计》-nicholas C.Zakas  </p><p>《你不知道的JavaScript》</p><h1 id="Web开发"><a href="#Web开发" class="headerlink" title="Web开发"></a>Web开发</h1><h2 id="1-什么是网页"><a href="#1-什么是网页" class="headerlink" title="1.什么是网页"></a>1.什么是网页</h2><p>web page，打开浏览器查看到的一页，是网络中的一页，包括文字、链接、音乐、视频等</p><h2 id="2-什么是网站"><a href="#2-什么是网站" class="headerlink" title="2.什么是网站"></a>2.什么是网站</h2><p>网站是由多个网页组成；通常是n个网页（n&gt;&#x3D;1）</p><h2 id="3-网页的显示过程"><a href="#3-网页的显示过程" class="headerlink" title="3.网页的显示过程"></a>3.网页的显示过程</h2><p>用户：</p><p>网址-&gt;DNS服务器解析-&gt;ip地址-&gt;服务器-&gt;下载资源到浏览器-&gt;浏览器渲染引擎</p><p>​1.用户在浏览器输入一个网址</p><p>​2.浏览器会找到一个对应的服务器地址，请求静态资源</p><p>​3.服务器返回静态资源给浏览器</p><p>​4.浏览器对静态资源进行解析和展示</p><p>前端工程师：</p><p>​1.开发项目</p><p>​2.打包、部署项目到服务器里面</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230216162009343.png" alt="image-20230216162009343"></p><h2 id="4-服务器是什么"><a href="#4-服务器是什么" class="headerlink" title="4.服务器是什么"></a>4.服务器是什么</h2><p>本质是一台类似电脑的主机；稳定运行不关机；没有显示器；一般装的是Linux操作系统</p><h2 id="5-网页的组成"><a href="#5-网页的组成" class="headerlink" title="5.网页的组成"></a>5.网页的组成</h2><ul><li><p>HTML元素：网页的内容结构</p></li><li><p>CSS样式：网页的视觉体验</p></li><li><p>JavaScript语言：网页的交互处理</p></li></ul><h2 id="6-浏览器的作用"><a href="#6-浏览器的作用" class="headerlink" title="6.浏览器的作用"></a>6.浏览器的作用</h2><p>浏览器最核心的部分是渲染引擎，一般也称之为“浏览器内核”，负责解析网页语法，并渲染（显示）网页</p><h2 id="7-不同浏览器的内核"><a href="#7-不同浏览器的内核" class="headerlink" title="7.不同浏览器的内核"></a>7.不同浏览器的内核</h2><ul><li>Trident（三叉戟）：IE、360安全、搜狗高速、百度、UC；</li><li>Gecko（壁虎）：火狐；</li><li>Presto（急板乐趣）-&gt;Blink（眨眼）：Opera；</li><li>Webkit：Safari、360极速、搜狗高速、移动端浏览器（安卓、ios）；</li><li>Webkit-&gt;Blink：谷歌、Edge；</li></ul><p>不同的浏览器内核有不同的解析、渲染规则，所以同一个网页在不同内核的浏览器中的渲染效果也可能不同。</p><h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><p>Hyper-Text-Markup-Language：超文本标记语言，是一种用于创建网页的标记语言。</p><p>HTML是构建网页的基石；</p><h2 id="1-什么是标记语言"><a href="#1-什么是标记语言" class="headerlink" title="1.什么是标记语言"></a>1.什么是标记语言</h2><ul><li>由无数个标记组成；</li><li>是对某些内容进行特殊的标记，以供其他解释器识别处理；</li><li>比如<h2></h2>标记的文本会被识别为“标题”进行加粗、文字放大显示；</li><li>由标签和内容组成的部分称为元素</li></ul><h2 id="2-什么是超文本"><a href="#2-什么是超文本" class="headerlink" title="2.什么是超文本"></a>2.什么是超文本</h2><ul><li>不仅仅可以插入普通的文本，还可以插入图片、音视频等；</li><li>还可以表示超链接，从一个网页跳转到另一个网页</li></ul><h2 id="3-HTML文件的特点-结构"><a href="#3-HTML文件的特点-结构" class="headerlink" title="3.HTML文件的特点-结构"></a>3.HTML文件的特点-结构</h2><h3 id="1、HTML文件的扩展名"><a href="#1、HTML文件的扩展名" class="headerlink" title="1、HTML文件的扩展名"></a>1、HTML文件的扩展名</h3><p>因历史遗留问题，win95&#x2F;98系统的文件扩展名不能超过3位，所以用.htm</p><p>现在统一使用.html</p><h3 id="2、结构"><a href="#2、结构" class="headerlink" title="2、结构"></a>2、结构</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span>元数据（metedata）<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span>内容<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h2 id="4-工具"><a href="#4-工具" class="headerlink" title="4.工具"></a>4.工具</h2><p>vscode安装</p><p>安装插件：中文-chinese</p><p>颜色主题：atom one dark</p><p>文件夹图标：VScode great Icons</p><p>在浏览器打开网页：open in browser、Live sever（实时刷新）</p><p>自动重命名标签：auto rename tag</p><p>配置</p><p>自动保存</p><p>自动换行：word wrap</p><p>空格的渲染方式：render whitespace</p><p>缩进：tab size</p><h2 id="5-认识元素"><a href="#5-认识元素" class="headerlink" title="5.认识元素"></a>5.认识元素</h2><h3 id="1、什么是元素"><a href="#1、什么是元素" class="headerlink" title="1、什么是元素"></a>1、什么是元素</h3><p>元素是网页的一部分</p><p>一个元素可以包含一个数据项，或是一块文本，或是一张照片，亦或是什么都不包含</p><p>那么HTML中都有哪些元素呢？</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element">https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element</a></p><h3 id="2、元素的组成"><a href="#2、元素的组成" class="headerlink" title="2、元素的组成"></a>2、元素的组成</h3><ul><li>开始标签：被左右尖括号所包围</li><li>结束标签：与开始标签相似，只是在其元素名之前包含了一个斜杠，表示元素的结尾</li><li>内容：元素的内容</li><li>元素：前三者相结合便是一个完整的元素</li></ul><h3 id="3、单标签-双标签"><a href="#3、单标签-双标签" class="headerlink" title="3、单标签-双标签"></a>3、单标签-双标签</h3><p>双标签元素</p><p>html、body、head、h2、p、a元素；</p><p>单标签元素</p><p>br、img、hr、meta、input</p><p>注意：</p><p>html标签不区分大小写，推荐小写</p><h3 id="4、元素的属性"><a href="#4、元素的属性" class="headerlink" title="4、元素的属性"></a>4、元素的属性</h3><p>元素也是可以拥有属性（Attribute）:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;p <span class="keyword">class</span>=<span class="string">&quot;attr&quot;</span>&gt;wowowo&lt;/p&gt;</span><br></pre></td></tr></table></figure><p>属性包含元素的额外信息，这些信息不会出现在实际的内容中</p><p>一个属性必须包含：</p><ul><li>1.一个空格，在属性和元素名称之间。多个属性用空格隔开</li><li>2.属性名称，后面跟着一个等于符</li><li>3.一个属性值，由一对引号“ ”引起来</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;h1 属性名=<span class="string">&quot;属性值&quot;</span>&gt;我是标题&lt;/h1&gt;</span><br></pre></td></tr></table></figure><p>元素属性的分类</p><p>有些属性是公共的，每一个元素都可以设置</p><ul><li>class、id、title属性</li></ul><p>有些属性是元素特有的，不是每一个元素都可以设置</p><ul><li>meta元素的charset属性、img元素的alt属性等</li></ul><h3 id="5、元素的嵌套关系"><a href="#5、元素的嵌套关系" class="headerlink" title="5、元素的嵌套关系"></a>5、元素的嵌套关系</h3><p>某些元素的内容除了可以是文本外，还可以是其他元素，这样就形成了元素的嵌套</p><p>元素之间的关系：                                                                                                                                                                                            </p><p>父子关系，比如ul和li，li和span之间； </p><p>兄弟关系，比如两个div，两个span之间； </p><p>注释：ctrl+&#x2F;</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!--  --&gt;</span><br></pre></td></tr></table></figure><h2 id="6-HTML常见的元素"><a href="#6-HTML常见的元素" class="headerlink" title="6.HTML常见的元素"></a>6.HTML常见的元素</h2><h3 id="1、HTML结构分析"><a href="#1、HTML结构分析" class="headerlink" title="1、HTML结构分析"></a>1、HTML结构分析</h3><p>文档声明：HTML最上方的一段文本我们称之为文档类型声明，用于声明类型。不仅声明文件类型，而且声明版本，让浏览器按照相应标准去解析识别内容，必须放在HTML文档的最前面，不可省略，否则会出现兼容性问题。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!<span class="variable constant_">DOCTYPE</span> html&gt;  <span class="comment">// 告诉浏览器是HTML5版本</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;元素表示一个<span class="variable constant_">HTML</span>文档的根（顶级元素），所以它被称之为根元素。</span><br></pre></td></tr></table></figure><p>所有其他元素必须是此元素的后代。</p><p>W3C标准建议为html元素增加一个lang属性，作用是</p><ul><li>帮助语言合成工具确定要使用的语言</li><li>帮助翻译工具确定要使用的翻译规则</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt; 表示这个<span class="variable constant_">HTML</span>文档使用的语言是英文</span><br><span class="line">&lt;html lang=<span class="string">&quot;zh-CN&quot;</span>&gt; 表示这个<span class="variable constant_">HTML</span>文档的语言是中文</span><br></pre></td></tr></table></figure><p>HTML中head元素规定文档相关的配置信息（也称为元数据），包括文档的标题，引用的文档样式和脚本等。</p><ul><li><p>元数据：描述数据的数据。</p></li><li><p>这里我们可以理解成对整个页面的配置。</p></li></ul><p>网页的标题：title元素</p><p>网页的编码：meta元素</p><ul><li>可以用于设置网页的字符编码，让浏览器更精准的显示每一个文字，不设置或者设置错误会导致乱码；</li><li>一般都使用utf-8编码，涵盖了世界上几乎所有的文字</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br></pre></td></tr></table></figure><p>body元素里面的内容将是你在浏览器窗口中看到的东西，也就是网页的具体内容和结构。</p><h3 id="2、常见的元素"><a href="#2、常见的元素" class="headerlink" title="2、常见的元素"></a>2、常见的元素</h3><p><strong>h元素</strong>：作为标题—h1-h6：呈现6个不同的级别的标题。</p><p><strong>p元素</strong>：表示段落，段落之间有一定的间距。</p><p><strong>img元素</strong>：将一份图像嵌入文档。是一个可替换元素。</p><ul><li>src属性：图片文件的路径（必须）</li><li>alt属性：文件加载不成功时候显示这段文本；屏幕阅读器会将这些描述给需要使用阅读器的使用者听，让他们知道图片的含义（不是强制性的）</li></ul><p>图片的路径：</p><ul><li>绝对路径：根盘符开始查找，一直找到这个资源</li><li>相对路径：相对于当前文件的路径；.当前文件夹；..上级文件夹</li></ul><p>对于网页来说，不管是什么操作系统，路径分隔符都是&#x2F;，而不是\</p><p><strong>a元素</strong>：（锚：anchor）超链接，打开新的URL</p><ul><li><p>href（ Hypertext Reference）：指定要打开的URL地址，也可以是一个本地地址</p></li><li><p>target：指定在何处显示链接的资源</p><p>​_self：默认值，在当前窗口打开URL</p><p>​_blank：在新的窗口打开URL</p></li></ul><p>锚点链接：锚点可以实现跳转到网页中的具体位置。</p><ul><li>在要跳到的元素上定义一个id属性；</li><li>定义a元素，并且a元素的href指向对应的id；</li></ul><p>a元素中能使用img元素作为跳转</p><p>a元素指向其他的URL：</p><ul><li>压缩包：</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;a href=<span class="string">&quot;https://github.com/coderwhy/HYMiniMall/archive/master.zip&quot;</span>&gt;下载zip包&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>​会直接下载</p><ul><li>指向其他的协议地址：</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;a href=<span class="string">&quot;mailto:123@qq.com&quot;</span>&gt;发邮箱给123qq.<span class="property">com</span>&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>​能打开电脑邮箱软件对发件邮箱进行填充</p><p><strong>iframe元素</strong>：在一个HTML文档中嵌入其他HTML文档</p><ul><li>frameborder属性：用于规定是否显示边框  1：显示  0：不显示</li></ul><p>a元素target属性的其他值：</p><ul><li>_parent：在父窗口打开URL</li><li>_top：在顶层窗口打开URL</li></ul><p>div元素和span元素都是纯粹的容器，也可以把他们理解为盒子，他们都是用来包裹内容的</p><p>无所用、无所不用：</p><p><strong>div元素</strong>：division，分开、分配的意思；</p><p>多个div元素包裹的内容会在不同的行显示；</p><ul><li>一般作为其他元素的父容器，把其他元素包住，代表一个整体</li><li>用于将网页分割为多个独立的部分</li></ul><p><strong>span元素</strong>：跨域、涵盖的意思；</p><p>多个span元素包裹的内容会同一行显示</p><ul><li>默认情况下，跟普通文本几乎没有差别</li><li>用于区分特殊文本和普通文本，比如显示一些关键字</li></ul><h3 id="3、不常用元素"><a href="#3、不常用元素" class="headerlink" title="3、不常用元素"></a>3、不常用元素</h3><p><strong>strong元素</strong>：内容加粗，强调</p><ul><li>通常加粗会使用css样式来完成</li><li>开发中偶尔会使用</li></ul><p><strong>i元素</strong>：内容倾斜</p><ul><li>开发中通常使用css设置倾斜</li><li>偶尔使用它来做字体图标（看起来像是icon的缩写）</li></ul><p><strong>code元素</strong>：用来显示代码</p><ul><li>偶尔会使用来显示等宽字体</li></ul><p><strong>br元素</strong>：换行元素</p><ul><li>开发中不再使用</li></ul><h3 id="4、HTML全局属性"><a href="#4、HTML全局属性" class="headerlink" title="4、HTML全局属性"></a>4、HTML全局属性</h3><p>某些属性只能设置在特定的元素中</p><p>但是也有一些属性是所有HTML都可以设置和拥有的，这样的属性称之为全局属性</p><p>常见的全局属性：</p><ul><li>id：定义唯一标识符，该标识符在整个文档中必须是唯一的。</li><li>class：一个以空格分隔的元素的类名列表</li><li>style：给元素添加内联样式</li><li>title：包含表示与其属性元素相关信息的文本</li></ul><h2 id="7-额外补充"><a href="#7-额外补充" class="headerlink" title="7.额外补充"></a>7.额外补充</h2><h3 id="1、字符实体"><a href="#1、字符实体" class="headerlink" title="1、字符实体"></a>1、字符实体</h3><p>我们编写的HTML会被浏览器解析，那是怎么解析的呢？</p><ul><li><p>如果使用小于号&lt;，浏览器会将其后面的文本解析为一个tag</p></li><li><p>但是在某些情况下我们确实需要编写一个小于号&lt;</p></li><li><p>这时候就可以使用字符实体</p></li></ul><p>HTML实体是一段以连字号(&amp;)开头、以分号(;)结尾的文本（字符串）</p><ul><li>字符实体常用于显示保留字符（这些字符会被解析为HTML代码）和不可见字符（如“不换行空格”）</li><li>你也可以使用实体来代替其他难以用标准键盘键入的字符</li></ul><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230219140224361.png" alt="image-20230219140224361"></p><h3 id="2、URL地址"><a href="#2、URL地址" class="headerlink" title="2、URL地址"></a>2、URL地址</h3><p><strong>URL</strong> 代表着统一资源定位符（Uniform Resource Locator）</p><p>URL 无非就是一个给定的独特资源在Web上的网址</p><ul><li>理论上说：每一个有效的URL都指向一个唯一的资源；</li><li>这个资源可以是一个HTML页面，一个CSS文档，一幅图像，等等；</li></ul><p>URL标准格式：</p><ul><li>【协议类型】:&#x2F;&#x2F;[服务器地址]:[端口号]&#x2F;【文件路径】【文件名】？[查询]#[片段ID]</li></ul><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230219142839021.png" alt="image-20230219142839021"></p><p>和URI的区别：</p><p>URI（identifier）：统一资源标志符，用于标识Web技术使用的逻辑或物理资源；</p><p>URI在某一个规则下能把一个资源独一无二的识别出来</p><ul><li>URL作为一个网络web资源的地址，可以唯一将一个资源识别出来，所以URL是一个URI；</li><li>URL是URI的一个子集；</li><li>但是URI并不一定是URL</li></ul><h3 id="3、元素语义化"><a href="#3、元素语义化" class="headerlink" title="3、元素语义化"></a>3、元素语义化</h3><p>用正确的元素做正确的事情</p><p>理论上来说，所有的HTML元素，我们都能实现相同的事情</p><p>标签语义化</p><ul><li>方面代码的维护</li><li>减少开发者之间的沟通成本</li><li>能让语音识别工具识别正确识别网页的用图，以便做出正确的反应</li><li>有利于SEO</li></ul><h3 id="4、SEO优化"><a href="#4、SEO优化" class="headerlink" title="4、SEO优化"></a>4、SEO优化</h3><p>搜索引擎优化（search engine optimization）是通过了解搜索引擎的运作规则来调整网站，以及提高网站在有关搜索引擎内排名的方式。</p><h3 id="5、字符编码"><a href="#5、字符编码" class="headerlink" title="5、字符编码"></a>5、字符编码</h3><p>计算机只认识01二进制数字(底层硬件控制电路的开和闭)，计算机只能直接存储和处理二进制数字</p><p>为了在计算机上也能表示、存储和处理像文字、符号之类的字符，就必须将这些字符转化为二进制数字。而转化的标准就称之为字符编码。</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230220161644042.png" alt="image-20230220161644042"></p><h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><h2 id="1-邂逅CSS"><a href="#1-邂逅CSS" class="headerlink" title="1.邂逅CSS"></a>1.邂逅CSS</h2><h3 id="1、认识CSS"><a href="#1、认识CSS" class="headerlink" title="1、认识CSS"></a>1、认识CSS</h3><p>CSS表示层叠样式表（Cascading Style Sheet），是为网页添加样式的代码</p><p>属于计算机语言，他不是真正的编程语言，甚至不是标记语言，是一门样式表语言</p><p>94年开发，96发布css1，97W3C成立CSS工作组，98年5月发布css2，06-09流行div+css</p><p>没有真正的CSS3，之后的发布是模块化发布</p><p>CSS的出现是为了美化HTML的，并且让结构与样式分离</p><ul><li>美化1：添加样式</li><li>美化2：对HTML进行布局</li></ul><h3 id="2、编写CSS样式"><a href="#2、编写CSS样式" class="headerlink" title="2、编写CSS样式"></a>2、编写CSS样式</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">color</span>: red;   <span class="comment">// 属性名： 属性值；</span></span><br></pre></td></tr></table></figure><p>三种方法添加样式：</p><ul><li>内联样式（行内样式）：存于HTML元素的style属性之中，分号隔开多个样式；</li><li>内部样式表：将css放在HTML文件<code>&lt;head&gt;</code>元素里的<code>&lt;style&gt;</code>元素之中；</li><li>外部样式表：link外部的CSS文件</li></ul><p>CSS注释：ctrl+&#x2F;</p><h3 id="3、常见的CSS属性"><a href="#3、常见的CSS属性" class="headerlink" title="3、常见的CSS属性"></a>3、常见的CSS属性</h3><p>css属性的官方文档：<a href="https://www.w3.org/TR/?tag=css">https://www.w3.org/TR/?tag=css</a></p><p>浏览器支持查询CSS属性的可用性：<a href="https://caniuse.com/">https://caniuse.com</a></p><ul><li>font-size：文字大小</li><li>color：前景色</li><li>background-color：背景色</li><li>width：宽度</li><li>height：高度</li></ul><h3 id="4、额外知识补充2"><a href="#4、额外知识补充2" class="headerlink" title="4、额外知识补充2"></a>4、额外知识补充2</h3><h4 id="1-link元素"><a href="#1-link元素" class="headerlink" title="1.link元素"></a>1.link元素</h4><p>link元素是外部资源链接元素，规范了文档与外部资源的关系</p><ul><li>link元素通常是在head元素中</li><li>最常用的链接是样式表</li><li>也可以使用网站图标（favicon）</li></ul><p>常见属性：</p><ul><li>href：指定被链接资源的URL</li><li>rel：指定链接类型<ul><li>icon：站点图标</li><li>stylesheet：CSS样式</li></ul></li></ul><h4 id="2-计算机进制"><a href="#2-计算机进制" class="headerlink" title="2.计算机进制"></a>2.计算机进制</h4><p>进位制是一种计数方式，亦称进位计数法或位值计数法；当数字达到某个值时，进一位</p><p>十六进制：a(10)，b(11)，c(12)，d(13)，e(14)，f(15)，10(16)</p><p>二进制：0b开头</p><p>八进制：0o开头</p><p>十六进制：0x开头</p><p>编程中还是以十进制为主</p><p>十进制转化其他进制：整除取余数</p><p>其他进制转十进制：二进制1001：9</p><h4 id="3-CSS表示颜色"><a href="#3-CSS表示颜色" class="headerlink" title="3.CSS表示颜色"></a>3.CSS表示颜色</h4><p>表示颜色的方法：</p><ul><li>颜色关键字</li></ul><p>RGB【A】颜色（取值0-255），A是可选的，表示透明度</p><ul><li>使用函数符：rgb[a]:(255,255,255)<ul><li>可以是数字，也可以是百分比</li><li>A处于0-1之间的数字，或者百分比，数字1表示完全不透明(100%)</li></ul></li><li>也可以使用十六进制：#FFFFFF <ul><li>可以使用三位数：#f09&#x3D;#ff0099</li><li>可以使用四位数：#0f38&#x3D;#00ff3388</li></ul></li></ul><h4 id="4-浏览器渲染流程"><a href="#4-浏览器渲染流程" class="headerlink" title="4.浏览器渲染流程"></a>4.浏览器渲染流程</h4><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230226155625725.png" alt="image-20230226155625725"></p><h2 id="2-CSS属性"><a href="#2-CSS属性" class="headerlink" title="2.CSS属性"></a>2.CSS属性</h2><h3 id="1、文本"><a href="#1、文本" class="headerlink" title="1、文本"></a>1、文本</h3><h4 id="1-text-decoration（常用）"><a href="#1-text-decoration（常用）" class="headerlink" title="1.text-decoration（常用）"></a>1.text-decoration（常用）</h4><p>用于设置文本的装置线</p><p>取值：</p><ul><li>none：无任何装饰<ul><li>可以去除 a 元素的下划线</li></ul></li><li>underline：添加下划线</li><li>overline：上划线</li><li>line-through：中划线（删除线）</li></ul><h4 id="2-text-transform"><a href="#2-text-transform" class="headerlink" title="2.text-transform"></a>2.text-transform</h4><p>用于设置文字的大小写转换</p><p>常见的值：</p><ul><li>capitalize：将每个单词的首字母变成大写</li><li>uppercase：将每个单词的全部字母变成大写</li><li>lowercase：将每个单词的全部字母变成小写</li><li>none：没有任何影响</li></ul><h4 id="3-text-indent"><a href="#3-text-indent" class="headerlink" title="3.text-indent"></a>3.text-indent</h4><p>用于设置第一行内容的缩进</p><p>text-indent：2em；  ：刚好是缩进2个文字</p><h4 id="4-text-align（重要）"><a href="#4-text-align（重要）" class="headerlink" title="4.text-align（重要）"></a>4.text-align（重要）</h4><p>设置<strong>文本</strong>的对齐方式（不准确）</p><p>MDN：定义行内内容（例如文字）如何相对于它的<strong>块父元素</strong>对齐（不准确）</p><p>常用的值</p><ul><li>left：左对齐</li><li>right：右对齐</li><li>center：居中对齐，也可以让图片居中</li><li>justify：两端对齐<ul><li>最有一行与只有一行的情况下不生效要想生效需要设置：text-align-last：justify</li></ul></li></ul><p>W3C：设置的是行内级元素居中</p><h4 id="5-word-x2F-letter-spacing"><a href="#5-word-x2F-letter-spacing" class="headerlink" title="5.word&#x2F;letter-spacing"></a>5.word&#x2F;letter-spacing</h4><p>分别是改变单词&#x2F;字母之间的间距</p><h3 id="2、字体"><a href="#2、字体" class="headerlink" title="2、字体"></a>2、字体</h3><h4 id="1-font-size"><a href="#1-font-size" class="headerlink" title="1.font-size"></a>1.font-size</h4><p>决定字体的大小</p><p>常用的设置</p><ul><li>具体数值+单位：比如100px，也可以使用em，1em代表100%</li><li>百分比：基于父元素的font-size计算</li></ul><h4 id="2-font-family"><a href="#2-font-family" class="headerlink" title="2.font-family"></a>2.font-family</h4><p>用于设置文字的字体名称</p><p>可以设置一个或多个字体名称</p><p>浏览器会选择列表中第一个该计算机上有安装的字体</p><p>或者是通过 @font-face 指定的可以直接下载的字体</p><h4 id="3-font-weight"><a href="#3-font-weight" class="headerlink" title="3.font-weight"></a>3.font-weight</h4><p>用于设置文字的粗细（重量）</p><p>常见的取值：</p><ul><li>100|200|300|400|500|600|700|800|900：每一个数字表示一个重量</li><li>nomal：等于400</li><li>bold：等于700</li></ul><p> strong、b、h1-h6等标签的font-weight默认值就是bold</p><h4 id="4-font-style"><a href="#4-font-style" class="headerlink" title="4.font-style"></a>4.font-style</h4><p>用来设置文本的常规、斜体显示</p><ul><li>normal：常规显示</li><li>italic（斜体）：用字体的斜体显示（通常会有专门的字体）</li><li>oblique（倾斜）：文本倾斜显示（仅仅是让文字倾斜）</li></ul><p>em、i、cite、address、var、dfn等元素的font-style默认值就是italic</p><h4 id="5-font-variant（了解）"><a href="#5-font-variant（了解）" class="headerlink" title="5.font-variant（了解）"></a>5.font-variant（了解）</h4><p>可以影响小写字母的显示形式</p><p>normal：正常显示</p><p>small-caps：将小写字母替换为缩小过的大写字母（高度不变，小写变为大写）</p><h4 id="6-line-height"><a href="#6-line-height" class="headerlink" title="6.line-height"></a>6.line-height</h4><p>用来设置文本的行高</p><p>简单理解就是一行文字所占据的高度</p><p>为什么需要行高？</p><p>严格定义：两行文字基线之间的间距</p><p>区分：</p><ul><li>height：整个元素的高度</li><li>line-height：元素中每一行文字所占据的高度</li></ul><p>只有一行文字时，设置line-height等于height可以设置文本居中（仅限于文本）</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230303083221666.png" alt="image-20230303083221666"></p><h4 id="7-font缩写属性"><a href="#7-font缩写属性" class="headerlink" title="7.font缩写属性"></a>7.font缩写属性</h4><p>font 是一个缩写属性，可以作为以上属性的缩写</p><p>一般：font-style font-variant font-weight font-size&#x2F;line-height font-family;</p><ul><li>前三个可以省略，顺序可以调换</li><li>&#x2F;line-height 可以省略，如果不省略，必须跟在 font-size后面</li><li>font-size、font-family不可以调换顺序，也不能省略</li></ul><p>line-height 写数字的话表示为font-size 的倍数</p><h3 id="3、选择器"><a href="#3、选择器" class="headerlink" title="3、选择器"></a>3、选择器</h3><p>需要找到特定的网页元素进行设置样式</p><p>选择器就是按照一定的规则选出符合条件的元素，为之添加css样式</p><h4 id="1-通用选择器"><a href="#1-通用选择器" class="headerlink" title="1.通用选择器"></a>1.通用选择器</h4><p>所有的元素都会被选中，一般用来设置所有元素的一些通用属性，比如网页重置</p><p>性能比较低，尽量不使用</p><h4 id="2-简单选择器"><a href="#2-简单选择器" class="headerlink" title="2.简单选择器"></a>2.简单选择器</h4><ul><li>元素选择器：使用元素名称</li><li>类选择器：使用 .类名</li><li>id 选择器：使用 #id</li></ul><p>id 注意事项</p><ul><li>一个HTML文档中的id值是唯一的，不能重复<ul><li>id值如果由多个单词组成，单词之间可以用中划线-、下划线_连接，也可使用驼峰标识</li><li>最好不要使用标签名作为id值（阅读性比较差）</li></ul></li></ul><p>中划线又叫连字符</p><h4 id="3-属性选择器"><a href="#3-属性选择器" class="headerlink" title="3.属性选择器"></a>3.属性选择器</h4><p>拥有某一个属性</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[title] &#123;</span><br><span class="line">      <span class="attr">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置包含title属性的div元素的背景色 */</span></span><br><span class="line">[title=div] &#123;</span><br><span class="line">    background-<span class="attr">color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他：</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230303095554442.png" alt="image-20230303095554442"></p><h4 id="4-后代选择器"><a href="#4-后代选择器" class="headerlink" title="4.后代选择器"></a>4.后代选择器</h4><p>后代选择器1：所有的后代（直接&#x2F;间接后代）</p><p>选择器之间以空格分开</p><p>后代选择器2：直接子代选择器（必须是直接子代）</p><p>选择器之间以 &gt; 分割</p><h4 id="5-兄弟选择器"><a href="#5-兄弟选择器" class="headerlink" title="5.兄弟选择器"></a>5.兄弟选择器</h4><p>兄弟选择器1：相邻兄弟选择器（后面）</p><p>使用符号 + 连接</p><p>兄弟选择器2：普遍兄弟选择器（后面）</p><p>使用符号 ~ 连接</p><h4 id="6-选择器组"><a href="#6-选择器组" class="headerlink" title="6.选择器组"></a>6.选择器组</h4><h5 id="1、交集选择器"><a href="#1、交集选择器" class="headerlink" title="1、交集选择器"></a>1、交集选择器</h5><p>需要同时符合两个选择器条件（两个选择器紧密相连）</p><ul><li>在开发中通常为了精准的选择某一个元素</li></ul><h5 id="2、并集选择器"><a href="#2、并集选择器" class="headerlink" title="2、并集选择器"></a>2、并集选择器</h5><p>符合一个选择器条件即可（两个选择器使用, 分割）</p><ul><li>在开发中通常为了给多个元素设置相同的样式</li></ul><h4 id="7-伪类"><a href="#7-伪类" class="headerlink" title="7.伪类"></a>7.伪类</h4><p>伪类是选择器的一种，它用于选择处于特定状态的元素</p><p> 比如：在鼠标悬浮在元素上时变色</p><h5 id="常见的伪类"><a href="#常见的伪类" class="headerlink" title="常见的伪类"></a>常见的伪类</h5><ul><li>动态伪类<ul><li>:link   :visited  :hover  :active  :focus</li></ul></li><li>目标伪类<ul><li>:target</li></ul></li><li>语言伪类<ul><li>:lang()</li></ul></li><li>元素状态伪类<ul><li>:enabled  :disabled  :checked</li></ul></li><li>结构伪类<ul><li>:nth-child()  nth-last-child()  :nth-of-type()  nth-last-of-type()</li><li>:first- child  :last-child  :first-of-type  :last-of-type</li><li>:root  :only-child  :only-of-type  :empty</li></ul></li><li>否定伪类<ul><li>:not()</li></ul></li></ul><h5 id="使用举例"><a href="#使用举例" class="headerlink" title="使用举例"></a>使用举例</h5><ul><li>a:link 未访问的链接</li><li>a:visited 已访问的链接</li><li>a:hover 鼠标挪动到链接上</li><li>a:active 激活的链接（鼠标在链接上长按未松开）</li></ul><h5 id="使用注意"><a href="#使用注意" class="headerlink" title="使用注意"></a>使用注意</h5><ul><li><p>:hover 必须放在 :link 和 :visited 后面才能完全生效</p></li><li><p>:active 必须放在 : hover后面才能完全生效</p></li><li><p>编程建议：:link、:visited、:hover、:active</p></li></ul><p>除了a元素，:hover、:active 也能用在其他元素上</p><p>:focus指当前拥有输入焦点的元素（能接收键盘输入）（能进行交互交互的元素）</p><ul><li>文本输入框一聚焦后，背景就会变红色</li></ul><p>编写顺序：:link、:visited、:focus、:hover、:active</p><p>直接给a元素设置样式，相当于给a元素的所有动态伪类都设置了</p><h4 id="8-伪元素"><a href="#8-伪元素" class="headerlink" title="8.伪元素"></a>8.伪元素</h4><p>伪元素默认为：行内非替换元素</p><p>常用的伪元素有</p><ul><li>:first-line、::first-line：针对首行文本设置属性</li><li>:first-letter、::first-letter：可以针对首字母设置属性</li><li>:before、::before：在一个元素之前插入其他内容</li><li>:after、::after：在一个元素之后插入其他内容</li></ul><p>使用伪元素的过程中，content不能省略，可以为””</p><p>为了区分伪元素和伪类，建议伪元素使用2个冒号</p><h2 id="3-CSS属性的特性"><a href="#3-CSS属性的特性" class="headerlink" title="3.CSS属性的特性"></a>3.CSS属性的特性</h2><h3 id="1、css属性的继承"><a href="#1、css属性的继承" class="headerlink" title="1、css属性的继承"></a>1、css属性的继承</h3><p>css的某些属性具有继承性</p><ul><li>如果一个属性具备继承性，那么在该元素上设置后，他的后代元素都可以继承这个属性</li><li>如果后代元素自己有设置属性，那么优先使用后代元素自己的属性（不管继承过来的属性权重多高）</li></ul><p>常见的 fone-size&#x2F;font-family&#x2F;font-weight&#x2F;line-height&#x2F;color&#x2F;text-align都具有继承性</p><p><strong>继承过来的是计算值，而不是设置值</strong></p><p>强制继承：在子元素的style中将需要继承的属性的值设置为 inherit</p><h3 id="2、css属性的层叠"><a href="#2、css属性的层叠" class="headerlink" title="2、css属性的层叠"></a>2、css属性的层叠</h3><p>css：层叠样式表</p><ul><li><p>对于一个元素来说，相同一个属性我们可以通过不同的选择器给它进行多次设置</p></li><li><p>那么属性会被一层层覆盖上去，但是最终只有一个会生效</p></li><li><p>判断哪个样式生效</p></li></ul><p>判断1：选择器的权重, 权重大的生效, 根据权重可以判断出优先级</p><p>判断2：先后顺序, 权重相同时, 后面设置的生效</p><p>选择器的权重</p><p>!important：10000</p><p>内联样式：1000</p><p>id选择器：100</p><p>类选择器、属性选择器、伪类：10</p><p>元素选择器、伪元素：1</p><p>通配符：0</p><h3 id="3、HTML元素的类型"><a href="#3、HTML元素的类型" class="headerlink" title="3、HTML元素的类型"></a>3、HTML元素的类型</h3><p>html考虑一个问题：每个元素在页面中到底需要占据多大的空间</p><ul><li><p>某些元素非常重要；独占一行 -&gt;类型 块级元素（block level）h&#x2F;div&#x2F;p</p></li><li><p>某些元素属于内容的一部分，没不要独占一行，与其他内容在同一行显示，类型 -&gt; (inline level)  span a img</p></li></ul><p>HTML元素的类型</p><p>块级元素：独占父元素的一行</p><p>行内级元素：多个行内级元素可以在父元素的同一行中显示</p><p>img元素：inline - replaced -&gt; 行内替换元素</p><p>行内替换元素</p><p>  1.和其他的行内元素在同一行显示</p><p>  2.可以设置宽高</p><h3 id="4、display属性"><a href="#4、display属性" class="headerlink" title="4、display属性"></a>4、display属性</h3><p>css中有一个display属性，能够修改元素的显示类型</p><p>block：让元素显示为块级元素（独占父元素的一行，可以设置宽高，高度默认由内容决定）</p><p>inline：让元素显示为行内级元素（和其他元素在一行显示，不能设置宽高，大小由内容决定）</p><p>inline-block：让元素同时具备行内级、块级元素的特征</p><p>none：隐藏元素</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230319072815754.png" alt="image-20230319072815754"></p><p>编写 HTML 注意事项</p><p>块级元素、inline-block元素</p><ul><li><p>一般情况下，可以包含其他任何元素（比如块级元素、行内级元素、inline-block元素）</p></li><li><p>特殊情况，p元素不能包含其他块级元素</p></li></ul><p>行内级元素（比如a、span、strong等）</p><ul><li>一般情况下，只能包含行内级元素</li></ul><h3 id="5、元素的隐藏"><a href="#5、元素的隐藏" class="headerlink" title="5、元素的隐藏"></a>5、元素的隐藏</h3><p>方法一: display设置为none</p><ul><li>元素不显示出来, 并且也不占据位置, 不占据任何空间(和不存在一样)</li></ul><p>方法二: visibility设置为hidden</p><ul><li><p>设置为hidden, 虽然元素不可见, 但是会占据元素应该占据的空间</p></li><li><p>默认为visible, 元素是可见的</p></li></ul><p>方法三: rgba设置颜色, 将a的值设置为0</p><ul><li>rgba的a设置的是alpha值, 可以设置透明度, 不影响子元素（占据空间）</li></ul><p>方法四: opacity设置透明度, 设置为0</p><ul><li>设置整个元素的透明度, 会影响所有的子元素（占据空间）</li></ul><h4 id="编写的-CSS-样式不生效技巧"><a href="#编写的-CSS-样式不生效技巧" class="headerlink" title="编写的 CSS 样式不生效技巧"></a>编写的 CSS 样式不生效技巧</h4><ul><li>选择器优先级太低</li><li>选择器没选中对应的元素</li><li>CSS属性的使用形式不对<ul><li>元素不支持此CSS属性，比如span不支持设置宽高</li><li>浏览器不支持此CSS属性，比如旧版本的浏览器不支持一些css module3的某些属性</li><li>被同类型的CSS属性覆盖，比如font覆盖font-size</li></ul></li></ul><h3 id="6、overflow-属性"><a href="#6、overflow-属性" class="headerlink" title="6、overflow 属性"></a>6、overflow 属性</h3><p>overflow用于控制内容溢出时的行为</p><ul><li><p>visible：溢出的内容照样可见（默认值）</p></li><li><p>hidden：溢出的内容直接裁剪</p></li><li><p>scroll：溢出的内容被裁剪，但可以通过滚动机制查看</p><ul><li>会一直显示滚动条区域，滚动条区域占用的空间属于width、height</li></ul></li><li><p>auto：自动根据内容是否溢出来决定是否提供滚动机制（常用）</p></li></ul><h2 id="4-CSS的盒子模型"><a href="#4-CSS的盒子模型" class="headerlink" title="4.CSS的盒子模型"></a>4.CSS的盒子模型</h2><h3 id="1、认识盒子模型"><a href="#1、认识盒子模型" class="headerlink" title="1、认识盒子模型"></a>1、认识盒子模型</h3><p>我们可以把HTML每一个元素看出一个个的盒子，以具备这4个属性：</p><p>内容（content） ：元素的内容width&#x2F;height</p><p>内边距（padding）：元素和内容之间的间距</p><p>边框（border）：元素自己的边框</p><p>外边距（margin）：元素和其他元素之间的间距</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230314164800601.png" alt="image-20230314164800601"></p><p>盒子模型的四边</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230314171639045.png" alt="image-20230314171639045"></p><h3 id="2、内容—宽度和高度"><a href="#2、内容—宽度和高度" class="headerlink" title="2、内容—宽度和高度"></a>2、内容—宽度和高度</h3><p>设置内容是通过高度和宽度设置的：</p><p>宽度设置：width，默认值 auto，交给浏览器决定</p><p>高度设置：height</p><p>注意：对于行内级非替换元素来说, 设置宽高是无效的</p><p>其他设置：</p><p>min-width：最小宽度，无论内容多少，宽度都大于或等于min-width</p><p>max-width：最大宽度，无论内容多少，宽度都小于或等于max-width</p><p>移动端适配时, 可以设置最大宽度和最小宽度;</p><p>min-height：最小高度，无论内容多少，高度都大于或等于min-height</p><p>max-height：最大高度，无论内容多少，高度都小于或等于max-height</p><h3 id="3、内边距：padding"><a href="#3、内边距：padding" class="headerlink" title="3、内边距：padding"></a>3、内边距：padding</h3><p>padding属性用于设置盒子的内边距, 通常用于设置边框和内容之间的间距</p><p>padding单独编写是一个缩写属性</p><ul><li><p>padding-top、padding-right、padding-bottom、padding-left的简写属性</p></li><li><p>padding缩写属性是从零点钟方向开始, 沿着顺时针转动的, 也就是上右下左</p></li></ul><p>padding并非必须是四个值, 也可以有其他值</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230319081108760.png" alt="image-20230319081108760"></p><h3 id="4、边框"><a href="#4、边框" class="headerlink" title="4、边框"></a>4、边框</h3><p>border用于设置盒子的边框，边框具备宽度width、样式style、颜色color</p><p>边框宽度</p><ul><li><p>border-top-width、border-right-width、border-bottom-width、border-left-width</p></li><li><p>border-width是上面4个属性的简写属性</p></li></ul><p>边框颜色</p><ul><li><p>border-top-color、border-right-color、border-bottom-color、border-left-color</p></li><li><p>border-color是上面4个属性的简写属性</p></li></ul><p>边框样式</p><ul><li><p>border-top-style、border-right-style、border-bottom-style、border-left-style</p></li><li><p>border-style是上面4个属性的简写属性</p></li></ul><p>边框样式的设置值：</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230319230129421.png" alt="image-20230319230129421"></p><p>同时设置的方式</p><p>border-top、border-right、border-bottom、border-left</p><p>border：统一设置4个方向的边框</p><p>边框颜色、宽度、样式的编写顺序任意</p><p>圆角</p><p>border-radius用于设置盒子的圆角</p><p>border-radius常见的值</p><ul><li><p>数值: 通常用来设置小的圆角, 比如6px</p></li><li><p>百分比: 通常用来设置一定的弧度或者圆形;</p></li></ul><p>border-radius事实上是一个缩写属性</p><ul><li><p>将这四个属性 border-top-left-radius、border-top-right-radius、border-bottom-right-radius，和 border-bottomleft-radius 简写为一个属性</p></li><li><p>开发中比较少见一个个圆角设置</p></li></ul><p>如果一个元素是正方形，设置border-radius大于或等于50%时，就会变成一个圆</p><h3 id="5、外边距"><a href="#5、外边距" class="headerlink" title="5、外边距"></a>5、外边距</h3><p>margin属性用于设置盒子的外边距, 通常用于元素和元素之间的间距</p><p>margin包括四个方向, 所以有如下的取值</p><ul><li><p>margin-top：上内边距</p></li><li><p>margin-right：右内边距</p></li><li><p>margin-bottom：下内边距</p></li><li><p>margin-left：左内边距</p></li></ul><p>margin单独编写是一个缩写属性：</p><ul><li><p>margin-top、margin-right、margin-bottom、margin-left的简写属性</p></li><li><p>margin缩写属性是从零点钟方向开始, 沿着顺时针转动的, 也就是上右下左</p></li></ul><p>margin也并非必须是四个值, 也可以有其他值</p><p>margin和padding的区别</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">  &lt;style&gt;</span><br><span class="line">    .<span class="property">box</span> &#123;</span><br><span class="line">      <span class="attr">width</span>: 300px;</span><br><span class="line">      <span class="attr">height</span>: 300px;</span><br><span class="line">      background-<span class="attr">color</span>: red;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* padding弊端 会撑大盒子 */</span></span><br><span class="line">      <span class="comment">/* padding-left: 100px;</span></span><br><span class="line"><span class="comment">      box-sizing: border-box; */</span></span><br><span class="line">      <span class="attr">overflow</span>: auto;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .<span class="property">container</span> &#123;</span><br><span class="line">      <span class="attr">width</span>: 100px;</span><br><span class="line">      <span class="attr">height</span>: 100px;</span><br><span class="line">      background-<span class="attr">color</span>: green;</span><br><span class="line">      <span class="comment">/* 不用设置 border-box */</span></span><br><span class="line">      margin-<span class="attr">left</span>: 100px;</span><br><span class="line">      <span class="comment">/* 设置上下会有问题 发生传递  需在父元素设置overflow auto 触发bfc */</span></span><br><span class="line">      margin-<span class="attr">top</span>: 100px;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h4 id="1-上下margin传递"><a href="#1-上下margin传递" class="headerlink" title="1.上下margin传递"></a>1.上下margin传递</h4><p>margin-top传递</p><ul><li>如果块级元素的顶部线和父元素的顶部线重叠，那么这个块级元素的margin-top值会传递给父元素</li></ul><p>margin-bottom传递</p><ul><li>如果块级元素的底部线和父元素的底部线重写，并且父元素的高度是auto，那么这个块级元素的margin-bottom值会传递给父元素</li></ul><p>如何防止出现传递问题</p><p>给父元素设置padding-top\padding-bottom</p><p>给父元素设置border</p><p>触发BFC: 设置overflow为auto</p><p>建议</p><ul><li><p>margin一般是用来设置兄弟元素之间的间距</p></li><li><p>padding一般是用来设置父子元素之间的间距</p></li></ul><h4 id="2-上下margin的折叠"><a href="#2-上下margin的折叠" class="headerlink" title="2.上下margin的折叠"></a>2.上下margin的折叠</h4><p>垂直方向上相邻的2个margin（margin-top、margin-bottom）有可能会合并为1个margin，这种现象叫做collapse（折叠）</p><p>水平方向上的margin（margin-left、margin-right）永远不会collapse</p><p>折叠后最终值的计算规则</p><ul><li>两个值进行比较，取较大的值</li></ul><p>如何防止margin collapse？ </p><ul><li>只设置其中一个元素的margin</li></ul><p>margin 和 padding 的选择</p><p>元素与元素的距离：margin</p><p>子元素与父元素的距离：padding</p><h3 id="6、外轮廓"><a href="#6、外轮廓" class="headerlink" title="6、外轮廓"></a>6、外轮廓</h3><p>outline表示元素的外轮廓</p><ul><li><p>不占用空间</p></li><li><p>默认显示在border的外面</p></li></ul><p>outline相关属性有</p><ul><li><p>outline-width: 外轮廓的宽度</p></li><li><p>outline-style：取值跟border的样式一样，比如solid、dotted等</p></li><li><p>outline-color: 外轮廓的颜色</p></li><li><p>outline：outline-width、outline-style、outline-color的简写属性，跟border用法类似</p></li></ul><p>应用实例</p><ul><li>去除a元素、input元素的focus轮廓效果</li></ul><h3 id="7、盒子阴影"><a href="#7、盒子阴影" class="headerlink" title="7、盒子阴影"></a>7、盒子阴影</h3><p>box-shadow属性可以设置一个或者多个阴影</p><p>每个阴影用表示</p><p>多个阴影之间用逗号,隔开，从前到后叠加</p><p>格式：</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230319222535516.png" alt="image-20230319222535516"></p><p>第1个：offset-x, 水平方向的偏移，正数往右偏移</p><p>第2个：offset-y, 垂直方向的偏移，正数往下偏移</p><p>第3个：blur-radius, 模糊半径</p><p>第4个：spread-radius, 延伸半径</p><p><code>&lt;color&gt;</code>：阴影的颜色，如果没有设置，就跟随color属性的颜色</p><p>inset：外框阴影变成内框阴影</p><p>在线网址：<a href="https://html-css-js.com/css/generator/box-shadow/">https://html-css-js.com/css/generator/box-shadow/</a></p><h3 id="8、文字阴影"><a href="#8、文字阴影" class="headerlink" title="8、文字阴影"></a>8、文字阴影</h3><p>text-shadow用法类似于box-shadow，用于给文字添加阴影效果</p><p>常见格式如下</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230319222559369.png" alt="image-20230319222559369"></p><p>相当于box-shadow, 它没有spread-radius的值</p><h3 id="9、行内非替换元素的注意事项"><a href="#9、行内非替换元素的注意事项" class="headerlink" title="9、行内非替换元素的注意事项"></a>9、行内非替换元素的注意事项</h3><p>设置高宽不生效；</p><p>设置padding：左右可以生效，上下能够撑开，但是不占据空间</p><p>设置border：上下会被撑起来，不占据空间</p><p>设置margin：上下不生效</p><p>以下属性对行内级非替换元素不起作用</p><ul><li>width、height、margin-top、margin-bottom</li></ul><p>以下属性对行内级非替换元素的效果比较特殊</p><ul><li>padding-top、padding-bottom、上下方向的border</li></ul><p>1.前景色有没有设置到border下面（有设置）</p><p>2.前景色回在border没有设置颜色的情况下，显示出color的颜色</p><h3 id="10、box-sizing"><a href="#10、box-sizing" class="headerlink" title="10、box-sizing"></a>10、box-sizing</h3><p>box-sizing用来设置盒子模型中宽高的行为</p><ul><li>content-box<ul><li>padding、border都布置在width、height<strong>外边</strong></li><li>元素的实际占用宽度 &#x3D; border + padding + width</li><li>元素的实际占用高度 &#x3D; border + padding + height</li></ul></li><li>border-box<ul><li>padding、border都布置在width、height<strong>里边</strong></li><li>元素的实际占用宽度 &#x3D; width</li><li>元素的实际占用高度 &#x3D; height</li></ul></li></ul><h3 id="11、元素的水平居中方案"><a href="#11、元素的水平居中方案" class="headerlink" title="11、元素的水平居中方案"></a>11、元素的水平居中方案</h3><p>在一些需求中，需要元素在父元素中水平居中显示（父元素一般都是块级元素、inline-block）</p><p>行内级元素(包括inline-block元素) </p><ul><li>水平居中：在父元素中设置text-align: center</li></ul><p>块级元素</p><ul><li>水平居中：margin: 0 auto（在块级元素中对自己设置）</li></ul><h3 id="12、案例练习总结"><a href="#12、案例练习总结" class="headerlink" title="12、案例练习总结"></a>12、案例练习总结</h3><p>文字介绍一行展示溢出显示…</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">white-<span class="attr">space</span>: nowrap;</span><br><span class="line"><span class="attr">overflow</span>: hidden;</span><br><span class="line">text-<span class="attr">overflow</span>: ellipsis;</span><br></pre></td></tr></table></figure><p>文字介绍两行展示溢出显示…</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">overflow</span>: hidden;</span><br><span class="line">text-<span class="attr">overflow</span>: ellipsis;</span><br><span class="line"><span class="attr">display</span>: -webkit-box;</span><br><span class="line">-webkit-line-<span class="attr">clamp</span>: <span class="number">2</span>;  <span class="comment">// 设置几行显示文字</span></span><br><span class="line">-webkit-box-<span class="attr">orient</span>: vertical;</span><br><span class="line"></span><br><span class="line">并且需要保证其父元素有具体的宽度，如果父元素设置了inline-block，可调为block</span><br></pre></td></tr></table></figure><h2 id="5-CSS-的背景设置"><a href="#5-CSS-的背景设置" class="headerlink" title="5.CSS 的背景设置"></a>5.CSS 的背景设置</h2><h3 id="1、background-image"><a href="#1、background-image" class="headerlink" title="1、background-image"></a>1、background-image</h3><p>background-image用于设置元素的背景图片</p><ul><li>会盖在（不是覆盖）background-color 的上面</li></ul><p>如果设置了多张图片</p><ul><li>设置的第一张图片将显示在最上面，其他图片按顺序层叠在下面</li></ul><p>注意：如果设置了背景图片后，元素没有具体的宽高，背景图片是不会显示出来的</p><h3 id="2、background-repeat"><a href="#2、background-repeat" class="headerlink" title="2、background-repeat"></a>2、background-repeat</h3><p>background-repeat用于设置背景图片是否要平铺</p><p>常见的设值有</p><ul><li><p>repeat：平铺（默认值）</p></li><li><p>no-repeat：不平铺</p></li><li><p>repeat-x：只在水平方向平铺</p></li><li><p>repeat-y：只在垂直平方向平铺</p></li></ul><h3 id="3、background-size"><a href="#3、background-size" class="headerlink" title="3、background-size"></a>3、background-size</h3><p>background-size用于设置背景图片的大小</p><p>auto：默认值, 以背景图本身大小显示</p><p>cover：缩放背景图，以完全覆盖铺满元素,可能背景图片部分看不见</p><p>contain：缩放背景图，宽度或者高度铺满元素，但是图片保持宽高比</p><p><code>&lt;percentage&gt;</code>：百分比，相对于背景区（background positioning area）</p><p>length：具体的大小，比如100px</p><h3 id="4、background-position"><a href="#4、background-position" class="headerlink" title="4、background-position"></a>4、background-position</h3><p>background-position用于设置背景图片在水平、垂直方向上的具体位置</p><ul><li><p>可以设置具体的数值 比如 20px 30px</p></li><li><p>水平方向还可以设值：left、center、right</p></li><li><p>垂直方向还可以设值：top、center、bottom</p></li></ul><p>如果只设置了1个方向，另一个方向默认是center</p><h3 id="5、background-attachment"><a href="#5、background-attachment" class="headerlink" title="5、background-attachment"></a>5、background-attachment</h3><p>background-attachment决定背景图像的位置是在视口内固定，或者随着包含它的区块滚动。</p><p>可以设置以下3个值</p><ul><li><p>scroll：此关键属性值表示背景相对于元素本身固定， 而不是随着它的内容滚动</p></li><li><p>local：此关键属性值表示背景相对于元素的内容固定。如果一个元素拥有滚动机制，背景将会随着元素的内容滚动</p></li><li><p>fixed：此关键属性值表示背景相对于视口固定。即使一个元素拥有滚动机制，背景也不会随着元素的内容滚动。</p></li></ul><h3 id="6、background"><a href="#6、background" class="headerlink" title="6、background"></a>6、background</h3><p>background是一系列背景相关属性的简写属性</p><p>background-size可以省略，如果不省略，&#x2F;background-size必须紧跟在background-position的后面</p><p>其他属性也都可以省略，而且顺序任意</p><h4 id="background-image-和-img-对比"><a href="#background-image-和-img-对比" class="headerlink" title="background-image 和 img 对比"></a>background-image 和 img 对比</h4><p>利用background-image和img都能够实现显示图片的需求，在开发中该如何选择？</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230319215927911.png" alt="image-20230319215927911"></p><p>总结</p><ul><li><p>img，作为网页内容的重要组成部分，比如广告图片、LOGO图片、文章配图、产品图片</p></li><li><p>background-image，可有可无。有，能让网页更加美观。无，也不影响用户获取完整的网页内容信息</p></li></ul><h2 id="6-高级元素"><a href="#6-高级元素" class="headerlink" title="6.高级元素"></a>6.高级元素</h2><h3 id="1、列表元素"><a href="#1、列表元素" class="headerlink" title="1、列表元素"></a>1、列表元素</h3><p>列表功能不同的方案实现</p><ul><li><p>方案一: 使用div元素来实现（比如汽车之家, 知乎上的很多列表）</p></li><li><p>方案二: 使用列表元素，使用元素语义化的方式实现</p></li></ul><p>HTML提供了3组常用的用来展示列表的元素</p><ul><li><p>有序列表：ol、li：直接子元素只能是 li</p></li><li><p>无序列表：ul、li：直接子元素只能是 li</p></li><li><p>定义列表：dl、dt、dd：直接子元素只能是 dt、dd</p><ul><li>dt（definition term）term是项的意思, 列表中每一项的项目名</li><li>列表中每一项的具体描述，是对 dt 的描述、解释、补充</li><li>一个dt后面一般紧跟着1个或者多个dd</li></ul></li></ul><h3 id="2、表格元素"><a href="#2、表格元素" class="headerlink" title="2、表格元素"></a>2、表格元素</h3><h4 id="1-常见的元素"><a href="#1-常见的元素" class="headerlink" title="1.常见的元素"></a>1.常见的元素</h4><p>table：表格</p><p>tr：表格中的行</p><p>td：行中的单元格</p><p>border-collapse CSS 属性是用来决定表格的<strong>边框</strong>是分开的还是合并的。 </p><ul><li><p>table { border-collapse: collapse; }</p></li><li><p>合并单元格的边框</p></li></ul><h4 id="2-表格的其他元素"><a href="#2-表格的其他元素" class="headerlink" title="2.表格的其他元素"></a>2.表格的其他元素</h4><p>thead：表格的表头</p><p>tbody：表格的主体</p><p>tfoot：表格的页脚</p><p>caption：表格的标题</p><p>th：表格的表头单元格</p><h4 id="3-单元格合并"><a href="#3-单元格合并" class="headerlink" title="3.单元格合并"></a>3.单元格合并</h4><p>在某些特殊的情况下, 每个单元格占据的大小可能并不是固定的</p><p>一个单元格可能会跨多行或者多列来使用</p><p>单元格合并分成两种情况</p><p>跨列合并: 使用colspan</p><ul><li>在最左边的单元格写上colspan属性，并且省略掉合并的td</li></ul><p>跨行合并: 使用rowspan</p><ul><li>在最上面的单元格协商rowspan属性，并且省略掉后面tr中的td</li></ul><h3 id="3、表单"><a href="#3、表单" class="headerlink" title="3、表单"></a>3、表单</h3><p>表单元素</p><p>form：表单，一般情况下，其他表单相关元素都是它的后代元素</p><p>input：单行文本输入框、单选框、复选框、按钮等元素</p><p>textarea：多行文本框</p><p>select、option：下拉选择框 </p><p>button：按钮</p><p>label：表单元素的标题</p><h4 id="1-input-元素的使用"><a href="#1-input-元素的使用" class="headerlink" title="1.input 元素的使用"></a>1.input 元素的使用</h4><p>常见的属性：</p><p>type：input的类型</p><ul><li><p>text：文本输入框（明文输入）</p></li><li><p>password：文本输入框（密文输入）</p></li><li><p>radio：单选框</p></li><li><p>checkbox：复选框</p></li><li><p>button：按钮</p></li><li><p>reset：重置</p></li><li><p>submit：提交表单数据给服务器</p></li><li><p>file：文件上传</p></li></ul><p>readonly：只读</p><p>disabled：禁用</p><p>checked：默认被选中</p><ul><li>只有当type为radio或checkbox时可用</li></ul><p>autofocus：当页面加载时，自动聚焦</p><p>name：名字</p><ul><li>在提交数据给服务器时，可用于区分数据类型</li></ul><p>value：取值</p><p>布尔属性</p><p>常见的布尔属性有disabled、checked、readonly、multiple、autofocus、selected</p><p>布尔属性可以没有属性值，写上属性名就代表使用这个属性</p><ul><li>如果要给布尔属性设值，值就是属性名本身</li></ul><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230320205600506.png" alt="image-20230320205600506"></p><h4 id="2-表单按钮"><a href="#2-表单按钮" class="headerlink" title="2.表单按钮"></a>2.表单按钮</h4><p>普通按钮（type&#x3D;button）：使用value属性设置按钮文字</p><p>重置按钮（type&#x3D;reset）：重置它所属form的所有表单元素（包括input、textarea、select）</p><p>提交按钮（type&#x3D;submit）：提交它所属form的表单数据给服务器（包括input、textarea、select）</p><h4 id="3-input-和-label-的关系"><a href="#3-input-和-label-的关系" class="headerlink" title="3.input 和 label 的关系"></a>3.input 和 label 的关系</h4><p>label元素一般跟input配合使用，用来表示input的标题</p><p>labe可以跟某个input绑定，点击label就可以激活对应的input变成选中</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;username&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    用户:</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;username&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h4 id="4-单选框—radio"><a href="#4-单选框—radio" class="headerlink" title="4.单选框—radio"></a>4.单选框—radio</h4><p>name值相同的radio才具备单选功能</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- 在类型为radio的input中 如果name一样 那么两个radio会互斥 --&gt;</span><br><span class="line">    &lt;label for=&quot;male&quot;&gt;</span><br><span class="line">      &lt;input type=&quot;radio&quot; name=&quot;sex&quot; id=&quot;male&quot; value=&quot;male&quot;&gt;男</span><br><span class="line">    &lt;/label&gt;</span><br><span class="line">    &lt;label for=&quot;female&quot;&gt;</span><br><span class="line">      &lt;input type=&quot;radio&quot; name=&quot;sex&quot; id=&quot;female&quot; value=&quot;female&quot;&gt;女</span><br><span class="line">    &lt;/label&gt;</span><br></pre></td></tr></table></figure><h4 id="5-多选框—checkbox"><a href="#5-多选框—checkbox" class="headerlink" title="5.多选框—checkbox"></a>5.多选框—checkbox</h4><p>属于同一种类型的checkbox，name值要保持一致</p><p>可以设置 checked 来默认选中其中一项</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;label <span class="keyword">for</span>=<span class="string">&quot;basketball&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;basketball&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span> <span class="attr">value</span>=<span class="string">&quot;basketball&quot;</span> <span class="attr">checked</span>&gt;</span>篮球</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h4 id="6-多行输入—textarea"><a href="#6-多行输入—textarea" class="headerlink" title="6.多行输入—textarea"></a>6.多行输入—textarea</h4><p>textarea的常用属性</p><p>cols：列数</p><p>rows：行数</p><p>缩放的CSS设置</p><ul><li><p>禁止缩放：resize: none</p></li><li><p>水平缩放：resize: horizontal</p></li><li><p>垂直缩放：resize: vertical</p></li><li><p>水平垂直缩放：resize: both</p></li></ul><h4 id="7-选项列表"><a href="#7-选项列表" class="headerlink" title="7.选项列表"></a>7.选项列表</h4><p>option是select的子元素，一个option代表一个选项</p><p>select常用属性</p><ul><li><p>multiple：可以多选</p></li><li><p>size：显示多少项</p></li></ul><p>option常用属性</p><ul><li>selected：默认被选中</li></ul><h4 id="8-form元素"><a href="#8-form元素" class="headerlink" title="8.form元素"></a>8.form元素</h4><p>form通常作为表单元素的父元素</p><ul><li><p>form可以将整个表单作为一个整体来进行操作</p></li><li><p>比如对整个表单进行重置</p></li><li><p>比如对整个表单的数据进行提交</p></li></ul><p>form常见的属性如下</p><ul><li><p>action：用于提交表单数据的请求URL</p></li><li><p>method：请求方法（get和post），默认是get</p></li><li><p>target：在什么地方打开URL（参考a元素的target）</p></li></ul><h2 id="7-emmet语法和结构伪类"><a href="#7-emmet语法和结构伪类" class="headerlink" title="7.emmet语法和结构伪类"></a>7.emmet语法和结构伪类</h2><h3 id="1、emmet语法"><a href="#1、emmet语法" class="headerlink" title="1、emmet语法"></a>1、emmet语法</h3><p>Emmet (前身为 Zen Coding) 是一个能大幅度提高前端开发效率的一个工具</p><p>在前端开发的过程中，一大部分的工作是写 HTML、CSS 代码，如果手动来编写效果会非常低</p><p>VsCode内置了Emmet语法，在后缀为.html&#x2F;.css中输入缩写后按Tab&#x2F;Enter键即会自动生成相应代码</p><p>!和html:5可以快速生成完整结构的html5代码</p><p><code>&gt;</code>：子代    <code>+</code>；兄弟   <code>*</code>：多个   <code>^</code>：上一级（最多到body）  <code>()</code>：分组</p><p> 属性：<code>[]</code>：普通属性  <code>#</code>：id属性  <code>.</code> ：class属性   <code>&#123;&#125;</code>：内容   <code>$</code>：数字  </p><p>隐式标签：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- ul&gt;.<span class="property">item</span>&#123;列表元素$$&#125;*<span class="number">3</span> --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span>列表元素01<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span>列表元素02<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span>列表元素03<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>css emmet：属性的缩写</p><h3 id="2、结构伪类"><a href="#2、结构伪类" class="headerlink" title="2、结构伪类"></a>2、结构伪类</h3><h4 id="1-nth-child-n"><a href="#1-nth-child-n" class="headerlink" title="1.:nth-child(n)"></a>1.:nth-child(n)</h4><p>:nth-child(1)：是父元素中的第1个子元素</p><p>:nth-child(2n)：n代表任意正整数和0</p><ul><li><p>是父元素中的第偶数个子元素（第2、4、6、8……个）</p></li><li><p>跟:nth-child(even)同义</p></li></ul><p>:nth-child(2n + 1)：n代表任意正整数和0</p><ul><li>是父元素中的第奇数个子元素（第1、3、5、7……个）</li><li>跟:nth-child(odd)同义</li></ul><p>nth-child(-n + 2)：代表前2个子元素</p><h4 id="2-nth-last-child-n"><a href="#2-nth-last-child-n" class="headerlink" title="2.:nth-last-child(n)"></a>2.:nth-last-child(n)</h4><p>:nth-last-child()的语法跟:nth-child()类似，不同点是:nth-last-child()从最后一个子元素开始往前计数</p><ul><li><p>:nth-last-child(1)，代表倒数第一个子元素</p></li><li><p>:nth-last-child(-n + 2)，代表最后2个子元素</p></li></ul><p>:nth-of-type()用法跟:nth-child()类似</p><ul><li>不同点是:nth-of-type()计数时只计算同种类型的元素</li></ul><p>:nth-last-of-type()用法跟:nth-of-type()类似</p><ul><li>不同点是:nth-last-of-type()从最后一个这种类型的子元素开始往前计数</li></ul><p>其他常见的伪类(了解)</p><ul><li><p>:first-child，等同于:nth-child(1)</p></li><li><p>:last-child，等同于:nth-last-child(1)</p></li><li><p>:first-of-type，等同于:nth-of-type(1)</p></li><li><p>:last-of-type，等同于:nth-last-of-type(1)</p></li><li><p>:only-child，是父元素中唯一的子元素</p></li><li><p>:only-of-type，是父元素中唯一的这种类型的子元素</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">.<span class="property">box</span> &gt; :first-child &#123;</span><br><span class="line">     <span class="attr">color</span>: red;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>偶尔使用</p><ul><li><p>:root，根元素，就是HTML元素</p></li><li><p>:empty代表里面完全空白的元素</p></li></ul><h4 id="3-否定伪类"><a href="#3-否定伪类" class="headerlink" title="3.否定伪类"></a>3.否定伪类</h4><p>:not()的格式是:not(x)</p><ul><li><p>x是一个简单选择器</p></li><li><p>元素选择器、通用选择器、属性选择器、类选择器、id选择器、伪类（除否定伪类）</p></li></ul><p>:not(x)表示除x以外的元素</p><h2 id="8-额外知识"><a href="#8-额外知识" class="headerlink" title="8.额外知识"></a>8.额外知识</h2><h3 id="1、边框的形状"><a href="#1、边框的形状" class="headerlink" title="1、边框的形状"></a>1、边框的形状</h3><p>border 主要是用来给盒子增加边框的, 但是在开发中我们也可以利用边框的特性来实现一些形状</p><p><a href="https://css-tricks.com/the-shape-of-css/#top-of-site">https://css-tricks.com/the-shape-of-css/#top-of-site</a></p><h3 id="2、认识-web-字体"><a href="#2、认识-web-字体" class="headerlink" title="2、认识 web 字体"></a>2、认识 web 字体</h3><p>在之前设置页面使用的字体: font-family</p><ul><li><p>我们需要提供一个或多个字体种类名称，浏览器会在列表中搜寻，直到找到它所运行的系统上可用的字体</p></li><li><p>这样的方式完全没有问题，但是对于传统的web开发人员来说，字体选择是有限的</p></li><li><p>这就是所谓的 Web-safe 字体</p></li><li><p>并且这种默认可选的字体并不能进行一些定制化的需求</p></li></ul><p>如果我们依然想在网页中使用别的字体，使用Web Fonts即可</p><h4 id="1-web-fonts-的工作原理"><a href="#1-web-fonts-的工作原理" class="headerlink" title="1.web fonts 的工作原理"></a>1.web fonts 的工作原理</h4><p>首先, 我们需要通过一些渠道获取到希望使用的字体(不是开发来做的事情): </p><ul><li><p>对于某些收费的字体, 我们需要获取到对应的授权</p></li><li><p>对于某些公司定制的字体, 需要设计人员来设计</p></li><li><p>对于某些免费的字体, 我们需要获取到对应的字体文件</p></li></ul><p>其次, 在我们的CSS代码当中使用该字体(重要): </p><p>最后, 在部署静态资源时, 将HTML&#x2F;CSS&#x2F;JavaScript&#x2F;Font一起部署在静态服务器中</p><p>用户的角度</p><ul><li>浏览器一个网页时, 因为代码中有引入字体文件, 字体文件会被一起下载下来</li><li>浏览器会根据使用的字体在下载的字体文件中查找、解析、使用对应的字体</li><li>在浏览器中使用对应的字体显示内容；</li></ul><p>使用：</p><p>第一步</p><ul><li><p>在字体天下网站下载一个字体   <a href="https://www.fonts.net.cn/">https://www.fonts.net.cn/</a></p></li><li><p>默认下载下来的是ttf文件</p></li></ul><p> 第二步：使用字体</p><p>使用过程如下：</p><ul><li><p>1.将字体放到对应的目录中</p></li><li><p>2.通过@font-face来引入字体, 并且设置格式</p></li><li><p>3.使用字体</p></li></ul><p>注意: @font-face 用于加载一个自定义的字体;</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 字体引入 */</span></span><br><span class="line">    @font-face &#123;</span><br><span class="line">      font-<span class="attr">family</span>: <span class="string">&quot;wbh&quot;</span>;</span><br><span class="line">      <span class="attr">src</span>: <span class="title function_">url</span>(<span class="string">&quot;./fonts/SanJiLiFengTi-2.ttf&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 使用 */</span></span><br><span class="line">    .<span class="property">box</span> &#123;</span><br><span class="line">      font-<span class="attr">family</span>: <span class="string">&quot;wbh&quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="2-网络字体的兼容性"><a href="#2-网络字体的兼容性" class="headerlink" title="2.网络字体的兼容性"></a>2.网络字体的兼容性</h4><p>在开发中某些浏览器可能不支持该字体, 所以为了浏 览器的兼容性问题, 我们需要有对应其他格式的字体</p><p>TrueType字体：拓展名是 .ttf </p><ul><li><p>OpenType&#x2F;TrueType字体：拓展名是 .ttf、.otf， 建立在TrueType字体之上</p></li><li><p>Embedded OpenType字体：拓展名是 .eot， OpenType字体的压缩版</p></li><li><p>SVG字体：拓展名是 .svg、 .svgz</p></li><li><p>WOFF表示Web Open Font Format web开放字体： 拓展名是 .woff，建立在TrueType字体之上</p></li></ul><p>生成兼容性字体：<a href="https://font.qqe2.com/">https://font.qqe2.com/</a></p><p>兼容性写法：</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230321122936480.png" alt="image-20230321122936480"></p><p>src用于指定字体资源</p><ul><li><p>url指定资源的路径</p></li><li><p>format用于帮助浏览器快速识别字体的格式</p></li></ul><h3 id="3、字体图标"><a href="#3、字体图标" class="headerlink" title="3、字体图标"></a>3、字体图标</h3><p>字体图标的使用步骤</p><p>第一步: 通过link引入iconfont.css文件</p><p>第二步: 使用字体图标</p><p>使用字体图标常见的有两种方式</p><p>方式一: 通过对应字体图标的 Unicode 来显示代码</p><p>方式二: 利用已经编写好的class，直接使用即可</p><p>即：方式1：同webfonts方式，引入ttf文件，再使用对应的字符实体，打开demo_index.html查看字符实体</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">  &lt;style&gt;</span><br><span class="line">    @font-face &#123;</span><br><span class="line">      font-<span class="attr">family</span>: <span class="string">&quot;iconfont&quot;</span>;</span><br><span class="line">      <span class="attr">src</span>: <span class="title function_">url</span>(<span class="string">&quot;./fonts03/iconfont.ttf&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .<span class="property">iconfont</span> &#123;</span><br><span class="line">      font-<span class="attr">family</span>: <span class="string">&quot;iconfont&quot;</span>;</span><br><span class="line">      font-<span class="attr">size</span>: normal;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;iconfont&quot;</span>&gt;</span><span class="symbol">&amp;#xe738;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>方式2：使用伪元素，::before，在 iconfont.css  查看 content</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">    @font-face &#123;</span><br><span class="line">      font-<span class="attr">family</span>: <span class="string">&quot;iconfont&quot;</span>;</span><br><span class="line">      <span class="attr">src</span>: <span class="title function_">url</span>(<span class="string">&quot;./fonts03/iconfont.ttf&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .<span class="property">iconfont</span> &#123;</span><br><span class="line">      font-<span class="attr">family</span>: <span class="string">&quot;iconfont&quot;</span>;</span><br><span class="line">      font-<span class="attr">size</span>: normal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .<span class="property">music</span>::before &#123;</span><br><span class="line">      <span class="attr">content</span>: <span class="string">&quot;\e61a&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;iconfont music&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>方法3：使用 class 类名，引入iconfont.css文件，需先设置类名 iconfont 再设置对应的图标类名</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">  &lt;link rel=<span class="string">&quot;stylesheet&quot;</span> href=<span class="string">&quot;./fonts03/iconfont.css&quot;</span>&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;iconfont icon-music&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>阿里：<a href="https://www.iconfont.cn/">https://www.iconfont.cn/</a></p><h3 id="4、精灵图"><a href="#4、精灵图" class="headerlink" title="4、精灵图"></a>4、精灵图</h3><p>CSS Sprite：是一种CSS图像合成技术，将各种小图片合并到一张图片上，然后利用CSS的背景定位来显示对应的图片部分</p><p>有人翻译为：CSS雪碧、CSS精灵</p><p>使用CSS Sprite的好处</p><ul><li>减少网页的http请求数量，加快网页响应速度，减轻服务器压力</li><li>减小图片总大小</li><li>解决了图片命名的困扰，只需要针对一张集合的图片命名</li></ul><p>精灵图的制作</p><p>方法1：专业设计人员</p><p>方法2：<a href="https://www.toptal.com/developers/css/sprite-generator">https://www.toptal.com/developers/css/sprite-generator</a></p><p>精灵图的使用</p><p>精灵图的原理是通过只显示图片的很小一部分来展示的</p><p>通常使用背景</p><ul><li>1.设置对应元素的宽度和高度</li><li>2.设置精灵图作为背景图片</li><li>3.调整背景图片的位置来展示</li></ul><p>获取精灵图的位置：<a href="http://www.spritecow.com/">http://www.spritecow.com/</a></p><h3 id="5、cursor"><a href="#5、cursor" class="headerlink" title="5、cursor"></a>5、cursor</h3><p>cursor可以设置鼠标指针（光标）在元素上面时的显示样式</p><p>cursor常见的设值有</p><ul><li><p>auto：浏览器根据上下文决定指针的显示样式，比如根据文本和非文本切换指针样式</p></li><li><p>default：由操作系统决定，一般就是一个小箭头</p></li><li><p>pointer：一只小手，鼠标指针挪动到链接上面默认就是这个样式</p></li><li><p>text：一条竖线，鼠标指针挪动到文本输入框上面默认就是这个样式</p></li><li><p>none：没有任何指针显示在元素上面</p></li></ul><h2 id="9-元素定位"><a href="#9-元素定位" class="headerlink" title="9.元素定位"></a>9.元素定位</h2><h3 id="1、标准流布局"><a href="#1、标准流布局" class="headerlink" title="1、标准流布局"></a>1、标准流布局</h3><p>默认情况下，元素都是按照normal flow（标准流、常规流、正常流、文档流【document flow】）进行排布</p><ul><li><p>从左到右、从上到下按顺序摆放好</p></li><li><p>默认情况下，互相之间不存在层叠现象</p></li></ul><p>在标准流中，可以使用margin、padding对元素进行定位</p><p>其中margin还可以设置负数</p><p>比较明显的缺点是</p><ul><li><p>设置一个元素的margin或者padding，通常会影响到标准流中其他元素的定位效果</p></li><li><p>不便于实现元素层叠的效果</p></li></ul><p>如果我们希望一个元素可以跳出标准流，单独的对某个元素进行定位呢? </p><p>可以通过position属性来进行设置</p><p>定位允许您从正常的文档流布局中取出元素，并使它们具有不同的行为: </p><ul><li><p>例如放在另一个元素的上面;</p></li><li><p>或者始终保持在浏览器视窗内的同一位置</p></li></ul><p>利用position可以对元素进行定位，常用取值有5个: </p><ul><li>默认值:  static：默认值, 静态定位</li></ul><p>使用下面的值, 可以让元素变成 定位元素(positioned element)</p><ul><li><p>relative：相对定位</p></li><li><p>absolute：绝对定位</p></li><li><p>fixed：固定定位</p></li><li><p>sticky：粘性定位</p></li></ul><p>position属性的默认值：static</p><ul><li><p>元素按照 normal flow 布局</p></li><li><p>left 、right、top、bottom没有任何作用</p></li></ul><h3 id="2、相对定位"><a href="#2、相对定位" class="headerlink" title="2、相对定位"></a>2、相对定位</h3><p>元素按照normal flow布局</p><p>可以通过left、right、top、bottom进行定位</p><ul><li><strong>定位参照对象是元素自己原来的位置</strong></li></ul><p>left、right、top、bottom用来设置元素的具体位置</p><p>相对定位的应用场景</p><ul><li>在不影响其他元素位置的前提下，对当前元素位置进行微调（相对自己原来的位置）</li></ul><h3 id="3、固定定位"><a href="#3、固定定位" class="headerlink" title="3、固定定位"></a>3、固定定位</h3><p>元素脱离normal flow（脱离标准流、脱标）</p><p>可以通过left、right、top、bottom进行定位</p><p><strong>定位参照对象是视口（viewport）</strong></p><p>当画布滚动时，固定不动</p><p>视口（Viewport）</p><ul><li>文档的可视区域</li></ul><p>画布（Canvas）</p><ul><li><p>用于渲染文档的区域</p></li><li><p>文档内容超出视口范围，可以通过滚动查看</p></li></ul><p>宽高对比</p><ul><li>画布 &gt;&#x3D; 视口 画布 和 视口</li></ul><h3 id="4、绝对定位"><a href="#4、绝对定位" class="headerlink" title="4、绝对定位"></a>4、绝对定位</h3><p>元素脱离normal flow（脱离标准流、脱标）</p><p>可以通过left、right、top、bottom进行定位</p><ul><li><p><strong>定位参照对象是最邻近的定位祖先元素</strong></p></li><li><p><strong>如果找不到这样的祖先元素，参照对象是视口，内容是可以滚动的</strong></p></li></ul><p>定位元素（positioned element）</p><ul><li><p>position值不为static的元素</p></li><li><p>也就是position值为relative、absolute、fixed的元素</p></li></ul><h4 id="子绝父相"><a href="#子绝父相" class="headerlink" title="子绝父相"></a>子绝父相</h4><p>在绝大数情况下，子元素的绝对定位都是相对于父元素进行定位</p><p>如果希望子元素相对于父元素进行定位，又不希望父元素脱标，常用解决方案是：</p><ul><li><p>父元素设置position: relative（让父元素成为定位元素，而且父元素不脱离标准流）</p></li><li><p>子元素设置position: absolute</p></li><li><p>简称为“子绝父相”</p></li></ul><h4 id="绝对-x2F-固定-定位元素的特点"><a href="#绝对-x2F-固定-定位元素的特点" class="headerlink" title="绝对&#x2F;固定-定位元素的特点"></a>绝对&#x2F;固定-定位元素的特点</h4><ol><li>position:fixed    </li><li>position:absolute</li></ol><p>可以随意设置宽高</p><p>宽高默认由内容决定</p><p>不再受标准流的约束</p><ul><li>不再严格按照从上往下、从左到右排布</li><li>不再严格区分块级、行内级、行内块级的很多特征都会消失</li></ul><p>不再给父元素汇报宽高数据</p><p>脱标元素内部还是按照标准流布局</p><p>对于绝对定位元素来说</p><p>定位参照对象的宽度 &#x3D; left + right + margin-left + margin-right + 绝对定位元素的实际占用宽度</p><p>定位参照对象的高度 &#x3D; top + bottom + margin-top + margin-bottom + 绝对定位元素的实际占用高度</p><p>如果希望绝对定位元素的宽高和定位参照对象一样，可以给绝对定位元素设置以下属性</p><ul><li>left: 0、right: 0、top: 0、bottom: 0、margin:0</li></ul><p>如果希望绝对定位元素在定位参照对象中居中显示，可以给绝对定位元素设置以下属性</p><ul><li><p>left: 0、right: 0、top: 0、bottom: 0、margin: auto</p></li><li><p>另外，还得设置具体的宽高值（宽高小于定位参照对象的宽高）</p></li></ul><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230321222022472.png"></p><h3 id="5、粘性定位"><a href="#5、粘性定位" class="headerlink" title="5、粘性定位"></a>5、粘性定位</h3><p>还有一个定位的值是position: sticky，比起其他定位值要新一些</p><ul><li><p>sticky是一个大家期待已久的属性</p></li><li><p>可以看做是相对定位和固定定位的结合体</p></li></ul><p>它允许被定位的元素表现得像相对定位一样，直到它滚动到某个阈值点</p><p>当达到这个阈值点时, 就会变成固定定位</p><p>sticky是相对于最近的滚动祖先包含视口的(the nearest ancestor scroll container’s scrollport )</p><h3 id="6、z-index"><a href="#6、z-index" class="headerlink" title="6、z-index"></a>6、z-index</h3><p>z-index属性用来设置<strong>定位元素</strong>的层叠顺序（<strong>仅对定位元素有效</strong>）</p><ul><li>取值可以是正整数、负整数、0</li></ul><p>比较原则</p><ul><li><p>如果是兄弟关系</p><ul><li>z-index越大，层叠在越上面</li><li>z-index相等，写在后面的那个元素层叠在上面</li></ul></li><li><p>如果不是兄弟关系 </p><ul><li>各自从元素自己以及祖先元素中，找出最邻近的2个定位元素进行比较</li><li>而且这2个定位元素必须有设置z-index的具体数值</li></ul></li></ul><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230321224530651.png" alt="image-20230321224530651"></p><h2 id="10-CSS元素浮动"><a href="#10-CSS元素浮动" class="headerlink" title="10.CSS元素浮动"></a>10.CSS元素浮动</h2><h3 id="1、认识浮动"><a href="#1、认识浮动" class="headerlink" title="1、认识浮动"></a>1、认识浮动</h3><p>float 属性可以指定一个元素应沿其容器的左侧或右侧放置，允许文本和内联元素环绕它。</p><ul><li><p>float 属性最初只用于在一段文本内浮动图像, 实现文字环绕的效果</p></li><li><p>但是早期的CSS标准中并没有提供好的左右布局方案, 因此在一段时间里面它成为网页多列布局的最常用工具</p></li></ul><p>绝对定位、浮动都会让元素脱离标准流，以达到灵活布局的效果</p><p>可以通过float属性让元素产生浮动效果，float的常用取值</p><ul><li><p>none：不浮动，默认值</p></li><li><p>left：向左浮动</p></li><li><p>right：向右浮动</p></li></ul><h3 id="2、浮动规则"><a href="#2、浮动规则" class="headerlink" title="2、浮动规则"></a>2、浮动规则</h3><h4 id="浮动规则1"><a href="#浮动规则1" class="headerlink" title="浮动规则1"></a>浮动规则1</h4><p>元素一旦浮动后, 脱离标准流</p><p>朝着向左或向右方向移动，直到自己的边界紧贴着包含块（一般是父元素）或者其他浮动元素的边界为止</p><p>定位元素会层叠在浮动元素上面</p><h4 id="浮动规则2"><a href="#浮动规则2" class="headerlink" title="浮动规则2"></a>浮动规则2</h4><p>如果元素是向左（右）浮动，浮动元素的左（右）边界不能超出包含块的左（右）边界</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230322211609799.png" alt="image-20230322211609799"></p><h4 id="浮动规则3"><a href="#浮动规则3" class="headerlink" title="浮动规则3"></a>浮动规则3</h4><p>浮动元素之间不能层叠</p><ul><li><p>如果一个元素浮动，另一个浮动元素已经在那个位置了，后浮动的元素将紧贴着前一个浮动元素（左浮找左浮，右浮找右浮）</p></li><li><p>如果水平方向剩余的空间不够显示浮动元素，浮动元素将向下移动，直到有充足的空间为止</p></li></ul><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230322211713800.png" alt="image-20230322211713800"></p><h4 id="浮动规则4"><a href="#浮动规则4" class="headerlink" title="浮动规则4"></a>浮动规则4</h4><p>浮动元素不能与行内级内容层叠，行内级内容将会被浮动元素推出</p><p>​比如行内级元素、inline-block元素、块级元素的文字内容</p><h4 id="浮动规则5"><a href="#浮动规则5" class="headerlink" title="浮动规则5"></a>浮动规则5</h4><p>行内级元素、inline-block元素浮动后，其顶部将与所在行的顶部对齐</p><h4 id="空隙的解决方案"><a href="#空隙的解决方案" class="headerlink" title="空隙的解决方案"></a>空隙的解决方案</h4><p>将多个行内级元素中间的空格去除</p><p>   1.删除换行符（不推荐）</p><p>   2.将父元素的font-size设置为0  但是需要在子元素设置回来</p><p>   3.浮动（设置子元素统一向一个方向浮动）</p><p>   4.flex 布局 (未学习)</p><h4 id="案例练习总结"><a href="#案例练习总结" class="headerlink" title="案例练习总结"></a>案例练习总结</h4><p>京东布局：</p><p>考虑本行最后一个模块跑第二行的解决办法</p><p>方法1：通过类名设置 margin-right 为 0，稍微麻烦，但是无需考虑兼容</p><p>方法2：结构伪类，nth-child(n)，有可能存在兼容问题（好用）</p><p>方法3：margin 负值，无需考虑兼容（掌握）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">需在模块再包裹一个div元素，为其设置 margin 的负值</span><br><span class="line">    .<span class="property">box</span> &#123;</span><br><span class="line">      <span class="comment">/* margin-right: -10px; */</span></span><br><span class="line">      <span class="attr">margin</span>: <span class="number">0</span> -5px;</span><br><span class="line">    &#125;</span><br><span class="line">在item设置对应的外边距</span><br><span class="line">      <span class="attr">margin</span>: <span class="number">0</span> 5px;</span><br><span class="line">      <span class="comment">/* margin-right: 10px; */</span></span><br></pre></td></tr></table></figure><p>考拉边框线布局：需设置每一项为border-box</p><p>方法1：为item的父元素设置边框，再为item设置border-right，清除最后一个item的border-right</p><p>方法2：为每一个item设置边框，再设置item 的margin-right为-1px，再设置其中一个item的宽少一个px</p><h3 id="3、浮动存在的问题"><a href="#3、浮动存在的问题" class="headerlink" title="3、浮动存在的问题"></a>3、浮动存在的问题</h3><p>由于浮动元素脱离了标准流，变成了脱标元素，所以不再向父元素汇报高度</p><p>父元素计算总高度时，就不会计算浮动子元素的高度，导致了高度坍塌的问题</p><p>解决父元素高度坍塌问题的过程，一般叫做清浮动（清理浮动、清除浮动）</p><p>清浮动的目的是</p><ul><li>让父元素计算总高度的时候，把浮动子元素的高度算进去</li></ul><h3 id="4、清除浮动"><a href="#4、清除浮动" class="headerlink" title="4、清除浮动"></a>4、清除浮动</h3><p>clear属性是做什么的呢? </p><p>clear 属性可以指定一个元素是否必须移动（清除浮动后）到在它之前的浮动元素下面</p><p>clear的常用取值</p><ul><li><p>left：要求元素的顶部低于之前生成的所有左浮动元素的底部 </p></li><li><p>right：要求元素的顶部低于之前生成的所有右浮动元素的底部</p></li><li><p>both：要求元素的顶部低于之前生成的所有浮动元素的底部</p></li><li><p>none：默认值，无特殊要求</p></li></ul><p>因为所有的后代item元素都是浮动的，脱了标准流</p><p>不会向父元素汇报高度，所以content压根没有高度</p><p>方法一：给父元素设置固定高度</p><ul><li>扩展性不好（不推荐）</li></ul><p>方法二：在父元素最后增加一个空的块级子元素，并且让它设置clear: both</p><ul><li><p>会增加很多无意义的空标签，维护麻烦</p></li><li><p>违反了结构与样式分离的原则（不推荐）</p></li></ul><p>方法三：给父元素添加一个伪元素 </p><ul><li><p>推荐使用</p></li><li><p>编写好后可以轻松实现清除浮动</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">.<span class="property">clear</span>-<span class="attr">fix</span>::after &#123;</span><br><span class="line">  <span class="attr">content</span>: <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="attr">clear</span>: both;</span><br><span class="line">  <span class="attr">display</span>: block;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 增加兼容性 */</span></span><br><span class="line">  <span class="attr">visibility</span>: hidden;</span><br><span class="line">  <span class="attr">height</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.<span class="property">clear</span>-fix &#123;</span><br><span class="line">  <span class="comment">/* 兼容ie 6 7 */</span></span><br><span class="line">  *<span class="attr">zoom</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5、对比布局方案"><a href="#5、对比布局方案" class="headerlink" title="5、对比布局方案"></a>5、对比布局方案</h3><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230322212037560.png" alt="image-20230322212037560"></p><h2 id="11-flex布局"><a href="#11-flex布局" class="headerlink" title="11.flex布局"></a>11.flex布局</h2><h3 id="1、认识flex布局"><a href="#1、认识flex布局" class="headerlink" title="1、认识flex布局"></a>1、认识flex布局</h3><p>Flexbox翻译为弹性盒子：</p><ul><li><p>弹性盒子是一种用于按行或按列布局元素的一维布局方法</p></li><li><p>元素可以膨胀以填充额外的空间, 收缩以适应更小的空间</p></li><li><p>通常我们使用Flexbox来进行布局的方案称之为flex布局(flex layout)</p></li></ul><p>flex布局是目前web开发中使用最多的布局方案</p><ul><li><p>flex 布局（Flexible 布局，弹性布局）</p></li><li><p>目前特别在移动端可以说已经完全普及</p></li><li><p>在PC端也几乎已经完全普及和使用, 只有非常少数的网站依然在用浮动来布局</p></li></ul><p>为什么需要flex布局</p><ul><li><p>长久以来，CSS 布局中唯一可靠且跨浏览器兼容的布局工具只有 floats 和 positioning</p></li><li><p>但是这两种方法本身存在很大的局限性, 并且他们用于布局实在是无奈之举</p></li></ul><p>原先布局存在的痛点</p><ul><li>比如在父内容里面垂直居中一个块内容</li><li>比如使容器的所有子项等分可用宽度&#x2F;高度，而不管有多少宽度&#x2F;高度可用</li><li>比如使多列布局中的所有列采用相同的高度，即使它们包含的内容量不同</li></ul><h3 id="2、flex布局的理解"><a href="#2、flex布局的理解" class="headerlink" title="2、flex布局的理解"></a>2、flex布局的理解</h3><p>两个重要的概念：</p><ul><li><p>开启了 flex 布局的元素叫 flex container</p></li><li><p>flex container 里面的直接子元素叫做 flex item</p></li></ul><p>当flex container中的子元素变成了flex item时, 具备一下特点:</p><ul><li><p>flex item的布局将受flex container属性的设置来进行控制和布局</p></li><li><p>flex item不再严格区分块级元素和行内级元素</p></li><li><p>flex item默认情况下是包裹内容的, 但是可以设置宽度和高度</p></li></ul><p>设置 display 属性为 flex 或者 inline-flex 可以成为 flex container</p><p>flex：flex container 以 block-level 形式存在</p><p>inline-flex：flex container 以 inline-level 形式存在</p><h4 id="flex布局的模型"><a href="#flex布局的模型" class="headerlink" title="flex布局的模型"></a>flex布局的模型</h4><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230322220731649.png" alt="image-20230322220731649"></p><h3 id="3、flex-container属性"><a href="#3、flex-container属性" class="headerlink" title="3、flex-container属性"></a>3、flex-container属性</h3><p>应用在 flex container 上的 CSS 属性</p><p>flex-flow、flex-direction、flex-wrap、flex-flow、justify-content、align-items、align-content</p><h4 id="flex-direction"><a href="#flex-direction" class="headerlink" title="flex-direction"></a>flex-direction</h4><p>flex items 默认都是沿着 main axis（主轴）从 main start 开始往 main end 方向排布</p><p>flex-direction 决定了 main axis 的方向，有 4 个取值</p><p>row（默认值）、row-reverse、column、column-reverse</p><h4 id="flex-wrap"><a href="#flex-wrap" class="headerlink" title="flex-wrap"></a>flex-wrap</h4><p>flex-wrap 决定了 flex container 是单行还是多行</p><ul><li><p>nowrap（默认）：单行</p></li><li><p>wrap：多行</p></li><li><p>wrap-reverse：多行（对比 wrap，cross start 与 cross end 相反）</p></li></ul><h4 id="flex-flow"><a href="#flex-flow" class="headerlink" title="flex-flow"></a>flex-flow</h4><p>flex-flow 属性是 flex-direction 和 flex-wrap 的简写，顺序任何, 并且都可以省略</p><h4 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a>justify-content</h4><p>justify-content 决定了 flex items 在 main axis 上的对齐方式</p><p>flex-start（默认值）：与 main start 对齐</p><p>flex-end：与 main end 对齐</p><p>center：居中对齐</p><p>space-between：</p><ul><li><p>✓ flex items 之间的距离相等</p></li><li><p>✓ 与 main start、main end两端对齐</p></li></ul><p>space-around： </p><ul><li><p>✓ flex items 之间的距离相等 </p></li><li><p>✓ flex items 与 main start、main end 之间的距离是 flex items 之间距离的一半</p></li></ul><p>space-evenly： </p><ul><li><p>✓ flex items 之间的距离相等 </p></li><li><p>✓ flex items 与 main start、main end 之间的距离等于 flex items 之间的距离</p></li></ul><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230322221215021.png" alt="image-20230322221215021"></p><h4 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h4><p>align-items 决定了 flex items 在 cross axis 上的对齐方式</p><ul><li><p>normal：在弹性布局中，效果和stretch一样</p></li><li><p>stretch：当 flex items 在 cross axis 方向的 size（height） 为 auto 时，会自动拉伸至填充 flex container</p></li><li><p>flex-start：与 cross start 对齐</p></li><li><p>flex-end：与 cross end 对齐</p></li><li><p>center：居中对齐</p></li><li><p>baseline：与基准线对齐 align-item</p></li></ul><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230322221453595.png" alt="image-20230322221453595"></p><h4 id="align-content"><a href="#align-content" class="headerlink" title="align-content"></a>align-content</h4><p>align-content 决定了多行 flex items 在 cross axis 上的对齐方式，用法与 justify-content 类似</p><p>stretch（默认值）：与 align-items 的 stretch 类似</p><p>flex-start：与 cross start 对齐</p><p>flex-end：与 cross end 对齐</p><p>center：居中对齐</p><p>space-between： ✓ flex items 之间的距离相等 ✓ 与 cross start、cross end两端对齐</p><p>space-around： ✓ flex items 之间的距离相等 ✓ flex items 与 cross start、cross end 之间的距离是 flex items 之间距离的一半</p><p>space-evenly： ✓ flex items 之间的距离相等 ✓ flex items 与 cross start、cross end 之间的距离 等于 flex items 之间的距离</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230322221508510.png" alt="image-20230322221508510"></p><h3 id="4、flex-item属性"><a href="#4、flex-item属性" class="headerlink" title="4、flex-item属性"></a>4、flex-item属性</h3><h4 id="order"><a href="#order" class="headerlink" title="order"></a>order</h4><p>order 决定了 flex items 的排布顺序</p><ul><li><p>可以设置任意整数（正整数、负整数、0），值越小就越排在前面</p></li><li><p>默认值是 0</p></li></ul><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230322222250489.png" alt="image-20230322222250489"></p><h4 id="align-self"><a href="#align-self" class="headerlink" title="align-self"></a>align-self</h4><p>flex items 可以通过 align-self 覆盖 flex container 设置的 align-items</p><ul><li><p>auto（默认值）：遵从 flex container 的 align-items 设置</p></li><li><p>stretch、flex-start、flex-end、center、baseline，效果跟 align-items 一致</p></li></ul><h4 id="flex-grow"><a href="#flex-grow" class="headerlink" title="flex-grow"></a>flex-grow</h4><p>flex-grow 决定了 flex items 如何扩展(拉伸&#x2F;成长) </p><ul><li><p>可以设置任意非负数字（正小数、正整数、0），默认值是 0</p></li><li><p>当 flex container 在 main axis 方向上有剩余 size 时，flex-grow 属性才会有效</p></li></ul><p>如果所有 flex items 的 flex-grow 总和 sum 超过 1，每个 flex item 扩展的 size 为</p><ul><li>flex container 的剩余 size * flex-grow &#x2F; sum</li></ul><p>flex items 扩展后的最终 size 不能超过 max-width\max-height</p><h4 id="flex-shrink"><a href="#flex-shrink" class="headerlink" title="flex-shrink"></a>flex-shrink</h4><p>flex-shrink 决定了 flex items 如何收缩（缩小）</p><ul><li><p>可以设置任意非负数字（正小数、正整数、0），默认值是 1</p></li><li><p>当 flex items 在 main axis 方向上超过了 flex container 的 size，flex-shrink 属性才会有效</p></li></ul><p>如果所有 flex items 的 flex-shrink 总和超过 1，每个 flex item 收缩的 size为</p><ul><li>flex items 超出 flex container 的 size * 收缩比例 &#x2F; 所有 flex items 的收缩比例之和</li></ul><p>flex items 收缩后的最终 size 不能小于 min-width\min-height</p><h4 id="flex-basis"><a href="#flex-basis" class="headerlink" title="flex-basis"></a>flex-basis</h4><p>flex-basis 用来设置 flex items 在 main axis 方向上的 base size</p><ul><li>auto（默认值）、具体的宽度数值（100px）</li></ul><p>唯一用处：和width差不多，但是在显示某些内容（比如一串英文）时会当做一个整体，显示不完是会扩展尺寸来显示完整</p><p>决定 flex items 最终 base size 的因素，从优先级高到低</p><ul><li><p>max-width\max-height\min-width\min-height</p></li><li><p>flex-basis</p></li><li><p>width\height</p></li><li><p>内容本身的 size</p></li></ul><h4 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h4><p>flex 是 flex-grow || flex-shrink || flex-basis 的简写,flex 属性可以指定1个，2个或3个值</p><p>设置为none：0 0 auto</p><p>设置为 auto：1 1 auto</p><p>单值语法: 值必须为以下其中之一</p><ul><li><p>一个无单位数：它会被当作 flex-grow 的值</p></li><li><p>一个有效的宽度值：它会被当作 flex-basis 的值</p></li><li><p>关键字none，auto或initial</p></li></ul><p>双值语法: </p><ul><li><p>第一个值必须为一个无单位数，并且它会被当作 flex-grow 的值。</p></li><li><p>第二个值必须为以下之一：</p><ul><li>一个无单位数：它会被当作 flex-shrink 的值</li><li>一个有效的宽度值: 它会被当作 flex-basis 的值</li></ul></li></ul><p>三值语法:</p><p>第一个值必须为一个无单位数，并且它会被当作 flex-grow 的值</p><p>第二个值必须为一个无单位数，并且它会被当作 flex-shrink 的值</p><p>第三个值必须为一个有效的宽度值， 并且它会被当作 flex-basis 的值。</p><h3 id="5、以下布局解决方案"><a href="#5、以下布局解决方案" class="headerlink" title="5、以下布局解决方案"></a>5、以下布局解决方案</h3><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230322222340960.png" alt="image-20230322222340960"></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">常用：在item元素结尾加上span元素 再为span设置相同的宽度（列数-<span class="number">2</span>）</span><br><span class="line">    &lt;div <span class="keyword">class</span>=<span class="string">&quot;item3 item&quot;</span>&gt;3x&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">    .<span class="property">container</span> &gt; span &#123;</span><br><span class="line">      <span class="attr">width</span>: 120px;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="12-项目练习"><a href="#12-项目练习" class="headerlink" title="12.项目练习"></a>12.项目练习</h2><h3 id="1、布局练习"><a href="#1、布局练习" class="headerlink" title="1、布局练习"></a>1、布局练习</h3><h3 id="2、网易云布局"><a href="#2、网易云布局" class="headerlink" title="2、网易云布局"></a>2、网易云布局</h3><p>1.text-indent对行内非替换元素无效</p><p>2.line-height对行内非替换元素的作用</p><p>3.块级元素中嵌套img，需要设置img的vertical-align才能完整盖住块级元素</p><p>4.box-sizing的应用场景：盒子明确设置了宽度和高度</p><p>5.box-sizing无效：块级盒子嵌套、定位、浮动</p><p>6.在a元素中嵌套div元素</p><h3 id="3、王者荣耀"><a href="#3、王者荣耀" class="headerlink" title="3、王者荣耀"></a>3、王者荣耀</h3><h2 id="13-形变与动画"><a href="#13-形变与动画" class="headerlink" title="13.形变与动画"></a>13.形变与动画</h2><h3 id="1、transform"><a href="#1、transform" class="headerlink" title="1、transform"></a>1、transform</h3><p>CSS transform属性允许对某一个元素进行某些形变, 包括旋转，缩放，倾斜或平移等</p><p>注意事项，并非所有的盒子都可以进行transform的转换（通常行内级元素不能进行形变）</p><p>所以，transform对于行内级非替换元素是无效的</p><ul><li><p>比如对span、a元素等；</p></li><li><p>table 相关的也不能形变</p></li></ul><p>常见的函数transform function有</p><ul><li><p>平移：translate(x, y) </p></li><li><p>缩放：scale(x, y) </p></li><li><p>旋转：rotate(deg) </p></li><li><p>倾斜：skew(deg, deg)</p></li></ul><p>通过上面的几个函数，我们可以改变某个元素的形变</p><h4 id="1-位移—translate"><a href="#1-位移—translate" class="headerlink" title="1.位移—translate"></a>1.位移—translate</h4><p>平移：translate(x, y) </p><p>这个CSS 函数用于移动元素在平面上的位置</p><p>translate本身可以表示翻译的意思，在物理上也可以表示平移；</p><p>值个数 </p><ul><li>一个值时，设置x轴上的位移</li><li>二个值时，设置x轴和y轴上的位移</li></ul><p>值类型</p><ul><li><p>数字：100px</p></li><li><p>百分比：参照元素本身（ refer to the size of bounding box ）</p></li></ul><p>translate是translateX和translateY函数的简写；translate的百分比可以完成一个元素的水平和垂直居中；translate函数相对于flex布局的兼容性会好一点点（可忽略不计）</p><h4 id="2-补充：水平居中和垂直居中的方案"><a href="#2-补充：水平居中和垂直居中的方案" class="headerlink" title="2.补充：水平居中和垂直居中的方案"></a>2.补充：水平居中和垂直居中的方案</h4><p>水平居中<br>1.行内级元素</p><ul><li>设置父元素的 text-align:cente</li></ul><p>2.块级元素</p><ul><li>需要有宽度，设置当前块级元素的 margin:0 auto</li></ul><p>3.绝对定位</p><ul><li>元素有宽度的情况下，left0&#x2F;right0&#x2F;margin:0 auto;</li></ul><p>4.flex</p><pre><code>    * justify-content:center</code></pre><p>垂直居中方法</p><p>   1.绝对定位</p><p>​    元素在有高度的情况下，top0&#x2F;bottom0&#x2F;margin:auto 0;</p><p>​    弊端：必须使用定位（脱离标准流）</p><p>​       必须给元素设置宽度</p><p>   2.flex布局</p><p>​    弊端:当前flex局部中的所有元素都会被垂直居中</p><p>​         相对来说兼容性差一点点（基本可以忽略）</p><p>   3.top&#x2F;translate</p><p>​    1、让元素向下位移父元素的50%</p><p>​      使用相对定位，不能使用margin-top 它相对于的是父元素的宽度</p><p>​    2、让元素向上位移自身的50%</p><h4 id="3-缩放"><a href="#3-缩放" class="headerlink" title="3.缩放"></a>3.缩放</h4><p>缩放：scale(x, y)  scale() CSS 函数可改变元素的大小</p><p>值个数</p><ul><li><p>一个值时，设置x轴上的缩放</p></li><li><p>二个值时，设置x轴和y轴上的缩放</p></li></ul><p>值类型：</p><ul><li><p>数字</p><ul><li>1：保持不变</li><li>2：放大一倍 </li><li>0.5：缩小一半</li></ul></li><li><p>百分比：百分比不常用</p></li></ul><p>scale函数时scaleX和scaleY的缩写</p><h4 id="4-旋转"><a href="#4-旋转" class="headerlink" title="4.旋转"></a>4.旋转</h4><p>旋转：rotate(<code>&lt;angle&gt;</code>) </p><p>值个数</p><ul><li>一个值时，表示旋转的角度</li></ul><p>值类型：</p><ul><li><p>常用单位deg：旋转的角度（ degrees ）</p></li><li><p>正数为顺时针</p></li><li><p>负数为逆时针</p></li></ul><p>补充一：rotate函数是rotateZ函数的简写写法</p><p>补充二：rotate的其他单位</p><ul><li>度（degrees）、 百分度（gradians）、弧度（radians）或圈数（turns）；</li></ul><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230325082302662.png" alt="image-20230325082302662"></p><h4 id="5-transform-origin"><a href="#5-transform-origin" class="headerlink" title="5.transform origin"></a>5.transform origin</h4><p>transform-origin：形变的原点</p><p>比如在进行scale缩放或者rotate旋转时，都会有一个原点。</p><p>一个值：设置x轴的原点 </p><p>两个值：设置x轴和y轴的原点</p><p>必须是<code>&lt;length&gt;</code>，<code>&lt;percentage&gt;</code>，或 left, center, right, top, bottom关键字中的一个</p><ul><li><p>left, center, right, top, bottom关键字</p></li><li><p>length：从左上角开始计算</p></li><li><p>百分比：参考元素本身大小</p></li></ul><h4 id="6-倾斜"><a href="#6-倾斜" class="headerlink" title="6.倾斜"></a>6.倾斜</h4><p>倾斜：skew(x, y)  函数定义了一个元素在二维平面上的倾斜转换</p><p>值个数 </p><ul><li>一个值时，表示x轴上的倾斜 </li><li>二个值时，表示x轴和y轴上的倾斜</li></ul><p>值类型</p><ul><li><p>deg：倾斜的角度 </p></li><li><p>正数为顺时针 </p></li><li><p>负数为逆时针</p></li></ul><p>注意：倾斜的原点受transform-origin的影响</p><h4 id="7-transform-设置多个值"><a href="#7-transform-设置多个值" class="headerlink" title="7.transform 设置多个值"></a>7.transform 设置多个值</h4><p>transform的语法是可以设置多个transform-function的</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230325081501119.png" alt="image-20230325081501119"></p><p>+:一个或者多个，并且之间使用空格分割</p><p>#：一个或者多个 之间使用,进行分割（如box-shadow）</p><h3 id="2、transition动画"><a href="#2、transition动画" class="headerlink" title="2、transition动画"></a>2、transition动画</h3><p>CSS transitions 提供了一种在更改CSS属性时控制动画速度的方法</p><p>可以让CSS属性变化成为一个持续一段时间的过程，而不是立即生效的</p><p>比如将一个元素从一个位置移动到另外一个位置，默认在修改完CSS属性后会立即生效</p><p>但是我们可以通过CSS transition，让这个过程加上一定的动画效果，包括一定的曲线速率变化</p><p>通常将两个状态之间的过渡称为隐式过渡（implicit transitions），因为开始与结束之间的状态由浏览器决定</p><p>CSS transitions 可以决定</p><ul><li><p>哪些属性发生动画效果 (明确地列出这些属性) </p></li><li><p>何时开始 (设置 delay）</p></li><li><p>持续多久 (设置 duration) </p></li><li><p>如何动画 (定义timing function，比如匀速地或先快后慢)</p></li></ul><p>哪些属性可以做动画</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_animated_properties">https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_animated_properties</a></p><p>transition CSS 属性是 transition-property，transition-duration，transition-timing-function 和 transition-delay 的一个简写属性</p><p>transition-property：指定应用过渡属性的名称</p><ul><li><p>all：所有属性都执行动画</p></li><li><p>none：所有属性都不执行动画</p></li><li><p>CSS属性名称：要执行动画的CSS属性名称，比如width、left、transform等</p></li></ul><p>transition-duration：指定过渡动画所需的时间</p><ul><li>单位可以是秒（s）或毫秒（ms）</li></ul><p>transition-timing-function：指定动画的变化曲线</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transition-timing-function">https://developer.mozilla.org/zh-CN/docs/Web/CSS/transition-timing-function</a></li></ul><p>transition-delay：指定过渡动画执行之前的等待时间</p><p>transform是形变</p><ul><li><p>一个CSS属性，该CSS属性用于设置形变</p></li><li><p>后面的值是形变的函数，比如scale、rotate、translate</p></li></ul><p>translate是其中一个transform-function ：用于对元素进行平移</p><p>transition是过渡的意思：它本身也有转变的含义，但是更多表示的是过渡的过程</p><h3 id="3、Animation"><a href="#3、Animation" class="headerlink" title="3、Animation"></a>3、Animation</h3><p>transition来进行过渡动画，但是有如下的缺点：</p><ul><li><p>transition只能定义开始状态和结束状态，不能定义中间状态，也就是说只有两个状态</p></li><li><p>transition不能重复执行，除非一再触发动画</p></li><li><p>transition需要在特定状态下会触发才能执行，比如某个属性被修改了</p></li></ul><p>如果我们希望可以有更多状态的变化，我们可以使用CSS Animation</p><p>CSS Animation的使用分成两个步骤：</p><ul><li><p>步骤一：使用keyframes定义动画序列（每一帧动画如何执行）</p></li><li><p>步骤二：配置动画执行的名称、持续时间、动画曲线、延迟、执行次数、方向等等</p></li></ul><h3 id="4、vertical-align"><a href="#4、vertical-align" class="headerlink" title="4、vertical-align"></a>4、vertical-align</h3><p>给行内级元素设置</p><p>vertical-align会影响行内块级元素在一个行盒中垂直方向的位置</p><p>行盒的作用：包裹所有的内容</p><p>一个div没有设置高度的时候，会不会有高度？</p><ul><li><p>没有内容，没有高度</p></li><li><p>有内容，内容撑起来高度</p></li></ul><p>但是内容撑起来高度的本质是什么呢？</p><ul><li>内容有行高（line-height），撑起来了div的高度</li></ul><p>行高为什么可以撑起div的高度？</p><ul><li><p>这是因为line boxes的存在，并且line-boxes有一个特性，包裹每行的inline level</p></li><li><p>而其中的文字是有行高的，必须将整个行高包裹进去，才算包裹这个line-leve</p></li></ul><p>line-boxes一定会想办法包裹住当前行中所有的内容</p><p>为什么对齐方式千奇百怪呢？</p><p>答案就是baseline对齐</p><ul><li>官方vertical-align的默认值：没错，就是baseline</li></ul><p>但是baseline都是谁呢?</p><ul><li><p>文本的baseline是字母x的下方</p></li><li><p>Inline-block默认的baseline是margin-bottom的底部（没有，就是盒子的底部）</p></li><li><p>Inline-block有文本时，baseline是最后一行文本的x的下方</p></li></ul><p>不同的取值</p><ul><li>baseline(默认值)：基线对齐（你得先明白什么是基线</li><li>top：把行内级盒子的顶部跟line boxes顶部对齐</li><li>middle：行内级盒子的中心点与父盒基线加上x-height一半的线对齐 </li><li>bottom：把行内级盒子的底部跟line box底部对齐</li><li><code>&lt;percentage&gt;</code>：把行内级盒子提升或者下降一段距离（距离相对于line-height计算\元素高度）， 0%意味着同baseline一 样</li><li><code>&lt;length&gt;</code>：把行内级盒子提升或者下降一段距离，0cm意味着同baseline一样</li></ul><p>解决图片下边缘的间隙方法</p><ul><li>方法一: 设置成top&#x2F;middle&#x2F;bottom</li><li>方法二: 将图片设置为block元素</li></ul><p>盒子与文本分离：line-height 的继承与 vertical-align 的基线对齐导致，需要重新设置line-height</p><h2 id="14-额外知识补充"><a href="#14-额外知识补充" class="headerlink" title="14.额外知识补充"></a>14.额外知识补充</h2><h3 id="1-HTML5新增元素"><a href="#1-HTML5新增元素" class="headerlink" title="1.HTML5新增元素"></a>1.HTML5新增元素</h3><h4 id="1、语义化元素"><a href="#1、语义化元素" class="headerlink" title="1、语义化元素"></a>1、语义化元素</h4><p> 在HMTL5之前，我们的网站分布层级通常包括 header、nav、main、footer</p><p>弊端：</p><ul><li><p>我们往往过多的使用div, 通过id或class来区分元素；</p></li><li><p>对于浏览器来说这些元素不够语义化；</p></li><li><p>对于搜索引擎来说, 不利于SEO的优化；</p></li></ul><p> HTML5新增了语义化的元素：</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230327081851504.png" alt="image-20230327081851504"></p><h4 id="2、Video、Audio元素"><a href="#2、Video、Audio元素" class="headerlink" title="2、Video、Audio元素"></a>2、Video、Audio元素</h4><p>在HTML5之前是通过flash或者其他插件实现的, 但是会有很多问题</p><ul><li>比如无法很好的支持HTML&#x2F;CSS特性, 兼容性问题等</li></ul><p>HTML5增加了对媒体类型的支持：</p><ul><li><p>音频：audio</p></li><li><p>视频：video</p></li></ul><p>使用方法有两个：</p><ul><li>直接通过元素使用</li><li>通过 javascript 的 API 对其进行控制</li></ul><p><code> &lt;video&gt;</code> 元素用于在HTML或者XHTML文档中嵌入媒体播放器，用于支持文档内的视频播放</p><p>常见属性：</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230327150507161.png" alt="image-20230327150507161"></p><p>每个视频都会有自己的格式，浏览器的video并非支持所有的视频格式，mp4常用</p><p>video的兼容性写法</p><ul><li><p>内容一：通过元素指定更多视频格式的源</p></li><li><p>内容二：通过p&#x2F;div等元素指定在浏览器不支持video元素的情况，显示的内容</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;video src=<span class="string">&quot;./assets/fcrs.mp4&quot;</span> width=<span class="string">&quot;500&quot;</span> controls&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;./assets/fcrs.ogg&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;./assets/fcrs.webm&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>当前您的浏览器不支持视频的播放，请更换浏览器<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p><code>&lt;audio&gt;</code>元素用于在文档中嵌入音频内容, 和video的用法非常类似</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230327150706535.png" alt="image-20230327150706535"></p><p>每个音频都会有自己的格式, 浏览器的audio并非支持所有的视频格式</p><p>具体的支持的格式可以通过下面的链接查看</p><p><a href="https://developer.mozilla.org/en-US/docs/Web/Media/Formats/Audio_codecs">https://developer.mozilla.org/en-US/docs/Web/Media/Formats/Audio_codecs</a></p><p>兼容性写法（降级处理）：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;audio src=<span class="string">&quot;./assets/yhbk.mp3&quot;</span> controls &gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;./assets/fcrs.mp3&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>你的浏览器不支持<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="2-input、全局属性-data"><a href="#2-input、全局属性-data" class="headerlink" title="2.input、全局属性 data-*"></a>2.input、全局属性 data-*</h3><p>HTML5对input元素也进行了扩展，在之前我们已经学习过的其中几个属性也是HTML5的特性：</p><ul><li><p>placeholder：输入框的占位文字</p></li><li><p>multiple：多个值</p></li><li><p>autofocus：最多输入的内容</p></li></ul><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/Input">https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/Input</a></p><p>在HTML5中, 新增一种全局属性的格式 data-*，用于自定义数据属性</p><ul><li><p>data设置的属性可以在JavaScript的DOM操作中通过dataset轻松获取到</p></li><li><p>通常用于HTML和JavaScript数据之间的传递；</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div <span class="keyword">class</span>=<span class="string">&quot;box&quot;</span> data-name=<span class="string">&quot;dww&quot;</span> data-age=<span class="string">&quot;18&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">const</span> boxEl = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;.box&quot;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="variable language_">console</span>.<span class="title function_">log</span>(boxEl.<span class="property">dataset</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>在小程序中, 就是通过data-来传递数据的, 所以该全局属性必须要掌握</p><h3 id="3-white-space-x2F-text-overflow"><a href="#3-white-space-x2F-text-overflow" class="headerlink" title="3.white-space&#x2F;text-overflow"></a>3.white-space&#x2F;text-overflow</h3><p>white-space用于设置空白处理和换行规则</p><ul><li>normal：合并所有连续的空白，允许单词超屏时自动换行</li><li>nowrap：合并所有连续的空白，不允许单词超屏时自动换行</li><li>pre：阻止合并所有连续的空白，不允许单词超屏时自动换行</li><li>pre-wrap：阻止合并所有连续的空白，允许单词超屏时自动换行</li><li>pre-line：合并所有连续的空白（但保留换行），允许单词超屏时自动换行</li></ul><p>text-overflow</p><p>text-overflow通常用来设置文字溢出时的行为</p><ul><li><p>clip：溢出的内容直接裁剪掉（字符可能会显示不完整）</p></li><li><p>ellipsis：溢出那行的结尾处用省略号表示</p></li></ul><p>text-overflow生效的前提是overflow不为visible </p><p>常见的是将white-space、text-overflow、overflow一起使用：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">overflow</span>: hidden;</span><br><span class="line">white-<span class="attr">space</span>: nowrap;</span><br><span class="line">text-<span class="attr">overflow</span>: ellipsis;</span><br></pre></td></tr></table></figure><h3 id="4-CSS常见的函数扩展"><a href="#4-CSS常见的函数扩展" class="headerlink" title="4.CSS常见的函数扩展"></a>4.CSS常见的函数扩展</h3><p>在前面我们有使用过很多个CSS函数</p><ul><li><p>比如rgb&#x2F;rgba&#x2F;translate&#x2F;rotate&#x2F;scale等</p></li><li><p>CSS函数通常可以帮助我们更加灵活的来编写样式的值</p></li></ul><p>下面再学习几个好用的CSS函数</p><ul><li><p>var: 使用CSS定义的变量</p></li><li><p>calc: 计算CSS值，通常用于计算元素的大小或位置</p></li><li><p>blur: 毛玻璃（高斯模糊）效果</p></li><li><p>gradient：颜色渐变函数</p></li></ul><h4 id="1、var"><a href="#1、var" class="headerlink" title="1、var()"></a>1、var()</h4><p>CSS中可以自定义属性</p><ul><li><p>属性名需要以两个减号（–）开始</p></li><li><p>属性值则可以是任何有效的CSS值</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">:root &#123;</span><br><span class="line">  <span class="comment">/* 定义了一个变量 */</span></span><br><span class="line">  <span class="comment">/* 只有后代元素可以使用 */</span></span><br><span class="line">  --main-<span class="attr">color</span>: #f3c221;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以通过var函数来使用</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">.<span class="property">box</span> &#123;</span><br><span class="line">  <span class="attr">color</span>: <span class="title function_">var</span>(--main-color);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>规则集定义的选择器, 是自定义属性的可见作用域(只在选择器内部有效) </p><ul><li>所以推荐将自定义属性定义在html中，也可以使用 :root 选择器;</li></ul><h4 id="2、calc"><a href="#2、calc" class="headerlink" title="2、calc()"></a>2、calc()</h4><p>calc() 函数允许在声明 CSS 属性值时执行一些计算</p><p>计算支持加减乘除的运算</p><ul><li>加和减运算符的两边必须要有空白字符</li></ul><p>通常用来设置一些元素的尺寸或者位置</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">.<span class="property">item1</span> &#123;</span><br><span class="line">    <span class="comment">/* width的百分比相当于包含块 */</span></span><br><span class="line">    <span class="attr">width</span>: <span class="title function_">calc</span>(<span class="number">100</span>% - 100px);</span><br><span class="line">    background-<span class="attr">color</span>: #f00;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、blur"><a href="#3、blur" class="headerlink" title="3、blur()"></a>3、blur()</h4><p>blur() 函数将高斯模糊应用于输出图片或者元素</p><p>blur(radius)</p><p>radius, 模糊的半径, 用于定义高斯函数的偏差值, 偏差值越大, 图片越模糊</p><p>通常会和两个属性一起使用：</p><p>filter: 将模糊或颜色偏移等图形效果应用于元素</p><p>backdrop-filter: 为元素后面的区域添加模糊或者其他效果</p><h4 id="4、gradient"><a href="#4、gradient" class="headerlink" title="4、gradient()"></a>4、gradient()</h4><p>是一种<code>&lt;image&gt;</code>CSS数据类型的子类型，用于表现两种或多种颜色的过渡转变</p><ul><li><p>CSS的<code>&lt;image&gt;</code>数据类型描述的是2D图形</p></li><li><p>比如 background-image、list-style-image、border-image、content 等</p></li><li><p>常见的方式是通过url来引入一个图片资源</p></li><li><p>它也可以通过 CSS 的 gradient() 函数来设置颜色的渐变</p></li></ul><p>常见的函数实现有下面几种：</p><ul><li><p>linear-gradient()：创建一个表示两种或多种颜色线性渐变的图片</p></li><li><p>radial-gradient()：创建了一个图像，该图像是由从原点发出的两种或者多种颜色之间的逐步过渡组成</p></li><li><p>repeating-linear-gradient()：创建一个由重复线性渐变组成的<code>&lt;image&gt;</code></p></li><li><p>repeating-radial-gradient()：创建一个重复的原点触发渐变组成的<code>&lt;image&gt;</code></p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">background-<span class="attr">image</span>: linear-<span class="title function_">gradient</span>( 90deg, red, blue 40px, orange <span class="number">60</span>%, purple <span class="number">100</span>%);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">background-<span class="attr">image</span>: radial-<span class="title function_">gradient</span>(at <span class="number">0</span> <span class="number">50</span>%, red,blue);</span><br></pre></td></tr></table></figure><h3 id="5-浏览器前缀"><a href="#5-浏览器前缀" class="headerlink" title="5.浏览器前缀"></a>5.浏览器前缀</h3><p>有时候可能会看到有些CSS属性名前面带有：-o-、-xv-、-ms-、mso-、-moz-、-webkit-</p><p>官方文档专业术语叫做：vendor-specific extensions（供应商特定扩展）</p><p>为什么需要浏览器前缀了？</p><p>CSS属性刚开始并没有成为标准，浏览器为了防止后续会修改名字给新的属性添加了浏览器前缀</p><p>上述前缀叫做浏览器私有前缀，只有对应的浏览器才能解析使用</p><ul><li>-o-、-xv-：Opera等</li><li>-ms-、mso-：IE等</li><li>-moz-：Firefox等</li><li>-webkit-：Safari、Chrome等</li></ul><p>注意：不需要手动添加，后面学习了模块化打包工具会自动添加浏览器前缀</p><h3 id="6-深入理解BFC"><a href="#6-深入理解BFC" class="headerlink" title="6.深入理解BFC"></a>6.深入理解BFC</h3><h4 id="1、FC的概念"><a href="#1、FC的概念" class="headerlink" title="1、FC的概念"></a>1、FC的概念</h4><p>FC的全称是Formatting Context，元素在标准流里面都是属于一个FC的</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230327151516721.png" alt="image-20230327151516721"></p><p>块级元素的布局属于Block Formatting Context（BFC）</p><p>也就是block level box都是在BFC中布局的</p><ul><li><p>行内级元素的布局属于Inline Formatting Context（IFC） </p></li><li><p>而inline level box都是在IFC中布局的；</p></li></ul><h4 id="2、BFC的创建"><a href="#2、BFC的创建" class="headerlink" title="2、BFC的创建"></a>2、BFC的创建</h4><p>MDN上有整理出在哪些具体的情况下会创建BFC：</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230327151542003.png" alt="image-20230327151542003"></p><ul><li><p>根元素（<code>&lt;html&gt;</code>）</p></li><li><p>浮动元素（元素的 float 不是 none）</p></li><li><p>绝对定位元素（元素的 position 为 absolute 或 fixed）</p></li><li><p>行内块元素（元素的 display 为 inline-block）</p></li></ul><ul><li><p>表格单元格（元素的 display 为 table-cell，HTML表格单元格默认为该值），表格标题（元素的 display 为 table-caption，HTML表格标题默认为该值）</p></li><li><p>匿名表格单元格元素（元素的 display 为 table、table-row、 table-row-group、table-header-group、table-footer-group（分别是HTML table、 row、tbody、thead、tfoot 的默认属性）或 inline-table）</p></li><li><p>overflow 计算值(Computed)不为 visible 的块元素</p></li><li><p>弹性元素（display 为 flex 或 inline-flex 元素的直接子元素）</p></li><li><p>网格元素（display 为 grid 或 inline-grid 元素的直接子元素）</p></li><li><p>display 值为 flow-root 的元素</p></li></ul><h4 id="3、BFC的作用"><a href="#3、BFC的作用" class="headerlink" title="3、BFC的作用"></a>3、BFC的作用</h4><p>作用：</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230327151603473.png" alt="image-20230327151603473"></p><p>其作用简单概况如下：</p><ul><li><p>在BFC中，box会在垂直方向上一个挨着一个的排布</p></li><li><p>垂直方向的间距由margin属性决定</p></li><li><p>在同一个BFC中，相邻两个box之间的margin会折叠（collapse）</p></li><li><p>在BFC中，每个元素的左边缘是紧挨着包含块的左边缘的</p></li></ul><p>那么这个东西有什么用呢？</p><ul><li><p>解决margin的折叠问题</p></li><li><p>解决浮动高度塌陷问题</p></li></ul><h5 id="1-解决margin折叠"><a href="#1-解决margin折叠" class="headerlink" title="1.解决margin折叠"></a>1.解决margin折叠</h5><p>在同一个BFC中，相邻两个box之间的margin会折叠（collapse）</p><p>官方文档明确的有说</p><p>The vertical distance between two sibling boxes is determined by the ‘margin’ properties. Vertical margins  between adjacent block-level boxes in a block formatting context collapse.</p><p>那么如果我们让两个box是不同的BFC呢？那么就可以解决折叠问题</p><h5 id="2-解决高度塌陷"><a href="#2-解决高度塌陷" class="headerlink" title="2.解决高度塌陷"></a>2.解决高度塌陷</h5><p>网上有很多说法，BFC可以解决浮动高度塌陷，可以实现清除浮动的效果</p><p>但是从来没有给出过BFC可以解决高度塌陷的原理或者权威的文档说明</p><p>他们也压根没有办法解释，为什么可以解决浮动高度的塌陷问题，但是不能解决绝对定位元素的高度塌陷问题呢？</p><p>事实上，BFC解决高度塌陷需要满足两个条件：</p><ul><li><p>浮动元素的父元素触发BFC，形成独立的块级格式化上下文（Block Formatting Context）</p></li><li><p>浮动元素的父元素的高度是auto的</p></li></ul><p>BFC的高度是auto的情况下，是如下方法计算高度的</p><ul><li><p>1.如果只有inline-level，是行高的顶部和底部的距离</p></li><li><p>2.如果有block-level，是由最底层的块上边缘和最底层 块盒子的下边缘之间的距离</p></li><li><p>3.如果有绝对定位元素，将被忽略</p></li><li><p>4.如果有浮动元素，那么会增加高度以包括这些浮动元素的下边缘</p></li></ul><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230327141545017.png" alt="image-20230327141545017"></p><h3 id="7、媒体查询"><a href="#7、媒体查询" class="headerlink" title="7、媒体查询"></a>7、媒体查询</h3><p>媒体查询是一种提供给开发者针对不同设备需求进行定制化开发的一个接口。</p><p>你可以根据设备的类型（比如屏幕设备、打印机设备）或者特定的特性（比如屏幕的宽度）来修改你的页面</p><p>媒体查询的使用方式主要有三种：</p><p>方式一：通过@media和@import使用不同的CSS规则（常用）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式1</span></span><br><span class="line">@<span class="keyword">import</span> <span class="title function_">url</span>(./css/body_bgc.<span class="property">css</span>) (max-<span class="attr">width</span>: 800px);</span><br><span class="line"><span class="comment">// 方式2</span></span><br><span class="line">@media (max-<span class="attr">width</span>: 800px) &#123;</span><br><span class="line">    body &#123;</span><br><span class="line">        background-<span class="attr">color</span>: #0f0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方式二：使用media属性为<code>&lt;style&gt;</code>、<code>&lt;style&gt;</code>、<code>&lt;style&gt;</code>和其他HTML元素指定的媒体类型</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方式3</span></span><br><span class="line">&lt;link rel=<span class="string">&quot;stylesheet&quot;</span> media=<span class="string">&quot;(max-width: 800px)&quot;</span> href=<span class="string">&quot;./css/body_bgc.css&quot;</span>&gt;</span><br></pre></td></tr></table></figure><p>方式三：使用Window.matchMedia() 和MediaQueryList.addListener() 方法来测试和监控媒体状态</p><h4 id="1-媒体类型"><a href="#1-媒体类型" class="headerlink" title="1.媒体类型"></a>1.媒体类型</h4><p>在使用媒体查询时，你必须指定要使用的媒体类型</p><ul><li>媒体类型是可选的，并且会（隐式地）应用 all 类型</li></ul><p>常见的媒体类型值如下：</p><ul><li>all：适用于所有设备。</li></ul><ul><li><p>print：适用于在打印预览模式下在屏幕上查看的分页材料和文档。</p></li><li><p>screen（掌握）：主要用于屏幕。</p></li><li><p>speech：主要用于语音合成器。</p></li></ul><p>被废弃的媒体类型：</p><ul><li><p>CSS2.1 和 Media Queries 3 定义了一些额外的媒体类型(tty, tv, projection, handheld, braille, embossed, 以及 aural)；</p></li><li><p>但是他们在Media Queries 4 中已经被废弃，并且不应该被使用；</p></li><li><p>aural类型被替换为具有相似效果的speech。</p></li></ul><h4 id="2-媒体特性"><a href="#2-媒体特性" class="headerlink" title="2.媒体特性"></a>2.媒体特性</h4><p>媒体特性（Media features）描述了 浏览器、输出设备，或是预览环境的具体特征</p><ul><li><p>通常会将媒体特性描述为一个表达式</p></li><li><p>每条媒体特性表达式都必须用括号括起来</p></li></ul><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230327144350254.png" alt="image-20230327144350254"></p><h4 id="3-逻辑操作符"><a href="#3-逻辑操作符" class="headerlink" title="3.逻辑操作符"></a>3.逻辑操作符</h4><p>媒体查询的表达式最终会获得一个Boolean值，也就是真（true）或者假（false）</p><p>如果结果为真（true），那么就会生效</p><p>如果结果为假（false），那么就不会生效</p><p>如果有多个条件，我们可以通过逻辑操作符联合复杂的媒体查询： </p><ul><li>and：and 操作符用于将多个媒体查询规则组合成单条媒体查询</li><li>not：not运算符用于否定媒体查询，如果不满足这个条件则返回true，否则返回false</li><li>only：only运算符仅在整个查询匹配时才用于应用样式</li><li>, (逗号)：逗号用于将多个媒体查询合并为一个规则。</li></ul><p>常见的移动端设备：</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230327152232222.png" alt="image-20230327152232222"></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">@media (min-<span class="attr">width</span>: 320px) and (max-<span class="attr">width</span>:375px) &#123;</span><br><span class="line">    .<span class="property">box</span> &#123; font-<span class="attr">size</span>: 15px; &#125;</span><br><span class="line">&#125;</span><br><span class="line">@media (min-<span class="attr">width</span>: 375px) and (max-<span class="attr">width</span>:414px) &#123;</span><br><span class="line">    .<span class="property">box</span> &#123; font-<span class="attr">size</span>: 18px; &#125;</span><br><span class="line">&#125;</span><br><span class="line">@media (min-<span class="attr">width</span>: 414px) and (max-<span class="attr">width</span>:480px) &#123;</span><br><span class="line">    .<span class="property">box</span> &#123; font-<span class="attr">size</span>: 21px; &#125;</span><br><span class="line">&#125;</span><br><span class="line">@media (min-<span class="attr">width</span>: 480px) &#123;</span><br><span class="line">    .<span class="property">box</span> &#123; font-<span class="attr">size</span>: 24px; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="15-额外知识补充二"><a href="#15-额外知识补充二" class="headerlink" title="15.额外知识补充二"></a>15.额外知识补充二</h2><h3 id="1、CSS中的单位"><a href="#1、CSS中的单位" class="headerlink" title="1、CSS中的单位"></a>1、CSS中的单位</h3><p>px是一个长度（length）单位，事实上CSS中还有非常多的长度单位</p><p>整体可以分成两类：</p><ul><li><p>绝对长度单位（Absolute length units）</p></li><li><p>相对长度单位（Relative length units）</p></li></ul><h4 id="1-绝对单位"><a href="#1-绝对单位" class="headerlink" title="1.绝对单位"></a>1.绝对单位</h4><p>它们与其他任何东西都没有关系，通常被认为总是相同的大小</p><p>这些值中的大多数在用于打印时比用于屏幕输出时更有用，例如，我们通常不会在屏幕上使用cm</p><p>唯一一个经常使用的值，就是px(像素)</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230327154240579.png" alt="image-20230327154240579"></p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230327154805615.png" alt="image-20230327154805615"></p><h4 id="2-相对单位"><a href="#2-相对单位" class="headerlink" title="2.相对单位"></a>2.相对单位</h4><p>相对长度单位相对于其他一些东西</p><p>比如父元素的字体大小，或者视图端口的大小</p><p>使用相对单位的好处是经过一些仔细的规划，可以使文本或其他元素的大小与页面上的其他内容相对应</p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230327154928680.png" alt="image-20230327154928680"></p><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230327154942985.png" alt="image-20230327154942985"></p><h3 id="2、深入理解pixel、DPR、PPI"><a href="#2、深入理解pixel、DPR、PPI" class="headerlink" title="2、深入理解pixel、DPR、PPI"></a>2、深入理解pixel、DPR、PPI</h3><h4 id="1-pixel"><a href="#1-pixel" class="headerlink" title="1.pixel"></a>1.pixel</h4><p>前面我们已经一直在使用px单位了，px是pixel单词的缩写，翻译为像素</p><p>像素是影响显示的基本单位。（比如屏幕上看到的画面、一幅图片）</p><p>pix是英语单词picture的常用简写，加上英语单词“元素”element，就得到pixel</p><p>“像素”表示“画像元素”之意，有时亦被称为pel（picture element）</p><p>像素的分类</p><p>但是这个100个pixel到底是多少呢？</p><ul><li><p>我们确实可以在屏幕上看到一个大小，但是这个大小代表的真实含义是什么呢？</p></li><li><p>我们经常说一个电脑的分辨率、手机的分辨率，这个CSS当中的像素又是什么关系呢？</p></li></ul><p>这里我们要深入到不同的像素概念中，来理解CSS中的pixel到底代表什么含义</p><p>像素单位常见的有三种像素名称：</p><ul><li><p>设备像素（也称之为物理像素）</p></li><li><p>设备独立像素（也称之为逻辑像素）</p></li></ul><ul><li>CSS像素</li></ul><p>设备像素，也叫物理像素。</p><ul><li><p>设备像素指的是显示器上的真实像素，每个像素的大小是屏幕固有的属性，屏幕出厂以后就不会改变了</p></li><li><p>我们在购买显示器或者手机的时候，提到的设备分辨率就是设备像素的大小；</p></li><li><p>比如iPhone X的分辨率 1125x2436，指的就是设备像素；</p></li></ul><p>设备独立像素，也叫逻辑像素。</p><ul><li>如果面向开发者我们使用设备像素显示一个100px的宽度，那么在不同屏幕上显示效果会是不同的；</li></ul><ul><li><p>开发者针对不同的屏幕很难进行较好的适配，编写程序必须了解用户的分辨率来进行开发；</p></li><li><p>所以在设备像素之上，操作系统为开发者进行抽象，提供了逻辑像素的概念；</p></li><li><p>比如你购买了一台显示器，在操作系统上是以1920x1080设置的显示分辨率，那么无论你购买的是2k、4k的显示器，对于开发者来说，都是 1920x1080的大小。</p></li></ul><p>CSS像素</p><ul><li><p>CSS中我们经常使用的单位也是pixel，它在默认情况下等同于设备独立像素（也就是逻辑像素）；</p></li><li><p>毕竟逻辑像素才是面向我们开发者的；</p></li></ul><p>我们可以通过JavaScript中的screen.width和screen.height获取到电脑的逻辑分辨率：</p><h4 id="2-DPR、PPI"><a href="#2-DPR、PPI" class="headerlink" title="2.DPR、PPI"></a>2.DPR、PPI</h4><p>DPR：device pixel ratio</p><p>2010年，iPhone4问世，不仅仅带来了移动互联网，还带来了Retina屏幕</p><p>Retina屏幕翻译为视网膜显示屏，可以为用户带来更好的显示</p><p>在Retina屏幕中，一个逻辑像素在长度上对应两个物理像素，这个比例称之为设备像素比（device pixel ratio）</p><p>我们可以通过window.devicePixelRatio获取到当前屏幕上的DPR值</p><p>PPI（了解）：每英寸像素（英语：Pixels Per Inch，缩写：PPI）</p><p>通常用来表示一个打印图像或者显示器上像素的密度</p><p>前面我们提过1英寸&#x3D;2.54厘米（大概为96px&#x2F;逻辑像素），在工业领域被广泛应用</p><h3 id="3、预处理器"><a href="#3、预处理器" class="headerlink" title="3、预处理器"></a>3、预处理器</h3><h4 id="1-css编写的痛点"><a href="#1-css编写的痛点" class="headerlink" title="1.css编写的痛点"></a>1.css编写的痛点</h4><p>CSS作为一种样式语言, 本身用来给HTML元素添加样式是没有问题的</p><p>但是目前前端项目已经越来越复杂，不再是简简单单的几行CSS就可以搞定的，我们需要几千行甚至上万行的CSS来完成页面的美化工作</p><p>随着代码量的增加, 必然会造成很多的编写不便：</p><ul><li><p>比如大量的重复代码, 虽然可以用类来勉强管理和抽取, 但是使用起来依然不方便；</p></li><li><p>比如无法定义变量（当然目前已经支持）, 如果一个值被修改, 那么需要修改大量代码, 可维护性很差; (比如主题颜色)</p></li><li><p>比如没有专门的作用域和嵌套, 需要定义大量的id&#x2F;class来保证选择器的准确性, 避免样式混淆;</p></li></ul><p>所以有一种对CSS称呼是 “面向命名编程”; </p><p>社区为了解决CSS面临的大量问题, 出现了一系列的CSS预处理器(CSS_preprocessor)</p><ul><li>CSS 预处理器是一个能让你通过预处理器自己独有的语法来生成CSS的程序</li><li>市面上有很多CSS预处理器可供选择，且绝大多数CSS预处理器会增加一些原生CSS不具备的特性</li><li>代码最终会转化为CSS来运行, 因为对于浏览器来说只识别CSS</li></ul><h4 id="2-常见的三种预处理器"><a href="#2-常见的三种预处理器" class="headerlink" title="2.常见的三种预处理器"></a>2.常见的三种预处理器</h4><p>Sass&#x2F;Scss：</p><ul><li>2007年诞生，最早也是最成熟的CSS预处理器，拥有ruby社区的支持，是属于Haml（一种模板系统）的一部分</li><li>目前受LESS影响，已经进化到了全面兼容CSS的SCSS</li></ul><p>Less：</p><ul><li>2009年出现，受SASS的影响较大，但又使用CSS的语法，让大部分开发者更容易上手</li><li>比起SASS来，可编程功能不够，不过优点是使用方式简单、便捷，兼容CSS，并且已经足够使用</li><li>另外反过来也影响了SASS演变到了SCSS的时代</li><li>著名的Twitter Bootstrap就是采用LESS做底层语言的，也包括 React 的 UI 框架 AntDesign</li></ul><p>Stylus：</p><ul><li>2010年产生，来自Node.js社区，主要用来给Node项目进行CSS预处理支持</li><li>语法偏向于Python, 使用率相对于Sass&#x2F;Less少很多</li></ul><h4 id="3-less"><a href="#3-less" class="headerlink" title="3.less"></a>3.less</h4><p>It’s CSS, with just a little more</p><p>Less （Leaner Style Sheets 的缩写） 是一门CSS 扩展语言, 并且兼容CSS</p><ul><li><p>Less增加了很多相比于CSS更好用的特性</p></li><li><p>比如定义变量、混入、嵌套、计算等等</p></li><li><p>Less最终需要被编译成CSS运行于浏览器中（包括部署到服务器中）</p></li></ul><h5 id="1-less-代码的编译"><a href="#1-less-代码的编译" class="headerlink" title="1.less 代码的编译"></a>1.less 代码的编译</h5><p>方式一：下载Node环境，通过npm包管理下载less工具，使用less工具对代码进行编译</p><p>方法二：通过VSCode插件（easy less）来编译成CSS或者在线编译：<a href="https://lesscss.org/less-preview/">https://lesscss.org/less-preview/</a></p><p>方式三：引入CDN的less编译代码，对less进行实时的处理</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;link rel=<span class="string">&quot;stylesheet/less&quot;</span> href=<span class="string">&quot;./less/01-less的基本使用.less&quot;</span>&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/less@4&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>方式四：将less编译的js代码下载到本地，执行js代码对less进行编译</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;link rel=<span class="string">&quot;stylesheet/less&quot;</span> href=<span class="string">&quot;./less/01-less的基本使用.less&quot;</span>&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./js/lessc.js&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h5 id="2-less语法"><a href="#2-less语法" class="headerlink" title="2.less语法"></a>2.less语法</h5><p><strong>Less语法一：兼容</strong></p><p>Less是兼容CSS的</p><ul><li>所以我们可以在Less文件中编写所有的CSS代码</li></ul><ul><li>只是将css的扩展名改成了.less结尾而已</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 兼容 css 代码</span></span><br><span class="line">.<span class="property">box</span> &#123;</span><br><span class="line">   <span class="attr">width</span>: 100px;</span><br><span class="line">   <span class="attr">height</span>: 100px;</span><br><span class="line">   background-<span class="attr">color</span>: orange;</span><br><span class="line">   font-<span class="attr">size</span>: 20px;</span><br><span class="line">   <span class="attr">color</span>: white;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>less语法二：变量</strong></p><p>在一个大型的网页项目中，我们CSS使用到的某几种属性值往往是特定的</p><ul><li>比如我们使用到的主题颜色值，那么每次编写类似于#f3c258格式的语法</li><li>一方面是记忆不太方便，需要重新编写或者拷贝样式</li><li>另一方面如果有一天主题颜色改变，我们需要修改大量的代码</li><li>所以，我们可以将常见的颜色或者字体等定义为变量来使用</li></ul><p>在Less中使用如下的格式来定义变量：</p><p>@变量名: 变量值;</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义变量</span></span><br><span class="line">@<span class="attr">mainColor</span>: #0f0;</span><br><span class="line">@<span class="attr">mainFontSize</span>: 15px;</span><br><span class="line">@<span class="attr">smallFontSize</span>: 12px;</span><br><span class="line">@<span class="attr">bigFontSize</span>: 20px;</span><br><span class="line"></span><br><span class="line">.<span class="property">box</span> .<span class="property">pel</span> &#123;</span><br><span class="line">  background-<span class="attr">color</span>: @mainColor;</span><br><span class="line">  font-<span class="attr">size</span>: @smallFontSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>less语法三：嵌套</strong></p><p>在之前的项目中，当我们需要找到一个内层的元素时，往往需要嵌套很多层的选择器</p><p>Less提供了选择器的嵌套</p><p>特殊符号：&amp; 表示当前选择器的父级</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 选择器的嵌套</span></span><br><span class="line">.<span class="property">box</span> &#123;</span><br><span class="line">  .<span class="property">pel</span> &#123;</span><br><span class="line">    <span class="attr">color</span>: @mainColor;</span><br><span class="line">    font-<span class="attr">size</span>: @mainFontSize;</span><br><span class="line">  &#125;</span><br><span class="line">  h1 &#123;</span><br><span class="line">    .<span class="property">keyword</span> &#123;</span><br><span class="line">      <span class="attr">color</span>: @mainColor;</span><br><span class="line">      font-<span class="attr">size</span>: @bigFontSize;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  p &#123;</span><br><span class="line">    a.<span class="property">link</span> &#123;</span><br><span class="line">      <span class="attr">color</span>: @mainColor;</span><br><span class="line">      font-<span class="attr">size</span>: @smallFontSize;</span><br><span class="line">        </span><br><span class="line">      &amp;:hover &#123;</span><br><span class="line">        <span class="attr">color</span>: blue;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>less语法四：运算</strong></p><p>在Less中，算术运算符 +、-、 * 、&#x2F; 可以对任何数字、颜色或变量进行运算</p><ul><li>算术运算符在加、减或比较之前会进行单位换算，计算的结果以最左侧操作数的单位类型为准</li></ul><ul><li>如果单位换算无效或失去意义，则忽略单位</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">.<span class="property">box</span> &#123;</span><br><span class="line">  font-<span class="attr">size</span>: 20px;</span><br><span class="line">  <span class="attr">width</span>: <span class="number">10</span>% + 50px;  <span class="comment">// 60%</span></span><br><span class="line">  <span class="attr">height</span>: 100px;</span><br><span class="line">  background-<span class="attr">color</span>: #ff0000 + #00ff00;  <span class="comment">//#ffff00</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>less语法五：混入（Mixins）</strong></p><p>在原来的CSS编写过程中，多个选择器中可能会有大量相同的代码</p><ul><li><p>我们希望可以将这些代码进行抽取到一个独立的地方，任何选择器都可以进行复用</p></li><li><p>在less中提供了混入（Mixins）来帮助我们完成这样的操作</p></li></ul><p>混合（Mixin）是一种将一组属性从一个规则集（或混入）到另一个规则集的方法</p><p>注意：混入在没有参数的情况下，小括号可以省略，但是不建议这样使用</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2.1 混入的基本使用</span></span><br><span class="line">.<span class="property">nowrap_ellipsis</span> &#123;</span><br><span class="line">  white-<span class="attr">space</span>: nowrap;</span><br><span class="line">  text-<span class="attr">overflow</span>: ellipsis;</span><br><span class="line">  <span class="attr">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.<span class="property">box1</span> &#123;</span><br><span class="line">  <span class="attr">width</span>: 200px;</span><br><span class="line">  background-<span class="attr">color</span>: orange;</span><br><span class="line"></span><br><span class="line">  .<span class="title function_">nowrap_ellipsis</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>混入也可以传入变量</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2.2混入是可以传递参数（定义变量）的</span></span><br><span class="line">.<span class="title function_">box_border</span>(<span class="params">@borderWidth: 5px, @borderColor: green</span>) &#123;</span><br><span class="line">  <span class="attr">border</span>: @borderWidth solid @borderColor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.<span class="property">box2</span> &#123;</span><br><span class="line">  <span class="attr">width</span>: 150px;</span><br><span class="line">  background-<span class="attr">color</span>: #f00;</span><br><span class="line"></span><br><span class="line">  .<span class="title function_">nowrap_ellipsis</span>();</span><br><span class="line">  .<span class="title function_">box_border</span>(10px, yellow);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>less语法六：映射</strong></p><p>混入和映射结合：混入也可以当做一个自定义函数来使用</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2.3 混入和映射（Map）结合使用</span></span><br><span class="line"><span class="comment">// 作用：弥补less中不能自定义函数的缺陷</span></span><br><span class="line">.<span class="property">box_size</span> &#123;</span><br><span class="line">  <span class="attr">width</span>: 200px;</span><br><span class="line">  <span class="attr">height</span>: 150px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.<span class="property">box1</span> &#123;</span><br><span class="line">  <span class="attr">width</span>: .<span class="title function_">box_size</span>()[width];</span><br><span class="line">  background-<span class="attr">color</span>: orange;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单位转换：</p><p><img src="C:\Users\王邦辉\AppData\Roaming\Typora\typora-user-images\image-20230327211450716.png" alt="image-20230327211450716"></p><p><strong>less语法七：extend继承</strong></p><p>和mixins作用类似，用于复用代码</p><p>和mixins相比，继承代码最终会转化成并集选择器</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.box_border &#123;</span><br><span class="line">  border: 5px solid red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.box &#123;</span><br><span class="line">  width: 100px;</span><br><span class="line">  background-color: orange;</span><br><span class="line"></span><br><span class="line">  // .box_border();</span><br><span class="line">  &amp;:extend(.box_border);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Less语法八：Less内置函数</strong></p><p>Less 内置了多种函数用于转换颜色、处理字符串、算术运算等</p><p>内置函数手册：<a href="https://less.bootcss.com/functions/">https://less.bootcss.com/functions/</a></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">.<span class="property">box</span> &#123;</span><br><span class="line">  <span class="attr">color</span>: <span class="title function_">color</span>(skyblue);  <span class="comment">// 转化为16进制编码</span></span><br><span class="line">  <span class="attr">width</span>: <span class="title function_">convert</span>(100px, <span class="string">&quot;in&quot;</span>);  <span class="comment">// px转化为in</span></span><br><span class="line">  font-<span class="attr">size</span>: <span class="title function_">ceil</span>(<span class="number">18.</span>5px);  <span class="comment">// 向上取整</span></span><br><span class="line">  background-<span class="attr">color</span>: orange;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Less语法九：作用域（Scope）</strong></p><p>在查找一个变量时，首先在本地查找变量和混合（mixins）</p><p>如果找不到，则从“父”级作用域继承</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">@<span class="attr">mainColor</span>:#f00;</span><br><span class="line"></span><br><span class="line">.<span class="property">box_mixin</span> &#123;</span><br><span class="line">  @<span class="attr">mainColor</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line">.<span class="property">box</span> &#123;</span><br><span class="line">  <span class="comment">// @mainColor:#0f0;</span></span><br><span class="line">  .<span class="property">item</span> &#123;</span><br><span class="line">    span &#123;</span><br><span class="line">      <span class="attr">color</span>: @mainColor;  <span class="comment">// yellow</span></span><br><span class="line">      .<span class="title function_">box_mixin</span>()</span><br><span class="line">      <span class="comment">// @mainColor:#00f;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Less语法十：注释（Comments）</strong></p><p>在Less中，块注释和行注释都可以使用</p><p><strong>Less语法十一：导入（Importing）</strong></p><ul><li><p>导入的方式和CSS的用法是一致的</p></li><li><p>导入一个 .less 文件，此文件中的所有变量就可以全部使用了</p></li><li><p>如果导入的文件是 .less 扩展名，则可以将扩展名省略掉</p></li></ul><h3 id="4、认识Sass和Scss"><a href="#4、认识Sass和Scss" class="headerlink" title="4、认识Sass和Scss"></a>4、认识Sass和Scss</h3><p>事实上，最初Sass 是Haml的一部分，Haml 是一种模板系统，由 Ruby 开发者设计和开发</p><p>所以，Sass的语法使用的是类似于Ruby的语法，没有花括号，没有分号，具有严格的缩进</p><p>它的语法和CSS区别很大，后来官方推出了全新的语法SCSS，意思是Sassy CSS，完全兼容CSS的</p><p>SCSS的语法也包括变量、嵌套、混入、函数、操作符、作用域等</p><p>通常也包括更为强大的控制语句、更灵活的函数、插值语法等</p><p><a href="https://sass-lang.com/guide">https://sass-lang.com/guide</a></p><h3 id="5、移动端适配"><a href="#5、移动端适配" class="headerlink" title="5、移动端适配"></a>5、移动端适配</h3><p>移动端开发目前主要包括三类：</p><ul><li><p>原生App开发（iOS、Android、RN、uniapp、Flutter等）</p></li><li><p>小程序开发（原生小程序、uniapp、Taro等）</p></li><li><p>Web页面（移动端的Web页面，可以使用浏览器或者webview浏览）</p></li></ul><p>因为目前移动端设备较多，所以我们需要对其进行一些适配</p><p>这里有两个概念：</p><ul><li><p>自适应：根据不同的设备屏幕大小来自动调整尺寸、大小；</p></li><li><p>响应式：会随着屏幕的实时变动而自动调整，是一种自适应；</p></li></ul><h4 id="1-视口"><a href="#1-视口" class="headerlink" title="1.视口"></a>1.视口</h4><p>在前面我们已经简单了解过视口的概念了：</p><ul><li><p>在一个浏览器中，我们可以看到的区域就是视口（viewport）</p></li><li><p>fixed就是相对于视口来进行定位的</p></li><li><p>在PC端的页面中，是不需要对视口进行区分，因为我们的布局视口和视觉视口是同一个</p></li></ul><p>但是在移动端不太一样，布局的视口和可见的视口是不太一样的</p><p>这是因为移动端的网页窗口往往比较小，我们可能会希望一个大的网页在移动端可以完整的显示，所以在默认情况下，移动端的布局视口是大于视觉视口的</p><p>在移动端，我们可以将视口划分为三种情况：</p><ul><li><p>布局视口（layout viewport）</p></li><li><p>视觉视口（visual layout）</p></li><li><p>理想视口（ideal layout）</p></li></ul><p>这些概念的区分，来自于ppk：<a href="https://www.quirksmode.org/mobile/viewports2.html">https://www.quirksmode.org/mobile/viewports2.html</a></p><p>布局视口</p><p>默认情况下，一个在PC端的网页在移动端的显示：</p><ul><li><p>第一，它会按照宽度为980px来布局一个页面的盒子和内容；</p></li><li><p>第二，为了在移动端可以完整的显示页面，会对整个页面进行缩小；</p></li></ul><p>我们相对于980px布局的这个视口，称之为布局视口（layout  viewport）</p><ul><li>布局视口的默认宽度是980px；</li></ul><p>视觉视口</p><ul><li><p>如果默认情况下，我们按照980px显示内容，那么右侧有一部分区域就会无法显示，所以手机端浏览器会默认对页面进行缩放以显示到用户的可见区域中；</p></li><li><p>那么显示在可见区域的这个视口，就是视觉视口（visual viewport）</p></li></ul><p>如果所有的网页都按照980px在移动端布局，那么最终页面都会被缩放显示</p><p>事实上这种方式是不利于我们进行移动的开发的，我们希望的是设置100px，那么显示的就是100px；</p><p>如何做到这一点呢？通过设置理想视口（ideal viewport）；</p><p>理想视口</p><ul><li><p>默认情况下的layout viewport并不适合我们进行布局；</p></li><li><p>我们可以对layout viewport进行宽度和缩放的设置，以满足正常在一个移动端窗口的布局；</p></li><li><p>这个时候可以设置meta中的viewport</p></li></ul><p><img src="https://wbhnote.oss-cn-hangzhou.aliyuncs.com/img/image-20230328092425280.png" alt="image-20230328092425280"></p><h4 id="2-移动适配方案"><a href="#2-移动适配方案" class="headerlink" title="2.移动适配方案"></a>2.移动适配方案</h4><p>移动端的屏幕尺寸通常是非常繁多的，很多时候我们希望在不同的屏幕尺寸上显示不同的大小；</p><p>比如我们设置一个100x100的盒子</p><ul><li><p>在375px的屏幕上显示是100x100</p></li><li><p>在320px的屏幕上显示是90x90</p></li><li><p>在414px的屏幕上显示是100x100</p></li></ul><p>其他尺寸也是类似，比如padding、margin、border、left，甚至是font-size等</p><p>这个时候，我们可能可以想到一些方案来处理尺寸：</p><ul><li><p>方案一：百分比设置；</p><ul><li>因为不同属性的百分比值，相对的可能是不同参照物，所以百分比往往很难统一</li><li>所以百分比在移动端适配中使用是非常少的</li></ul></li><li><p>方案二：rem单位+动态html的font-size</p></li><li><p>方案三：vw单位</p></li><li><p>方案四：flex的弹性布局</p></li></ul><h5 id="方案二："><a href="#方案二：" class="headerlink" title="方案二："></a>方案二：</h5><p>rem单位是相对于html元素的font-size来设置的，那么如果我们需要在不同的屏幕下有不同的尺寸，可以动态的修改html的 font-size尺寸</p><p>比如如下案例：</p><ul><li><p>1.设置一个盒子的宽度是2rem；</p></li><li><p>2.设置不同的屏幕上html的font-size不同；</p></li></ul><p>这样在开发中，我们只需要考虑两个问题：</p><ul><li>问题一：针对不同的屏幕，设置html不同的font-size</li><li>问题二：将原来要设置的尺寸，转化成rem单位</li></ul><h6 id="动态改变font-size"><a href="#动态改变font-size" class="headerlink" title="动态改变font-size"></a>动态改变font-size</h6><p>方案一：媒体查询</p><ul><li>可以通过媒体查询来设置不同尺寸范围内的屏幕html的font-size尺寸；</li><li>缺点：<ul><li>1.我们需要针对不同的屏幕编写大量的媒体查询；</li><li>2.如果动态改变尺寸，不会实时的进行更新</li></ul></li></ul><p>方案二：编写js代码</p><ul><li><p>如果希望实时改变屏幕尺寸时，font-size也可以实时更改，可以通过js代码；</p></li><li><p>方法：</p><ul><li>1.根据html的宽度计算出font-size的大小，并且设置到html上；</li><li>2.监听页面的实时改变，并且重新设置font-size的大小到html上</li></ul></li></ul><p>方案三：lib-flexible库</p><ul><li>事实上，lib-flexible库做的事情是相同的，你也可以直接引入它</li></ul><h6 id="rem计算"><a href="#rem计算" class="headerlink" title="rem计算"></a>rem计算</h6><p>方案一：手动换算</p><p>比如有一个在375px屏幕上，100px宽度和高度的盒子；</p><p>我们需要将100px转成对应的rem值；</p><p>100&#x2F;37.5&#x3D;2.6667，其他也是相同的方法计算即可；</p><p>方案二：less&#x2F;scss函数</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">.<span class="title function_">pxToRem</span>(<span class="params">@px</span>) &#123;</span><br><span class="line">  <span class="attr">result</span>: 1rem * (@px / <span class="number">37.5</span>);</span><br><span class="line">&#125;</span><br><span class="line">.<span class="property">box</span> &#123;</span><br><span class="line">  <span class="attr">width</span>: .<span class="title function_">pxToRem</span>(<span class="number">100</span>)[result];</span><br><span class="line">  <span class="attr">height</span>: .<span class="title function_">pxToRem</span>(<span class="number">100</span>)[result];</span><br><span class="line">  background-<span class="attr">color</span>: orange;</span><br><span class="line">&#125;</span><br><span class="line">p &#123;</span><br><span class="line">  font-<span class="attr">size</span>: .<span class="title function_">pxToRem</span>(<span class="number">14</span>)[result];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方案三：postcss-pxtorem（后续学习）</p><ul><li>目前在前端的工程化开发中，我们可以借助于webpack的工具来完成自动的转化</li></ul><p>方案四：VSCode插件</p><ul><li>px to rem 的插件，在编写时自动转化</li></ul><h5 id="方案三：vw适配"><a href="#方案三：vw适配" class="headerlink" title="方案三：vw适配"></a>方案三：vw适配</h5><p>rem事实上是作为一种过渡的方案，它利用的也是vw的思想</p><p>前面不管是我们自己编写的js，还是flexible的源码</p><p>都是将1rem等同于设计稿的1&#x2F;10，在利用1rem计算相对于整个屏幕的尺寸大小；</p><p>1vw刚好等于屏幕的1&#x2F;100</p><p>vw相比于rem的优势：</p><ul><li><p>优势一：不需要去计算html的font-size大小，也不需要给html设置这样一个font-size；</p></li><li><p>优势二：不会因为设置html的font-size大小，而必须给body再设置一个font-size，防止继承；</p></li><li><p>优势三：因为不依赖font-size的尺寸，所以不用担心某些原因html的font-size尺寸被篡改，页面尺寸混乱</p></li><li><p>优势四：vw相比于rem更加语义化，1vw刚才是1&#x2F;100的viewport的大小</p></li><li><p>优势五：可以具备rem之前所有的优点；</p></li></ul><p>vw我们只面临一个问题，将尺寸换算成vw的单位即可</p><p>所以，目前相比于rem，更加推荐大家使用vw</p><p>vw的单位转换</p><p>方案一：手动换算</p><ul><li><p>比如有一个在375px屏幕上，100px宽度和高度的盒子</p></li><li><p>我们需要将100px转成对应的vw值</p></li><li><p>100&#x2F;3.75&#x3D;26.667，其他也是相同的方法计算即可</p></li></ul><p>方案二：less&#x2F;scss函数</p><p>方案三：postcss-px-to-viewport-8-plugin（后续学习）</p><ul><li>和rem一样，在前端的工程化开发中，可以借助于webpack的工具来完成自动的转化</li></ul><p>方案四：VSCode插件</p><ul><li>px to vw 的插件，在编写时自动转化</li></ul><h3 id="6、认识grid布局"><a href="#6、认识grid布局" class="headerlink" title="6、认识grid布局"></a>6、认识grid布局</h3><p>CSS为了进一步增强自己的布局能力，提供了grid布局:</p><ul><li><p>CSS Grid Layout (又名“Grid”或 “CSS Grid”)是一种基于二维的布局系统</p></li><li><p>它更加强大，同时也更加复杂; .</p></li></ul><p>目前公司生产环境的项目基本都是使用flex布局为主，因为它兼容性比flex布局差一 些</p><p>Grid Container</p><ul><li>元素设置display 为grid的盒子</li></ul><p>Grid Item，单元格称之为grid cell</p><ul><li>grid container 的直接子项</li></ul><p>Grid Line</p><ul><li>构成网格结构的分割线</li><li>它们可以是垂直的(“列网格线”)或水平的(”行网格线”)</li></ul><p>Grid Track</p><ul><li>两条相邻网格线之间的空间</li><li>可以看成是网格的行或者列</li></ul><p>Grid Area</p><ul><li>由四条网格线包围的总空间</li><li>一个网格区域可以由任意数量的网格单元组成</li></ul><p><a href="https://css-tricks.com/snippets/css/complete-guide-grid/">https://Css-tricks.com/snippets/css/complete-guide-grid/</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IT前端 </tag>
            
            <tag> HTML </tag>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>站点简介</title>
      <link href="/archives/a8213f80.html"/>
      <url>/archives/a8213f80.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>大家好，欢迎来到我的个人blog，在这里我将会分享一些自己的学习笔记，主要分为前端体系、计算机网络、网络规划与设计、相关工具等，也会分享一些个人好用的网站，白嫖攻略，科学魔法等；如有需要，也欢迎私信进行分享交流~</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
